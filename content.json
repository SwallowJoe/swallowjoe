{"meta":{"title":"SwallowJoe的博客","subtitle":"Be a real go-getter,<br>NEVER SETTLE!","description":"君子知命不惧，日日自新","author":"SwallowJoe","url":"https://swallowjoe.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-26T09:28:27.221Z","updated":"2022-02-26T09:28:27.221Z","comments":true,"path":"404/index.html","permalink":"https://swallowjoe.github.io/404/index.html","excerpt":"","text":"layout: falsecomments: falsetitle: 404permalink: &#x2F;404 幽灵404页面 html,body{background:#28254C;font-family:'Ubuntu';}*{box-sizing:border-box;}.box{width:350px;height:100%;max-height:600px;min-height:450px;background:#332F63;border-radius:20px;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:30px 50px;}.box .box__ghost{padding:15px 25px 25px;position:absolute;left:50%;top:30%;transform:translate(-50%,-30%);}.box .box__ghost .symbol:nth-child(1){opacity:.2;animation:shine 4s ease-in-out 3s infinite;}.box .box__ghost .symbol:nth-child(1):before,.box .box__ghost .symbol:nth-child(1):after{content:'';width:12px;height:4px;background:#fff;position:absolute;border-radius:5px;bottom:65px;left:0;}.box .box__ghost .symbol:nth-child(1):before{transform:rotate(45deg);}.box .box__ghost .symbol:nth-child(1):after{transform:rotate(-45deg);}.box .box__ghost .symbol:nth-child(2){position:absolute;left:-5px;top:30px;height:18px;width:18px;border:4px solid;border-radius:50%;border-color:#fff;opacity:.2;animation:shine 4s ease-in-out 1.3s infinite;}.box .box__ghost .symbol:nth-child(3){opacity:.2;animation:shine 3s ease-in-out .5s infinite;}.box .box__ghost .symbol:nth-child(3):before,.box .box__ghost .symbol:nth-child(3):after{content:'';width:12px;height:4px;background:#fff;position:absolute;border-radius:5px;top:5px;left:40px;}.box .box__ghost .symbol:nth-child(3):before{transform:rotate(90deg);}.box .box__ghost .symbol:nth-child(3):after{transform:rotate(180deg);}.box .box__ghost .symbol:nth-child(4){opacity:.2;animation:shine 6s ease-in-out 1.6s infinite;}.box .box__ghost .symbol:nth-child(4):before,.box .box__ghost .symbol:nth-child(4):after{content:'';width:15px;height:4px;background:#fff;position:absolute;border-radius:5px;top:10px;right:30px;}.box .box__ghost .symbol:nth-child(4):before{transform:rotate(45deg);}.box .box__ghost .symbol:nth-child(4):after{transform:rotate(-45deg);}.box .box__ghost .symbol:nth-child(5){position:absolute;right:5px;top:40px;height:12px;width:12px;border:3px solid;border-radius:50%;border-color:#fff;opacity:.2;animation:shine 1.7s ease-in-out 7s infinite;}.box .box__ghost .symbol:nth-child(6){opacity:.2;animation:shine 2s ease-in-out 6s infinite;}.box .box__ghost .symbol:nth-child(6):before,.box .box__ghost .symbol:nth-child(6):after{content:'';width:15px;height:4px;background:#fff;position:absolute;border-radius:5px;bottom:65px;right:-5px;}.box .box__ghost .symbol:nth-child(6):before{transform:rotate(90deg);}.box .box__ghost .symbol:nth-child(6):after{transform:rotate(180deg);}.box .box__ghost .box__ghost-container{background:#fff;width:100px;height:100px;border-radius:100px 100px 0 0;position:relative;margin:0 auto;animation:upndown 3s ease-in-out infinite;}.box .box__ghost .box__ghost-container .box__ghost-eyes{position:absolute;left:50%;top:45%;height:12px;width:70px;}.box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-left{width:12px;height:12px;background:#332F63;border-radius:50%;margin:0 10px;position:absolute;left:0;}.box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-right{width:12px;height:12px;background:#332F63;border-radius:50%;margin:0 10px;position:absolute;right:0;}.box .box__ghost .box__ghost-container .box__ghost-bottom{display:flex;position:absolute;top:100%;left:0;right:0;}.box .box__ghost .box__ghost-container .box__ghost-bottom div{flex-grow:1;position:relative;top:-10px;height:20px;border-radius:100%;background-color:#fff;}.box .box__ghost .box__ghost-container .box__ghost-bottom div:nth-child(2n){top:-12px;margin:0 -0px;border-top:15px solid #332F63;background:transparent;}.box .box__ghost .box__ghost-shadow{height:20px;box-shadow:0 50px 15px 5px #3B3769;border-radius:50%;margin:0 auto;animation:smallnbig 3s ease-in-out infinite;}.box .box__description{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);}.box .box__description .box__description-container{color:#fff;text-align:center;width:200px;font-size:16px;margin:0 auto;}.box .box__description .box__description-container .box__description-title{font-size:24px;letter-spacing:.5px;}.box .box__description .box__description-container .box__description-text{color:#8C8AA7;line-height:20px;margin-top:20px;}.box .box__description .box__button{display:block;position:relative;background:#FF5E65;border:1px solid transparent;border-radius:50px;height:50px;text-align:center;text-decoration:none;color:#fff;line-height:50px;font-size:18px;padding:0 70px;white-space:nowrap;margin-top:25px;transition:background .5s ease;overflow:hidden;}.box .box__description .box__button:before{content:'';position:absolute;width:20px;height:100px;background:#fff;bottom:-25px;left:0;border:2px solid #fff;transform:translateX(-50px) rotate(45deg);transition:transform .5s ease;}.box .box__description .box__button:hover{background:transparent;border-color:#fff;}.box .box__description .box__button:hover:before{transform:translateX(250px) rotate(45deg);}@keyframes upndown{0%{transform:translateY(5px);}50%{transform:translateY(15px);}100%{transform:translateY(5px);}}@keyframes smallnbig{0%{width:90px;}50%{width:100px;}100%{width:90px;}}@keyframes shine{0%{opacity:.2;}25%{opacity:.1;}50%{opacity:.2;}100%{opacity:.2;}} 404错误！ 看来我们找不到你要找的那一页 返回 var pageX =$(document).width();var pageY =$(document).height();var mouseY=0;var mouseX=0;$(document).mousemove(function(event ) {mouseY =event.pageY;yAxis =(pageY/2-mouseY)/pageY*300;mouseX =event.pageX / -pageX;xAxis =-mouseX *100 - 100;$('.box__ghost-eyes').css({'transform':'translate('+ xAxis +'%,-'+ yAxis +'%)' });});"}],"posts":[{"title":"Vulkan入门(2)-创建Vulkan示例及验证层","slug":"Vulkan入门-2-创建Vulkan示例及验证层","date":"2022-02-26T14:24:59.000Z","updated":"2022-02-26T14:36:43.896Z","comments":true,"path":"2022/02/26/Vulkan入门-2-创建Vulkan示例及验证层/","link":"","permalink":"https://swallowjoe.github.io/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-2-%E5%88%9B%E5%BB%BAVulkan%E7%A4%BA%E4%BE%8B%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%B1%82/","excerpt":"","text":"参考资料 简述 一. 创建 vulkan 实例 1.1 创建 Window 实例 1.2 创建 Vulkan 实例 二. 验证层(Validation layers) 2.1 什么是 Validation layers？ 2.2 Validation layers示例 2.3 启用验证层 2.4 消息回调 2.4.1 调试回调函数 debugCallback 2.4.2 注册调试回调 三. 代码 3.1 Makefile 3.2 main.cpp 参考资料 https://github.com/KhronosGroup/Vulkan-Docs https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateInstance https://github.com/SaschaWillems/Vulkan/blob/master/base/vulkanexamplebase.h 简述本文主要是实现Vulkan Tutorial.pdf文档中的Base Code, Instance和Validation Layers部分。 一. 创建 vulkan 实例1.1 创建 Window 实例先创建个 window 窗口 12345678910111213141516void initWindow() &#123; // 第一步一定是先初始化GLFW库. glfwInit(); // 因为GLFW最初是为创建OpenGL上下文而设计的， // 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); // 创建窗口 // GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share) window = glfwCreateWindow(WIDTH, HEIGHT, WINDOW_TITLE, nullptr, nullptr);&#125; 1.2 创建 Vulkan 实例 创建 VkApplicationInfo 结构体变量，参数可选 创建 VkInstanceCreateInfo 结构体变量，必须指明 使用 GLFW (glfwGetRequiredInstanceExtensions) 创建 glfwExtensions, 以便为GLFW窗口创建Vulkan surface 调用 vkCreateInstance, 创建 vulkan 实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void createInstance() &#123; // 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo // 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化 VkApplicationInfo appInfo = &#123;&#125;; // Vulkan中的许多结构要求在sType成员中明确指定类型。 // 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。 appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; appInfo.pApplicationName = &quot;Hello Triangle&quot;; appInfo.applicationVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.pEngineName = &quot;No Engine&quot;; appInfo.engineVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.apiVersion = VK_API_VERSION_1_1; // Vulkan中的很多信息都是通过结构而不是函数参数传递的， // 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。 // VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 VkInstanceCreateInfo createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pNext = nullptr; createInfo.pApplicationInfo = &amp;appInfo; // 前两个参数很简单。 // Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。 // GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo uint32_t glfwExtensionCount = 0; const char** glfwExtensions; // 返回GLFW所需的Vulkan实例扩展。 // 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 // 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。 // 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。 glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; // createInfo.ppEnabledLayerNames = glfwExtensions; // 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped) // 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。 createInfo.ppEnabledExtensionNames = glfwExtensions; // 结构体的最后两个成员确定要启用的全局验证层。 createInfo.enabledLayerCount = 0; // VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) VkResult res = vkCreateInstance(&amp;createInfo, nullptr, &amp;instance); if (res != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create instance!&quot;); &#125;&#125; 二. 验证层(Validation layers)2.1 什么是 Validation layers？Vulkan API围绕最小驱动程序开销的想法而设计，该目标的一个表现形式是默认情况下API中的错误检查非常有限。即使是将枚举设置为不正确的值或将空指针传递给所需参数这样简单的错误通常也不会被显式处理，只会导致崩溃或未定义的行为。这一点，笔者已经深刻体会到了，(╯﹏╰)因为Vulkan要求你对你所做的一切都非常明确，所以很容易犯很多小错误，例如使用新的GPU功能而忘记在逻辑设备创建时请求它。 但是，这并不意味着无法将这些检查添加到API中。Vulkan为这种称为验证层的系统引入了一个优雅的系统: Validation layers.验证层是可选组件，它挂接到Vulkan函数调用以应用其他操作。 验证层中的常见操作是： 根据规范检查参数值以检测误用 跟踪对象的创建和销毁以查找资源泄漏 通过跟踪调用的线程来检查线程安全性 将每个调用及其参数记录到标准输出方便调试 跟踪Vulkan要求进行性能分析和重放 2.2 Validation layers示例123456789101112VkResult vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* instance) &#123; if (pCreateInfo == nullptr || instance == nullptr) &#123; log(&quot;Null pointer passed to required parameter!&quot;); return VK_ERROR_INITIALIZATION_FAILED; &#125; return real_vkCreateInstance(pCreateInfo, pAllocator, instance);&#125; 比如上面的vkCreateInstance中的if语句。官方文档上如此说： 1234567891011这些验证层可以自由堆叠，以包含您感兴趣的所有调试功能。您可以简单地为调试版本启用验证层，并为发布版本完全禁用它们，这将为您提供两全其美的优势！Vulkan没有内置任何验证层，但LunarG Vulkan SDK提供了一组很好的层来检查常见错误。它们也是完全开源的，因此您可以检查它们检查和贡献的错误类型。使用验证层是避免应用程序因意外依赖未定义行为而破坏不同驱动程序的最佳方法。验证层只有在已安装到系统上时才能使用。例如，LunarG验证层仅适用于安装了Vulkan SDK的PC。Vulkan中以前有两种不同类型的验证层：实例和设备特定。我们的想法是，实例层只会检查与全局Vulkan对象（如实例）相关的调用，而设备特定层只会检查与特定GPU相关的调用。现在已弃用特定于设备的层，这意味着实例验证层适用于所有Vulkan调用。规范文档仍建议您在设备级别启用验证层以及兼容性，这是某些实现所需的。 2.3 启用验证层如何启用Vulkan SDK提供的标准诊断层? 就像扩展一样，需要通过指定其名称来启用验证层。所有有用的标准验证都捆绑在SDK中包含的层中，称为VK_LAYER_KHRONOS_validation。让我们首先向程序添加两个配置变量，以指定要启用的层以及是否启用它们。 我已经选择将该值作为程序是否在调试模式下编译。NDEBUG宏是C ++标准的一部分，意味着“不调试”。 123456789const std::vector&lt;const char*&gt; validationLayers = &#123; &quot;VK_LAYER_KHRONOS_validation&quot;&#125;;#ifdef NDEBUG const bool enableValidationLayers = false;#else const bool enableValidationLayers = true;#endif 2.4 消息回调仅启用这些层并没有多大帮助，因为它们目前无法将调试消息中继回我们的程序。要接收这些消息，我们必须设置一个带回调的调试信使，这需要VK_EXT_debug_utils扩展。我们将首先创建一个getRequiredExtensions函数，根据是否启用验证层返回所需的扩展名列表： 12345678910111213std::vector&lt;const char*&gt; getRequiredExtensions() &#123; uint32_t glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount); if (enableValidationLayers) &#123; extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); &#125; return extensions;&#125; GLFW指定的扩展始终是必需的，但有条件地添加了调试信使扩展(VK_EXT_debug_utils)。请注意，在这里使用了VK_EXT_DEBUG_UTILS_EXTENSION_NAME宏，它等于文字字符串“VK_EXT_debug_utils”。 使用此宏可以避免拼写错误。我们现在可以在createInstance中使用此函数： 123auto extensions = getRequiredExtensions();createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());createInfo.ppEnabledExtensionNames = extensions.data(); 2.4.1 调试回调函数 debugCallback现在让我们看一下调试回调函数的样子。使用PFN_vkDebugUtilsMessengerCallbackEXT原型添加一个名为debugCallback的新静态成员函数。VKAPI_ATTR和VKAPI_CALL确保该函数具有Vulkan调用它的正确签名。 12345678910static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) &#123; std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl; return VK_FALSE;&#125; 第一个参数: VkDebugUtilsMessageSeverityFlagBitsEXT 指明了消息的严重程度•VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT：诊断消息•VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT：信息性消息，如创建资源•VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT：有关行为的消息不一定是错误，但很可能是应用程序中的错误•VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT：有关无效行为的消息，可能导致崩溃可以根据这个参数过滤所需的信息。 第二个参数: VkDebugUtilsMessageTypeFlagsEXT 指明了消息的类型•VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT：发生了与规范或性能无关的某些事件•VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT：发生了违反规范或表明可能存在错误的事情•VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT：潜在的非最佳使用Vulkan 第三个参数: VkDebugUtilsMessengerCallbackDataEXT 这个结构体包含了消息更多的细节内容•pMessage：调试消息为以空字符结尾的字符串•pObjects：与消息相关的Vulkan对象句柄数组•object Count：数组中的对象数 第四个参数: pUserData 包含在回调设置期间指定的指针，并允许您将自己的数据传递给它。 回调返回一个布尔值，指示是否应该中止触发验证层消息的Vulkan调用。如果回调返回true，则调用将因VK_ERROR_VALIDATION_FAILED_EXT错误而中止。这通常仅用于测试验证层本身，因此应始终返回VK_FALSE。 2.4.2 注册调试回调在Vulkan中, 调试回调也是通过需要显式创建和销毁的句柄来管理的。 这样的回调是debug message的一部分，可以根据需要设置尽可能多的回调。 12345678910111213141516171819202122232425// 在成员变量中添加：VkDebugUtilsMessengerEXTVkDebugUtilsMessengerEXT debugMessenger;void initVulkan() &#123; createInstance(); setupDebugMessenger();&#125;void setupDebugMessenger() &#123; if (!enableValidationLayers) return; VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT; // 指定消息回调函数 createInfo.pfnUserCallback = debugCallback; createInfo.pUserData = nullptr; // 可选&#125; messageSeverity字段允许指定要为其调用回调的所有类型的严重性。在这里指定了除VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT之外的所有类型，以接收有关可能问题的通知，同时省略详细的一般调试信息。类似地，messageType字段可以过滤通知回调的消息类型。 在这里启用了所有类型。最后，pfnUserCallback字段指定回调函数的指针。可以选择将指针传递给pUserData字段，该字段将通过pUserData参数传递给回调函数。例如，可以使用它来传递指向HelloTriangleApplication类的指针。 应该将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。然而因为这个function是一个扩展函数，它不会自动加载。必须使用vkGetInstanceProcAddr查找其地址。 创建代理函数，然后在处理它，如下: 12345678910111213VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) &#123; auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance,&quot;vkCreateDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; return func(instance, pCreateInfo, pAllocator, pDebugMessenger); &#125; else &#123; return VK_ERROR_EXTENSION_NOT_PRESENT; &#125;&#125; 现在我们可以在 setupDebugMessenger 中调用此函数： 12345678910void setupDebugMessenger() &#123; if (!enableValidationLayers) return; ...... // 实例化DebugUtilsMessengerEXT if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to set up debug messenger!&quot;); &#125;&#125; 最后注意，既然有 vkCreateXXX, 就需要显示调用 vkDestroyXXX 哦！ 12345678910void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) &#123; auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; func(instance, debugMessenger, pAllocator); &#125;&#125; 如果你忘了调用DestroyDebugUtilsMessengerEXT去销毁debugMessenger，在关闭窗口的时候就会打印如下信息: 三. 代码3.1 Makefile12345678910111213141516VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/includeLDFLAGS = -L$(VULKAN_SDK_PATH)/lib -lvulkan `pkg-config --static --libs glfw3`LDFLAGS += -ldlHelloTriangleApplication: main.cpp g++ $(CFLAGS) -o HelloTriangleApplication main.cpp $(LDFLAGS).PHONY: test cleantest: HelloTriangleApplication LD_LIBRARY_PATH=$(VULKAN_SDK_PATH)/lib VK_LAYER_PATH=$(VULKAN_SDK_PATH)/etc/explicit_layer.d ./HelloTriangleApplicationclean:rm -f HelloTriangleApplication 3.2 main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294/** * #include &lt;vulkan/vulkan.h&gt; // vulkan 头文件 * 使用下面两行替换 vulkan头文件 * #define GLFW_INCLUDE_VULKAN * #include &lt;GLFW/glfw3.h&gt; * * GLFW 会自动加载 vulkan 头文件的。 * GLFW是一个开源，多平台的库，用于桌面上的OpenGL，OpenGL ES和Vulkan开发。 * 它提供了一个简单的API，用于创建窗口，上下文和曲面，接收输入和事件。 * GLFW是用C语言编写的，并且使用X Window系统（例如Linux和FreeBSD）对Windows，macOS和许多类Unix系统提供原生支持。 */#define GLFW_INCLUDE_VULKAN#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;#include &lt;stdexcept&gt; // 包含用于报告错误的头文件#include &lt;functional&gt; // 用于资源管理部分中的lambda函数#include &lt;cstdlib&gt; // cstdlib: EXIT_FAILURE, EXIT_SUCCESS#include &lt;vector&gt;#include &lt;string.h&gt; #ifdef NDEBUG const bool enableValidationLayers = false;#else const bool enableValidationLayers = true;#endifclass HelloTriangleApplication &#123;public: void run() &#123; initWindow(); initVulkan(); mainLoop(); cleanup(); &#125; const int WIDTH = 800; const int HEIGHT = 600; const char * WINDOW_TITLE = &quot;Vulkan&quot;;private: void initWindow() &#123; // 第一步一定是先初始化GLFW库. glfwInit(); // 因为GLFW最初是为创建OpenGL上下文而设计的， // 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); // 创建窗口 // GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share) window = glfwCreateWindow(WIDTH, HEIGHT, WINDOW_TITLE, nullptr, nullptr); &#125; void initVulkan() &#123; checkAvailableExtensions(); createInstance(); // 创建DEBUG消息回调 setupDebugMessenger(); &#125; void setupDebugMessenger() &#123; if (!enableValidationLayers) return; VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT; // 指定消息回调函数 createInfo.pfnUserCallback = debugCallback; createInfo.pUserData = nullptr; // 可选 // 实例化DebugUtilsMessengerEXT if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to set up debug messenger!&quot;); &#125; &#125; void checkAvailableExtensions() &#123; uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, nullptr); std::vector&lt;VkExtensionProperties&gt; extensions(extensionCount); vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, extensions.data()); std::cout &lt;&lt; &quot;available extensions:&quot; &lt;&lt; std::endl; for (const auto&amp; extension : extensions) &#123; std::cout &lt;&lt; &quot;\\t&quot; &lt;&lt; extension.extensionName &lt;&lt; std::endl; &#125; &#125; bool checkValidationLayerSupport() &#123; uint32_t layerCount; vkEnumerateInstanceLayerProperties(&amp;layerCount, nullptr); std::vector&lt;VkLayerProperties&gt; availableLayers(layerCount); vkEnumerateInstanceLayerProperties(&amp;layerCount, availableLayers.data()); for (const char* layerName : validationLayers) &#123; //bool layerFound = false; for (const auto&amp; layerProperties : availableLayers) &#123; if (strcmp(layerName, layerProperties.layerName) == 0) &#123; //layerFound = true; return true; &#125; &#125; &#125; return false; &#125; void createInstance() &#123; // 验证层，检验VK_LAYER_KHRONOS_validation if (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) &#123; throw std::runtime_error(&quot;validation layers requested, but not available!&quot;); &#125; // 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo // 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化 VkApplicationInfo appInfo = &#123;&#125;; // Vulkan中的许多结构要求在sType成员中明确指定类型。 // 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。 appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; appInfo.pApplicationName = &quot;Hello Triangle&quot;; appInfo.applicationVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.pEngineName = &quot;No Engine&quot;; appInfo.engineVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.apiVersion = VK_API_VERSION_1_1; // Vulkan中的很多信息都是通过结构而不是函数参数传递的， // 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。 // VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 VkInstanceCreateInfo createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pNext = nullptr; createInfo.pApplicationInfo = &amp;appInfo; /* // 前两个参数很简单。 // Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。 // GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo uint32_t glfwExtensionCount = 0; const char** glfwExtensions; // 返回GLFW所需的Vulkan实例扩展。 // 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 // 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。 // 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。 glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); // 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped) // 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。 createInfo.ppEnabledLayerNames = glfwExtensions; createInfo.ppEnabledExtensionNames = glfwExtensions; createInfo.enabledExtensionCount = glfwExtensionCount; */ // 返回GLFW所需的Vulkan实例扩展, 支持消息回调 auto extensions = getRequiredExtensions(); createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size()); createInfo.ppEnabledExtensionNames = extensions.data(); // 结构体的最后两个成员确定要启用的全局验证层。 if (enableValidationLayers) &#123; createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); &#125; else &#123; createInfo.enabledLayerCount = 0; &#125; // VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) VkResult res = vkCreateInstance(&amp;createInfo, nullptr, &amp;instance); if (res != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create instance!&quot;); &#125; &#125; void mainLoop() &#123; // 添加一个事件循环, 使应用程序保持运行直到发生错误或窗口关闭 while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); &#125; &#125; // 在 vulkan 中推荐在创建的资源不需要后主动释放 void cleanup() &#123; // 释放debugMessenger(VkDebugUtilsMessengerEXT, 用于打印调试信息) if (enableValidationLayers) &#123; DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr); &#125; // 在 vulkan 中资源一般都是 vkCreateXXX 创建，由 vkDestroyXXX 或 vkFreeXXX 释放. vkDestroyInstance(instance, nullptr); // 此函数会破坏指定的窗口及其上下文。 在调用此函数时，不会为该窗口调用其他回调。 // 如果指定窗口的上下文在主线程上是最新的，则在销毁之前将其分离。 glfwDestroyWindow(window); // 此功能会释放所有剩余的窗口和光标并释放任何其他已分配的资源。 // 调用此函数后，必须再次成功调用@ref glfwInit，然后才能使用大多数GLFW函数。 glfwTerminate(); &#125; // 用于消息回调Message Callback std::vector&lt;const char*&gt; getRequiredExtensions() &#123; uint32_t glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount); if (enableValidationLayers) &#123; extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); &#125; return extensions; &#125; // 打印debug信息 static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) &#123; std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl; return VK_FALSE; &#125; // 创建 VkDebugUtilsMessengerEXT 对象debugMessenger VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) &#123; // 将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。 // 然而因为这个function是一个扩展函数，它不会自动加载。 // 必须使用vkGetInstanceProcAddr查找其地址。 auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance,&quot;vkCreateDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; return func(instance, pCreateInfo, pAllocator, pDebugMessenger); &#125; else &#123; return VK_ERROR_EXTENSION_NOT_PRESENT; &#125; &#125; // 销毁VkDebugUtilsMessengerEXT void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) &#123; auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; func(instance, debugMessenger, pAllocator); &#125; &#125; // Window实例 GLFWwindow* window; // Vulkan实例 VkInstance instance; // DEBUG消息回调 VkDebugUtilsMessengerEXT debugMessenger; // 验证层 const std::vector&lt;const char*&gt; validationLayers = &#123; &quot;VK_LAYER_KHRONOS_validation&quot; &#125;;&#125;;int main() &#123; HelloTriangleApplication app; try &#123; app.run(); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; &#125; return EXIT_SUCCESS;&#125;","categories":[],"tags":[]},{"title":"Vulkan入门(1)-环境配置","slug":"Vulkan入门-1-环境配置","date":"2022-02-26T13:13:24.000Z","updated":"2022-02-26T15:16:47.687Z","comments":true,"path":"2022/02/26/Vulkan入门-1-环境配置/","link":"","permalink":"https://swallowjoe.github.io/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"参考资料 简述 一. 准备环境 1.1 开发环境 1.2 下载 SDK 1.3 安装SDK 1.4 安装驱动 1.5. 运行示例程序 二. GLFW 安装 三. GLM 安装 四. 手动编译示例代码 4.1 在编译示例代码的时候老是报错，找不到vulkan头文件。 4.2 error adding symbols: DSO missing from command line 4.3 运行示例 五. 主要代码 5.1 main.cpp 5.2 Makefile 参考资料 https://vulkan.lunarg.com/doc/sdk/1.2.170.0/linux/getting_started.html https://github.com/google/glog [pkg-config的用法]https://www.cnblogs.com/chris-cp/p/3580002.html [解决&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libglog.so.0: error adding symbols: DSO missing from command line]https://blog.csdn.net/u010987458/article/details/72235408 https://www.glfw.org/docs/3.3/build_guide.html#build_link_cmake_package [GLFW]https://www.glfw.org/ [GLM]https://github.com/g-truc/glm 简述本文主要是介绍如何在 ubuntu 机器上安装并编译Vulkan程序。 一. 准备环境1.1 开发环境12345sudo apt-get updatesudo apt-get dist-upgradesudo apt-get install libglm-dev cmake libxcb-dri3-0 libxcb-present0 libpciaccess0 libpng-dev libxcb-keysyms1-dev libxcb-dri3-dev libx11-dev libmirclient-dev libwayland-dev libxrandr-dev libxcb-ewmh-devsudo apt-get install git libpython2.7 1.2 下载 SDK官方网站：https://vulkan.lunarg.com/ 下载SDK包：vulkan-sdk.tar.gz 1234cd ~/Programmkdir vulkancd vulkantar zxf $HOME/Downloads/vulkan-sdk.tar.gz 解压后的文件目录如下： 文件夹 描述 x86_64&#x2F;bin Vulkan工具和命令 x86_64&#x2F;include&#x2F;vulkan 编译链接头文件 x86_64&#x2F;lib Vulkan加载程序库和layer运行时库 x86_64&#x2F;etc&#x2F;explicit_layer.d .json 用于Vulkan验证层的清单文件 config 样本层设置文件，系统配置说明 doc Khronos SPIRV，Vulkan，Loader和WSI规范 examples Vulkan程序示例 samples Vulkan的示例代码 source glslang和所选Vulkan组件的源和调试库 1.3 安装SDK123456source ~/Program/vulkan/1.2.170.0/setup-env.shexport VULKAN_SDK=~/vulkan/1.2.170.0/x86_64export PATH=$VULKAN_SDK/bin:$PATHexport LD_LIBRARY_PATH=$VULKAN_SDK/lib:$LD_LIBRARY_PATHexport VK_LAYER_PATH=$VULKAN_SDK/etc/explicit_layer.d 大功告成，检查一下：输入vulkaninfo&#x75;&#98;&#117;&#110;&#116;&#x75;&#x40;&#x31;&#x38;&#46;&#48;&#52;&#x4c; ~ vulkaninfoCannot create Vulkan instance.&#x2F;home&#x2F;lunarg&#x2F;sdk-build&#x2F;Vulkan-Tools&#x2F;vulkaninfo&#x2F;vulkaninfo.c:921: failed with VK_ERROR_INCOMPATIBLE_DRIVER wtf, 发生了什么？等等，貌似我们没有检查是否安装了驱动。。。 1.4 安装驱动123456789sudo add-apt-repository ppa:oibaf/graphics-driverssudo apt updatesudo apt upgradeapt install libvulkan1 mesa-vulkan-drivers vulkan-utils// 或者试试：sudo add-apt-repository ppa:graphics-drivers/ppasudo apt upgradesudo apt install nvidia-graphics-drivers-396 nvidia-settings vulkan vulkan-utils 检查一下：输入vulkaninfo 或者：vulkaninfo –html , 在当前目录生成 vulkaninfo.html 文件，用浏览器打开，可以看到更多信息 1.5. 运行示例程序12345cd Program/vulkan/1.1.160.0/examplesmkdir buildcd buildcmake ..make make成功后会在当前目录生成： 运行示例程序： 1./vkcube 一个旋转的立方体～ 二. GLFW 安装Vulkan本身是一个与平台无关的API，不包括用于创建显示渲染结果的窗口的工具。 为了从Vulkan的跨平台优势中受益并避免X11的限制，我们将使用GLFW库来创建一个支持Windows，Linux和MacOS的窗口。还有其他可用于此目的的库，如SDL，但GLFW的优势在于它除了窗口创建之外，还抽象了Vulkan中一些其他特定于平台的东西。我们将从源代码安装GLFW而不是使用软件包，因为Vulkan支持需要最新版本。 可以在官方网站上找到这些来源。将源代码解压缩到一个方便的目录，并使用CMakeLists.txt等文件打开目录中的终端。 github地址：https://github.com/glfw/glfw解压后进入其主目录：cmake .有报错： 12345678-- Looking for shmat - found-- Found X11: /usr/lib/x86_64-linux-gnu/libX11.soCMake Error at CMakeLists.txt:220 (message): The Xinerama headers were not found-- Configuring incomplete, errors occurred!See also &quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeOutput.log&quot;.See also &quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeError.log&quot;. 缺少环境： 1$ ~/Program/vulkan/glfw-master  sudo apt-get install libsdl2-dev 然后重新: cmake . 123456🦄  ~/Program/vulkan/glfw-master  cmake .-- Could NOT find Doxygen (missing: DOXYGEN_EXECUTABLE) -- Using X11 for window creation-- Configuring done-- Generating done-- Build files have been written to: /home/jh/Program/vulkan/glfw-master 濡染没有报错，但这个也是没有成功的：缺少Doxygensudo apt-get install doxygen 重新: cmake .最后: make成功后：sudo make install 三. GLM 安装与DirectX 12不同，Vulkan不包含用于线性代数运算的库，因此我们必须下载一个。GLM是一个很好的库，设计用于图形API，也常用于OpenGL。它是一个只有头的库，可以从libglm-dev包安装： sudo apt install libglm-dev 四. 手动编译示例代码4.1 在编译示例代码的时候老是报错，找不到vulkan头文件。123456$ gcc -o main main.cpp -lglfw3In file included from main.cpp:2:/usr/local/include/GLFW/glfw3.h:215:12: fatal error: vulkan/vulkan.h: 没有那个文件或目录 #include &lt;vulkan/vulkan.h&gt; ^~~~~~~~~~~~~~~~~compilation terminated. 当然是环境设置的问题：需要将头文件等拷贝到对应system文件夹 12345678cd Program/vulkan/1.2.170.0/x86_64sudo cp -r include/vulkan/ /usr/local/include/sudo cp -P lib/libvulkan.so* /usr/local/lib/sudo cp lib/libVkLayer_*.so /usr/local/lib/sudo mkdir -p /usr/local/share/vulkan/explicit_layer.dsudo cp etc/explicit_layer.d/VkLayer_*.json /usr/local/share/vulkan/explicit_layer.d sudo ldconfig 4.2 error adding symbols: DSO missing from command line123456makeg++ -std=c++17 -I/home/jh/Program/vulkan/1.1.160.0/x86_64/include -o VulkanTest main.cpp -L/home/jh/Program/vulkan/1.1.160.0/x86_64/lib -lvulkan -lglfw3/usr/bin/ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol &#x27;dlclose@@GLIBC_2.2.5&#x27;/usr/bin/ld: //lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command linecollect2: error: ld returned 1 exit statusmake: *** [Makefile:8：VulkanTest] 错误 1 cd &#x2F;usr&#x2F;lib&#x2F;ll |grep -iE “liblog”没有文件 https://github.com/google/glog下载解压, 进入解压后的主目录，执行：.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install 如果报错：autogen.sh: 5: autogen.sh: autoreconf: not foundsudo apt-get install autoconfsudo apt-get install automakesudo apt-get install libtool 重新执行：.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install可能还有权限问题： 123456-- Up-to-date: /usr/local/include/GLFWCMake Error at cmake_install.cmake:41 (file): file INSTALL cannot set permissions on &quot;/usr/local/include/GLFW&quot;make: *** [Makefile:118：install] 错误 1 执行：cd ..chmod a+x glog-master -Rcd glog-mastermake &amp;&amp; make install okay,现在可以在Makefile文件中添加：-lglog 重新 make 还是会存在这个问题，笔者查阅各种资料，大部分指明在Makefile中加入 -ldl 即可，尝试后失败。最后发现是 Makefile 文件写的有问题，改成如[#5.2]即可. 4.3 运行示例make 成功后，会在当前目录生成 VulkanTest 可执行文件: 1./VulkanTest 结果如下: 五. 主要代码5.1 main.cpp123456789101112131415161718192021222324252627282930313233#define GLFW_INCLUDE_VULKAN#include &lt;GLFW/glfw3.h&gt;#define GLM_FORCE_RADIANS#define GLM_FORCE_DEPTH_ZERO_TO_ONE#include &lt;glm/vec4.hpp&gt;#include &lt;glm/mat4x4.hpp&gt;#include &lt;iostream&gt;int main() &#123; glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); GLFWwindow* window = glfwCreateWindow(800, 600, &quot;Vulkan window&quot;, nullptr, nullptr); uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, nullptr); std::cout &lt;&lt; extensionCount &lt;&lt; &quot; extensions supported&quot; &lt;&lt; std::endl; glm::mat4 matrix; glm::vec4 vec; auto test = matrix * vec; while(!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); &#125; glfwDestroyWindow(window); glfwTerminate(); return 0;&#125; 5.2 Makefile12345678910111213141516VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/includeLDFLAGS = -L$(VULKAN_SDK_PATH)/lib -lvulkan `pkg-config --static --libs glfw3`LDFLAGS += -ldlVulkanTest: main.cpp g++ $(CFLAGS) -o VulkanTest main.cpp $(LDFLAGS).PHONY: test cleantest: VulkanTest LD_LIBRARY_PATH=$(VULKAN_SDK_PATH)/lib VK_LAYER_PATH=$(VULKAN_SDK_PATH)/etc/explicit_layer.d ./VulkanTestclean:rm -f VulkanTest","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]}],"categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]}