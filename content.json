{"meta":{"title":"SwallowJoe的博客","subtitle":"Be a real go-getter,<br>NEVER SETTLE!","description":"君子知命不惧，日日自新","author":"SwallowJoe","url":"https://swallowjoe.github.io","root":"/"},"pages":[{"title":"","date":"2022-02-26T09:28:27.221Z","updated":"2022-02-26T09:28:27.221Z","comments":true,"path":"404/index.html","permalink":"https://swallowjoe.github.io/404/index.html","excerpt":"","text":"layout: falsecomments: falsetitle: 404permalink: &#x2F;404 幽灵404页面 html,body{background:#28254C;font-family:'Ubuntu';}*{box-sizing:border-box;}.box{width:350px;height:100%;max-height:600px;min-height:450px;background:#332F63;border-radius:20px;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);padding:30px 50px;}.box .box__ghost{padding:15px 25px 25px;position:absolute;left:50%;top:30%;transform:translate(-50%,-30%);}.box .box__ghost .symbol:nth-child(1){opacity:.2;animation:shine 4s ease-in-out 3s infinite;}.box .box__ghost .symbol:nth-child(1):before,.box .box__ghost .symbol:nth-child(1):after{content:'';width:12px;height:4px;background:#fff;position:absolute;border-radius:5px;bottom:65px;left:0;}.box .box__ghost .symbol:nth-child(1):before{transform:rotate(45deg);}.box .box__ghost .symbol:nth-child(1):after{transform:rotate(-45deg);}.box .box__ghost .symbol:nth-child(2){position:absolute;left:-5px;top:30px;height:18px;width:18px;border:4px solid;border-radius:50%;border-color:#fff;opacity:.2;animation:shine 4s ease-in-out 1.3s infinite;}.box .box__ghost .symbol:nth-child(3){opacity:.2;animation:shine 3s ease-in-out .5s infinite;}.box .box__ghost .symbol:nth-child(3):before,.box .box__ghost .symbol:nth-child(3):after{content:'';width:12px;height:4px;background:#fff;position:absolute;border-radius:5px;top:5px;left:40px;}.box .box__ghost .symbol:nth-child(3):before{transform:rotate(90deg);}.box .box__ghost .symbol:nth-child(3):after{transform:rotate(180deg);}.box .box__ghost .symbol:nth-child(4){opacity:.2;animation:shine 6s ease-in-out 1.6s infinite;}.box .box__ghost .symbol:nth-child(4):before,.box .box__ghost .symbol:nth-child(4):after{content:'';width:15px;height:4px;background:#fff;position:absolute;border-radius:5px;top:10px;right:30px;}.box .box__ghost .symbol:nth-child(4):before{transform:rotate(45deg);}.box .box__ghost .symbol:nth-child(4):after{transform:rotate(-45deg);}.box .box__ghost .symbol:nth-child(5){position:absolute;right:5px;top:40px;height:12px;width:12px;border:3px solid;border-radius:50%;border-color:#fff;opacity:.2;animation:shine 1.7s ease-in-out 7s infinite;}.box .box__ghost .symbol:nth-child(6){opacity:.2;animation:shine 2s ease-in-out 6s infinite;}.box .box__ghost .symbol:nth-child(6):before,.box .box__ghost .symbol:nth-child(6):after{content:'';width:15px;height:4px;background:#fff;position:absolute;border-radius:5px;bottom:65px;right:-5px;}.box .box__ghost .symbol:nth-child(6):before{transform:rotate(90deg);}.box .box__ghost .symbol:nth-child(6):after{transform:rotate(180deg);}.box .box__ghost .box__ghost-container{background:#fff;width:100px;height:100px;border-radius:100px 100px 0 0;position:relative;margin:0 auto;animation:upndown 3s ease-in-out infinite;}.box .box__ghost .box__ghost-container .box__ghost-eyes{position:absolute;left:50%;top:45%;height:12px;width:70px;}.box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-left{width:12px;height:12px;background:#332F63;border-radius:50%;margin:0 10px;position:absolute;left:0;}.box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-right{width:12px;height:12px;background:#332F63;border-radius:50%;margin:0 10px;position:absolute;right:0;}.box .box__ghost .box__ghost-container .box__ghost-bottom{display:flex;position:absolute;top:100%;left:0;right:0;}.box .box__ghost .box__ghost-container .box__ghost-bottom div{flex-grow:1;position:relative;top:-10px;height:20px;border-radius:100%;background-color:#fff;}.box .box__ghost .box__ghost-container .box__ghost-bottom div:nth-child(2n){top:-12px;margin:0 -0px;border-top:15px solid #332F63;background:transparent;}.box .box__ghost .box__ghost-shadow{height:20px;box-shadow:0 50px 15px 5px #3B3769;border-radius:50%;margin:0 auto;animation:smallnbig 3s ease-in-out infinite;}.box .box__description{position:absolute;bottom:30px;left:50%;transform:translateX(-50%);}.box .box__description .box__description-container{color:#fff;text-align:center;width:200px;font-size:16px;margin:0 auto;}.box .box__description .box__description-container .box__description-title{font-size:24px;letter-spacing:.5px;}.box .box__description .box__description-container .box__description-text{color:#8C8AA7;line-height:20px;margin-top:20px;}.box .box__description .box__button{display:block;position:relative;background:#FF5E65;border:1px solid transparent;border-radius:50px;height:50px;text-align:center;text-decoration:none;color:#fff;line-height:50px;font-size:18px;padding:0 70px;white-space:nowrap;margin-top:25px;transition:background .5s ease;overflow:hidden;}.box .box__description .box__button:before{content:'';position:absolute;width:20px;height:100px;background:#fff;bottom:-25px;left:0;border:2px solid #fff;transform:translateX(-50px) rotate(45deg);transition:transform .5s ease;}.box .box__description .box__button:hover{background:transparent;border-color:#fff;}.box .box__description .box__button:hover:before{transform:translateX(250px) rotate(45deg);}@keyframes upndown{0%{transform:translateY(5px);}50%{transform:translateY(15px);}100%{transform:translateY(5px);}}@keyframes smallnbig{0%{width:90px;}50%{width:100px;}100%{width:90px;}}@keyframes shine{0%{opacity:.2;}25%{opacity:.1;}50%{opacity:.2;}100%{opacity:.2;}} 404错误！ 看来我们找不到你要找的那一页 返回 var pageX =$(document).width();var pageY =$(document).height();var mouseY=0;var mouseX=0;$(document).mousemove(function(event ) {mouseY =event.pageY;yAxis =(pageY/2-mouseY)/pageY*300;mouseX =event.pageX / -pageX;xAxis =-mouseX *100 - 100;$('.box__ghost-eyes').css({'transform':'translate('+ xAxis +'%,-'+ yAxis +'%)' });});"},{"title":"tags","date":"2022-02-26T17:54:37.000Z","updated":"2022-02-26T17:55:15.037Z","comments":true,"path":"tags/index.html","permalink":"https://swallowjoe.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-02-26T17:54:25.000Z","updated":"2022-02-26T17:55:06.933Z","comments":true,"path":"categories/index.html","permalink":"https://swallowjoe.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"WMS(9)-Input事件分发给窗口的过程","slug":"WMS(9)-Input事件分发给窗口的过程","date":"2022-05-08T17:35:34.000Z","updated":"2022-06-18T09:57:24.664Z","comments":true,"path":"2022/05/09/WMS(9)-Input事件分发给窗口的过程/","link":"","permalink":"https://swallowjoe.github.io/2022/05/09/WMS(9)-Input%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%BB%99%E7%AA%97%E5%8F%A3%E7%9A%84%E8%BF%87%E7%A8%8B/","excerpt":"以下分析基于Android S. 简述在前面两篇文章中我们打通了应用进程和Input进程，这两者通过一对名为InputChannel实际是通过socket实现的通道来通信。然后我们又梳理了窗口信息是如何更新并传递给Input进程的。现在我们简单梳理一下一次触摸事件分发给窗口的过程。 事件要分发，首先是需要找到被分发的事件和对应的目标窗口。","text":"以下分析基于Android S. 简述在前面两篇文章中我们打通了应用进程和Input进程，这两者通过一对名为InputChannel实际是通过socket实现的通道来通信。然后我们又梳理了窗口信息是如何更新并传递给Input进程的。现在我们简单梳理一下一次触摸事件分发给窗口的过程。 事件要分发，首先是需要找到被分发的事件和对应的目标窗口。 一. 查找Input事件的目标窗口Input事件是显示屏驱动收到中断后通知给InputReader，由其打包交给InputDispatcher分发的，我们直接看InputDispatcher的MotionEvent分发过程。 1.1 InputDispatcher.dispatchMotionLocked123456789101112131415161718192021bool InputDispatcher::dispatchMotionLocked(nsecs_t currentTime, std::shared_ptr&lt;MotionEntry&gt; entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; ...... // 通过输入源确认是否为点击触摸事件 bool isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER; // 输入事件的目标窗口集合 std::vector&lt;InputTarget&gt; inputTargets; // 触摸屏事件 if (isPointerEvent) &#123; // [1.2] 找到此次触摸事件的目标窗口 injectionResult = findTouchedWindowTargetsLocked(currentTime, *entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions); &#125; ...... // [2.1] Input事件的分发 dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125;&#125; Android的输入源有如下几种： 名称 值 含义 AINPUT_SOURCE_CLASS_NONE 0 未定义，交给应用自行处理 AINPUT_SOURCE_CLASS_BUTTON 1 按键之类的设备 AINPUT_SOURCE_CLASS_POINTER 2 输入源是一个与显示器相关联的指向设备，如触摸屏 AINPUT_SOURCE_CLASS_NAVIGATION 4 输入源轨迹球导航设备 AINPUT_SOURCE_CLASS_POSITION 8 输入源是与显示器无关的绝对定位装置，如触控板 AINPUT_SOURCE_CLASS_JOYSTICK 16 输入源是一个操纵杆，摇杆设备 当然，MotionEvent肯定是来自AINPUT_SOURCE_CLASS_POINTER了。 1.2 InputDispatcher.findTouchedWindowTargetsLocked123456789101112131415161718192021222324252627282930313233343536373839404142InputEventInjectionResult InputDispatcher::findTouchedWindowTargetsLocked( nsecs_t currentTime, const MotionEntry&amp; entry, std::vector&lt;InputTarget&gt;&amp; inputTargets, nsecs_t* nextWakeupTime, bool* outConflictingPointerActions) &#123; ...... sp&lt;InputWindowHandle&gt; newTouchedWindowHandle; ...... TouchState tempTouchState; ...... bool isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN; // 区分是否为新的手势事件（区别与ACTION_MOVE） bool newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN || maskedAction == AMOTION_EVENT_ACTION_SCROLL || isHoverAction); ...... if (newGesture || (isSplit &amp;&amp; maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) &#123; int32_t x; int32_t y; ...... // 获取此次触摸事件在屏幕坐标中的位置 x = int32_t(entry.pointerCoords[pointerIndex].getAxisValue(AMOTION_EVENT_AXIS_X)); y = int32_t(entry.pointerCoords[pointerIndex].getAxisValue(AMOTION_EVENT_AXIS_Y)); ...... // [1.3] 根据触摸事件的坐标找到可触摸的窗口 newTouchedWindowHandle = findTouchedWindowAtLocked(displayId, x, y, &amp;tempTouchState, isDown /*addOutsideTargets*/, true /*addPortalWindows*/); ...... if (newTouchedWindowHandle != nullptr) &#123; ...... // [1.4] 将找到的目标窗口存入TouchState中 tempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds); &#125; ....... &#125; ...... // 依次遍历找到的目标窗口 for (const TouchedWindow&amp; touchedWindow : tempTouchState.windows) &#123; // [1.5] 将找到的目标窗口存入inputTargets中 addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags, touchedWindow.pointerIds, inputTargets); &#125; ......&#125; 1.3 InputDispatcher.findTouchedWindowAtLocked1234567891011121314151617181920212223242526272829303132sp&lt;InputWindowHandle&gt; InputDispatcher::findTouchedWindowAtLocked(int32_t displayId, int32_t x, int32_t y, TouchState* touchState, bool addOutsideTargets, bool addPortalWindows, bool ignoreDragWindow) &#123; ...... // [1.3.1] 从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息 const std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; windowHandles = getWindowHandlesLocked(displayId); for (const sp&lt;InputWindowHandle&gt;&amp; windowHandle : windowHandles) &#123; ...... const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo(); if (windowInfo-&gt;displayId == displayId) &#123; auto flags = windowInfo-&gt;flags; // 首先窗口必须是可见的，不可见窗口无法接收input事件 if (windowInfo-&gt;visible) &#123; // 窗口必须不携带NOT_TOUCHABLE的flag if (!flags.test(InputWindowInfo::Flag::NOT_TOUCHABLE)) &#123; bool isTouchModal = !flags.test(InputWindowInfo::Flag::NOT_FOCUSABLE) &amp;&amp; !flags.test(InputWindowInfo::Flag::NOT_TOUCH_MODAL); // [1.3.2] 判断坐标是否位于该窗口内或者该窗口是TOUCH_MODAL的 if (isTouchModal || windowInfo-&gt;touchableRegionContainsPoint(x, y)) &#123; ...... // 找到的第一个窗口直接返回 return windowHandle; &#125; &#125; ...... &#125; &#125; &#125; return nullptr;&#125; 首先从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息，依次遍历，判断窗口是否可见，不可见窗口无法接收input事件。如果可见，在判断窗口是否携带NOT_TOUCHABLE的flag。如果不携带，只要触摸事件的坐标位于该窗口的可触摸区域内，就返回该窗口。 注意getWindowHandlesLocked拿到的窗口是有顺序的，index越小，Z轴越大。因为在SurfaceFlinger.updateInputWindowInfo时我们遍历layer的顺序是沿着Z轴反向遍历的。那么窗口在上面的会存储在mWindowHandlesByDisplay中对应队列的前面，所以这里只需要找到第一个窗口返回即可。 1.3.1 InputDispatcher.getWindowHandlesLocked123456const std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; InputDispatcher::getWindowHandlesLocked( int32_t displayId) const &#123; static const std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; EMPTY_WINDOW_HANDLES; auto it = mWindowHandlesByDisplay.find(displayId); return it != mWindowHandlesByDisplay.end() ? it-&gt;second : EMPTY_WINDOW_HANDLES;&#125; 从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息（WMS中addWindow后添加的）。 1.3.2 InputWindowInfo.touchableRegionContainsPoint123bool InputWindowInfo::touchableRegionContainsPoint(int32_t x, int32_t y) const &#123; return touchableRegion.contains(x,y);&#125; 判断该窗口的可触摸区域是否包含此坐标点。 1.4 TouchState.addOrUpdateWindow12345678910void TouchState::addOrUpdateWindow(const sp&lt;InputWindowHandle&gt;&amp; windowHandle, int32_t targetFlags, BitSet32 pointerIds) &#123; ...... // 封装成TouchedWindow存入windows队列的末尾 TouchedWindow touchedWindow; touchedWindow.windowHandle = windowHandle; touchedWindow.targetFlags = targetFlags; touchedWindow.pointerIds = pointerIds; windows.push_back(touchedWindow);&#125; 将找到的目标窗口封装成TouchedWindow存入TouchState.windows队列的末尾。 1.5 InputDispatcher.addWindowTargetLocked123456789101112131415161718192021222324252627282930313233343536void InputDispatcher::addWindowTargetLocked(const sp&lt;InputWindowHandle&gt;&amp; windowHandle, int32_t targetFlags, BitSet32 pointerIds, std::vector&lt;InputTarget&gt;&amp; inputTargets) &#123; // 使用find_if函数，查找inputTargets中inputChannel的token和传入的窗口token一致的InputTarget std::vector&lt;InputTarget&gt;::iterator it = std::find_if(inputTargets.begin(), inputTargets.end(), [&amp;windowHandle](const InputTarget&amp; inputTarget) &#123; return inputTarget.inputChannel-&gt;getConnectionToken() == windowHandle-&gt;getToken(); &#125;); const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo(); // 当it是指向inputTargets.end()时，说明inputTargets中不存在和传入的窗口token一致的InputTarget对象 if (it == inputTargets.end()) &#123; // 创建新的InputTarget，对应传入的窗口，放在inputTargets队列的末尾 InputTarget inputTarget; std::shared_ptr&lt;InputChannel&gt; inputChannel = getInputChannelLocked(windowHandle-&gt;getToken()); if (inputChannel == nullptr) &#123; ALOGW(&quot;Window %s already unregistered input channel&quot;, windowHandle-&gt;getName().c_str()); return; &#125; inputTarget.inputChannel = inputChannel; inputTarget.flags = targetFlags; inputTarget.globalScaleFactor = windowInfo-&gt;globalScaleFactor; inputTarget.displaySize = vec2(windowHandle-&gt;getInfo()-&gt;displayWidth, windowHandle-&gt;getInfo()-&gt;displayHeight); inputTargets.push_back(inputTarget); it = inputTargets.end() - 1; &#125; ALOG_ASSERT(it-&gt;flags == targetFlags); ALOG_ASSERT(it-&gt;globalScaleFactor == windowInfo-&gt;globalScaleFactor); // 将pointerIds存入InputTarget, 顺便将transform存入pointerTransforms中，以方便做转换 it-&gt;addPointers(pointerIds, windowInfo-&gt;transform);&#125; 这里也是比较简单的一个函数，首先使用find_if函数，查找inputTargets中inputChannel的token和传入的窗口token一致的InputTarget，如果不存在就根据传入的窗口信息windowHandle创键新的InputTarget并存入inputTargets队列的末尾。 二. Input事件分发2.1 InputDispatcher.dispatchEventLocked1234567891011121314151617181920212223void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, std::shared_ptr&lt;EventEntry&gt; eventEntry, const std::vector&lt;InputTarget&gt;&amp; inputTargets) &#123; ...... // 这里通过JNI调用到PowerManagerService, 更新自动灭屏的时间，这样触碰屏幕后自动灭屏就重新开始计时了 pokeUserActivityLocked(*eventEntry); // 依次遍历所有的目标窗口 for (const InputTarget&amp; inputTarget : inputTargets) &#123; // [2.1.1] 拿到目标窗口InputChannel对应的Connection sp&lt;Connection&gt; connection = getConnectionLocked(inputTarget.inputChannel-&gt;getConnectionToken()); if (connection != nullptr) &#123; // [2.2] 准备分发 prepareDispatchCycleLocked(currentTime, connection, eventEntry, inputTarget); &#125; else &#123; if (DEBUG_FOCUS) &#123; ALOGD(&quot;Dropping event delivery to target with channel &#x27;%s&#x27; because it &quot; &quot;is no longer registered with the input dispatcher.&quot;, inputTarget.inputChannel-&gt;getName().c_str()); &#125; &#125; &#125;&#125; 2.1.1 InputDispatcher.getConnectionLocked12345678910111213sp&lt;Connection&gt; InputDispatcher::getConnectionLocked(const sp&lt;IBinder&gt;&amp; inputConnectionToken) const &#123; if (inputConnectionToken == nullptr) &#123; return nullptr; &#125; for (const auto&amp; [token, connection] : mConnectionsByToken) &#123; if (token == inputConnectionToken) &#123; return connection; &#125; &#125; return nullptr;&#125; 传入的token就是InputChannel初始化时创建BBinder, 而InputChannel创建完成后会生成Connection存入mConnectionsByToken，这个发生在InputDispatcher::createInputChannel中。 2.2 InputDispatcher.prepareDispatchCycleLocked1234567891011121314151617181920212223242526void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, std::shared_ptr&lt;EventEntry&gt; eventEntry, const InputTarget&amp; inputTarget) &#123; ...... // 将Input事件和对应分发的连接作为一次分发事件存入Input分发队列 enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);&#125;void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, std::shared_ptr&lt;EventEntry&gt; eventEntry, const InputTarget&amp; inputTarget) &#123; ...... // 判断该连接是否存在input事件待分发 bool wasEmpty = connection-&gt;outboundQueue.empty(); ...... enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_IS); ...... // 如果出站队列之前为空，则启动调度周期 if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.empty()) &#123; // [2.3] 启动input事件分发 startDispatchCycleLocked(currentTime, connection); &#125;&#125; 2.3 InputDispatcher.startDispatchCycleLocked123456789101112131415161718void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; ...... // InputChannel连接正常，将待分发队列里的事件一一分发 while (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.empty()) &#123; // 每次都取第一个事件，保证先进先出 DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.front(); ...... const EventEntry&amp; eventEntry = *(dispatchEntry-&gt;eventEntry); switch (eventEntry.type) &#123; ...... case EventEntry::Type::MOTION: &#123; ...... // [2.4] 发布input事件，将input事件所有信息都发出去 status = connection-&gt;inputPublisher .publishMotionEvent(......); ......&#125; 当InputChannel对应的连接正常，则将待分发队列里的事件一一分发，每次都取outboundQueue中的第一个事件，保证先进先出。 Connection中的InputPublisher就是Connection初始化时创建的InputPublisher。 2.4 InputPublisher.publishMotionEvent12345678910111213141516171819status_t InputPublisher::publishMotionEvent( uint32_t seq, int32_t eventId, int32_t deviceId, int32_t source, int32_t displayId, std::array&lt;uint8_t, 32&gt; hmac, int32_t action, int32_t actionButton, int32_t flags, int32_t edgeFlags, int32_t metaState, int32_t buttonState, MotionClassification classification, const ui::Transform&amp; transform, float xPrecision, float yPrecision, float xCursorPosition, float yCursorPosition, int32_t displayWidth, int32_t displayHeight, nsecs_t downTime, nsecs_t eventTime, uint32_t pointerCount, const PointerProperties* pointerProperties, const PointerCoords* pointerCoords) &#123; ...... // 将input事件封装成InputMessage InputMessage msg; msg.header.type = InputMessage::Type::MOTION; ...... msg.body.motion.eventTime = eventTime; msg.body.motion.pointerCount = pointerCount; ...... // 交给InputChannel将input事件通知给应用进程 return mChannel-&gt;sendMessage(&amp;msg);&#125; 将input事件封装成InputMessage, 在交给InputChannel将input事件通知给应用进程. 2.5 InputChannel.sendMessage12345678910111213status_t InputChannel::sendMessage(const InputMessage* msg) &#123; const size_t msgLength = msg-&gt;size(); InputMessage cleanMsg; msg-&gt;getSanitizedCopy(&amp;cleanMsg); ssize_t nWrite; do &#123; // 交给Socket进行通信 nWrite = ::send(getFd(), &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); ...... return OK;&#125; 经过InputChannel, 此次的input事件就通知给了目标窗口所在进程。回忆一下，我们应用进程中注册该InputChannel对的Socket文件描述符是在NativeInputEventReceiver中的： 123456789101112void NativeInputEventReceiver::setFdEvents(int events) &#123; if (mFdEvents != events) &#123; mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; // 将InputChannel中的客户端Socket的文件描述符加入的Looper中监听 mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, nullptr); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; 所以我们应用进程收到该socket文件描述符消息时，会调用NativeInputEventReceiver::handleEvent函数了（Looper机制）。 三. 应用进程收到Input事件3.1 NativeInputEventReceiver.handleEvent1234567891011int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; ...... if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); // [3.2] 消费此次input事件 status_t status = consumeEvents(env, false /*consumeBatches*/, -1, nullptr); mMessageQueue-&gt;raiseAndClearException(env, &quot;handleReceiveCallback&quot;); return status == OK || status == NO_MEMORY ? KEEP_CALLBACK : REMOVE_CALLBACK; &#125; ......&#125; 3.2 NativeInputEventReceiver.consumeEvents12345678910111213141516171819202122232425262728293031323334353637status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; ...... for (;;) &#123; uint32_t seq; InputEvent* inputEvent; // [3.3] 将接收到的数据封装成InputEvent status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); ...... if (!skipCallbacks) &#123; ...... jobject inputEventObj; switch (inputEvent-&gt;getType()) &#123; ...... case AINPUT_EVENT_TYPE_MOTION: &#123; MotionEvent* motionEvent = static_cast&lt;MotionEvent*&gt;(inputEvent); if ((motionEvent-&gt;getAction() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123; *outConsumedBatch = true; &#125; // 通过JNI创建java层的MotionEvent对象 inputEventObj = android_view_MotionEvent_obtainAsCopy(env, motionEvent); break; &#125; ...... &#125; if (inputEventObj) &#123; // [3.4] 通过JNI调用dispatchInputEvent将Input事件分发给应用java层的View env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); ...... // 此次Input事件使用之后就回收 env-&gt;DeleteLocalRef(inputEventObj); &#125; &#125; &#125;&#125; consumeEvents就是接收socket数据，将input事件封装成对应类型的对象，如触摸事件对应MotionEvent，按键事件对应KeyEvent. 然后通过JNI创建对应java层的input事件对象，最后调用InputEventReceiver.dispatchInputEvent将Input事件分发给应用java层的View。 3.3 InputConsumer.consume123456789101112131415161718192021222324252627status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123; ...... *outSeq = 0; *outEvent = nullptr; while (!*outEvent) &#123; ...... // [3.3.1] 通过recv函数接收Socket数据 status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); ...... switch (mMsg.header.type) &#123; ...... case InputMessage::Type::MOTION: &#123; ...... // 创建MotionEvent MotionEvent* motionEvent = factory-&gt;createMotionEvent(); if (!motionEvent) return NO_MEMORY; // 更新触摸状态信息 updateTouchState(mMsg); // 使用收到的InputMessage填充创建的MotionEvent initializeMotionEvent(motionEvent, &amp;mMsg); &#125; ...... &#125; &#125; return OK;&#125; 这里首先在InputChannel中通过recv函数接收来自Input系统的Socket数据(InputMessage), 然后根据input类型分别封装成对应的input事件，比如MotionEvent、KeyEvent等。 3.3.1 InputChannel.receiveMessage12345678status_t InputChannel::receiveMessage(InputMessage* msg) &#123; ssize_t nRead; do &#123; // 通过recv函数接收Socket数据 nRead = ::recv(getFd(), msg, sizeof(InputMessage), MSG_DONTWAIT); &#125; while (nRead == -1 &amp;&amp; errno == EINTR); ......&#125; 通过recv函数接收Socket数据, 还原成InputMessage. 3.4 WindowInputEventReceiver.dispatchInputEvent1234567// Called from native code.@SuppressWarnings(&quot;unused&quot;)@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event);&#125; 注意这里JNI注册的InputEventReceiver其实是ViewRootImpl中的WindowInputEventReceiver, 所以onInputEvent其实是调用了被Override的子类函数。 12345678// WindowInputEventReceiver.java@Overridepublic void onInputEvent(InputEvent event) &#123; ...... &#125; else &#123; enqueueInputEvent(event, this, 0, true); &#125;&#125; 后面将事件分发给对应的View组件的过程，其实也不难猜测，因为View是树形结构，只需要前序遍历该树找到input事件坐标所在的最叶子节点的View，如果该View消耗了此次事件，也就是设置了对应的Listener并实现了接口返回true, 那么该事件就不继续分发了。否则沿着树形结构依次遍历父View，看是否需要使用该事件。 到这里，Input和窗口的关系分析就告一段落了。接下来分析窗口对应的View和SurfaceFlinger通信过程。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"},{"name":"Input","slug":"Android/WMS/Input","permalink":"https://swallowjoe.github.io/categories/Android/WMS/Input/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"},{"name":"Input","slug":"Input","permalink":"https://swallowjoe.github.io/tags/Input/"}]},{"title":"WMS(8)-窗口信息传递给Input系统","slug":"WMS(8)-窗口信息传递给Input系统","date":"2022-05-07T17:35:34.000Z","updated":"2022-06-18T09:57:17.677Z","comments":true,"path":"2022/05/08/WMS(8)-窗口信息传递给Input系统/","link":"","permalink":"https://swallowjoe.github.io/2022/05/08/WMS(8)-%E7%AA%97%E5%8F%A3%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E7%BB%99Input%E7%B3%BB%E7%BB%9F/","excerpt":"以下分析基于Android S. 简述上文中，我们知道了应用View和窗口与input系统交互通道InputChannel的打通过程。有了通信通道，就可以通过这个来通信，将input事件传递给应用程序。很自然的，input系统中必须要保存代表该应用窗口的对象，用于识别以及分发事件。 还记得我们初始化WindowState时，有创建过一个InputWindowHandleWrapper类的对象，当时我们认为是将该Window注册进input系统：","text":"以下分析基于Android S. 简述上文中，我们知道了应用View和窗口与input系统交互通道InputChannel的打通过程。有了通信通道，就可以通过这个来通信，将input事件传递给应用程序。很自然的，input系统中必须要保存代表该应用窗口的对象，用于识别以及分发事件。 还记得我们初始化WindowState时，有创建过一个InputWindowHandleWrapper类的对象，当时我们认为是将该Window注册进input系统： 123456789101112131415// 创建InputApplicationHandle, 将该Window注册进Input系统，以便后续input事件传输mInputWindowHandle = new InputWindowHandleWrapper(new InputWindowHandle( mActivityRecord != null ? mActivityRecord.getInputApplicationHandle(false /* update */) : null, getDisplayId()));// ActivityRecord.java@NonNull InputApplicationHandle getInputApplicationHandle(boolean update) &#123; if (mInputApplicationHandle == null) &#123; // 创建InputApplicationHandle, 这里的appToken是IApplicationToken.Stub的子类对象，是ActivityRecord初始化时创建的 mInputApplicationHandle = new InputApplicationHandle(appToken, toString(), mInputDispatchingTimeoutMillis); ...... return mInputApplicationHandle;&#125; 我们先看看这里InputWindowHandleWrapper、InputWindowHandle、InputApplicationHandle等相关类的类图： 可以看到这里InputWindowHandle类中包含该Window的大小和位置、可触碰区域(touchableRegion)等等信息，这些信息是什么时候更新的呢？回到我们之前研究过的焦点窗口的更新一文，在WMS.addWindow中创建WindowState的对象并且更新焦点窗口后，会更新input相关信息: 123456789// WMS.addWindow// 如果焦点窗口有更新，也需要更新input相关设置if (focusChanged) &#123; // [1.1] 设置输入焦点窗口信息 displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus, false /*updateInputWindows*/);&#125;// [1.2] 更新输入窗口信息displayContent.getInputMonitor().updateInputWindowsLw(false /*force*/); 这里我们加上mCurrentFocus就是此次新创建的WindowState. 一. 更新窗口信息1.1 InputMonitor.setInputFocusLw1234567891011121314151617181920212223void setInputFocusLw(WindowState newWindow, boolean updateInputWindows) &#123; ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, &quot;Input focus has changed to %s display=%d&quot;, newWindow, mDisplayId); final IBinder focus = newWindow != null ? newWindow.mInputChannelToken : null; if (focus == mInputFocus) &#123; return; &#125; if (newWindow != null &amp;&amp; newWindow.canReceiveKeys()) &#123; // 隐式地显示一个窗口将导致取消调度, 为了防止错误，如果有人暂停调度但忘记resume newWindow.mToken.paused = false; &#125; // 标记mUpdateInputWindowsNeeded为true setUpdateInputWindowsNeededLw(); // 此时传入的updateInputWindows为false, 表明不是此时更新信息的 if (updateInputWindows) &#123; updateInputWindowsLw(false /*force*/); &#125;&#125;void setUpdateInputWindowsNeededLw() &#123; mUpdateInputWindowsNeeded = true;&#125; 这里是判断新的窗口是否与当前输入焦点窗口一致，如果不一致，则标记mUpdateInputWindowsNeeded为true，表明需要更新输入窗口了。 1.2 InputMonitor.updateInputWindowsLw123456789101112131415161718192021void updateInputWindowsLw(boolean force) &#123; // mUpdateInputWindowsNeeded 在[1.1]中就被标记为true了 if (!force &amp;&amp; !mUpdateInputWindowsNeeded) &#123; return; &#125; scheduleUpdateInputWindows();&#125;private void scheduleUpdateInputWindows() &#123; // 当前input对应的Display设备被移除时，无需处理 if (mDisplayRemoved) &#123; return; &#125; // mUpdateInputWindowsPending默认是false // 用于标记当前是否有存在尚未执行的 mUpdateInputWindows if (!mUpdateInputWindowsPending) &#123; mUpdateInputWindowsPending = true; // [1.3] 将输入窗口信息交给&quot;android.anim&quot;线程处理，mHandler=&gt;WMS.mAnimationHandler mHandler.post(mUpdateInputWindows); &#125;&#125; 先判断是否需要执行更新（mUpdateInputWindowsNeeded变量），如果需要则将更新操作交给”android.anim”线程处理。 1.3 InputMonitor.UpdateInputWindows.run1234567891011121314151617181920public void run() &#123; synchronized (mService.mGlobalLock) &#123; // 执行输入窗口信息更新，将变量恢复 mUpdateInputWindowsPending = false; mUpdateInputWindowsNeeded = false; if (mDisplayRemoved) &#123; return; &#125; // 用可能接收输入的所有窗口的信息填充输入窗口列表 // 作为一个优化，可以尝试修剪窗口列表，但这是困难的，因为只有native代码知道哪个窗口当前有触摸焦点。 // 如果滑动过程中有拖拽，提供一个伪窗口来捕获拖拽输入，为了方便分析这里加上是非拖拽 final boolean inDrag = mService.mDragDropController.dragDropActiveLocked(); // [1.4] 在默认Display中添加所有窗口 mUpdateInputForAllWindowsConsumer.updateInputWindows(inDrag); &#125;&#125; 在”android.anim”线程处理时，首先将标记变量恢复为false, 表示可以接收下一次输入窗口更新了。接下来就是在默认Display中添加所有窗口了。 1.4 InputMonitor.UpdateInputForAllWindowsConsumer.updateInputWindows12345678910111213141516171819202122232425262728293031323334353637383940private void updateInputWindows(boolean inDrag) &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;updateInputWindows&quot;); // 获取对应的InputConsumer mPipInputConsumer = getInputConsumer(INPUT_CONSUMER_PIP); mWallpaperInputConsumer = getInputConsumer(INPUT_CONSUMER_WALLPAPER); mRecentsAnimationInputConsumer = getInputConsumer(INPUT_CONSUMER_RECENTS_ANIMATION); // 判断对应InputConsumer是否为null mAddPipInputConsumerHandle = mPipInputConsumer != null; mAddWallpaperInputConsumerHandle = mWallpaperInputConsumer != null; mAddRecentsAnimationInputConsumerHandle = mRecentsAnimationInputConsumer != null; mDisableWallpaperTouchEvents = false; mInDrag = inDrag; // mInputConsumers 中所有的InputConsumer都调用hide隐藏 resetInputConsumers(mInputTransaction); mRecentsAnimationFocusOverride = false; // [1.5] 从上到下（Z轴大到小）遍历该DisplayContent中所有的WindowState // 依次执行UpdateInputForAllWindowsConsumer.accept mDisplayContent.forAllWindows(this, true /* traverseTopToBottom */); if (mRecentsAnimationFocusOverride) &#123; requestFocus(mRecentsAnimationInputConsumer.mWindowHandle.token, mRecentsAnimationInputConsumer.mName); &#125; else &#123; // [1.6] 将焦点窗口信息更新给input系统 updateInputFocusRequest(); &#125; // mUpdateInputWindowsImmediately一般为false if (!mUpdateInputWindowsImmediately) &#123; mDisplayContent.getPendingTransaction().merge(mInputTransaction); mDisplayContent.scheduleAnimation(); &#125; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);&#125;InputConsumerImpl getInputConsumer(String name) &#123; return mInputConsumers.get(name);&#125; InputConsumer总共有四种: INPUT_CONSUMER_PIP: “pip_input_consumer”, 用于pip INPUT_CONSUMER_NAVIGATION: “nav_input_consumer”，用于导航栏 INPUT_CONSUMER_WALLPAPER: “wallpaper_input_consumer”，用于壁纸 INPUT_CONSUMER_RECENTS_ANIMATION: “recents_animation_input_consumer”，用于多任务 更新输入窗口的步骤如下: 重置InputConsumer，将所有consumer都调用hide 从上到下（Z轴大到小）遍历该DisplayContent中所有的WindowState，依次执行UpdateInputForAllWindowsConsumer.accept 这个accept就是计算更新窗口信息，比如可触碰区域的计算 通过SurfaceControl传递窗口信息给SurfaceFlinger，在native层生成对应的InputWindowHandle 如果有最近任务栏动画，则调用requestFocus更新多任务焦点；否则调用updateInputFocusRequest更新输入焦点请求 1.5 InputMonitor.UpdateInputForAllWindowsConsumer.accept12345678910111213141516public void accept(WindowState w) &#123; // 这里假设传入的WindowState是addWindow中新创建的 final InputWindowHandleWrapper inputWindowHandle = w.mInputWindowHandle; ...... // 注册事件拦截信息 mService.mKeyInterceptionInfoForToken.put(w.mInputChannelToken, w.getKeyInterceptionInfo()); // [1.5.1] mWinAnimator是WindowState初始化时构建的WindowStateAnimator对象 if (w.mWinAnimator.hasSurface()) &#123; // [1.5.2] 计算更新该窗口的信息 populateInputWindowHandle(inputWindowHandle, w); // [1.5.3] 通知对应Surface更新窗口信息 setInputWindowInfoIfNeeded(mInputTransaction, w.mWinAnimator.mSurfaceController.mSurfaceControl, inputWindowHandle); &#125;&#125; 1.5.1 WindowStateAnimator.hasSurface1234567891011// WindowStateAnimator.javaboolean hasSurface() &#123; // mSurfaceController是WindowSurfaceController的对象 return mSurfaceController != null &amp;&amp; mSurfaceController.hasSurface();&#125;// WindowSurfaceController.javaboolean hasSurface() &#123; // SurfaceControl对象，在WindowSurfaceController初始化时构建 return mSurfaceControl != null;&#125; WindowStateAnimator中的mSurfaceController是WindowSurfaceController的对象，在其对应的Window被调用relayoutWindow时通过winAnimator.createSurfaceLocked(win.mAttrs.type)创建的。 而relayoutWindow则是三方应用进程接收到Vsync信号之后，调用对应的ViewRootImpl中的performTraversals在通过Session通知到WMS执行的。在这里我们假设”android.anim”线程更新所有输入窗口时，这个新建的WindowState已经被调用过了relayoutWindow，存在Surface。 1.5.2 InputMonitor.populateInputWindowHandle123456789101112131415161718192021222324252627282930313233343536373839404142void populateInputWindowHandle(final InputWindowHandleWrapper inputWindowHandle, final WindowState w) &#123; // 添加一个窗口到可输入事件的窗口列表中 // 设置窗口相关信息到inputWindowHandle中 inputWindowHandle.setInputApplicationHandle(w.mActivityRecord != null ? w.mActivityRecord.getInputApplicationHandle(false /* update */) : null); inputWindowHandle.setToken(w.mInputChannelToken); // 设置该窗口的input超时时长，如果该WindowState对应Activity，这个时长就是5s inputWindowHandle.setDispatchingTimeoutMillis(w.getInputDispatchingTimeoutMillis()); inputWindowHandle.setTouchOcclusionMode(w.getTouchOcclusionMode()); inputWindowHandle.setInputFeatures(w.mAttrs.inputFeatures); inputWindowHandle.setPaused(w.mActivityRecord != null &amp;&amp; w.mActivityRecord.paused); inputWindowHandle.setVisible(w.isVisible()); // 设置是否可聚焦 final boolean focusable = w.canReceiveKeys() &amp;&amp; (mService.mPerDisplayFocusEnabled || mDisplayContent.isOnTop()); inputWindowHandle.setFocusable(focusable); // 是否包含壁纸 final boolean hasWallpaper = mDisplayContent.mWallpaperController.isWallpaperTarget(w) &amp;&amp; !mService.mPolicy.isKeyguardShowing() &amp;&amp; !mDisableWallpaperTouchEvents; inputWindowHandle.setHasWallpaper(hasWallpaper); final Rect frame = w.getFrame(); // 设置该窗口的位置和大小 inputWindowHandle.setFrame(frame.left, frame.top, frame.right, frame.bottom); // Surface insets 被硬编码为在所有方向上都是相同的，所以这里仅需一个参数 inputWindowHandle.setSurfaceInset(w.mAttrs.surfaceInsets.left); // 如果缩放窗口，输入坐标需要反向缩放，将屏幕上的内容映射到UI中实际触摸的内容 inputWindowHandle.setScaleFactor(w.mGlobalScale != 1f ? (1f / w.mGlobalScale) : 1f); // [1.5.2.1] 计算窗口可触摸区域 final int flags = w.getSurfaceTouchableRegion(mTmpRegion, w.mAttrs.flags); // 将计算得到的可触摸区域保存在inputWindowHandle中 inputWindowHandle.setTouchableRegion(mTmpRegion); inputWindowHandle.setLayoutParamsFlags(flags); ......&#125; 1.5.2.1 WindowState.getSurfaceTouchableRegion12345678910111213141516171819202122232425262728293031323334int getSurfaceTouchableRegion(Region region, int flags) &#123; // 判断该WindowState是否包含FLAG_NOT_TOUCH_MODAL和FLAG_NOT_FOCUSABLE，表明该窗口无法接收input以及无法作为焦点 final boolean modal = (flags &amp; (FLAG_NOT_TOUCH_MODAL | FLAG_NOT_FOCUSABLE)) == 0; if (modal) &#123; flags |= FLAG_NOT_TOUCH_MODAL; if (mActivityRecord != null) &#123; // [1.5.2.2] 将外部接触限制在活动根任务区域 updateRegionForModalActivityWindow(region); &#125; else &#123; // 首先给一个足够大的可触摸区域，因为它是触摸模态 // 窗口可能会在显示器上移动，所以可触摸区域应该足够大，以确保它覆盖整个显示器，无论它移动到哪里 // 比如启动窗口 getDisplayContent().getBounds(mTmpRect); final int dw = mTmpRect.width(); final int dh = mTmpRect.height(); region.set(-dw, -dh, dw + dw, dh + dh); &#125; // 将计算得到的窗口可触摸区域减去其不可触碰的区域 subtractTouchExcludeRegionIfNeeded(region); &#125; else &#123; // Not modal getTouchableRegion(region); &#125; // 转换为基于Surface的坐标, 因为Android中坐标原点在左上角，Y轴正方向向下，X轴正方向向右 final Rect frame = mWindowFrames.mFrame; if (frame.left != 0 || frame.top != 0) &#123; region.translate(-frame.left, -frame.top); &#125; ...... return flags;&#125; FLAG_NOT_TOUCH_MODAL: 允许窗口外的任何指针事件被发送到它后面的窗口, 即使这个窗口是可聚焦的。否则（不带此标志），窗口将消耗所有指针事件本身，而不管它们是否在窗口内。 FLAG_NOT_FOCUSABLE: 标记这个窗口永远不能接收触摸事件 Android中坐标原点在左上角，Y轴正方向向下，X轴正方向向右，所以计算的窗口可触摸区域需要转换为基于Surface的坐标。 1.5.2.2 WindowState.updateRegionForModalActivityWindow1234567891011121314151617181920212223242526272829private void updateRegionForModalActivityWindow(Region outRegion) &#123; // 获取内部边界的letterbox可触摸区域（一般不会设置的，这个就是&lt;activity&gt;中的android:maxAspectRatio属性） mActivityRecord.getLetterboxInnerBounds(mTmpRect); // 假设此时mTmpRect为empty的 if (mTmpRect.isEmpty()) &#123; // [1.5.2.3] 获取该ActivityRecord的View边界 final Rect transformedBounds = mActivityRecord.getFixedRotationTransformDisplayBounds(); if (transformedBounds != null) &#123; // Task与显示的方向相同，所以旋转的边界应该被选择为可触摸区域。当表面层将区域转换为显示空间时，方向是一致的。 mTmpRect.set(transformedBounds); &#125; else &#123; // 如果这是一个模态窗口，我们需要dismiss它如果它不是全屏，触摸发生在显示内容的窗口之外 // 这意味着我们需要拦截窗口外的触摸。与窗口(任务或根任务)相关联的dim layer将给一个界限，因为它们将用于显示dim layer final Task task = getTask(); if (task != null) &#123; // [1.5.2.4] 通过该WindowState所在Task获取该窗口的可触摸区域 task.getDimBounds(mTmpRect); &#125; else if (getRootTask() != null) &#123; getRootTask().getDimBounds(mTmpRect); &#125; &#125; &#125; // 如果当前窗口是freeform窗口模式时，调整区域大小 adjustRegionInFreefromWindowMode(mTmpRect); // 将计算后的可触摸区域大小复制给outRegion使用 outRegion.set(mTmpRect); // 根据坐标系调整RootTask边界大小 cropRegionToRootTaskBoundsIfNeeded(outRegion);&#125; ActivityRecord.getLetterboxInnerBounds是获取内部边界的letterbox可触摸区域;一般不会设置的，这个就是中的android:maxAspectRatio属性。 至于freeform模式的窗口调整区域大小以及根据坐标系调整RootTask边界，感兴趣的可以继续研究。这里仅须知道窗口的可触摸区域是怎么拿到的即可。 1.5.2.3 ActivityRecord.getFixedRotationTransformDisplayBounds1234567891011Rect getFixedRotationTransformDisplayBounds() &#123; return isFixedRotationTransforming() ? mFixedRotationTransformState.mRotatedOverrideConfiguration.windowConfiguration .getBounds() : null;&#125;boolean isFixedRotationTransforming() &#123; return mFixedRotationTransformState != null &amp;&amp; mFixedRotationTransformState.mIsTransforming;&#125; mFixedRotationTransformState是当手机方向旋转之后就会生成的， 这里我们假设没有发生旋转。 1.5.2.4 Task.getDimBounds123456789101112131415161718192021222324252627282930313233343536373839void getDimBounds(Rect out) &#123; // 如果当前task是RootTask, 那么直接返回其边界大小 if (isRootTask()) &#123; getBounds(out); return; &#125; final Task rootTask = getRootTask(); final DisplayContent displayContent = rootTask.getDisplayContent(); final boolean dockedResizing = displayContent != null &amp;&amp; displayContent.mDividerControllerLocked.isResizing(); // 判断该Task的WindowMode是否是Freeform模式，如果是，则找到该Task中最大的可见的区域 if (inFreeformWindowingMode()) &#123; boolean[] foundTop = &#123; false &#125;; final PooledConsumer c = PooledLambda.obtainConsumer(Task::getMaxVisibleBounds, PooledLambda.__(ActivityRecord.class), out, foundTop); forAllActivities(c); c.recycle(); if (foundTop[0]) &#123; return; &#125; &#125; // 当前task和父容器边界不匹配(此状态发生在回到home最小化task时)，假设是匹配的 if (!matchParentBounds()) &#123; if (dockedResizing) &#123; rootTask.getBounds(out); &#125; else &#123; rootTask.getBounds(mTmpRect); // 取两个边界的交集 mTmpRect.intersect(getBounds()); out.set(mTmpRect); &#125; &#125; else &#123; // 边界直接用当前task边界 out.set(getBounds()); &#125; return;&#125; 窗口模式有如下7种： 窗口模式 值 含义 WINDOWING_MODE_UNDEFINED 0 当前窗口模式尚未定义 WINDOWING_MODE_FULLSCREEN 1 占据屏幕或父容器的整个区域 WINDOWING_MODE_PINNED 2 总是在顶部(总是可见, 覆盖它的父容器中的其他兄弟容器) WINDOWING_MODE_SPLIT_SCREEN_PRIMARY 3 驱动屏幕处于分屏模式的主容器 WINDOWING_MODE_SPLIT_SCREEN_SECONDARY 4 在分屏模式下，紧邻WINDOWING_MODE_SPLIT_SCREEN_PRIMARY容器的容器 WINDOWING_MODE_FREEFORM 5 可以在其父容器内自由调整大小，如悬浮窗 WINDOWING_MODE_MULTI_WINDOW 6 窗口管理器中没有表示属性的通用多窗口 获取Task的边界大小的过程如下: 如果当前Task就是RootTask, 那么直接返回该Task的边界 判断该Task的WindowMode是否是Freeform模式，如果是，则找到该Task中最大的可见的区域并返回 当前Task和父容器边界不匹配时 如果该Task被最小化时，直接返回该Task的RootTask的边界 否则获取RootTask边界与当前Task边界的交集并返回 当前Task和父容器边界匹配时 直接返回该Task的边界 1.5.3 InputMonitor.setInputWindowInfoIfNeeded1234567891011static void setInputWindowInfoIfNeeded(SurfaceControl.Transaction t, SurfaceControl sc, InputWindowHandleWrapper inputWindowHandle) &#123; if (DEBUG_INPUT) &#123; Slog.d(TAG_WM, &quot;Update InputWindowHandle: &quot; + inputWindowHandle); &#125; // 在 [1.5.2] 有更新内容，所以isChanged必然返回true if (inputWindowHandle.isChanged()) &#123; // [1.5.4] 更新给Surface inputWindowHandle.applyChangesToSurface(t, sc); &#125;&#125; 1.5.4 InputWindowHandleWrapper.applyChangesToSurface12345void applyChangesToSurface(@NonNull SurfaceControl.Transaction t, @NonNull SurfaceControl sc) &#123; // [1.5.5] 通过Transaction传递信息 t.setInputWindowInfo(sc, mHandle); mChanged = false;&#125; 1.5.5 SurfaceControl.Transaction.setInputWindowInfo12345678910public Transaction setInputWindowInfo(SurfaceControl sc, InputWindowHandle handle) &#123; // 确认该SurfaceControl没有被释放 checkPreconditions(sc); // [1.5.6] 通知给SurfaceFlinger nativeSetInputWindowInfo(mNativeObject, sc.mNativeObject, handle); return this;&#125;private static native void nativeSetInputWindowInfo(long transactionObj, long nativeObject, InputWindowHandle handle); 1.5.6 android_view_SurfaceControl.nativeSetInputWindowInfo1234567891011121314static void nativeSetInputWindowInfo(JNIEnv* env, jclass clazz, jlong transactionObj, jlong nativeObject, jobject inputWindow) &#123; auto transaction = reinterpret_cast&lt;SurfaceComposerClient::Transaction*&gt;(transactionObj); // [1.5.6.1] 根据传入的InputWindowHandle获取NativeInputWindowHandle sp&lt;NativeInputWindowHandle&gt; handle = android_view_InputWindowHandle_getHandle( env, inputWindow); // [1.5.6.2] 更新NativeInputWindowHandle信息 handle-&gt;updateInfo(); auto ctrl = reinterpret_cast&lt;SurfaceControl *&gt;(nativeObject); // [1.5.6.3] 通知给SurfaceFligner transaction-&gt;setInputWindowInfo(ctrl, *handle-&gt;getInfo());&#125; 1.5.6.1 android_hardware_input_InputWindowHandle.android_view_InputWindowHandle_getHandle12345678910111213141516171819202122sp&lt;NativeInputWindowHandle&gt; android_view_InputWindowHandle_getHandle( JNIEnv* env, jobject inputWindowHandleObj) &#123; if (!inputWindowHandleObj) &#123; return NULL; &#125; AutoMutex _l(gHandleMutex); // 获取inputWindowHandle中对应的ptr, 该ptr就对应NativeInputWindowHandle jlong ptr = env-&gt;GetLongField(inputWindowHandleObj, gInputWindowHandleClassInfo.ptr); NativeInputWindowHandle* handle; if (ptr) &#123; handle = reinterpret_cast&lt;NativeInputWindowHandle*&gt;(ptr); &#125; else &#123; // 如果该ptr为0，那就创建一个NativeInputWindowHandle并赋值给java层的ptr中 jweak objWeak = env-&gt;NewWeakGlobalRef(inputWindowHandleObj); handle = new NativeInputWindowHandle(objWeak); handle-&gt;incStrong((void*)android_view_InputWindowHandle_getHandle); env-&gt;SetLongField(inputWindowHandleObj, gInputWindowHandleClassInfo.ptr, reinterpret_cast&lt;jlong&gt;(handle)); &#125; return handle;&#125; 1.5.6.2 NativeInputWindowHandle.updateInfo12345678910111213141516bool NativeInputWindowHandle::updateInfo() &#123; ...... mInfo.touchableRegion.clear(); ...... // 更新可触碰区域 jobject regionObj = env-&gt;GetObjectField(obj, gInputWindowHandleClassInfo.touchableRegion); if (regionObj) &#123; for (graphics::RegionIterator it(env, regionObj); !it.isDone(); it.next()) &#123; ARect rect = it.getRect(); mInfo.addTouchableRegion(Rect(rect.left, rect.top, rect.right, rect.bottom)); &#125; env-&gt;DeleteLocalRef(regionObj); &#125; ......&#125; 这里就是将java层InputWindowHandle里的信息同步给NativeInputWindowHandle. 1.5.6.3 SurfaceComposerClient::Transaction.setInputWindowInfo123456789101112131415SurfaceComposerClient::Transaction&amp; SurfaceComposerClient::Transaction::setInputWindowInfo( const sp&lt;SurfaceControl&gt;&amp; sc, const InputWindowInfo&amp; info) &#123; // 根据SurfaceControl获取对应的layer状态 layer_state_t* s = getLayerState(sc); if (!s) &#123; mStatus = BAD_INDEX; return *this; &#125; // 将InputWindowInfo转成InputWindowHandle存在layer中 s-&gt;inputHandle = new InputWindowHandle(info); // 标记该layer输入信息有更改 s-&gt;what |= layer_state_t::eInputInfoChanged; return *this;&#125; 这里是将窗口相关信息存入了SurfaceFling中，至于怎么传输的，为什么需要这些信息，我们后续研究WMS的窗口和SurfaceFlinger的关系时分析。 1.6 InputMonitor.updateInputFocusRequest12345678910111213141516171819private void updateInputFocusRequest() &#123; final WindowState focus = mDisplayContent.mCurrentFocus; final IBinder focusToken = focus != null ? focus.mInputChannelToken : null; ...... requestFocus(focusToken, focus.getName());&#125;private void requestFocus(IBinder focusToken, String windowName) &#123; ...... mInputFocus = focusToken; // 通过Transaction更新input系统中的焦点窗口 mInputTransaction.setFocusedWindow(mInputFocus, windowName, mDisplayId); EventLog.writeEvent(LOGTAG_INPUT_FOCUS, &quot;Focus request &quot; + windowName, &quot;reason=UpdateInputWindows&quot;); ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, &quot;Focus requested for window=%s&quot;, windowName);&#125; 注意mInputTransaction其实还是SurfaceControl.Transaction类， 在InputMonitor初始化时创建的: mInputTransaction &#x3D; mService.mTransactionFactory.get(); 1.6.1 SurfaceControl.setFocusedWindow123456789public Transaction setFocusedWindow(@NonNull IBinder token, String windowName, int displayId) &#123; nativeSetFocusedWindow(mNativeObject, token, windowName, null /* focusedToken */, null /* focusedWindowName */, displayId); return this;&#125;private static native void nativeSetFocusedWindow(long transactionObj, IBinder toToken, String windowName, IBinder focusedToken, String focusedWindowName, int displayId); 通过JNI调用到native层： 123456789101112131415161718192021222324// android_view_SurfaceControl.cppstatic void nativeSetFocusedWindow(JNIEnv* env, jclass clazz, jlong transactionObj, jobject toTokenObj, jstring windowNameJstr, jobject focusedTokenObj, jstring focusedWindowNameJstr, jint displayId) &#123; auto transaction = reinterpret_cast&lt;SurfaceComposerClient::Transaction*&gt;(transactionObj); if (toTokenObj == NULL) return; // toTokenObj就是mInputChannelToken sp&lt;IBinder&gt; toToken(ibinderForJavaObject(env, toTokenObj)); ...... FocusRequest request; request.token = toToken; ...... transaction-&gt;setFocusedWindow(request);&#125;// SurfaceComposerClient.cppSurfaceComposerClient::Transaction&amp; SurfaceComposerClient::Transaction::setFocusedWindow( const FocusRequest&amp; request) &#123; mInputWindowCommands.focusRequests.push_back(request); return *this;&#125; 将传入的焦点窗口的mInputChannelToken和其他信息打包封装在FocusRequest中，存入SurfaceComposerClient的mInputWindowCommands.focusRequests集合中。 那么这个mInputWindowCommands.focusRequests是什么时候使用的呢，当调用SurfaceControl.Transaction.apply()函数时，会通过binder将该Transaction的所有信息传递给SurfaceFlinger进程（sf-&gt;setTransactionState接口），SurfaceFlinger接收到该Transaction后将其保存在mTransactionQueue队列中。然后在下一次Vsync信号来临时，即onMessageInvalidate函数中，将Transaction从mTransactionQeue中提取出来存入mPendingTransactionQueues队列中，于此同时调用addInputWindowCommands将该Transaction中的inputWindowHandles保存在SurfaceFlinger的mInputWindowCommands中，之后就调用updateInputFlinger()将mInputWindowCommands中的focusRequests更新到InputFlinger中。 1.6.2 SurfaceFlinger.updateInputFlinger12345678910111213141516171819202122void SurfaceFlinger::updateInputFlinger() &#123; ATRACE_CALL(); if (!mInputFlinger) &#123; return; &#125; // 可视区域有更新或者输入信息更改需要通知InputFlinger if (mVisibleRegionsDirty || mInputInfoChanged) &#123; mInputInfoChanged = false; // [2.1] 更新窗口输入信息至InputFlinger updateInputWindowInfo(); &#125; else if (mInputWindowCommands.syncInputWindows) &#123; // If the caller requested to sync input windows, but there are no // changes to input windows, notify immediately. setInputWindowsFinished(); &#125; // 遍历所有focusRequests，依次通知给InputFlinger更新焦点窗口 for (const auto&amp; focusRequest : mInputWindowCommands.focusRequests) &#123; // [3.1] 将焦点窗口同步更新给InputFlinger mInputFlinger-&gt;setFocusedWindow(focusRequest); &#125; mInputWindowCommands.clear();&#125; 二. Window信息更新至InputFlinger上面我们分析了窗口的信息的收集过程，重点是可触碰区域的计算，现在我们分析一下窗口信息传递给InputFlinger的过程。 2.1 SurfaceFlinger.updateInputWindowInfo12345678910111213141516void SurfaceFlinger::updateInputWindowInfo() &#123; std::vector&lt;InputWindowInfo&gt; inputInfos; // mDrawingState我们之前有过分析，这里存储了所有需要更新的图层集 // 遍历所有的图层，依次计算该layer的输入窗口信息 mDrawingState.traverseInReverseZOrder([&amp;](Layer* layer) &#123; ...... // 2.2 在计算屏幕边界时，忽略透明区域， 因为它可能导致不必要的偏移量 // 将计算结果保存在inputInfos中, 每次都是添加到队列尾部 inputInfos.push_back(layer-&gt;fillInputInfo(display)); &#125;); // 2.3 将计算结果传递给InputFlinger mInputFlinger-&gt;setInputWindows(inputInfos, mInputWindowCommands.syncInputWindows ? mSetInputWindowsListener : nullptr);&#125; 这里是遍历所有的需要更新的Layer, 依次计算该Layer对应的窗口可触摸区域，将结果保存在InputWindowInfo的Vector中，然后通过Binder传给InputFlinger进程。 注意这里对layer的遍历是沿着Z轴反方向的，也就是从上到下的遍历顺序。layer在上面，存入inputInfos队列前面。 2.2 Layer.fillInputInfo123456789101112131415InputWindowInfo Layer::fillInputInfo(const sp&lt;DisplayDevice&gt;&amp; display) &#123; ...... InputWindowInfo info = mDrawingState.inputInfo; ...... // [2.2.1] 再次计算可触摸区域 fillInputFrameInfo(info, toPhysicalDisplay); // 判断该窗口是否可见 info.visible = hasInputInfo() ? canReceiveInput() : isVisible(); info.alpha = getAlpha(); ...... return info;&#125; 根据显示屏再次计算可触摸区域以及其他相关信息。 2.2.1 Layer.fillInputFrameInfo12345678910111213141516171819202122232425262728void Layer::fillInputFrameInfo(InputWindowInfo&amp; info, const ui::Transform&amp; toPhysicalDisplay) &#123; // 变换图层大小到屏幕空间 Rect layerBounds = info.portalToDisplayId == ADISPLAY_ID_NONE ? getInputBounds() : info.touchableRegion.getBounds(); ...... ui::Transform layerToDisplay = getInputTransform(); // 将窗口坐标转换为非旋转显示坐标的转换 ui::Transform t = toPhysicalDisplay * layerToDisplay; ...... ui::Transform inverseTransform = t.inverse(); Rect nonTransformedBounds = inverseTransform.transform(transformedLayerBounds); vec2 translation = t.transform(nonTransformedBounds.left, nonTransformedBounds.top); ui::Transform inputTransform(t); inputTransform.set(translation.x, translation.y); info.transform = inputTransform.inverse(); // 需要将裁剪的图层边界发送到屏幕边界，因为图层可以被裁剪 // frame应该是用户在屏幕上看到的区域，被用于遮挡检测 transformedLayerBounds.intersect(screenBounds, &amp;transformedLayerBounds); info.frameLeft = transformedLayerBounds.left; info.frameTop = transformedLayerBounds.top; info.frameRight = transformedLayerBounds.right; info.frameBottom = transformedLayerBounds.bottom; // 相对于框架屏幕位置定位可触摸区域，并将其限制在框架边界 info.touchableRegion = inputTransform.transform(info.touchableRegion);&#125; 虽然我们在WMS中有计算过可触摸区域，但通过SurfaceFlinger还是需要更加Display实际大小等加工一下，确定最终窗口的可触摸区域。 这里的计算过程就不展开分析了，感兴趣的可以自行研究。 2.3 InputFlinger.setInputWindows123456789101112131415161718192021binder::Status InputManager::setInputWindows( const std::vector&lt;InputWindowInfo&gt;&amp; infos, const sp&lt;ISetInputWindowsListener&gt;&amp; setInputWindowsListener) &#123; std::unordered_map&lt;int32_t, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&gt; handlesPerDisplay; std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; handles; // 将从SF传过来的InputWindowInfo信息打包成BinderWindowHandle // 存入对应DisplayId的InputWindowHandle集合中 for (const auto&amp; info : infos) &#123; // 注意这里是emplace，每次都是插入队列头部，相当于将infos中元素反向排列了 handlesPerDisplay.emplace(info.displayId, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;()); handlesPerDisplay[info.displayId].push_back(new BinderWindowHandle(info)); &#125; // 2.4 交给InputDispatcher处理 mDispatcher-&gt;setInputWindows(handlesPerDisplay); if (setInputWindowsListener) &#123; setInputWindowsListener-&gt;onSetInputWindowsFinished(); &#125; return binder::Status::ok();&#125; BinderWindowHandle就是个包装类，继承了InputWindowHandle，并且重写了updateInfo, 内部只有一个InputWindowHandle的成员变量。这是为了避免后续不小心更新窗口信息。 这里将从SF传过来的InputWindowInfo信息打包成BinderWindowHandle，存入对应DisplayId的InputWindowHandle集合中，然后交给InputDispatcher处理。 2.4 InputDispatcher.setInputWindows1234567891011void InputDispatcher::setInputWindows( const std::unordered_map&lt;int32_t, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&gt;&amp; handlesPerDisplay) &#123; &#123; // acquire lock std::scoped_lock _l(mLock); for (const auto&amp; [displayId, handles] : handlesPerDisplay) &#123; setInputWindowsLocked(handles, displayId); &#125; &#125; // 唤醒轮询循环，可能需要做出新的输入分派选择 mLooper-&gt;wake();&#125; 针对所有的Display依次更新输入窗口信息, 然后唤醒轮询循环，做出新的输入分派选择。 2.5 InputDispatcher.setInputWindowsLocked12345678910111213141516171819202122232425262728293031323334353637383940414243void InputDispatcher::setInputWindowsLocked( const std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; inputWindowHandles, int32_t displayId) &#123; ...... // 获取当前所有的输入窗口handle用于relase const std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; oldWindowHandles = getWindowHandlesLocked(displayId); // 更新输入窗口信息列表，就是将新窗口输入信息保存在mWindowHandlesByDisplay中 updateWindowHandlesForDisplayLocked(inputWindowHandles, displayId); ...... // 确认windowHandles列表中包含焦点窗口，如果不存在找上一次的焦点窗口作为当前焦点 std::optional&lt;FocusResolver::FocusChanges&gt; changes = mFocusResolver.setInputWindows(displayId, windowHandles); ...... for (const sp&lt;InputWindowHandle&gt;&amp; oldWindowHandle : oldWindowHandles) &#123; if (getWindowHandleLocked(oldWindowHandle) == nullptr) &#123; ...... // 将不在展示的窗口信息释放掉，节省资源 oldWindowHandle-&gt;releaseChannel(); ...... &#125; &#125;&#125;void InputDispatcher::updateWindowHandlesForDisplayLocked( const std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; inputWindowHandles, int32_t displayId) &#123; ...... std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; newHandles; for (const sp&lt;InputWindowHandle&gt;&amp; handle : inputWindowHandles) &#123; ...... if ((oldHandlesById.find(handle-&gt;getId()) != oldHandlesById.end()) &amp;&amp; (oldHandlesById.at(handle-&gt;getId())-&gt;getToken() == handle-&gt;getToken())) &#123; const sp&lt;InputWindowHandle&gt;&amp; oldHandle = oldHandlesById.at(handle-&gt;getId()); oldHandle-&gt;updateFrom(handle); newHandles.push_back(oldHandle); &#125; else &#123; // push_back是向队列尾部添加元素 newHandles.push_back(handle); &#125; &#125; // 保存新的窗口输入信息至mWindowHandlesByDisplay中. mWindowHandlesByDisplay[displayId] = newHandles;&#125; 这里是更新窗口输入信息至mWindowHandlesByDisplay，将不在展示的窗口信息释放掉，节省资源。 三. 更新InputFlinger的焦点窗口SurfaceFlinger通过binder将焦点窗口同步更新给InputFlinger。 3.1 InputFlinger.setFocusedWindow12345binder::Status InputManager::setFocusedWindow(const FocusRequest&amp; request) &#123; // [3.2] 交给InputDispatcher更新焦点窗口 mDispatcher-&gt;setFocusedWindow(request); return binder::Status::ok();&#125; 3.2 InputDispatcher.setFocusedWindow1234567891011121314void InputDispatcher::setFocusedWindow(const FocusRequest&amp; request) &#123; &#123; // acquire lock std::scoped_lock _l(mLock); // [3.3] 获取当前display中所有的窗口输入信息，交给FocusResolver更新焦点窗口 std::optional&lt;FocusResolver::FocusChanges&gt; changes = mFocusResolver.setFocusedWindow(request, getWindowHandlesLocked(request.displayId)); if (changes) &#123; // 响应焦点窗口更新 onFocusChangedLocked(*changes); &#125; &#125; // release lock // Wake up poll loop since it may need to make new input dispatching choices. mLooper-&gt;wake();&#125; 3.3 FocusResolver.setFocusedWindow123456789101112131415161718192021222324252627282930313233std::optional&lt;FocusResolver::FocusChanges&gt; FocusResolver::setFocusedWindow( const FocusRequest&amp; request, const std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; windows) &#123; const int32_t displayId = request.displayId; // 如果当前焦点窗口就是需要设置的窗口，直接返回 const sp&lt;IBinder&gt; currentFocus = getFocusedWindowToken(displayId); if (currentFocus == request.token) &#123; ALOGD_IF(DEBUG_FOCUS, &quot;setFocusedWindow %s on display %&quot; PRId32 &quot; ignored, reason: already focused&quot;, request.windowName.c_str(), displayId); return std::nullopt; &#125; // 处理焦点请求，即具有焦点令牌的请求。这些请求不是持久的。如果窗口不再可聚焦，焦点返回到先前聚焦的窗口 // 在[1.6.1] SurfaceControl.setFocusedWindow实际传入的focusedToken是null的，这里我们也假设为null好了 if (request.focusedToken) &#123; ....... &#125; // 检查传入的待聚焦的窗口是否可聚焦且在windows列表中 Focusability result = isTokenFocusable(request.token, windows); // 响应焦点请求 mFocusRequestByDisplay[displayId] = request; mLastFocusResultByDisplay[displayId] = result; if (result == Focusability::OK) &#123; // [3.4] 更新焦点窗口 return updateFocusedWindow(displayId, &quot;setFocusedWindow&quot;, request.token, request.windowName); &#125; //请求的窗口当前不能聚焦。等待窗口变成可聚焦的，但从当前窗口移除焦点，以便输入事件可以进入挂起队列，并在窗口变成聚焦时发送到窗口。 return updateFocusedWindow(displayId, &quot;Waiting for window because &quot; + NamedEnum::string(result), nullptr);&#125; 如果当前焦点窗口就是需要设置的窗口，直接返回。然后检查传入的待聚焦的窗口是否可聚焦且在windows列表中， 更新mFocusRequestByDisplay和mLastFocusResultByDisplay，最后无论待更新的焦点窗口是否可聚焦，都更新焦点窗口，即将焦点窗口token（对应InputChannel的token）保存在mFocusedWindowTokenByDisplay中。 3.4 FocusResolver.updateFocusedWindow123456789101112131415std::optional&lt;FocusResolver::FocusChanges&gt; FocusResolver::updateFocusedWindow( int32_t displayId, const std::string&amp; reason, const sp&lt;IBinder&gt;&amp; newFocus, const std::string&amp; tokenName) &#123; sp&lt;IBinder&gt; oldFocus = getFocusedWindowToken(displayId); if (newFocus == oldFocus) &#123; return std::nullopt; &#125; if (newFocus) &#123; mFocusedWindowTokenByDisplay[displayId] = &#123;tokenName, newFocus&#125;; &#125; else &#123; mFocusedWindowTokenByDisplay.erase(displayId); &#125; return &#123;&#123;oldFocus, newFocus, displayId, reason&#125;&#125;;&#125; 将焦点窗口token（对应InputChannel的token，即InputChannel初始化时创建的BBinder）保存在mFocusedWindowTokenByDisplay中。 小结总的来说，WMS上层创建WindowState之后，如果该窗口可以接收input事件就需要更新焦点窗口，其后更新输入窗口信息给Input系统。注意这里涉及了三个模块：System_server(WMS)，InputFlinger和SurfaceFlinger。之所以需要SurfaceFlinger，一是需要借助SurfaceControl通道通信，更重要的是，需要通过SurfaceFlinger进一步去计算窗口的信息，如可触摸区域、可见区域等等。在SurfaceFlinger计算完毕后，通过Binder调用将窗口信息封装成InputWindowInfo传给InputFlinger，InputFlinger将传过来的InputWindowInfo信息打包成BinderWindowHandle存入mWindowHandlesByDisplay中。 接下来我们看看一次触摸事件分发给窗口的流程作为Input事件和Window的结束语。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"},{"name":"Input","slug":"Android/WMS/Input","permalink":"https://swallowjoe.github.io/categories/Android/WMS/Input/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"},{"name":"Input","slug":"Input","permalink":"https://swallowjoe.github.io/tags/Input/"}]},{"title":"WMS(7)-窗口和InputChannel的联系","slug":"WMS(7)-窗口和InputChannel的联系","date":"2022-05-06T17:35:34.000Z","updated":"2022-06-18T09:57:14.172Z","comments":true,"path":"2022/05/07/WMS(7)-窗口和InputChannel的联系/","link":"","permalink":"https://swallowjoe.github.io/2022/05/07/WMS(7)-%E7%AA%97%E5%8F%A3%E5%92%8CInputChannel%E7%9A%84%E8%81%94%E7%B3%BB/","excerpt":"以下分析基于Android S. 简述本文集中研究input和窗口的关系, 特别是input系统是如何将事件传给正确的窗口进程的。 在Activity的resume过程中，会通过ViewRootImpl.setView向WMS传递其窗口信息，我们还是从这里入手：","text":"以下分析基于Android S. 简述本文集中研究input和窗口的关系, 特别是input系统是如何将事件传给正确的窗口进程的。 在Activity的resume过程中，会通过ViewRootImpl.setView向WMS传递其窗口信息，我们还是从这里入手： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// ViewRootImpl.javapublic void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123; ...... requestLayout(); // 创建InputChannel InputChannel inputChannel = null; // INPUT_FEATURE_NO_INPUT_CHANNEL 的意思是该窗口不接受input事件 if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; // 仅仅是实例化InputChannel， 啥也没有做 inputChannel = new InputChannel(); &#125; ....... // 将InputChannel传入WMS中, 我们先进入看这个 res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), userId, mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets, mTempControls); ...... // 处理后续 if (inputChannel != null) &#123; ...... // [3.1] 创建InputEventReceiver用于接收Input事件 mInputEventReceiver = new WindowInputEventReceiver(inputChannel, Looper.myLooper()); ...... &#125; ......&#125;// WMS.javapublic int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility, int displayId, int requestUserId, InsetsState requestedVisibility, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; ...... // 初始化WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); ...... // attrs就是上面ViewRootImpl中的mWindowAttributes final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) &#123; // [1.1] 初始化InputChanel win.openInputChannel(outInputChannel); &#125; ......&#125; 注意初始化InputChannel是在WindowState之后，也是通过其openInputChannel的。 一. InputChannel的初始化和Dispose1.1 WindowState.openInputChannel123456789101112131415161718192021222324void openInputChannel(InputChannel outInputChannel) &#123; if (mInputChannel != null) &#123; throw new IllegalStateException(&quot;Window already has an input channel.&quot;); &#125; // 获取名称: 数字+窗口包名 String name = getName(); // [1.2] 通过InputManager创建InputChannel mInputChannel = mWmService.mInputManager.createInputChannel(name); // 注意这里的token, 后面会发现其实是native创建的BBinder mInputChannelToken = mInputChannel.getToken(); // mInputWindowHandle是WindowState初始化时创建的 mInputWindowHandle.setToken(mInputChannelToken); // 将该InputChannel和WindowState作为KV对保存 mWmService.mInputToWindowMap.put(mInputChannelToken, this); if (outInputChannel != null) &#123; // [2.1] 将创建的InputChannel拷贝到outInputChannel中， 这个outInputChannel就是应用进程中创建的InputChannel mInputChannel.copyTo(outInputChannel); &#125; else &#123; // If the window died visible, we setup a fake input channel, so that taps // can still detected by input monitor channel, and we can relaunch the app. // Create fake event receiver that simply reports all events as handled. mDeadWindowEventReceiver = new DeadWindowEventReceiver(mInputChannel); &#125;&#125; 1.2 InputManagerService.createInputChannel12345private static native InputChannel nativeCreateInputChannel(long ptr, String name);public InputChannel createInputChannel(String name) &#123; return nativeCreateInputChannel(mPtr, name);&#125; 通过JNI由native层创建InputChannel。 1234567891011121314151617181920212223242526272829// com_android_server_input_InputManagerService.cppstatic jobject nativeCreateInputChannel(JNIEnv* env, jclass /* clazz */, jlong ptr, jstring nameObj) &#123; NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr); ScopedUtfChars nameChars(env, nameObj); std::string name = nameChars.c_str(); // [1.3] 创建Native层的InputChannel base::Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; inputChannel = im-&gt;createInputChannel(env, name); if (!inputChannel.ok()) &#123; std::string message = inputChannel.error().message(); message += StringPrintf(&quot; Status=%d&quot;, inputChannel.error().code()); jniThrowRuntimeException(env, message.c_str()); return nullptr; &#125; // [1.4] 通过JNI调用java层函数，创建java对象InputChannel jobject inputChannelObj = android_view_InputChannel_createJavaObject(env, std::move(*inputChannel)); if (!inputChannelObj) &#123; return nullptr; &#125; // [1.5] 注册资源回收处理的回调函数 android_view_InputChannel_setDisposeCallback(env, inputChannelObj, handleInputChannelDisposed, im); return inputChannelObj;&#125; 1.3 NativeInputManager.createInputChannel123456789101112// com_android_server_input_InputManagerService.cppbase::Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; NativeInputManager::createInputChannel( JNIEnv* /* env */, const std::string&amp; name) &#123; ATRACE_CALL(); // [1.3.1] 交给InputDispatcher return mInputManager-&gt;getDispatcher()-&gt;createInputChannel(name);&#125;// InputManager.cppsp&lt;InputDispatcherInterface&gt; InputManager::getDispatcher() &#123; return mDispatcher;&#125; 关于InputDispatcher的初始化后续单独分析。 1.3.1 InputDispatcher.createInputChannel12345678910111213141516171819202122232425262728293031323334353637// InputTransport.cppResult&lt;std::unique_ptr&lt;InputChannel&gt;&gt; InputDispatcher::createInputChannel(const std::string&amp; name) &#123; std::unique_ptr&lt;InputChannel&gt; serverChannel; std::unique_ptr&lt;InputChannel&gt; clientChannel; // [1.3.2] InputChannel是成对存在的 status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel); if (result) &#123; return base::Error(result) &lt;&lt; &quot;Failed to open input channel pair with name &quot; &lt;&lt; name; &#125; &#123; // acquire lock std::scoped_lock _l(mLock); const sp&lt;IBinder&gt;&amp; token = serverChannel-&gt;getConnectionToken(); int fd = serverChannel-&gt;getFd(); // 创建Connection, 用于记录此次连接行为 sp&lt;Connection&gt; connection = new Connection(std::move(serverChannel), false /*monitor*/, mIdGenerator); if (mConnectionsByToken.find(token) != mConnectionsByToken.end()) &#123; ALOGE(&quot;Created a new connection, but the token %p is already known&quot;, token.get()); &#125; // 将此次连接行为保存在mConnectionsByToken中 mConnectionsByToken.emplace(token, connection); // 利用bind绑定回调函数，顺便固定回调时的第二个参数为token std::function&lt;int(int events)&gt; callback = std::bind(&amp;InputDispatcher::handleReceiveCallback, this, std::placeholders::_1, token); // 将文件描述符添加进Looper, 这样有事件时会回调handleReceiveCallback mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, new LooperEventCallback(callback), nullptr); &#125; // release lock // 唤醒Looper以执行 mLooper-&gt;wake(); // 返回客户端InputChannel return clientChannel;&#125; 创建Native层的InputChannel其实就是利用socket创建了一对套接字，分别作为服务端和客户端，并将服务端的token作为key，存入作为记录此次InputChannel的Connection至mConnectionsByToken中。其后利用bind绑定handleReceiveCallback作为回调函数（注意这里固定了其第二个参数为当前的token），然后将服务端的文件描述符存入mLooper中。最后唤醒mLooper。 注意这里的mLooper是InputDispatcher初始化时创建的： mLooper &#x3D; new Looper(false); 所以这里InputChannel中的服务端就是用来分发input事件的，而客户端的InputChannel应该就需要传给对应的应用进程了。 1.3.2 InputChannel.openInputChannelPair1234567891011121314151617181920212223242526272829303132status_t InputChannel::openInputChannelPair(const std::string&amp; name, std::unique_ptr&lt;InputChannel&gt;&amp; outServerChannel, std::unique_ptr&lt;InputChannel&gt;&amp; outClientChannel) &#123; int sockets[2]; // 原来InputChannel之所以需要成对是因为这里是通过socket实现的 if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123; status_t result = -errno; ALOGE(&quot;channel &#x27;%s&#x27; ~ Could not create socket pair. errno=%s(%d)&quot;, name.c_str(), strerror(errno), errno); outServerChannel.reset(); outClientChannel.reset(); return result; &#125; int bufferSize = SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); sp&lt;IBinder&gt; token = new BBinder(); std::string serverChannelName = name + &quot; (server)&quot;; android::base::unique_fd serverFd(sockets[0]); // [1.3.3] 创建native层的InputChannel对象 outServerChannel = InputChannel::create(serverChannelName, std::move(serverFd), token); std::string clientChannelName = name + &quot; (client)&quot;; android::base::unique_fd clientFd(sockets[1]); outClientChannel = InputChannel::create(clientChannelName, std::move(clientFd), token); return OK;&#125; socketpair()函数用于创建一对无名的、相互连接的套接字。如果函数成功，则返回0，创建好的套接字分别是sockets[0]和sockets[1]；否则返回-1，错误码保存于errno中。 这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sockets[0]中写，从sockets[1]中读；或者从sockets[1]中写，从sockets[0]中读； 如果往一个套接字(如sockets[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sockets[1])上读成功； 读、写操作可以位于同一个进程，也可以分别位于不同的进程。因为sockets[0]和sockets[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。 1.3.3 InputChannel.create123456789101112131415161718std::unique_ptr&lt;InputChannel&gt; InputChannel::create(const std::string&amp; name, android::base::unique_fd fd, sp&lt;IBinder&gt; token) &#123; const int result = fcntl(fd, F_SETFL, O_NONBLOCK); if (result != 0) &#123; LOG_ALWAYS_FATAL(&quot;channel &#x27;%s&#x27; ~ Could not make socket non-blocking: %s&quot;, name.c_str(), strerror(errno)); return nullptr; &#125; // using &#x27;new&#x27; to access a non-public constructor return std::unique_ptr&lt;InputChannel&gt;(new InputChannel(name, std::move(fd), token));&#125;InputChannel::InputChannel(const std::string name, android::base::unique_fd fd, sp&lt;IBinder&gt; token) : mName(std::move(name)), mFd(std::move(fd)), mToken(std::move(token)) &#123; if (DEBUG_CHANNEL_LIFECYCLE) &#123; ALOGD(&quot;Input channel constructed: name=&#x27;%s&#x27;, fd=%d&quot;, getName().c_str(), getFd().get()); &#125;&#125; native层的InputChannel原来就是一对套接字，分成server端和client端，用于跨进程通信。 1.4 android_view_InputChannel_createJavaObject12345678910111213141516171819202122232425262728293031323334353637// android_view_InputChannel.cpp#123jobject android_view_InputChannel_createJavaObject(JNIEnv* env, std::unique_ptr&lt;InputChannel&gt; inputChannel) &#123; std::string name = inputChannel-&gt;getName(); // 创建NativeInputChannel jlong ptr = android_view_InputChannel_createInputChannel(env, std::move(inputChannel)); // 初始化java层的InputChannel // gInputChannelClassInfo.mCtor =&gt; &quot;&lt;init&gt;&quot;; // 调用java层InputChannel的构造函数，生成对象 jobject javaInputChannel = env-&gt;NewObject(gInputChannelClassInfo.clazz, gInputChannelClassInfo.mCtor); if (!javaInputChannel) &#123; ALOGE(&quot;Failed to create a Java InputChannel for channel %s.&quot;, name.c_str()); return nullptr; &#125; // gInputChannelClassInfo.mSetNativeInputChannel =&gt; &quot;setNativeInputChannel&quot; // [1.4.1] 调用setNativeInputChannel函数设置ptr env-&gt;CallVoidMethod(javaInputChannel, gInputChannelClassInfo.mSetNativeInputChannel, ptr); if (env-&gt;ExceptionOccurred()) &#123; ALOGE(&quot;Failed to set native ptr to the Java InputChannel for channel %s.&quot;, inputChannel-&gt;getName().c_str()); return nullptr; &#125; // 返回java层的InputChannel对象 return javaInputChannel;&#125;static jlong android_view_InputChannel_createInputChannel( JNIEnv* env, std::unique_ptr&lt;InputChannel&gt; inputChannel) &#123; std::unique_ptr&lt;NativeInputChannel&gt; nativeInputChannel = std::make_unique&lt;NativeInputChannel&gt;(std::move(inputChannel)); return reinterpret_cast&lt;jlong&gt;(nativeInputChannel.release());&#125;NativeInputChannel::NativeInputChannel(std::unique_ptr&lt;InputChannel&gt; inputChannel) : mInputChannel(std::move(inputChannel)), mDisposeCallback(nullptr) &#123;&#125; 经过1.3我们知道这里传入的InputChannel其实是一对socket中代表客户端的那个, 先通过std::move将InputChannel存入新创建的NativeInputChannel对象中，然后通过JNI构造出java层的InputChannel，在调用其setNativeInputChannel，将NativeInputChannel保存在其mPtr中。 1.4.1 InputChannel.setNativeInputChannel12345678910111213private void setNativeInputChannel(long nativeChannel) &#123; if (nativeChannel == 0) &#123; throw new IllegalArgumentException(&quot;Attempting to set native input channel to null.&quot;); &#125; if (mPtr != 0) &#123; throw new IllegalArgumentException(&quot;Already has native input channel.&quot;); &#125; if (DEBUG) &#123; Slog.d(TAG, &quot;setNativeInputChannel : &quot; + String.format(&quot;%x&quot;, nativeChannel)); &#125; sRegistry.registerNativeAllocation(this, nativeChannel); mPtr = nativeChannel;&#125; 所以java层的InputChannel里的mPtr是对应NativeInputChannel对象的。 1.5 android_view_InputChannel_setDisposeCallback12345678910111213141516171819// android_view_InputChannel.cppvoid android_view_InputChannel_setDisposeCallback(JNIEnv* env, jobject inputChannelObj, InputChannelObjDisposeCallback callback, void* data) &#123; // 通过java层InputChannel中存储的mPtr找到对应的NativeInputChannel NativeInputChannel* nativeInputChannel = android_view_InputChannel_getNativeInputChannel(env, inputChannelObj); if (!nativeInputChannel || !nativeInputChannel-&gt;getInputChannel()) &#123; ALOGW(&quot;Cannot set dispose callback because input channel object has not been initialized.&quot;); &#125; else &#123; // [1.5.1] 这里的data就是NativeInputManager nativeInputChannel-&gt;setDisposeCallback(callback, data); &#125;&#125;static NativeInputChannel* android_view_InputChannel_getNativeInputChannel(JNIEnv* env, jobject inputChannelObj) &#123; jlong longPtr = env-&gt;GetLongField(inputChannelObj, gInputChannelClassInfo.mPtr); return reinterpret_cast&lt;NativeInputChannel*&gt;(longPtr);&#125; 1.5.1 NativeInputChannel.setDisposeCallback1234void NativeInputChannel::setDisposeCallback(InputChannelObjDisposeCallback callback, void* data) &#123; mDisposeCallback = callback; mDisposeData = data;&#125; 将回调函数和相关参数保存起来， 当进程死亡，或者窗口被销毁时，会主动调用InputChannel.dispose()回收资源，最后就会调用到NativeInputChannel.dispose了。 1.5.2 NativeInputChannel.dispose12345678910111213void NativeInputChannel::dispose(JNIEnv* env, jobject obj) &#123; if (!mInputChannel) &#123; return; &#125; if (mDisposeCallback) &#123; // [1.5.3] 调用回调函数handleInputChannelDisposed mDisposeCallback(env, obj, mInputChannel, mDisposeData); mDisposeCallback = nullptr; mDisposeData = nullptr; &#125; mInputChannel.reset();&#125; 1.5.3 handleInputChannelDisposed1234567891011121314151617static void handleInputChannelDisposed(JNIEnv* env, jobject /* inputChannelObj */, const std::shared_ptr&lt;InputChannel&gt;&amp; inputChannel, void* data) &#123; NativeInputManager* im = static_cast&lt;NativeInputManager*&gt;(data); ALOGW(&quot;Input channel object &#x27;%s&#x27; was disposed without first being removed with &quot; &quot;the input manager!&quot;, inputChannel-&gt;getName().c_str()); // 移除连接 im-&gt;removeInputChannel(env, inputChannel-&gt;getConnectionToken());&#125;status_t NativeInputManager::removeInputChannel(JNIEnv* /* env */, const sp&lt;IBinder&gt;&amp; connectionToken) &#123; ATRACE_CALL(); return mInputManager-&gt;getDispatcher()-&gt;removeInputChannel(connectionToken);&#125; 1.5.4 InputDispatcher.removeInputChannel12345678910111213141516171819202122232425262728293031323334353637status_t InputDispatcher::removeInputChannel(const sp&lt;IBinder&gt;&amp; connectionToken) &#123; &#123; // acquire lock std::scoped_lock _l(mLock); status_t status = removeInputChannelLocked(connectionToken, false /*notify*/); if (status) &#123; return status; &#125; &#125; // release lock mLooper-&gt;wake(); return OK;&#125;status_t InputDispatcher::removeInputChannelLocked(const sp&lt;IBinder&gt;&amp; connectionToken, bool notify) &#123; // 通过token找到对应的Connection sp&lt;Connection&gt; connection = getConnectionLocked(connectionToken); if (connection == nullptr) &#123; // Connection can be removed via socket hang up or an explicit call to &#x27;removeInputChannel&#x27; return BAD_VALUE; &#125; // [1.5.4.1] 将该Connection从集合中移除 removeConnectionLocked(connection); if (connection-&gt;monitor) &#123; removeMonitorChannelLocked(connectionToken); &#125; // 将对应服务端Socket描述符从mLooper中移除，这样就不会接收到事件了 mLooper-&gt;removeFd(connection-&gt;inputChannel-&gt;getFd()); nsecs_t currentTime = now(); abortBrokenDispatchCycleLocked(currentTime, connection, notify); // 标记该Connection为ZOMBIE状态 connection-&gt;status = Connection::STATUS_ZOMBIE; return OK;&#125; 移除InputChannel的工作也不多，将Connection从直接保存的集合中移除，顺便将其中保存的服务端Socket描述符从mLooper中移除即可。最后标记被移除的Connection状态为ZOMBIE状态。 1.5.4.1 InputDispatcher.removeConnectionLocked12345void InputDispatcher::removeConnectionLocked(const sp&lt;Connection&gt;&amp; connection) &#123; mAnrTracker.eraseToken(connection-&gt;inputChannel-&gt;getConnectionToken()); // 将该连接从mConnectionsByToken中移除 mConnectionsByToken.erase(connection-&gt;inputChannel-&gt;getConnectionToken());&#125; 直接将该Connection从mConnectionsByToken和mAnrTracker中移除即可。 二. 应用进程InputChannel的来源通过 InputChannel的初始化 我们知道InputChannel的Native实现就是一对Socket，其中服务端作为input事件分发者被加入InputDispatcher的Looper中，客户端会被存入NativeInputChannel中，而后通过JNI存入java层的InputChannel的mPtr中，但是这里java层的InputChannel还是处于SystemServer进程，还没有看到应用进程InputChannel是如何被赋值的。 接下来我们先研究下InputChannel的拷贝。 2.1 InputChannel.copyTo12345678910111213public void copyTo(InputChannel outParameter) &#123; if (outParameter == null) &#123; throw new IllegalArgumentException(&quot;outParameter must not be null&quot;); &#125; if (outParameter.mPtr != 0) &#123; throw new IllegalArgumentException(&quot;Other object already has a native input channel.&quot;); &#125; // 2.2 nativeDup // setNativeInputChannel我们已经分析过了就不在赘述，重点看nativeDup函数 outParameter.setNativeInputChannel(nativeDup(mPtr));&#125;private native long nativeDup(long channel); 这里思考一下为什么不直接将mPtr赋值给outParameter的mPtr呢？ 2.2 android_view_InputChannel_nativeDup12345678910111213141516171819202122232425// android_view_InputChannel.cpp#123static jlong android_view_InputChannel_nativeDup(JNIEnv* env, jobject obj, jlong channel) &#123; NativeInputChannel* nativeInputChannel = reinterpret_cast&lt;NativeInputChannel*&gt;(channel); if (nativeInputChannel == nullptr) &#123; jniThrowRuntimeException(env, &quot;InputChannel has no valid NativeInputChannel&quot;); return 0; &#125; std::shared_ptr&lt;InputChannel&gt; inputChannel = nativeInputChannel-&gt;getInputChannel(); if (inputChannel == nullptr) &#123; jniThrowRuntimeException(env, &quot;NativeInputChannel has no corresponding InputChannel&quot;); return 0; &#125; // 2.3 调用native层的InputChannel.dup函数 std::unique_ptr&lt;InputChannel&gt; dupInputChannel = inputChannel-&gt;dup(); if (dupInputChannel == nullptr) &#123; std::string message = android::base::StringPrintf( &quot;Could not duplicate input channel %s&quot;, inputChannel-&gt;getName().c_str()); jniThrowRuntimeException(env, message.c_str()); &#125; // 创建新的NativeInputChannel对象 return reinterpret_cast&lt;jlong&gt;(new NativeInputChannel(std::move(dupInputChannel)));&#125; android_view_InputChannel_nativeDup的作用就是根据传入的java层InputChannel创建一个新的NativeInputChannel作为客户端socket, 与服务端Socket的InputChannel对应。 2.3 InputChannel.dup123456std::unique_ptr&lt;InputChannel&gt; InputChannel::dup() const &#123; // 2.3.1 dupFd创建一个新的文件描述符，但是执行同一个文件 base::unique_fd newFd(dupFd()); // 根据新的文件描述符创建新的InputChannel对象 return InputChannel::create(getName(), std::move(newFd), getConnectionToken());&#125; 2.3.1 InputChannel.dupFd123456789101112131415161718base::unique_fd InputChannel::dupFd() const &#123; // getFp返回的就是该InputChannel的mFd // ::dup 的作用是复制文件描述符，使多个文件描述符指向同一个文件 android::base::unique_fd newFd(::dup(getFd())); if (!newFd.ok()) &#123; ALOGE(&quot;Could not duplicate fd %i for channel %s: %s&quot;, getFd().get(), getName().c_str(), strerror(errno)); const bool hitFdLimit = errno == EMFILE || errno == ENFILE; // If this process is out of file descriptors, then throwing that might end up exploding // on the other side of a binder call, which isn&#x27;t really helpful. // Better to just crash here and hope that the FD leak is slow. // Other failures could be client errors, so we still propagate those back to the caller. LOG_ALWAYS_FATAL_IF(hitFdLimit, &quot;Too many open files, could not duplicate input channel %s&quot;, getName().c_str()); return &#123;&#125;; &#125; return newFd;&#125; dupFd是通过 ::dup(int oldFd) 函数复制文件描述符，使新的文件描述符指向参数描述符指向的同一个文件。 2.4 Binder通信中AIDL里的out标记看完了InputChannel的copyTo函数，我们知道该函数就是在native层创建了新的NativeInputChannel，但是还是和之前客户端InputChannel一样指向同一个Socket描述符，这样服务端Socket发的消息会同步传给信息的InputChannel了。 但是这里我们还是没有看到应用进程的InputChannel是如何被赋值的，在WMS.addWindow函数中，outInputChannel在被mInputChannel.copyTo函数赋值后，就没有继续使用过了。这里我们就要看到应用进程和WMS通信的桥梁Session的AIDL文件定义了: 1234567891011// IWindowSession.aidlint addToDisplay(IWindow window, in WindowManager.LayoutParams attrs, in int viewVisibility, in int layerStackId, in InsetsState requestedVisibility, out InputChannel outInputChannel, out InsetsState insetsState, out InsetsSourceControl[] activeControls);int addToDisplayAsUser(IWindow window, in WindowManager.LayoutParams attrs, in int viewVisibility, in int layerStackId, in int userId, in InsetsState requestedVisibility, out InputChannel outInputChannel, out InsetsState insetsState, out InsetsSourceControl[] activeControls);int addToDisplayWithoutInputChannel(IWindow window, in WindowManager.LayoutParams attrs, in int viewVisibility, in int layerStackId, out InsetsState insetsState); 毫无意外，所有的InputChannel都是被标记了out标签，这样binder回调时会将该参数回传给调用进程，即应用进程。 这样一来一个WindowState对应一对Socket，分成服务端和客户端，服务端Socket的描述符被存入InputDispatcher的mConnectionsByToken，也被添加到其mLooper中用于转发Input事件至客户端Socket中。而客户端Socket又被dup函数复制成两份NativeInputChannel, 一份存在WindowState的mInputChannel中，另一份通过Binder调用存入应用进程的ViewRootImpl的WindowInputEventReceiver对象中。 三. 应用进程注册接听Input事件在ViewRootImpl.setView函数中，当应用进程通过binder调用addToDisplayAsUser获得被复制的InputChannel后，会通过该InputChannel创建WindowInputEventReceiver。 3.1 WindowInputEventReceiver初始化1234567final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; ......&#125; WindowInputEventReceiver是继承了InputEventReceiver的，这里的构造函数也仅仅是将传入的参数继续调用给父类的构造函数。 3.2 InputEventReceiver初始化12345678910111213141516171819public InputEventReceiver(InputChannel inputChannel, Looper looper) &#123; if (inputChannel == null) &#123; throw new IllegalArgumentException(&quot;inputChannel must not be null&quot;); &#125; if (looper == null) &#123; throw new IllegalArgumentException(&quot;looper must not be null&quot;); &#125; mInputChannel = inputChannel; mMessageQueue = looper.getQueue(); // 3.3 通过JNI创建native层的对象 mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); mCloseGuard.open(&quot;dispose&quot;);&#125;private static native long nativeInit(WeakReference&lt;InputEventReceiver&gt; receiver, InputChannel inputChannel, MessageQueue messageQueue); 3.3 android_view_InputEventReceiver.cpp:nativeInit1234567891011121314151617181920212223242526272829303132// android_view_InputEventReceiver.cpp#486static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) &#123; // 通过java层的InputChannel转成Native层的InputChannel std::shared_ptr&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); if (inputChannel == nullptr) &#123; jniThrowRuntimeException(env, &quot;InputChannel is not initialized.&quot;); return 0; &#125; // 通过java层的MessageQueue转成Native层的MessageQueue sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == nullptr) &#123; jniThrowRuntimeException(env, &quot;MessageQueue is not initialized.&quot;); return 0; &#125; // 3.4 创建NativeInputEventReceiver sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); // 3.5 调用初始化 status_t status = receiver-&gt;initialize(); if (status) &#123; std::string message = android::base::StringPrintf(&quot;Failed to initialize input event receiver. status=%d&quot;, status); jniThrowRuntimeException(env, message.c_str()); return 0; &#125; receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 3.4 NativeInputEventReceiver初始化123456789101112NativeInputEventReceiver::NativeInputEventReceiver( JNIEnv* env, jobject receiverWeak, const std::shared_ptr&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;MessageQueue&gt;&amp; messageQueue) : mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)), mInputConsumer(inputChannel), mMessageQueue(messageQueue), mBatchedInputEventPending(false), mFdEvents(0) &#123; if (kDebugDispatchCycle) &#123; ALOGD(&quot;channel &#x27;%s&#x27; ~ Initializing input event receiver.&quot;, getInputChannelName().c_str()); &#125;&#125; 初始化NativeInputEventReceiver 3.5 NativeInputEventReceiver.initialize12345678910111213141516171819status_t NativeInputEventReceiver::initialize() &#123; // ALOOPER_EVENT_INPUT = 1 &lt;&lt; 0; setFdEvents(ALOOPER_EVENT_INPUT); return OK;&#125;void NativeInputEventReceiver::setFdEvents(int events) &#123; // 此时mFdEvents还只是0 if (mFdEvents != events) &#123; mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; // 将InputChannel中的客户端Socket的文件描述符加入的Looper中监听 mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, nullptr); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; 这里设置文件描述符，将作为客户端InputChannel的Socket的描述符添加到该应用进程的主线程Looper中（ViewRootImpl.setView是主线程才能被调用的）。 四. 小结WindowState和InputChannel的相关流程图如下： InputChannel的Native实现就是一对Socket，其中服务端作为input事件分发者被加入InputDispatcher的Looper中，客户端会被存入NativeInputChannel中。一个WindowState对应一对Socket，分成服务端和客户端，服务端Socket的描述符被存入InputDispatcher的mConnectionsByToken，也被添加到其mLooper中用于转发Input事件至客户端Socket中。而客户端Socket又被dup函数复制成两份NativeInputChannel, 一份存在WindowState的mInputChannel中，另一份通过Binder调用存入应用进程的ViewRootImpl的WindowInputEventReceiver对象中。 接下来我们看看input事件是如何传给正确的窗口进程的。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"},{"name":"Input","slug":"Android/WMS/Input","permalink":"https://swallowjoe.github.io/categories/Android/WMS/Input/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"},{"name":"Input","slug":"Input","permalink":"https://swallowjoe.github.io/tags/Input/"}]},{"title":"WMS(6)-焦点窗口的更新","slug":"WMS(6)-焦点窗口的更新","date":"2022-05-05T17:35:34.000Z","updated":"2022-06-18T09:57:10.732Z","comments":true,"path":"2022/05/06/WMS(6)-焦点窗口的更新/","link":"","permalink":"https://swallowjoe.github.io/2022/05/06/WMS(6)-%E7%84%A6%E7%82%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/","excerpt":"以下分析基于Android S. 简述这篇文章中我们重点关注焦点窗口的更新，所谓焦点窗口就是当前选择的窗口。在Android里可以通过下面的adb命令来查看当前的焦点窗口: adb shell dumpsys window |grep -iE “mCurr*” 我们知道一个实体显示器对应一个DisplayId, 相应的有一个DisplayContent，如同我们人眼或者相机的对焦，同一时刻只能有一个焦点，那么对应一个Display一般来说也只有一个焦点窗口了。 我们之前一直分析的WMS.addWindow，在应用进程调用setView传入对应窗口属性之后，当然也会有焦点窗口的重新计算了：","text":"以下分析基于Android S. 简述这篇文章中我们重点关注焦点窗口的更新，所谓焦点窗口就是当前选择的窗口。在Android里可以通过下面的adb命令来查看当前的焦点窗口: adb shell dumpsys window |grep -iE “mCurr*” 我们知道一个实体显示器对应一个DisplayId, 相应的有一个DisplayContent，如同我们人眼或者相机的对焦，同一时刻只能有一个焦点，那么对应一个Display一般来说也只有一个焦点窗口了。 我们之前一直分析的WMS.addWindow，在应用进程调用setView传入对应窗口属性之后，当然也会有焦点窗口的重新计算了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility, int displayId, int requestUserId, InsetsState requestedVisibility, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; ...... // 窗口类型保存在LayoutParams中 final int type = attrs.type; synchronized (mGlobalLock) &#123; ...... // 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord! WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); ... // 初始化WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); ...... // 创建SurfaceSession, 用来和SurfaceFlinger通信 win.attach(); // 保存WindowState, key为ViewRoomImpl.W mWindowMap.put(client.asBinder(), win); // 和应用窗口权限有关，后续分析 win.initAppOpsState(); ...... // 将该WindowState保存在其mToken(ActivityRecord)中 win.mToken.addWindow(win); ...... // 标记焦点窗口是否更新 boolean focusChanged = false; // [1.1] 检查该窗口是否可以接收input事件 if (win.canReceiveKeys()) &#123; // [1.2] 更新焦点窗口 focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false /*updateInputWindows*/); if (focusChanged) &#123; imMayMove = false; &#125; &#125; ...... // [2.1] 如果焦点窗口有更新，也需要更新input相关设置 if (focusChanged) &#123; displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus, false /*updateInputWindows*/); &#125; ...... // 该窗口成功被添加或者是可见的而且当前display需要更新方向时，更新display相关配置 if (win.isVisibleOrAdding() &amp;&amp; displayContent.updateOrientation()) &#123; displayContent.sendNewConfiguration(); &#125; ......&#125; 一. 焦点窗口更新应用的第一个addWindow应该是启动窗口的，所以我们以启动窗口为例分析焦点窗口更新。 1.1 WindowState.canReceiveKeys1234567891011121314151617181920boolean canReceiveKeys() &#123; return canReceiveKeys(false /* fromUserTouch */);&#125;public boolean canReceiveKeys(boolean fromUserTouch) &#123; // [1.1.1] 检查该窗口是否可见 final boolean canReceiveKeys = isVisibleOrAdding() &amp;&amp; (mViewVisibility == View.VISIBLE) &amp;&amp; !mRemoveOnExit &amp;&amp; ((mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) == 0) // [1.1.2] 确认该ActivityRecord是否可聚焦 &amp;&amp; (mActivityRecord == null || mActivityRecord.windowsAreFocusable(fromUserTouch)) // [1.1.3] 判断该WindowState是否允许接收input事件 &amp;&amp; canReceiveTouchInput(); if (!canReceiveKeys) &#123; return false; &#125; // 除非用户有意触摸显示器，否则不允许不受信任的虚拟显示接收input事件 return fromUserTouch || getDisplayContent().isOnTop() || getDisplayContent().isTrusted();&#125; 这里检查了一堆参数，我们一一分析： isVisibleOrAdding(): 判断当前窗口是否可见或者被添加 mViewVisibility &#x3D;&#x3D; View.VISIBLE: 窗口可见属性为VISIBLE !mRemoveOnExit: 该窗口没有移除或者退出 ((mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) &#x3D;&#x3D; 0): 该窗口的属性不带有FLAG_NOT_FOCUSABLE，是可聚焦的 (mActivityRecord &#x3D;&#x3D; null || mActivityRecord.windowsAreFocusable(fromUserTouch)):该窗口不是Activity对应的窗口，如果是那么需要满足windowsAreFocusable canReceiveTouchInput(): 该窗口可以接收touch事件 只有当上述条件都满足且窗口所处的DisplayContent是最上层的并且该Display是受信任的，该窗口才可能接收事件。 1.1.1 WindowState.isVisibleOrAdding1234567891011121314151617181920boolean isVisibleOrAdding() &#123; // 该窗口不一定对应Activity,比如启动窗口 final ActivityRecord atoken = mActivityRecord; return (mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility == View.VISIBLE)) &amp;&amp; isVisibleByPolicy() &amp;&amp; !isParentWindowHidden() &amp;&amp; (atoken == null || atoken.mVisibleRequested) &amp;&amp; !mAnimatingExit &amp;&amp; !mDestroying;&#125;boolean isVisibleByPolicy() &#123; // 判断mPolicyVisibility中的POLICY_VISIBILITY_ALL位是否被设置了 // mPolicyVisibility默认就是POLICY_VISIBILITY_ALL return (mPolicyVisibility &amp; POLICY_VISIBILITY_ALL) == POLICY_VISIBILITY_ALL;&#125;boolean isParentWindowHidden() &#123; // 当前窗口的父窗口是否被隐藏了 final WindowState parent = getParentWindow(); return parent != null &amp;&amp; parent.mHidden;&#125; 判断该窗口是否可见或者处于被添加状态。 (mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility &#x3D;&#x3D; View.VISIBLE))： mHasSurface：该窗口是否有对应Surface，该Surface会在该窗口对应的启动或退出动画时创建 (!mRelayoutCalled &amp;&amp; mViewVisibility &#x3D;&#x3D; View.VISIBLE): !mRelayoutCalled: 该窗口被调用了relayoutWindow mViewVisibility &#x3D;&#x3D; View.VISIBLE: 窗口View属性对应的是VISIBLE 如果该窗口已经有Surface或者没有被relayoutWindow但窗口可见属性是VISIBLE的时 isVisibleByPolicy()：判断mPolicyVisibility中的POLICY_VISIBILITY_ALL位都被设置了 !isParentWindowHidden(): 判断父窗口没有被隐藏 (atoken &#x3D;&#x3D; null || atoken.mVisibleRequested)： atoken &#x3D;&#x3D; null：该窗口不对应ActivityRecord atoken.mVisibleRequested: 如果对应，需要mVisibleRequested被设置为true !mAnimatingExit：该窗口当前没有执行退出动画 !mDestroying：该窗口没有被销毁 1.1.2 ActivityRecord.windowsAreFocusable1234567891011121314151617181920212223242526boolean windowsAreFocusable(boolean fromUserTouch) &#123; // fromUserTouch为false if (!fromUserTouch &amp;&amp; mTargetSdk &lt; Build.VERSION_CODES.Q) &#123; final int pid = getPid(); final ActivityRecord topFocusedAppOfMyProcess = mWmService.mRoot.mTopFocusedAppByProcess.get(pid); if (topFocusedAppOfMyProcess != null &amp;&amp; topFocusedAppOfMyProcess != this) &#123; // 对于Q以下的应用程序，每个进程只能有一个具有聚焦窗口的应用程序，因为以往的应用程序可能无法用于多聚焦系统 return false; &#125; &#125; // 确认该ActivityRecord是否已经attach了 // isAttached是其父类的父类WindowContainer中的方法，用于判断该ActivityRecord的parent的DisplayArea是否为null return (canReceiveKeys() || isAlwaysFocusable()) &amp;&amp; isAttached();&#125;boolean canReceiveKeys() &#123; // 确定该ActivityRecord对应的窗口配置是否允许接收input事件 return getWindowConfiguration().canReceiveKeys() &amp;&amp; (task == null || task.getWindowConfiguration().canReceiveKeys());&#125;private boolean isAlwaysFocusable() &#123; return (info.flags &amp; FLAG_ALWAYS_FOCUSABLE) != 0;&#125; windowsAreFocusable用于判断该ActivityRecord对应窗口是否可以接收input事件。 1.1.3 WindowState.canReceiveTouchInput123456789boolean canReceiveTouchInput() &#123; if (mActivityRecord == null || mActivityRecord.getTask() == null) &#123; return true; &#125; return !mActivityRecord.getTask().getRootTask().shouldIgnoreInput() &amp;&amp; mActivityRecord.mVisibleRequested &amp;&amp; !isRecentsAnimationConsumingAppInput();&#125; 这里可以看到如果是非ActivityRecord对应的Window那么直接返回true，如果该ActivityRecord还没有被加入task也直接返回true. !mActivityRecord.getTask().getRootTask().shouldIgnoreInput()：该ActivityRecord的task所处的rootTask没有被设置忽略input事件 mActivityRecord.mVisibleRequested: 该ActivityRecord被设置了VISIBLE !isRecentsAnimationConsumingAppInput():该窗口没有作为最近任务窗口的动画的一部分时 1.2 WMS.updateFocusedWindowLocked123456boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows) &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;wmUpdateFocus&quot;); boolean changed = mRoot.updateFocusedWindowLocked(mode, updateInputWindows); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); return changed;&#125; 这里传入的mode是UPDATE_FOCUS_WILL_ASSIGN_LAYERS，而且updateInputWindows为false. WMS.mRoot就是RootWindowContainer. 1.3 RootWindowContainer.updateFocusedWindowLocked1234567891011121314151617181920212223242526272829303132333435363738394041boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows) &#123; // 首先清除mTopFocusedAppByProcess中的元素：ArrayMap&lt;Integer, ActivityRecord&gt; mTopFocusedAppByProcess mTopFocusedAppByProcess.clear(); boolean changed = false; int topFocusedDisplayId = INVALID_DISPLAY; // 遍历所有DisplayContent, 并依次更新焦点窗口, 注意这里是倒序更新计算 for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123; final DisplayContent dc = mChildren.get(i); // [1.4] 更新单个DisplayContent的焦点窗口 changed |= dc.updateFocusedWindowLocked(mode, updateInputWindows, topFocusedDisplayId); final WindowState newFocus = dc.mCurrentFocus; // DC存在新的焦点窗口时 if (newFocus != null) &#123; final int pidOfNewFocus = newFocus.mSession.mPid; // 将新焦点窗口的ActivityRecord保存在mTopFocusedAppByProcess中 if (mTopFocusedAppByProcess.get(pidOfNewFocus) == null) &#123; mTopFocusedAppByProcess.put(pidOfNewFocus, newFocus.mActivityRecord); &#125; // 更新topFocusedDisplayId为该DC的DisplayId if (topFocusedDisplayId == INVALID_DISPLAY) &#123; topFocusedDisplayId = dc.getDisplayId(); &#125; &#125; else if (topFocusedDisplayId == INVALID_DISPLAY &amp;&amp; dc.mFocusedApp != null) &#123; // 即使应用窗口还没有准备好(未附加进程或未添加窗口)，具有焦点应用的顶部显示仍然应该是焦点顶部显示 topFocusedDisplayId = dc.getDisplayId(); &#125; &#125; if (topFocusedDisplayId == INVALID_DISPLAY) &#123; topFocusedDisplayId = DEFAULT_DISPLAY; &#125; // 当焦点所处的display有变化时 if (mTopFocusedDisplayId != topFocusedDisplayId) &#123; mTopFocusedDisplayId = topFocusedDisplayId; // [2.1] 通知input系统更新displayId mWmService.mInputManager.setFocusedDisplay(topFocusedDisplayId); // 将PhoneWindowManager中的mTopFocusedDisplayId更新为新焦点窗口所处的DisplayId mWmService.mPolicy.setTopFocusedDisplay(topFocusedDisplayId); ProtoLog.d(WM_DEBUG_FOCUS_LIGHT, &quot;New topFocusedDisplayId=%d&quot;, topFocusedDisplayId); &#125; return changed;&#125; 计算更新焦点窗口是对所有DisplayContent的依次计算更新焦点窗口。首先清除mTopFocusedAppByProcess中的元素，然后依次更新所有DisplayContent的焦点窗口。 1.4 DisplayContent.updateFocusedWindowLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061boolean updateFocusedWindowLocked(int mode, boolean updateInputWindows, int topFocusedDisplayId) &#123; // [1.4.1] 计算当前DisplayContent的焦点窗口，注意传入的topFocusedDisplayId是INVALID_DISPLAY WindowState newFocus = findFocusedWindowIfNeeded(topFocusedDisplayId); // 如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作 if (mCurrentFocus == newFocus) &#123; return false; &#125; boolean imWindowChanged = false; final WindowState imWindow = mInputMethodWindow; // 如果当前存在输入法窗口，这里我们先假设不存在 if (imWindow != null) &#123; ...... &#125; ProtoLog.d(WM_DEBUG_FOCUS_LIGHT, &quot;Changing focus from %s to %s displayId=%d Callers=%s&quot;, mCurrentFocus, newFocus, getDisplayId(), Debug.getCallers(4)); // 更新焦点窗口 final WindowState oldFocus = mCurrentFocus; mCurrentFocus = newFocus; // 如果新的焦点窗口不为null if (newFocus != null) &#123; mWinAddedSinceNullFocus.clear(); mWinRemovedSinceNullFocus.clear(); if (newFocus.canReceiveKeys()) &#123; // 隐式地显示一个窗口将导致取消调度 // 这是为了防止有人暂停调度但忘记resume newFocus.mToken.paused = false; &#125; &#125; // [1.4.2] 通知其他模组焦点窗口更新了,主要是更新两个Task的阴影 onWindowFocusChanged(oldFocus, newFocus); // [1.4.3] 更新DisplayPolicy中相关参数 int focusChanged = getDisplayPolicy().focusChangedLw(oldFocus, newFocus); ...... if ((focusChanged &amp; FINISH_LAYOUT_REDO_LAYOUT) != 0) &#123; // 焦点的变化导致需要做一个布局， SystemUI状态栏或者导航栏可见性有变化了 // 将参数mLayoutNeeded置位true setLayoutNeeded(); // 这里传入的mode为UPDATE_FOCUS_WILL_ASSIGN_LAYERS if (mode == UPDATE_FOCUS_PLACING_SURFACES) &#123; performLayout(true /*initial*/, updateInputWindows); &#125; else if (mode == UPDATE_FOCUS_REMOVING_FOCUS) &#123; mWmService.mRoot.performSurfacePlacement(); &#125; &#125; ...... // 将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI scheduleToastWindowsTimeoutIfNeededLocked(oldFocus, newFocus); ...... // 记录新焦点窗口 mLastFocus = mCurrentFocus; return true;&#125; DisplayContent更新焦点窗口的流程如下: 计算当前DisplayContent的焦点窗口 如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作 如果当前存在输入法窗口,执行相关操作(后续分析输入法窗口) 更新焦点窗口，保存在mCurrentFocus中 清空mWinAddedSinceNullFocus、mWinRemovedSinceNullFocus 通知其他模组焦点窗口更新了,主要是更新两个Task（当前焦点窗口和新的焦点窗口所处的Task）的阴影 更新DisplayPolicy中相关参数 更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性 如果因焦点窗口变化导致SystemUI状态栏或者导航栏可见性有变化了，将参数mLayoutNeeded置位true 将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI 记录新焦点窗口，保存在mLastFocus中 1.4.1 DisplayContent.findFocusedWindowIfNeeded1234567891011121314151617WindowState findFocusedWindowIfNeeded(int topFocusedDisplayId) &#123; return (mWmService.mPerDisplayFocusEnabled || topFocusedDisplayId == INVALID_DISPLAY) ? findFocusedWindow() : null;&#125;WindowState findFocusedWindow() &#123; mTmpWindow = null; // [1.4.1.1] 从上到下遍历所有的ActivityRecord，并对每一个执行mFindFocusedWindow方法 forAllWindows(mFindFocusedWindow, true /* traverseTopToBottom */); if (mTmpWindow == null) &#123; ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, &quot;findFocusedWindow: No focusable windows, display=%d&quot;, getDisplayId()); return null; &#125; return mTmpWindow;&#125; 注意这里的mFindFocusedWindow其实是一个函数: ToBooleanFunction mFindFocusedWindow, 这里又是使用了函数式编程的方法。我们先看forAllWindows方法，这个是被继承的祖父类WindowContainer中的方法。 1.4.1.1 WindowContainer.forAllWindows1234567891011121314151617boolean forAllWindows(ToBooleanFunction&lt;WindowState&gt; callback, boolean traverseTopToBottom) &#123; if (traverseTopToBottom) &#123; for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123; if (mChildren.get(i).forAllWindows(callback, traverseTopToBottom)) &#123; return true; &#125; &#125; &#125; else &#123; final int count = mChildren.size(); for (int i = 0; i &lt; count; i++) &#123; if (mChildren.get(i).forAllWindows(callback, traverseTopToBottom)) &#123; return true; &#125; &#125; &#125; return false;&#125; 对该WindowContainer的mChildren中的每一个元素执行forAllWindows，调用callback。traverseTopToBottom参数如果为true，则按z顺序从上到下遍历层次结构，否则从下到上遍历。如果因为传入的函数callback执行后的返回值为true,那么会中止遍历直接返回true。 回顾下DisplayContent的类图: 可以看到DisplayContent的是从WindowContainer一路继承下来的，所以其mChildren就是 WindowList。 而DisplayArea也是继承了WindowContainer，所以到底这个DisplayContent里存储了什么元素呢？ 回到之前我们研究过的DisplayContent的创建 WMS(2)-WMS中RootDisplayArea的创建， 在这里我们知道DisplayContent的mChildren中存储的是DisplayArea的对象，所以而DisplayArea又是继承了WindowContainer，然而DisplayArea中的mChildren存储的是ActivityRecord或者WindowState. 1.4.1.2 WindowState.forAllWindows12345678910111213@Overrideboolean forAllWindows(ToBooleanFunction&lt;WindowState&gt; callback, boolean traverseTopToBottom) &#123; if (mChildren.isEmpty()) &#123; // The window has no children so we just return it. return applyInOrderWithImeWindows(callback, traverseTopToBottom); &#125; if (traverseTopToBottom) &#123; return forAllWindowTopToBottom(callback); &#125; else &#123; return forAllWindowBottomToTop(callback); &#125;&#125; 这里我们假设该mChildren为null: 1234567891011121314151617private boolean applyInOrderWithImeWindows(ToBooleanFunction&lt;WindowState&gt; callback, boolean traverseTopToBottom) &#123; if (traverseTopToBottom) &#123; // applyImeWindowsIfNeeded是用于处理输入法窗口的，暂时先不管。 if (applyImeWindowsIfNeeded(callback, traverseTopToBottom) // [1.5] 对该Window执行传入的函数,即mFindFocusedWindow || callback.apply(this)) &#123; return true; &#125; &#125; else &#123; if (callback.apply(this) || applyImeWindowsIfNeeded(callback, traverseTopToBottom)) &#123; return true; &#125; &#125; return false;&#125; 1.4.2 DisplayContent.onWindowFocusChanged12345678910111213141516private static void onWindowFocusChanged(WindowState oldFocus, WindowState newFocus) &#123; final Task focusedTask = newFocus != null ? newFocus.getTask() : null; final Task unfocusedTask = oldFocus != null ? oldFocus.getTask() : null; // 如果是同一个task就不需要额外动作 if (focusedTask == unfocusedTask) &#123; return; &#125; // 通知新的焦点窗口所处的Task有焦点了 if (focusedTask != null) &#123; focusedTask.onWindowFocusChanged(true /* hasFocus */); &#125; // 之前焦点窗口所处的Task失去焦点 if (unfocusedTask != null) &#123; unfocusedTask.onWindowFocusChanged(false /* hasFocus */); &#125;&#125; 从WindowState中拿到的Task其实是其对应的ActivityRecord所在的Task： 123456789// WindowState.javaTask getTask() &#123; return mActivityRecord != null ? mActivityRecord.getTask() : null;&#125;// ActivityRecord.javaTask getTask() &#123; return task;&#125; 这个ActivityRecord.task就是 WMS(3)-ActivityRecord和WindowToken 中 [1.7.1]里赋值的，其实就是该ActivityRecord的mParent（创建的新Task）。 1.4.2.1 Task.onWindowFocusChanged1234567891011121314151617void onWindowFocusChanged(boolean hasFocus) &#123; updateShadowsRadius(hasFocus, getSyncTransaction()); // TODO(b/180525887): Un-comment once there is resolution on the bug. // dispatchTaskInfoChangedIfNeeded(false /* force */);&#125;private void updateShadowsRadius(boolean taskIsFocused, SurfaceControl.Transaction pendingTransaction) &#123; if (!mWmService.mRenderShadowsInCompositor || !isRootTask()) return; // 根据窗口模式和任务焦点状态更新阴影的长度 final float newShadowRadius = getShadowRadius(taskIsFocused); if (mShadowRadius != newShadowRadius) &#123; mShadowRadius = newShadowRadius; pendingTransaction.setShadowRadius(getSurfaceControl(), mShadowRadius); &#125;&#125; 这里根据该task是否持有焦点来更新阴影，后续研究 1.4.3 DisplayPolicy.focusChangedLw1234567891011121314public int focusChangedLw(WindowState lastFocus, WindowState newFocus) &#123; mFocusedWindow = newFocus; mLastFocusedWindow = lastFocus; if (mDisplayContent.isDefaultDisplay) &#123; // 更新PhoneWindowManager中相关参数，就是更新DisplayFoldController中的mFocusedApp(焦点窗口包名) mService.mPolicy.onDefaultDisplayFocusChangedLw(newFocus); &#125; // 更新SystemUi的可见与否，比如状态栏等，后续研究 if (updateSystemUiVisibilityLw()) &#123; // 如果导航栏已经被隐藏或显示，需要做另一个布局传递来更新窗口 return FINISH_LAYOUT_REDO_LAYOUT; &#125; return 0;&#125; 这里更新DisplayPolicy中存储的焦点窗口相关信息，包括更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性。 1.5 DisplayContent.mFindFocusedWindow123456789101112131415161718192021222324252627282930313233343536373839404142434445private final ToBooleanFunction&lt;WindowState&gt; mFindFocusedWindow = w -&gt; &#123; final ActivityRecord focusedApp = mFocusedApp; ProtoLog.v(WM_DEBUG_FOCUS, &quot;Looking for focus: %s, flags=%d, canReceive=%b, reason=%s&quot;, w, w.mAttrs.flags, w.canReceiveKeys(), w.canReceiveKeysReason(false /* fromUserTouch */)); // 检查该窗口是否可以接收input事件 // 无法接收输入事件的窗口没有资格作为焦点窗口 if (!w.canReceiveKeys()) &#123; return false; &#125; final ActivityRecord activity = w.mActivityRecord; // 如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了 if (focusedApp == null) &#123; ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, &quot;findFocusedWindow: focusedApp=null using new focus @ %s&quot;, w); mTmpWindow = w; return true; &#125; // 如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口 if (!focusedApp.windowsAreFocusable()) &#123; ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, &quot;findFocusedWindow: focusedApp windows not&quot; + &quot; focusable using new focus @ %s&quot;, w); mTmpWindow = w; return true; &#125; // 遍历所有app的token, 找到第一个符合要求的作为焦点窗口(从上到下遍历所有的ActivityRecord,所以第一个符合的token对应窗口Z轴最大) if (activity != null &amp;&amp; w.mAttrs.type != TYPE_APPLICATION_STARTING) &#123; // WindowState对应的有Activity, 而且类型不能是启动窗口 // [1.6] 对比计算Z轴大小 if (focusedApp.compareTo(activity) &gt; 0) &#123; // 当前焦点窗口Z轴比该Activity窗口大 ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, &quot;findFocusedWindow: Reached focused app=%s&quot;, focusedApp); mTmpWindow = null; return true; &#125; &#125; // 找到了新的焦点窗口，暂存在mTmpWindow中 ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, &quot;findFocusedWindow: Found new focus @ %s&quot;, w); mTmpWindow = w; return true;&#125;; 更新焦点窗口的步骤也不复杂： 遍历该DisplayContent中mChildren中的所有DisplayArea 依次对比DisplayArea中的mChildren集合里面的Window(ActivityRecord或WindowState) 检查该Window是否符合要求 无法接收输入事件的窗口没有资格作为焦点窗口 如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了 如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口 遍历所有app的token, 找到第一个符合要求的作为焦点窗口 WindowState对应的有Activity, 而且类型不能是启动窗口 该Activity窗口Z轴比当前焦点窗口大 更新mTmpWindow为当前Activity窗口，否则置为null 1.6 ActivityRecord.compareToActivityRecord其实是调用了父类WindowContainer中的方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Overridepublic int compareTo(WindowContainer other) &#123; if (this == other) &#123; return 0; &#125; // 如果该Activity的mParent是同一个，那么就对比两个在其中所处的位置 // 序号就代表了Z轴，可以理解为序号大的在上层，盖住序号小的 if (mParent != null &amp;&amp; mParent == other.mParent) &#123; final WindowList&lt;WindowContainer&gt; list = mParent.mChildren; return list.indexOf(this) &gt; list.indexOf(other) ? 1 : -1; &#125; // 如果两个WindowContainer不是同一个mParent, 那么先找到z轴最大的包含两个WC的父容器，然后对比z轴大小 final LinkedList&lt;WindowContainer&gt; thisParentChain = mTmpChain1; final LinkedList&lt;WindowContainer&gt; otherParentChain = mTmpChain2; try &#123; // [1.6.1] 获取当前WindowContainer的所有父容器 getParents(thisParentChain); other.getParents(otherParentChain); // 找到z轴最大的且包含两个WC的父容器 WindowContainer commonAncestor = null; WindowContainer thisTop = thisParentChain.peekLast(); WindowContainer otherTop = otherParentChain.peekLast(); while (thisTop != null &amp;&amp; otherTop != null &amp;&amp; thisTop == otherTop) &#123; // 移除拿到最后一个父容器 commonAncestor = thisParentChain.removeLast(); otherParentChain.removeLast(); thisTop = thisParentChain.peekLast(); otherTop = otherParentChain.peekLast(); &#125; ...... // 子容器总是被认为比父容器大，所以如果将一个容器与另一个容器的父容器进行比较，那么无论如何都是子容器更大。 if (commonAncestor == this) &#123; return -1; &#125; else if (commonAncestor == other) &#123; return 1; &#125; // 各自对比两个WC在Z轴最大的父容器中的位置 final WindowList&lt;WindowContainer&gt; list = commonAncestor.mChildren; return list.indexOf(thisParentChain.peekLast()) &gt; list.indexOf(otherParentChain.peekLast()) ? 1 : -1; &#125; finally &#123; mTmpChain1.clear(); mTmpChain2.clear(); &#125;&#125; 可以将WC的整个结构理解为树形结构，对比两个WC的Z轴大小就是对比这两个WC与最近的共同父节点的距离大小，距离越大，说明Z轴越大。 1.6.1 WindowContainer.getParents12345678private void getParents(LinkedList&lt;WindowContainer&gt; parents) &#123; parents.clear(); WindowContainer current = this; do &#123; parents.addLast(current); current = current.mParent; &#125; while (current != null);&#125; 依次遍历，将该WindowContainer的所有mParent添加到队列中. 二. 小结总的来说，更新焦点窗口就是对所有DisplayContent倒序遍历，依次计算新的焦点窗口： 计算当前DisplayContent的焦点窗口 遍历该DisplayContent中mChildren中的所有DisplayArea 依次对比DisplayArea中的mChildren集合里面的Window(ActivityRecord或WindowState) 检查该Window是否符合要求 无法接收输入事件的窗口没有资格作为焦点窗口 如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了 如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口 遍历所有app的token, 找到第一个符合要求的作为焦点窗口 WindowState对应的有Activity, 而且类型不能是启动窗口 该Activity窗口Z轴比当前焦点窗口大 更新mTmpWindow为当前Activity窗口，否则置为null 如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作 如果当前存在输入法窗口,执行相关操作(后续分析输入法窗口) 更新焦点窗口，保存在mCurrentFocus中 清空mWinAddedSinceNullFocus、mWinRemovedSinceNullFocus 通知其他模组焦点窗口更新了,主要是更新两个Task（当前焦点窗口和新的焦点窗口所处的Task）的阴影 更新DisplayPolicy中相关参数 更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性 如果因焦点窗口变化导致SystemUI状态栏或者导航栏可见性有变化了，将参数mLayoutNeeded置位true 将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI 记录新焦点窗口，保存在mLastFocus中 2.1 通知input系统更新焦点窗口在WMS计算更新完焦点窗口之后，需要同步通知给input系统: 12345// [2.1] 如果焦点窗口有更新，也需要更新input相关设置if (focusChanged) &#123; displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus, false /*updateInputWindows*/);&#125; 这里很自然就有疑问，窗口可大可小，不同的窗口层叠起来，input系统是如何判断分发事件到正确的窗口呢？ 接下来我们先看看应用窗口和input的关系。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"},{"name":"Input","slug":"Input","permalink":"https://swallowjoe.github.io/tags/Input/"}]},{"title":"WMS(5)-启动窗口","slug":"WMS(5)-启动窗口","date":"2022-05-04T17:35:34.000Z","updated":"2022-06-18T09:57:07.065Z","comments":true,"path":"2022/05/05/WMS(5)-启动窗口/","link":"","permalink":"https://swallowjoe.github.io/2022/05/05/WMS(5)-%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3/","excerpt":"以下分析基于Android S. 简述前面几篇文章中，我们弄清楚了WMS中比较核心的几个类的作用以及初始化等流程。现在我们看看Activity启动时的启动窗口动画过程，以此为锲子剖析WMS相关流程。 启动窗口，如其名，最合理的地方应该是在Activity启动的时候播放其动画的，回到startActivityInner，开始看:","text":"以下分析基于Android S. 简述前面几篇文章中，我们弄清楚了WMS中比较核心的几个类的作用以及初始化等流程。现在我们看看Activity启动时的启动窗口动画过程，以此为锲子剖析WMS相关流程。 启动窗口，如其名，最合理的地方应该是在Activity启动的时候播放其动画的，回到startActivityInner，开始看: 一. 启动窗口的初始化1.1 ActivityStarter.startActivityInner12345678910int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123; ...... // 交给对应Task启动Activity mTargetRootTask.startActivityLocked(mStartActivity, topRootTask != null ? topRootTask.getTopNonFinishingActivity() : null, newTask, mKeepCurTransition, mOptions, startFromSamePackage); ...... 在Activity启动过程中，在创建新的Task并将该ActivityRecord保存其中，之后就是将启动Activity的流程转交给Task继续执行. 1.2 Task.startActivityLocked12345678910111213141516171819202122232425262728293031323334353637383940414243void startActivityLocked(ActivityRecord r, @Nullable ActivityRecord focusedTopActivity, boolean newTask, boolean keepCurTransition, ActivityOptions options, boolean samePackage) &#123; ...... if ((!isHomeOrRecentsRootTask() || hasActivity()) &amp;&amp; allowMoveToFront) &#123; ...... boolean doShow = true; ...... // ActivityRecord.mLaunchTaskBehind 是用于表明启动该Activity时不需要动画 // 与options:&quot;android:activity.animType&quot;有关(调用了makeTaskLaunchBehind) // 使用了这个标记说明正在启动的Activity将不会显示给用户，而是只能通过最近的任务列表使用 if (r.mLaunchTaskBehind) &#123; ...... &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; // 显示启动窗口 // 这里判断上一个task是否存在启动窗口 Task prevTask = r.getTask(); // 获取当前Task中的上一个具有启动窗口的ActivityRecord ActivityRecord prev = prevTask.topActivityWithStartingWindow(); if (prev != null) &#123; // 当前Activity和启动窗口不在同一个task时，不会重用启动窗口 if (prev.getTask() != prevTask) &#123; prev = null; &#125; // 当前Activity已经显示出来了，也不会重用启动窗口 else if (prev.nowVisible) &#123; prev = null; &#125; &#125; final int splashScreenThemeResId = options != null ? options.getSplashScreenThemeResId() : 0; // [1.3] 显示启动窗口， 我们这里是第一个Activity，不存在启动窗口, 所以prev为null r.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity), splashScreenThemeResId, samePackage); &#125; ......&#125;// topFocusedActivity是当前展示的前台具有焦点的Activity对应的ActivityRecord// 这里是判断是否需要切换Task, 当然需要private boolean isTaskSwitch(ActivityRecord r, ActivityRecord topFocusedActivity) &#123; return topFocusedActivity != null &amp;&amp; r.getTask() != topFocusedActivity.getTask();&#125; Task中执行Activity的启动主要是： 将该Activity对应的ActivityRecord放在该task合适的位置 顺便检查是否需要显示启动窗口，如果需要： 检查是否可以重用启动窗口： 当前Activity和启动窗口不在同一个task时，不会重用启动窗口 当前Activity已经显示出来了，也不会重用启动窗口 显示启动窗口 1.3 ActivityRecord.showStartingWindow1234567891011121314151617181920212223242526272829void showStartingWindow(ActivityRecord prev, boolean newTask, boolean taskSwitch, int splashScreenTheme, boolean samePackage) &#123; if (mTaskOverlay) &#123; // 不显示overlay activity的启动窗口, 即始终处于最上层的Activity return; &#125; if (mPendingOptions != null &amp;&amp; mPendingOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123; // 当Activity动画类型为ANIM_SCENE_TRANSITION时，不显示启动窗口 return; &#125; final CompatibilityInfo compatInfo = mAtmService.compatibilityInfoForPackageLocked(info.applicationInfo); // 选择合适的窗口主题 final int resolvedTheme = evaluateStartingWindowTheme(packageName, theme, splashScreenTheme); // [1.4] 添加启动窗口 final boolean shown = addStartingWindow(packageName, resolvedTheme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags, prev != null ? prev.appToken : null, newTask, taskSwitch, isProcessRunning(), allowTaskSnapshot(), mState.ordinal() &gt;= STARTED.ordinal() &amp;&amp; mState.ordinal() &lt;= STOPPED.ordinal(), samePackage); // 成功添加时，标记此ActivityRecord的启动窗口状态为STARTING_WINDOW_SHOWN if (shown) &#123; mStartingWindowState = STARTING_WINDOW_SHOWN; &#125;&#125; 显示启动窗口首先需要检查是否需要显示，以下两种情况不显示启动窗口： 当此Activity为始终处于最上层时 Activity动画类型为ANIM_SCENE_TRANSITION时 然后选择合适窗口主题，添加启动窗口并在成功添加时，标记此ActivityRecord的启动窗口状态为STARTING_WINDOW_SHOWN，意为此Activity已经展示了启动窗口。 1.4 ActivityRecord.addStartingWindow123456789101112131415161718192021222324252627282930313233boolean addStartingWindow(String pkg, int resolvedTheme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, IBinder transferFrom, boolean newTask, boolean taskSwitch, boolean processRunning, boolean allowTaskSnapshot, boolean activityCreated, boolean samePackage) &#123; ...... // 根据当前Activity相关参数配置启动窗口的窗口属性 final int typeParameter = mWmService.mStartingSurfaceController .makeStartingWindowTypeParameter(newTask, taskSwitch, processRunning, allowTaskSnapshot, activityCreated, samePackage); ...... // 创建启动窗口相关数据 mStartingData = new SplashScreenStartingData(mWmService, pkg, resolvedTheme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags, getMergedOverrideConfiguration(), typeParameter); // 转交给WMS的动画处理线程执行启动窗口的动画 scheduleAddStartingWindow(); return true;&#125;void scheduleAddStartingWindow() &#123; // DEBUG_ENABLE_SHELL_DRAWER是&quot;persist.debug.shell_starting_surface&quot; // 该属性默认为true if (StartingSurfaceController.DEBUG_ENABLE_SHELL_DRAWER) &#123; // 执行启动窗口动画 mAddStartingWindow.run(); &#125; else &#123; // 如果是使用postAtFrontOfQueue，会将该动画放在执行队列最前面执行 if (!mWmService.mAnimationHandler.hasCallbacks(mAddStartingWindow)) &#123; ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Enqueueing ADD_STARTING&quot;); mWmService.mAnimationHandler.postAtFrontOfQueue(mAddStartingWindow); &#125; &#125;&#125; 添加启动窗口的动作有很多，忽略细节，主要是封装该启动窗口的相关数据保存在SplashScreenStartingData中，然后执行启动窗口动画。 如果是转交给WMS的动画处理线程执行启动窗口的动画，而且是将该动画放在执行队列最前面执行。 至于WMS的mAnimationHandler是在类创建时初始化的： 1234567// WMS.javafinal Handler mAnimationHandler = new Handler(AnimationThread.getHandler().getLooper());// AnimationThread.javaprivate AnimationThread() &#123; super(&quot;android.anim&quot;, THREAD_PRIORITY_DISPLAY, false /*allowIo*/);&#125; 所以mAnimationHandler执行所在的线程就是”android.anim”线程。 该ActivityRecord中的mAddStartingWindow也是类初始化时创建的： 123456// ActivityRecord.javaprivate final AddStartingWindow mAddStartingWindow = new AddStartingWindow();private class AddStartingWindow implements Runnable &#123; ......&#125; 二. 启动窗口的动画2.1 AddStartingWindow.run123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic void run() &#123; final StartingData startingData; synchronized (mWmService.mGlobalLock) &#123; ...... if (mStartingData == null) &#123; // 该对象被置null说明启动窗口动画被取消了... ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;startingData was nulled out before handling&quot; + &quot; mAddStartingWindow: %s&quot;, ActivityRecord.this); return; &#125; startingData = mStartingData; &#125; ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Add starting %s: startingData=%s&quot;, this, startingData); WindowManagerPolicy.StartingSurface surface = null; try &#123; // [2.2] 创建启动窗口Surface surface = startingData.createStartingSurface(ActivityRecord.this); &#125; catch (Exception e) &#123; Slog.w(TAG, &quot;Exception when adding starting window&quot;, e); &#125; if (surface != null) &#123; boolean abort = false; synchronized (mWmService.mGlobalLock) &#123; // 如果mStartingData现在被置null了，说明窗口成功创建并被添加了 if (mStartingData == null) &#123; ProtoLog.v(WM_DEBUG_STARTING_WINDOW, &quot;Aborted starting %s: startingData=%s&quot;, ActivityRecord.this, mStartingData); mStartingWindow = null; mStartingData = null; abort = true; &#125; else &#123; // 将创建的启动窗口surface赋值给mStartingSurface mStartingSurface = surface; &#125; ...... &#125; if (abort) &#123; // 如果启动窗口动画中止，则移除该Surface surface.remove(false /* prepareAnimation */); &#125; ......&#125; AddStartingWindow就是一个runnable, 执行的时候先判断当前启动窗口是否仍需要，如果需要就创建启动窗口的Surface，如果启动窗口被中止，则移除创建的Surface. 2.2 StartingData.createStartingSurfaceActivityRecord中的mStartingData就是SplashScreenStartingData类型的对象。SplashScreenStartingData是StartingData的子类。 1234567@OverrideStartingSurface createStartingSurface(ActivityRecord activity) &#123; return mService.mStartingSurfaceController.createSplashScreenStartingSurface( activity, mPkg, mTheme, mCompatInfo, mNonLocalizedLabel, mLabelRes, mIcon, mLogo, mWindowFlags, mMergedOverrideConfiguration, activity.getDisplayContent().getDisplayId());&#125; 通过WMS中的mStartingSurfaceController来创建StartingSurface, mStartingSurfaceController是在WMS初始化的时候创建，用来管理创建和释放启动窗口Surface。 2.3 StartingSurfaceController.createSplashScreenStartingSurface123456789101112131415161718StartingSurface createSplashScreenStartingSurface(ActivityRecord activity, String packageName, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, Configuration overrideConfig, int displayId) &#123; ...... synchronized (mService.mGlobalLock) &#123; // 这里的task是ActivityRecord中新创建的task final Task task = activity.getTask(); // 注意activity.token其实就是ActivityRecord.Token， 在ActivityRecord初始化时有分析，作为该ActivityRecord本身 // [2.4] mTaskOrganizerController.addStartingWindow if (task != null &amp;&amp; mService.mAtmService.mTaskOrganizerController.addStartingWindow( task, activity.token, theme, null /* taskSnapshot */)) &#123; // 最终创建的Surface是ShellStartingSurface. return new ShellStartingSurface(task); &#125; &#125; return null;&#125; 最终创建的Surface是ShellStartingSurface. 2.4 TaskOrganizerController.addStartingWindow123456789101112131415161718192021222324252627282930313233343536boolean addStartingWindow(Task task, IBinder appToken, int launchTheme, TaskSnapshot taskSnapshot) &#123; final Task rootTask = task.getRootTask(); if (rootTask == null || rootTask.mTaskOrganizer == null) &#123; return false; &#125; final TaskOrganizerState state = mTaskOrganizerStates.get(rootTask.mTaskOrganizer.asBinder()); // 通过TaskOrganizerState执行添加动作 state.addStartingWindow(task, appToken, launchTheme, taskSnapshot); return true;&#125;// TaskOrganizerStateprivate final TaskOrganizerCallbacks mOrganizer;void addStartingWindow(Task t, IBinder appToken, int launchTheme, TaskSnapshot taskSnapshot) &#123; mOrganizer.addStartingWindow(t, appToken, launchTheme, taskSnapshot);&#125;// TaskOrganizerCallbacksfinal ITaskOrganizer mTaskOrganizer;void addStartingWindow(Task task, IBinder appToken, int launchTheme, TaskSnapshot taskSnapshot) &#123; final StartingWindowInfo info = task.getStartingWindowInfo(); if (launchTheme != 0) &#123; info.splashScreenThemeResId = launchTheme; &#125; info.mTaskSnapshot = taskSnapshot; try &#123; // 交给ITaskOrganizer执行，appToken就是ActivityRecord.token, 即ActivityRecord.Token类的对象 mTaskOrganizer.addStartingWindow(info, appToken); &#125; catch (RemoteException e) &#123; Slog.e(TAG, &quot;Exception sending onTaskStart callback&quot;, e); &#125;&#125; 这里有点绕，我们看看mTaskOrganizer是什么,看看TaskOrganizerCallbacks和TaskOrganizerState的初始化可以知道： 123456789101112131415161718192021TaskOrganizerCallbacks(ITaskOrganizer taskOrg, Consumer&lt;Runnable&gt; deferTaskOrgCallbacksConsumer) &#123; mDeferTaskOrgCallbacksConsumer = deferTaskOrgCallbacksConsumer; // mTaskOrganizer是该类对象初始化时传入的ITaskOrganizer mTaskOrganizer = taskOrg;&#125;TaskOrganizerState(ITaskOrganizer organizer, int uid) &#123; final Consumer&lt;Runnable&gt; deferTaskOrgCallbacksConsumer = mDeferTaskOrgCallbacksConsumer != null ? mDeferTaskOrgCallbacksConsumer : mService.mWindowManager.mAnimator::addAfterPrepareSurfacesRunnable; mOrganizer = new TaskOrganizerCallbacks(organizer, deferTaskOrgCallbacksConsumer); mDeathRecipient = new DeathRecipient(organizer); try &#123; organizer.asBinder().linkToDeath(mDeathRecipient, 0); &#125; catch (RemoteException e) &#123; Slog.e(TAG, &quot;TaskOrganizer failed to register death recipient&quot;); &#125; mUid = uid;&#125; 所以mTaskOrganizer还是TaskOrganizerState初始化时传入的。那么TaskOrganizerState是怎么初始化的： 12345678910111213141516// TaskOrganizerController.java#121@Overridepublic ParceledListSlice&lt;TaskAppearedInfo&gt; registerTaskOrganizer(ITaskOrganizer organizer) &#123; ...... try &#123; synchronized (mGlobalLock) &#123; ...... if (!mTaskOrganizerStates.containsKey(organizer.asBinder())) &#123; mTaskOrganizers.add(organizer); mTaskOrganizerStates.put(organizer.asBinder(), new TaskOrganizerState(organizer, uid)); &#125; ....... ...... ......&#125; 所以是有其他进程调用了TaskOrganizerController的registerTaskOrganizer将该成员注册了，而这里的方法仅有TaskOrganizer.java#72调用： 1234567891011121314151617181920212223@RequiresPermission(android.Manifest.permission.MANAGE_ACTIVITY_TASKS)@CallSuper@NonNullpublic List&lt;TaskAppearedInfo&gt; registerOrganizer() &#123; try &#123; return mTaskOrganizerController.registerTaskOrganizer(mInterface).getList(); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;private final ITaskOrganizer mInterface = new ITaskOrganizer.Stub() &#123; @Override public void addStartingWindow(StartingWindowInfo windowInfo, IBinder appToken) &#123; mExecutor.execute(() -&gt; TaskOrganizer.this.addStartingWindow(windowInfo, appToken)); &#125; ......&#125;@BinderThreadpublic void addStartingWindow(@NonNull StartingWindowInfo info, @NonNull IBinder appToken) &#123;&#125; 所以这个是将启动窗口的信息通过binder调用，添加到实现TaskOrganizer的addStartingWindow方法的其他进程了，并非是系统进程管控。 总的来说AddStartingWindow.run这个就是做了两件事： 创建启动窗口Surface， 即ShellStartingSurface 将启动窗口信息通过binder调用传递给实现TaskOrganizer的进程 这里的流程和R的差异有点大，推测是Google希望启动窗口可以交给Launcher或者SystemUI实现，而不是由framework的system_server进程来管控。 搜索SystemUI源码可以发现，继承TaskOrganizer的类有一个：ShellTaskOrganizer! 2.5 ShellTaskOrganizer.addStartingWindow123456@Overridepublic void addStartingWindow(StartingWindowInfo info, IBinder appToken) &#123; if (mStartingWindow != null) &#123; mStartingWindow.addStartingWindow(info, appToken); &#125;&#125; 看来Google还真是将启动窗口交给SystemUI模块了。 三. SystemUI负责的启动窗口上面我们知道一个Activity启动后，从App进程交给SystemServer处理，在创建该Activity的ActivityRecord, 并将其保存在对应的Task之后，会在需要的时候开始启动窗口的播放。 启动窗口在Android S上是交给SystemUI进程负责了，在以前是交给SystemServer的“android.anim”线程处理。 关于R上SystemUI的ShellTaskOrganizer这一块涉及到Dagger2, 是一款基于 Java 注解来实现的在编译阶段完成依赖注入的开源库的使用，这里先不展开讲了，感兴趣的可以自行研究。 ShellTaskOrganizer中的mStartingWindow是StartingWindowController类对象。 3.1 StartingWindowController.addStartingWindow123456789101112131415161718192021222324252627public void addStartingWindow(StartingWindowInfo windowInfo, IBinder appToken) &#123; mSplashScreenExecutor.execute(() -&gt; &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;addStartingWindow&quot;); final int suggestionType = mStartingWindowTypeAlgorithm.getSuggestedWindowType( windowInfo); final RunningTaskInfo runningTaskInfo = windowInfo.taskInfo; if (mTaskLaunchingCallback != null &amp;&amp; shouldSendToListener(suggestionType)) &#123; mTaskLaunchingCallback.accept(runningTaskInfo.taskId, suggestionType); &#125; if (suggestionType == STARTING_WINDOW_TYPE_SPLASH_SCREEN) &#123; mStartingSurfaceDrawer.addSplashScreenStartingWindow(windowInfo, appToken, false /* emptyView */); &#125; else if (suggestionType == STARTING_WINDOW_TYPE_EMPTY_SPLASH_SCREEN) &#123; mStartingSurfaceDrawer.addSplashScreenStartingWindow(windowInfo, appToken, true /* emptyView */); &#125; else if (suggestionType == STARTING_WINDOW_TYPE_SNAPSHOT) &#123; final TaskSnapshot snapshot = windowInfo.mTaskSnapshot; mStartingSurfaceDrawer.makeTaskSnapshotWindow(windowInfo, appToken, snapshot); &#125; else /* suggestionType == STARTING_WINDOW_TYPE_NONE */ &#123; // Don&#x27;t add a staring window. &#125; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125;);&#125; 根据启动窗口类型选择不同的启动窗口，这里我们假设是STARTING_WINDOW_TYPE_SPLASH_SCREEN类型。 3.2 StartingSurfaceDrawer.addSplashScreenStartingWindow12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void addSplashScreenStartingWindow(StartingWindowInfo windowInfo, IBinder appToken, boolean emptyView) &#123; final RunningTaskInfo taskInfo = windowInfo.taskInfo; final ActivityInfo activityInfo = taskInfo.topActivityInfo; ...... Context context = mContext; ...... // 获取启动窗口显示view的资源id final int[] splashscreenContentResId = new int[1]; // 这里的R是 &quot;import com.android.internal.R;&quot; 说明是framework/res中的资源 getWindowResFromContext(context, a -&gt; &#123; splashscreenContentResId[0] = a.getResourceId(R.styleable.Window_windowSplashscreenContent, 0); showWallpaper[0] = a.getBoolean(R.styleable.Window_windowShowWallpaper, false); &#125;); ...... final PhoneWindow win = new PhoneWindow(context); win.setIsStartingWindow(true); ...... win.setType(WindowManager.LayoutParams.TYPE_APPLICATION_STARTING); ...... win.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT); final WindowManager.LayoutParams params = win.getAttributes(); // 这里的appToken就是一路传递过来的待启动的activity的appToken,即ActivityRecord.Token类的对象 params.token = appToken; params.packageName = activityInfo.packageName; ...... params.setTitle(&quot;Splash Screen &quot; + activityInfo.packageName); final SplashScreenViewSupplier viewSupplier = new SplashScreenViewSupplier(); final Runnable setViewSynchronized = () -&gt; &#123; // 获取启动窗口的ContentView // SplashScreenViewSupplier.get必须要等待其被调用setView之后才会返回，否则会阻塞等待 SplashScreenView contentView = viewSupplier.get(); ...... // 设置启动窗口View内容 win.setContentView(contentView); contentView.cacheRootWindow(win); ...... &#125; // [3.3] 创建启动窗口对应的View mSplashscreenContentDrawer.createContentView(context, emptyView, splashscreenContentResId[0], activityInfo, taskId, viewSupplier::setView); ...... final View view = win.getDecorView(); final WindowManager wm = mContext.getSystemService(WindowManager.class); // 将启动窗口的View添加进WMS,创建对应的WindowState postAddWindow(taskId, appToken, view, wm, params); // 请求Vsync,下一帧时调用setViewSynchronized，设置启动窗口View内容 mChoreographer.postCallback(CALLBACK_INSETS_ANIMATION, setViewSynchronized, null);&#125;protected void postAddWindow(int taskId, IBinder appToken, View view, WindowManager wm, WindowManager.LayoutParams params) &#123; ...... // WMS用来创建启动窗口对应的WindowState // 注意LayoutParams中的token是待启动的activity的appToken,即ActivityRecord.Token类的对象 wm.addView(view, params); ......&#125; 这里创建启动窗口对应的PhoneWindow以及设置相关的参数，并将启动窗口的DecorView和窗口属性通过binder传给WMS用来创建对应的WindowState，最后通过Choreographer请求vsync，在下一帧的时候设置该启动窗口的内容。 3.3 SplashscreenContentDrawer.createContentView1234567891011121314151617181920212223242526272829void createContentView(Context context, boolean emptyView, int splashScreenResId, ActivityInfo info, int taskId, Consumer&lt;SplashScreenView&gt; consumer) &#123; mSplashscreenWorkerHandler.post(() -&gt; &#123; SplashScreenView contentView; try &#123; // [3.3.1] 制作启动窗口显示的view contentView = SplashscreenContentDrawer.makeSplashscreenContent( context, splashScreenResId); // Android S之后这个一般都是null的 if (contentView == null) &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;makeSplashScreenContentView&quot;); // emptyView是false的 if (emptyView) &#123; contentView = makeEmptySplashScreenContentView(context); &#125; else &#123; // [3.3.2] 最后启动窗口的contentView是在这里创建的 contentView = makeSplashScreenContentView(context, info); &#125; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; &#125; catch (RuntimeException e) &#123; Slog.w(TAG, &quot;failed creating starting window content at taskId: &quot; + taskId, e); contentView = null; &#125; // [3.4] consumer是传入的viewSupplier::setView consumer.accept(contentView); &#125;);&#125; 这里是创建启动窗口显示的内容，首先通过SplashscreenContentDrawer创建SplashScreenView. 3.3.1 SplashscreenContentDrawer.makeSplashscreenContent12345678910private static SplashScreenView makeSplashscreenContent(Context ctx, int splashscreenContentResId) &#123; // 获取当前systemui的sdk版本 final int targetSdkVersion = ctx.getApplicationInfo().targetSdkVersion; // Andriod S之后不支持Window_SplashscreenContent了 if (targetSdkVersion &gt;= Build.VERSION_CODES.S) &#123; return null; &#125; ......&#125; Andriod S之后不支持Window_windowSplashscreenContent了. 3.3.2 SplashscreenContentDrawer.makeSplashScreenContentView1234567891011121314151617181920212223242526272829303132private SplashScreenView makeSplashScreenContentView(Context context, ActivityInfo ai) &#123; // 重置View相关配置 updateDensity(); // 重置窗口相关属性至mTmpAttrs中保存 getWindowAttrs(context, mTmpAttrs); final StartingWindowViewBuilder builder = new StartingWindowViewBuilder(); final int animationDuration; Drawable iconDrawable; // mReplaceIcon默认是R.styleable.Window_windowSplashScreenAnimatedIcon if (mTmpAttrs.mReplaceIcon != null) &#123; iconDrawable = mTmpAttrs.mReplaceIcon; animationDuration = Math.max(0, Math.min(mTmpAttrs.mAnimationDuration, mMaxAnimatableIconDuration)); &#125; else &#123; iconDrawable = mIconProvider.getIconForUI( ai, getUserHandleForUid(ai.applicationInfo.uid)); if (iconDrawable == null) &#123; iconDrawable = context.getPackageManager().getDefaultActivityIcon(); &#125; animationDuration = 0; &#125; // 选择启动窗口背景颜色 final int themeBGColor = peekWindowBGColor(context); // [3.3.3] 创建SplashScreenView return builder .setContext(context) .setWindowBGColor(themeBGColor) .setIconDrawable(iconDrawable) .setIconAnimationDuration(animationDuration) .setBrandingDrawable(mTmpAttrs.mBrandingImage) .setIconBackground(mTmpAttrs.mIconBgColor).build();&#125; 这里首先重置相关配置属性，然后根据默认配置创建SplashScreenView。 3.3.3 StartingWindowViewBuilder.build123456789101112131415SplashScreenView build() &#123; ...... // mIconDrawable必须不为空且是AdaptiveIconDrawable的实例 if (!processAdaptiveIcon() &amp;&amp; mIconDrawable != null) &#123; if (DEBUG) &#123; Slog.d(TAG, &quot;The icon is not an AdaptiveIconDrawable&quot;); &#125; createIconDrawable(mIconDrawable, mIconSize); &#125; final int iconSize = mFinalIconDrawable != null ? (int) (mIconSize * mScale) : 0; // 填充SplashScreenView内容 mCachedResult = fillViewWithIcon(mContext, iconSize, mFinalIconDrawable); mBuildComplete = true; return mCachedResult;&#125; 这里也仅仅是检查了下mIconDrawable是否为AdaptiveIconDrawable的实例，如果不是则重新创建一个。然后使用fillViewWithIcon填充内容，创建SplashScreenView. 3.3.4 StartingWindowViewBuilder.fillViewWithIcon1234567891011121314151617181920212223private SplashScreenView fillViewWithIcon(Context context, int iconSize, Drawable iconDrawable) &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;fillViewWithIcon&quot;); final SplashScreenView.Builder builder = new SplashScreenView.Builder(context); builder.setIconSize(iconSize).setBackgroundColor(mThemeColor) .setIconBackground(mIconBackground); if (iconDrawable != null) &#123; builder.setCenterViewDrawable(iconDrawable); &#125; builder.setAnimationDurationMillis(mIconAnimationDuration); if (mBrandingDrawable != null) &#123; builder.setBrandingDrawable(mBrandingDrawable, mBrandingImageWidth, mBrandingImageHeight); &#125; // 3.3.5 实例化SplashScreenView final SplashScreenView splashScreenView = builder.build(); if (DEBUG) &#123; Slog.d(TAG, &quot;fillViewWithIcon surfaceWindowView &quot; + splashScreenView); &#125; splashScreenView.makeSystemUIColorsTransparent(); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); return splashScreenView;&#125; 设置待创建的SplashScreenView相关的内容，如主题颜色、图标背景色、图标动画时长、三方应用的图标等等，然后通过build构建SplashScreenView. 3.3.5 SplashScreenView.Builder.build12345678910111213141516171819202122232425public SplashScreenView build() &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;SplashScreenView#build&quot;); final LayoutInflater layoutInflater = LayoutInflater.from(mContext); final SplashScreenView view = (SplashScreenView) layoutInflater.inflate(R.layout.splash_screen_view, null, false); ...... view.mIconView = view.findViewById(R.id.splashscreen_icon_view); view.mBrandingImageView = view.findViewById(R.id.splashscreen_branding_view); ...... // 设置icon图像 if (mIconDrawable != null) &#123; view.mIconView.setBackground(mIconDrawable); view.initIconAnimation(mIconDrawable, mIconAnimationDuration != null ? mIconAnimationDuration.toMillis() : 0); &#125; ...... // 设置brand图像 if (mBrandingImageHeight &gt; 0 &amp;&amp; mBrandingImageWidth &gt; 0 &amp;&amp; mBrandingDrawable != null) &#123; ...... view.mBrandingImageView.setBackground(mBrandingDrawable); &#125; ...... Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); return view;&#125; SplashScreenView是继承FrameLayout的，通过LayoutInflater实例化splash_screen_view作为其内容布局: 1234567891011121314151617181920&lt;android.window.SplashScreenView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;View android:id=&quot;@+id/splashscreen_icon_view&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:contentDescription=&quot;@string/splash_screen_view_icon_description&quot;/&gt; &lt;View android:id=&quot;@+id/splashscreen_branding_view&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal|bottom&quot; android:layout_marginBottom=&quot;60dp&quot; android:contentDescription=&quot;@string/splash_screen_view_branding_description&quot;/&gt;&lt;/android.window.SplashScreenView&gt; 这个非常简单，就是两个View, 所以说启动窗口的显示内容就是两个图标（如果有图标对应的image不为null,则会显示）。 3.4 SplashScreenViewSupplier.setView12345678910111213141516171819202122232425private static class SplashScreenViewSupplier implements Supplier&lt;SplashScreenView&gt; &#123; private SplashScreenView mView; private boolean mIsViewSet; void setView(SplashScreenView view) &#123; synchronized (this) &#123; // 保存SplashScreenView并通知其他线程继续执行get mView = view; mIsViewSet = true; notify(); &#125; &#125; @Override public @Nullable SplashScreenView get() &#123; synchronized (this) &#123; while (!mIsViewSet) &#123; try &#123; wait(); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; return mView; &#125; &#125;&#125; 这个类的主要作用就是将SplashScreenView的创建交给与使用线程不同的线程。 四.小结来一张流程图回顾下启动窗口被添加的过程: 虽然启动窗口对应的View和内容是通过SystemUI创建的，但是其还是被WMS归属为待启动的Activity的Task中的一员。究其原因还是其窗口属性中的token是该Activity对应的ActivityRecord.Token。SystemUI创建启动窗口的内容后，会在下一帧来时将该View添加到WMS中，然后WMS就会在addWindow里创建对应的WindowState。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"}]},{"title":"WMS(4)-WindowState创建及移除","slug":"WMS(4)-WindowState创建及移除","date":"2022-05-03T17:35:34.000Z","updated":"2022-06-18T09:57:00.562Z","comments":true,"path":"2022/05/04/WMS(4)-WindowState创建及移除/","link":"","permalink":"https://swallowjoe.github.io/2022/05/04/WMS(4)-WindowState%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%A7%BB%E9%99%A4/","excerpt":"以下分析基于Android S. 简述之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState：","text":"以下分析基于Android S. 简述之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState： 12345678910111213141516171819202122232425262728public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility, int displayId, int requestUserId, InsetsState requestedVisibility, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; ...... // 窗口类型保存在LayoutParams中 final int type = attrs.type; synchronized (mGlobalLock) &#123; ...... // 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord! WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); ... // [1.1] 初始化WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); ...... // [1.2] 创建SurfaceSession, 用来和SurfaceFlinger通信 win.attach(); // 保存WindowState, key为ViewRoomImpl.W mWindowMap.put(client.asBinder(), win); ...... // 将该WindowState保存在其mToken(ActivityRecord)中 win.mToken.addWindow(win); ...... ......&#125; 一. WindowStateWindowState，顾名思义是用于保存窗口状态的类，WindowToke是用于标记窗口身份、对应哪个进程的Activity的类。 1.1 WindowState的初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token, WindowState parentWindow, int appOp, WindowManager.LayoutParams a, int viewVisibility, int ownerId, int showUserId, boolean ownerCanAddInternalSystemWindow, PowerManagerWrapper powerManagerWrapper) &#123; super(service); // 创建Transaction，用于和SurfaceFlinger通信 // mTransactionFactory是实现了Supplier接口的SurfaceControl.Transaction::new mTmpTransaction = service.mTransactionFactory.get(); // mSession就是ViewRootImpl对应的mWindowSession mSession = s; // mClinet就是ViewRootImpl中的mWindow(即W类的对象) mClient = c; mAppOp = appOp; // mToken即WindowToke,也就是该WindowState对应的ActivityRecord mToken = token; mActivityRecord = mToken.asActivityRecord(); mOwnerUid = ownerId; mShowUserId = showUserId; mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow; // 创建WindowId mWindowId = new WindowId(this); // 保存该Activity的View对应的窗口属性 mAttrs.copyFrom(a); mLastSurfaceInsets.set(mAttrs.surfaceInsets); mViewVisibility = viewVisibility; // mPolicy就是PhoneWindowPolicy mPolicy = mWmService.mPolicy; mContext = mWmService.mContext; // 创建WindowState所处进程的死亡监听 DeathRecipient deathRecipient = new DeathRecipient(); ...... // 创建InputApplicationHandle, 将该Window注册进Input系统，以便后续input事件传输 mInputWindowHandle = new InputWindowHandleWrapper(new InputWindowHandle( mActivityRecord != null ? mActivityRecord.getInputApplicationHandle(false /* update */) : null, getDisplayId())); ...... // IWindow(ViewRootImpl.W) 建立binder死亡监听 c.asBinder().linkToDeath(deathRecipient, 0); ...... // 当前 Window type仍旧是TYPE_BASE_APPLICATION if (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123; ...... &#125; else &#123; // 将baseLayer设置为window类型对应的layer * TYPE_LAYER_MULTIPLIER 再加上一段偏移 // 即 baseLayer = windowLayer * 10000 + 1000; mBaseLayer = mPolicy.getWindowLayerLw(this) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET; mSubLayer = 0; mIsChildWindow = false; mLayoutAttached = false; mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD || mAttrs.type == TYPE_INPUT_METHOD_DIALOG; mIsWallpaper = mAttrs.type == TYPE_WALLPAPER; &#125; // 如果是输入法或者壁纸窗口，则标记为floating layer. mIsFloatingLayer = mIsImWindow || mIsWallpaper; if (mActivityRecord != null &amp;&amp; mActivityRecord.mShowForAllUsers) &#123; // 标记可以为所有用户显示的应用窗口可以在锁屏时显示 mAttrs.flags |= FLAG_SHOW_WHEN_LOCKED; &#125; // 创建WindowAnimator，用于实现该窗口的动画 mWinAnimator = new WindowStateAnimator(this); ...... // 非系统进程会有WPC来响应管理该窗口所属进程状态变化 mWpcForDisplayAreaConfigChanges = (s.mPid == MY_PID || s.mPid &lt; 0) ? null : service.mAtmService.getProcessController(s.mPid, s.mUid);&#125; 初始化WindowState的过程并不复杂： 调用SurfaceControl.Transaction::new创建mTmpTransaction 保存来自应用ViewRootImpl中的mWindowSession、mWindow等 保存该WindowState对应window的ActivityRecord 创建WindowId 保存该Activity的View对应的窗口属性 创建InputApplicationHandle，即将该Window注册进Input系统，以便后续input事件传输 建立binder死亡监听,处理该WindowState所属应用进程死亡后资源处理 计算mBaseLayer，mBaseLayer &#x3D; windowLayer(2) * 10000 + 1000; 标记mIsChildWindow、mIsImWindow（输入法窗口）、mIsWallpaper（壁纸窗口） 创建WindowAnimator，用于实现该窗口的动画 获取该pid对应的WindowProcessController 这里关于input相关的流程我们后续分析。 1.2 WindowState.attach1234void attach() &#123; if (DEBUG) Slog.v(TAG, &quot;Attaching &quot; + this + &quot; token=&quot; + mToken); mSession.windowAddedLocked();&#125; 很简单的，直接交给mSession处理。 1.2.1 Session.windowAddedLocked12345678910111213141516171819void windowAddedLocked() &#123; ...... // 第一次进入则需要创建mSurfaceSession if (mSurfaceSession == null) &#123; if (DEBUG) &#123; Slog.v(TAG_WM, &quot;First window added to &quot; + this + &quot;, creating SurfaceSession&quot;); &#125; // 创建SurfaceSession mSurfaceSession = new SurfaceSession(); ProtoLog.i(WM_SHOW_TRANSACTIONS, &quot; NEW SURFACE SESSION %s&quot;, mSurfaceSession); // 新创建的SurfaceSession后，将此Session保存至WMS中的mSessions集合中 mService.mSessions.add(this); if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123; mService.dispatchNewAnimatorScaleLocked(this); &#125; &#125; // 标记窗口数量增一 mNumWindow++;&#125; SurfaceSession是用于和SurfaceFlinger通信的，因为Session是单个进程只会持有一个，所以创建SurfaceSession也只会初始化一次。 创建Session的过程：WindowManagerGlobal.getWindowSession 12345678910111213&gt;&gt;// WindowManagerGlobal.getWindowSession&gt;&gt;public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; // 单个进程仅会创建一次 if (sWindowSession == null) &#123; try &#123; ...... sWindowSession = windowManager.openSession( ...... &#125; return sWindowSession; &#125;&gt;&gt;&#125; 1.2.2 创建SurfaceSession123456private static native long nativeCreate();public SurfaceSession() &#123; // 通过JNI创建 mNativeClient = nativeCreate();&#125; 这里直接通过JNI创建对应native层对象，关于JNI后续单独出文章分析，有一个最简单的法则： SurfaceSession所处的包是 “android.view”, 所以对应JNI文件就是:android_view_SurfaceSession.cpp 1.2.3 android_view_SurfaceSession.cpp:nativeCreate1234567static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123; // 对应创建的是SurfaceComposerClient SurfaceComposerClient* client = new SurfaceComposerClient(); // 对象引用计数加一 client-&gt;incStrong((void*)nativeCreate); return reinterpret_cast&lt;jlong&gt;(client);&#125; SurfaceSession对应的native层对象就是SurfaceComposerClient！ 1.2.4 创建SurfaceComposerClient1234SurfaceComposerClient::SurfaceComposerClient() : mStatus(NO_INIT)&#123;&#125; 标记mStatus为NO_INIT，尚未初始化。 回过头看WindowState.attach，这个方法其实就是创建mSurfaceSession并将其保存在WMS.mSessions集合中。而SurfaceSession其实就是对native层SurfaceComposerClient的包装。 1.3 WindowState所属应用进程死亡12345678910111213141516171819202122232425262728public void binderDied() &#123; try &#123; boolean resetSplitScreenResizing = false; synchronized (mWmService.mGlobalLock) &#123; // [1.3.1] 获取WindowState final WindowState win = mWmService .windowForClientLocked(mSession, mClient, false); Slog.i(TAG, &quot;WIN DEATH: &quot; + win); // 当WindowState尚未被移除时 if (win != null) &#123; final DisplayContent dc = getDisplayContent(); // 如果该WindowState是对应Activity的，且WindowState的mChildren中类型为TYPE_BASE_APPLICATION的WindowState // 就是保存在WMS中的WindowState if (win.mActivityRecord != null &amp;&amp; win.mActivityRecord.findMainWindow() == win) &#123; mWmService.mTaskSnapshotController.onAppDied(win.mActivityRecord); &#125; // [1.3.2] 移除该WindowState win.removeIfPossible(shouldKeepVisibleDeadAppWindow()); &#125; else if (mHasSurface) &#123; Slog.e(TAG, &quot;!!! LEAK !!! Window removed but surface still valid.&quot;); WindowState.this.removeIfPossible(); &#125; &#125; ....... &#125; catch (IllegalArgumentException ex) &#123; // This will happen if the window has already been removed. &#125;&#125; 1.3.1 WMS.windowForClientLocked123456789101112131415161718final WindowState windowForClientLocked(Session session, IWindow client, boolean throwOnError) &#123; return windowForClientLocked(session, client.asBinder(), throwOnError);&#125;final WindowState windowForClientLocked(Session session, IBinder client, boolean throwOnError) &#123; WindowState win = mWindowMap.get(client); if (DEBUG) Slog.v(TAG_WM, &quot;Looking up client &quot; + client + &quot;: &quot; + win); if (win == null) &#123; ...... return null; &#125; if (session != null &amp;&amp; win.mSession != session) &#123; ...... return null; &#125; return win;&#125; 从WMS的mWindowMap中查找client(ViewRootImpl.W)对应的WindowState, 这个是在addWindow时保存的。 1.3.2 WindowState.removeIfPossible1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overridevoid removeIfPossible() &#123; // WindowState是WindowContainer的子类，这里是对mChilder中的每一个WindowContainer执行removeIfPossible super.removeIfPossible(); removeIfPossible(false /*keepVisibleDeadWindow*/);&#125;private void removeIfPossible(boolean keepVisibleDeadWindow) &#123; // 标记该WindowState是被移除的 mWindowRemovalAllowed = true; // 应用启动窗口？ final boolean startingWindow = mAttrs.type == TYPE_APPLICATION_STARTING; ...... try &#123; // 将该WindowState从Input系统中移除 disposeInputChannel(); ...... // 标记待移除窗口的可见性 boolean wasVisible = false; // 首先确认是否需要运行动画。如果需要，必须推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。 if (mHasSurface &amp;&amp; mToken.okToAnimate()) &#123; // 该窗口将被替换，只需要标记相关状态，等待被替换完成即可。 if (mWillReplaceWindow) &#123; ...... mAnimatingExit = true; mReplacingRemoveRequested = true; return; &#125; // 记录待移除的窗口是否可见 wasVisible = isWinVisibleLw(); ...... // 如果是可见的，需要创建一个窗口退出动画 if (wasVisible) &#123; final int transit = (!startingWindow) ? TRANSIT_EXIT : TRANSIT_PREVIEW_DONE; if (mWinAnimator.applyAnimationLocked(transit, false)) &#123; mAnimatingExit = true; // 请求vsync进行动画 setDisplayLayoutNeeded(); mWmService.requestTraversal(); &#125; ...... &#125; ...... &#125; // [1.3.2.1] 将此WindowState移除 removeImmediately(); // 移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数 if (wasVisible) &#123; final DisplayContent displayContent = getDisplayContent(); if (displayContent.updateOrientation()) &#123; displayContent.sendNewConfiguration(); &#125; &#125; // 移除窗口后，计算更新焦点窗口 mWmService.updateFocusedWindowLocked(isFocused() ? UPDATE_FOCUS_REMOVING_FOCUS : UPDATE_FOCUS_NORMAL, true /*updateInputWindows*/); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 窗口所属进程死亡后，需要清理该窗口的WindowState: 标记该WindowState是被移除的,mWindowRemovalAllowed置为true 将该WindowState从Input系统中移除 确认是否需要运行动画。如果需要，推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。 如果是可见的，需要创建并执行一个窗口退出动画 将此WindowState移除 移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数 更新焦点窗口 1.3.2.1 WindowState.removeImmediately - 移除WindowState123456789101112131415161718192021222324@Overridevoid removeImmediately() &#123; // 对所有mChildren执行清理动作 super.removeImmediately(); ...... final DisplayContent dc = getDisplayContent(); ..... // 将该Window的窗口属性从DisplayContent中移除 dc.getDisplayPolicy().removeWindowLw(this); disposeInputChannel(); // 移除窗口的Surface mWinAnimator.destroySurfaceLocked(mTmpTransaction); mTmpTransaction.apply(); // 将此窗口WindowState从Session中移除 mSession.windowRemovedLocked(); try &#123; // 解除binder死亡监听 mClient.asBinder().unlinkToDeath(mDeathRecipient, 0); &#125; catch (RuntimeException e) &#123; &#125; // 执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制 mWmService.postWindowRemoveCleanupLocked(this);&#125; 移除WindowState会执行: 对所有mChildren执行清理动作 将该WindowState的窗口属性从DisplayContent中移除 移除窗口的Surface 将此窗口WindowState从Session中移除 Session中窗口数目减一 如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用 否则将此Session从WMS.mSessions集合中移除 如果存在mSurfaceSession，则同步清理，清理时将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉 执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制 1.3.2.2 Session.windowRemovedLocked12345678910111213141516171819202122232425262728293031void windowRemovedLocked() &#123; // 窗口数目减一 mNumWindow--; killSessionLocked();&#125;private void killSessionLocked() &#123; // 如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用 if (mNumWindow &gt; 0 || !mClientDead) &#123; return; &#125; // 将此Session从WMS.mSessions集合中移除 mService.mSessions.remove(this); // 如果存在mSurfaceSession，则同步清理 if (mSurfaceSession == null) &#123; return; &#125; ...... try &#123; // 不用怀疑，肯定是需要进入native层执行清理动作 mSurfaceSession.kill(); &#125; catch (Exception e) &#123; Slog.w(TAG_WM, &quot;Exception thrown when killing surface session &quot; + mSurfaceSession + &quot; in session &quot; + this + &quot;: &quot; + e.toString()); &#125; mSurfaceSession = null; mAlertWindowSurfaces.clear(); mAppOverlaySurfaces.clear(); setHasOverlayUi(false); cancelAlertWindowNotification();&#125; 1.3.2.3 SurfaceSession.kill - 清理SurfaceSession123456public void kill() &#123; if (mNativeClient != 0) &#123; nativeDestroy(mNativeClient); mNativeClient = 0; &#125;&#125; 执行native清理动作，将mNativeClient置为0. 1234static void nativeDestroy(JNIEnv* env, jclass clazz, jlong ptr) &#123; SurfaceComposerClient* client = reinterpret_cast&lt;SurfaceComposerClient*&gt;(ptr); client-&gt;decStrong((void*)nativeCreate);&#125; native层的清理动作也很简单，将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉即可。 二. 小结回顾下本文涉及类的类图： 之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState: 初始化WindowState 调用SurfaceControl.Transaction::new创建mTmpTransaction 保存来自应用ViewRootImpl中的mWindowSession、mWindow等 保存该WindowState对应window的ActivityRecord 创建WindowId 保存该Activity的View对应的窗口属性 创建InputApplicationHandle，即将该Window注册进Input系统，以便后续input事件传输 建立binder死亡监听,处理该WindowState所属应用进程死亡后资源处理 计算mBaseLayer，mBaseLayer &#x3D; windowLayer(2) * 10000 + 1000; 标记mIsChildWindow、mIsImWindow（输入法窗口）、mIsWallpaper（壁纸窗口） 创建WindowAnimator，用于实现该窗口的动画 获取该pid对应的WindowProcessController WindowState.attach, 创建SurfaceSession SurfaceSession是用于和SurfaceFlinger通信的，因为Session是单个进程只会持有一个，所以创建SurfaceSession也只会初始化一次。 创建SurfaceSession就是创建其对应native层的对象SurfaceComposerClient, 将其mStatus标记为NO_INIT，尚未初始化 保存WindowState至WMS.mTokenMap中, key为ViewRoomImpl.W 将该WindowState保存在其mToken(ActivityRecord的mChildren)中 当WindowState对应的进程死亡时，执行相关清理动作: 标记该WindowState是被移除的,mWindowRemovalAllowed置为true 将该WindowState从Input系统中移除 确认是否需要运行动画。如果需要，推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。 如果是可见的，需要创建并执行一个窗口退出动画 将此WindowState移除 对其所有mChildren执行清理动作 将该WindowState的窗口属性从DisplayContent中移除 移除窗口的Surface 将此窗口WindowState从Session中移除 Session中窗口数目减一 如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用 否则将此Session从WMS.mSessions集合中移除 如果存在mSurfaceSession，则同步清理，清理时将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉 执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制 移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数 更新焦点窗口 这里我们注意到WindowState被销毁时会存在一个窗口动画，那么当WindowState的窗口创建时应该也存在一个窗口动画，对应的应该是我们在WindowState被销毁时的TYPE_APPLICATION_STARTING类型窗口（因为Activity对应窗口尚未创建完毕，那么窗口启动动画应该在另一个准备完毕的窗口执行才行）。 下一篇文章我们就探秘一下应用启动窗口动画。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"}]},{"title":"WMS(3)-ActivityRecord和WindowToken.md","slug":"WMS(3)-ActivityRecord和WindowToken","date":"2022-05-02T17:35:34.000Z","updated":"2022-06-18T09:56:56.980Z","comments":true,"path":"2022/05/03/WMS(3)-ActivityRecord和WindowToken/","link":"","permalink":"https://swallowjoe.github.io/2022/05/03/WMS(3)-ActivityRecord%E5%92%8CWindowToken/","excerpt":"以下分析基于Android S. 简述上文中我们知道Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。 在Activity的Window被添加至WMS中，我们仅仅分析了一半，然后重点区分析了DisplayContent的构建，了解了其层次结构器的创建过程以及layer的个数和Window类型对应的layer。现在我们接着看WindowToken的创建，上文中留有一个疑问：","text":"以下分析基于Android S. 简述上文中我们知道Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。 在Activity的Window被添加至WMS中，我们仅仅分析了一半，然后重点区分析了DisplayContent的构建，了解了其层次结构器的创建过程以及layer的个数和Window类型对应的layer。现在我们接着看WindowToken的创建，上文中留有一个疑问： 1234567891011121314DisplayArea.Tokens findAreaForToken(int windowType, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123; // 获取window类型对应的layer，getWindowLayerFromTypeLw看[Window类型转Layer](#222-windowmanagerpolicygetwindowlayerfromtypelw)。 // 一般应用的window类型是 TYPE_BASE_APPLICATION （值为1，handleResumeActivity中赋值的） // 所以windowLayerFromType就是APPLICATION_LAYER！ int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType, ownerCanManageAppTokens, roundedCornerOverlay); // 所以这里就会抛出异常？？？ if (windowLayerFromType == APPLICATION_LAYER) &#123; throw new IllegalArgumentException( &quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;); &#125; return mAreaForLayer[windowLayerFromType];&#125; 因为Activity对应的windowType是TYPE_BASE_APPLICATION，所以拿到的windowLayerFromType就是APPLICATION_LAYER，那么这里必然会抛出异常！ 当然按照正常理解来说，必然不会发生异常才对，所以是我们流程分析哪里有问题？ 是也不是，这里就要留意到应用启动过程了，回到Activity的启动过程，我们先看ActivityRecord的创建过程。 一. ActivityRecord的创建ActivityRecord类是WindowToken子类： 而且从名字中也可以看出，这个类应该是和Activity一一对应的，那么应该在Activity启动流程中哪个步骤创建其对象呢？不难理解，肯定是在startActivity的过程中。 Activity的启动流程这里就不展开了，直接看关键代码. 1.1 ActivityTaskManagerService.startActivity1234567891011121314151617181920private int startActivityAsUser(IApplicationThread caller, String callingPackage, @Nullable String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) &#123; ...... // obtainStarter其实就是通过ActivityStarter.DefaultFactory获取ActivityStarter return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;) .setCaller(caller) .setCallingPackage(callingPackage) .setCallingFeatureId(callingFeatureId) .setResolvedType(resolvedType) .setResultTo(resultTo) .setResultWho(resultWho) .setRequestCode(requestCode) .setStartFlags(startFlags) .setProfilerInfo(profilerInfo) .setActivityOptions(bOptions) .setUserId(userId) .execute(); // 执行Activity的启动&#125; 将Activity的启动委托给ActivityStarter执行。 1.2 ActivityStarter.execute12345678910111213141516171819202122232425262728293031323334353637383940int execute() &#123; try &#123; ...... synchronized (mService.mGlobalLock) &#123; ...... res = executeRequest(mRequest); ......&#125;private int executeRequest(Request request) &#123; ...... // 注意这里的inTask是null的，因为ActivityStarter构建时没有设置inTask. Task inTask = request.inTask; ...... // [1.2.1] 针对此次启动的Activity创建对应的ActivityRecord final ActivityRecord r = new ActivityRecord.Builder(mService) .setCaller(callerApp) .setLaunchedFromPid(callingPid) .setLaunchedFromUid(callingUid) .setLaunchedFromPackage(callingPackage) .setLaunchedFromFeature(callingFeatureId) .setIntent(intent) .setResolvedType(resolvedType) .setActivityInfo(aInfo) .setConfiguration(mService.getGlobalConfiguration()) .setResultTo(resultRecord) .setResultWho(resultWho) .setRequestCode(requestCode) .setComponentSpecified(request.componentSpecified) .setRootVoiceInteraction(voiceSession != null) .setActivityOptions(checkedOptions) .setSourceRecord(sourceRecord) .build(); ...... // [1.3] 启动Activity mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession, request.voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, restrictedBgActivity, intentGrants); ......&#125; ActivityRecord的初始化是采用了Build模式. 1.2.1 ActivityRecord的初始化12345678910111213141516171819202122232425262728293031private ActivityRecord(ActivityTaskManagerService _service, WindowProcessController _caller, int _launchedFromPid, int _launchedFromUid, String _launchedFromPackage, @Nullable String _launchedFromFeature, Intent _intent, String _resolvedType, ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo, String _resultWho, int _reqCode, boolean _componentSpecified, boolean _rootVoiceInteraction, ActivityTaskSupervisor supervisor, ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState, TaskDescription _taskDescription, long _createTime) &#123; // 这里创建的Token是IApplicationToken.Stub的子类, 保存在ActivityRecord父类WindowToken的成员变量token中 super(_service.mWindowManager, new Token(_intent).asBinder(), TYPE_APPLICATION, true, null /* displayContent */, false /* ownerCanManageAppTokens */); mAtmService = _service; appToken = (Token) token; info = aInfo; ...... appToken.attach(this); ......&#125;static class Token extends IApplicationToken.Stub &#123; ...... private void attach(ActivityRecord activity) &#123; if (weakActivity != null) &#123; throw new IllegalStateException(&quot;Already attached...&quot; + this); &#125; // 将传入的ActivityRecord用弱引用方式保存起来 weakActivity = new WeakReference&lt;&gt;(activity); &#125; ...... 所以ActivityRecord里的appToken其实是ActivityRecord初始化时创建的Token(为IApplicationToken.Stub的子类)，里面保存了该Activity的Intent信息。 1.3 ActivityStarter.startActivityUnchecked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123; ...... result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants); ......&#125;int startActivityInner(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, Task inTask, boolean restrictedBgActivity, NeededUriGrants intentGrants) &#123; // 1.3.1 设置初始化状态 setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor, restrictedBgActivity); ...... // 获取可重用的task final Task reusedTask = getReusableTask(); ...... // 计算目标task final Task targetTask = reusedTask != null ? reusedTask : computeTargetTask(); final boolean newTask = targetTask == null; mTargetTask = targetTask; ...... // 因为当前Activity是应用启动的第一个Activity，所以newTask为true,targetTaskTop就是null的了 final ActivityRecord targetTaskTop = newTask ? null : targetTask.getTopNonFinishingActivity(); if (targetTaskTop != null) &#123; // 为此次Activity的启动回收task startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants); if (startResult != START_SUCCESS) &#123; return startResult; &#125; &#125; else &#123; mAddingToTask = true; &#125; ...... // 获取当前焦点（前台）Task final Task topRootTask = mPreferredTaskDisplayArea.getFocusedRootTask(); if (topRootTask != null) &#123; // 判断待启动的Activity是否与前台Activity一致 startResult = deliverToCurrentTopIfNeeded(topRootTask, intentGrants); if (startResult != START_SUCCESS) &#123; return startResult; &#125; &#125; if (mTargetRootTask == null) &#123; // 获取root task. mTargetRootTask = getLaunchRootTask(mStartActivity, mLaunchFlags, targetTask, mOptions); &#125; // 需要创建新的task if (newTask) &#123; final Task taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.getTask() : null; // 设置新的Task setNewTask(taskToAffiliate); &#125; else if (mAddingToTask) &#123; addOrReparentStartingActivity(targetTask, &quot;adding to task&quot;); &#125; ...... // 交给对应Task启动Activity mTargetRootTask.startActivityLocked(mStartActivity, topRootTask != null ? topRootTask.getTopNonFinishingActivity() : null, newTask, mKeepCurTransition, mOptions, startFromSamePackage); ......&#125;private void setNewTask(Task taskToAffiliate) &#123; final boolean toTop = !mLaunchTaskBehind &amp;&amp; !mAvoidMoveToFront; // 创建新的Task，关于Task的创建我们后续分析 final Task task = mTargetRootTask.reuseOrCreateTask( mNewTaskInfo != null ? mNewTaskInfo : mStartActivity.info, mNewTaskIntent != null ? mNewTaskIntent : mIntent, mVoiceSession, mVoiceInteractor, toTop, mStartActivity, mSourceRecord, mOptions); mService.getTransitionController().collectExistenceChange(task); // [1.4] 保存Activity至task！ addOrReparentStartingActivity(task, &quot;setTaskFromReuseOrCreateNewTask - mReuseTask&quot;); ......&#125; 这里我们假设启动的Activity是应用的首个Activity，而且也没有设置affinity，这样在启动该Activity时，会创建新的Task, 并在该Task中保存ActivityRecord！ 1.3.1 ActivityStarter.setInitialState - 设置初始化状态12345678910111213141516private void setInitialState(ActivityRecord r, ActivityOptions options, Task inTask, boolean doResume, int startFlags, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, boolean restrictedBgActivity) &#123; reset(false /* clearRequest */); mStartActivity = r; ...... mLaunchParams.reset(); ...... // 因为mLaunchParams被重置了，所以mPreferredTaskDisplayArea获取的就是mRootWindowContainer.getDefaultTaskDisplayArea // 即上文中RootDisplayArea创建的Result中的mDefaultTaskDisplayArea mPreferredTaskDisplayArea = mLaunchParams.hasPreferredTaskDisplayArea() ? mLaunchParams.mPreferredTaskDisplayArea : mRootWindowContainer.getDefaultTaskDisplayArea();&#125; 这里首先先清理ActivityStarter内部成员，然后依次赋值。 1.4 ActivityStarter.addOrReparentStartingActivity12345678910private void addOrReparentStartingActivity(Task parent, String reason) &#123; // mStartActivity是该Activity启动时创建的ActivityRecord. // ActivityRecord.getTask就是获取其task成员，该成员目前是没有被赋值的 if (mStartActivity.getTask() == null || mStartActivity.getTask() == parent) &#123; // [1.5] 将该ActivityRecord添加至task中 parent.addChild(mStartActivity); &#125; else &#123; mStartActivity.reparent(parent, parent.getChildCount() /* top */, reason); &#125;&#125; 1.5 Task.addChild1234567891011121314151617void addChild(ActivityRecord r) &#123; // 默认添加到该Task的最上层 addChild(r, Integer.MAX_VALUE /* add on top */);&#125;@Overridevoid addChild(WindowContainer child, int index) &#123; // 判断mChildren集合中是否存在元素 boolean hadChild = hasChild(); // [1.5.1] 获取当前Task最上层的WindowContainer对应的Activity类型 final int activityType = getActivityType(); // [1.5.2] 调整被添加的ActivityRecord在task中的位置 index = getAdjustedChildPosition(child, index); // [1.6] 将WindowContainer添加至mChildren中index位置 super.addChild(child, index); ......&#125; 1.5.1 Task.getActivityType123456789101112131415161718192021@Overridepublic int getActivityType() &#123; // Task的父类是WindowContainer, WindowContainer的父类是ConfigurationContainer final int applicationType = super.getActivityType(); if (applicationType != ACTIVITY_TYPE_UNDEFINED || !hasChild()) &#123; return applicationType; &#125; return getTopChild().getActivityType();&#125;// frameworks/base/core/java/android/content/res/Configuration.javapublic int getActivityType() &#123; // mFullConfiguration就是Configuration.java类 return mFullConfiguration.windowConfiguration.getActivityType();&#125;// frameworks/base/core/java/android/app/WindowConfiguration.java@ActivityTypepublic int getActivityType() &#123; return mActivityType;&#125; ActivityType有如下取值: 名称 值 含义 ACTIVITY_TYPE_UNDEFINED 0 Activity类型尚未定义 ACTIVITY_TYPE_STANDARD 1 标准Activity类型 ACTIVITY_TYPE_HOME 2 Home或Launcher的Activity类型 ACTIVITY_TYPE_RECENTS 3 Recents或者Overview的Activity类型，系统中只有一个具有此类型的Activity ACTIVITY_TYPE_ASSISTANT 4 Assistant Activity类型 ACTIVITY_TYPE_DREAM 5 Dream Activity类型 一般情况都是ACTIVITY_TYPE_STANDARD或者ACTIVITY_TYPE_HOME类型。当前Task获取的值应该是初始化的默认值： 1234567891011121314151617181920212223242526// ConfigurationContainer.java:mFullConfigurationprivate Configuration mFullConfiguration = new Configuration();// Configuration.java:windowConfigurationpublic final WindowConfiguration windowConfiguration = new WindowConfiguration();// WindowConfiguration.javapublic WindowConfiguration() &#123; unset();&#125;public void unset() &#123; setToDefaults();&#125;/** @hide */public void setToDefaults() &#123; setAppBounds(null); setBounds(null); setMaxBounds(null); setWindowingMode(WINDOWING_MODE_UNDEFINED); setActivityType(ACTIVITY_TYPE_UNDEFINED); setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED); setRotation(ROTATION_UNDEFINED); setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);&#125; 可以看到，ActivityType是被设置成：ACTIVITY_TYPE_UNDEFINED，也即未定义类型！ 1.5.2 Task.getAdjustedChildPosition12345678910111213141516171819202122232425262728293031private int getAdjustedChildPosition(WindowContainer wc, int suggestedPosition) &#123; // wc就是创建的ActivityRecord, 这里就是检查Activity是否带有FLAG_SHOW_FOR_ALL_USERS标志 // 或者该Activity所属的userId是否是当前userId，即非当前用户的Activity不可见 final boolean canShowChild = wc.showToCurrentUser(); final int size = mChildren.size(); // 根据WindowContainer是否可见，决定该WC应该被插入Task的位置 int minPosition = (canShowChild) ? computeMinUserPosition(0, size) : 0; int maxPosition = (canShowChild) ? size : computeMaxUserPosition(size - 1); // [1.5.2.1] 检查该WindowContainer是否是永远处于Task最上层 if (!wc.isAlwaysOnTop()) &#123; // 将所有应该永远处于最上层的WC放在Task的最上层 while (maxPosition &gt; minPosition) &#123; if (!mChildren.get(maxPosition - 1).isAlwaysOnTop()) break; --maxPosition; &#125; &#125; // 当该WC可以处于POSITION_BOTTOM且minPosition也是0时，返回POSITION_BOTTOM // 或者可以处于POSITION_TOP且maxPosition超过目前children数量时，返回POSITION_TOP if (suggestedPosition == POSITION_BOTTOM &amp;&amp; minPosition == 0) &#123; return POSITION_BOTTOM; &#125; else if (suggestedPosition == POSITION_TOP &amp;&amp; maxPosition &gt;= (size - 1)) &#123; return POSITION_TOP; &#125; // 挑选一个合适的位置 return Math.min(Math.max(suggestedPosition, minPosition), maxPosition);&#125; 这里是通过检查WindowContainer是否可见的属性以及是否应该永远处于最上层来调整该WC应该被插入Task的哪个位置。 当我们ActivityRecord被添加入一个新建的Task时，毫无疑问应该是处于最上层即返回POSITION_TOP。 1.5.2.1 WindowContainer.isAlwaysOnTop1234567public boolean isAlwaysOnTop() &#123; if (mWindowingMode == WINDOWING_MODE_PINNED) return true; if (mActivityType == ACTIVITY_TYPE_DREAM) return true; if (mAlwaysOnTop != ALWAYS_ON_TOP_ON) return false; return mWindowingMode == WINDOWING_MODE_FREEFORM || mWindowingMode == WINDOWING_MODE_MULTI_WINDOW;&#125; 说明如下情况，该WindowContainer应该始终处于所在Task的最上层: window模式为WINDOWING_MODE_PINNED Activity类型是ACTIVITY_TYPE_DREAM 当mAlwaysOnTop为ALWAYS_ON_TOP_ON，window模式为WINDOWING_MODE_FREEFORM或WINDOWING_MODE_MULTI_WINDOW 1.6 WindowContainer.addChild12345678910111213141516@CallSupervoid addChild(E child, int index) &#123; ...... // 最后调整index if (index == POSITION_TOP) &#123; index = mChildren.size(); &#125; else if (index == POSITION_BOTTOM) &#123; index = 0; &#125; // 将child保存在mChildren中的特定位置 mChildren.add(index, child); // [1.7] 让child保存该WC（即Task） child.setParent(this);&#125; @CallSuper: 是Android中特有的注解，如果子类覆盖了同名方法而没有显示调用父类的该方法时就会报错! 这个也挺简单的，首先最后调整一下index： 如果传入的index为POSITION_TOP，则将index设置为当前mChildren的size值，意为将待存入的child保存在mChildren中最后一位（上面） 如果传入的index为POSITION_BOTTOM， 则将index设置为0，意为将待存入的child保存在mChildren中第一位（下面） 然后让child(ActivityRecord)保存该WC（即Task）。 1.7 WindowContainer.setParent1234567891011121314151617181920final protected void setParent(WindowContainer&lt;WindowContainer&gt; parent) &#123; final WindowContainer oldParent = mParent; mParent = parent; if (mParent != null) &#123; mParent.onChildAdded(this); &#125; // ActivityRecord创建时，该值默认为false,只有被调用reparent重设父集时才会被短暂更改为true if (!mReparenting) &#123; onSyncReparent(oldParent, mParent); // mDisplayContent此时还是null的，而Task.mDisplayContent就是defaultDisplayContent if (mParent != null &amp;&amp; mParent.mDisplayContent != null &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123; // [1.8] 更改当前WC(ActivityRecord)的DisplayContent onDisplayChanged(mParent.mDisplayContent); &#125; // [1.7.1] 当前ActivityRecord的parent有更改 onParentChanged(mParent, oldParent); &#125;&#125; 设置WC(ActivityRecord)的父集（mParent, 即保存该WC的Task）, 如有必要同步Task中DisplayContent至该WC中。 1.7.1 ActivityRecord.onParentChanged12345678@Overridevoid onParentChanged(ConfigurationContainer newParent, ConfigurationContainer oldParent) &#123; final Task oldTask = oldParent != null ? (Task) oldParent : null; final Task newTask = newParent != null ? (Task) newParent : null; // 存入ActivityRecord.task中 this.task = newTask; ......&#125; 将传入的ConfigurationContainer作为Task，存入ActivityRecord.task中，其余部分暂时先不研究。 1.8 ActivityRecord.onDisplayChanged12345678910111213141516171819202122232425262728293031323334353637@Overridevoid onDisplayChanged(DisplayContent dc) &#123; DisplayContent prevDc = mDisplayContent; // WindowToken.onDisplayChanged super.onDisplayChanged(dc); ......&#125;// WindowToken.java:onDisplayChanged@Overridevoid onDisplayChanged(DisplayContent dc) &#123; // [1.9] 将WindowToken（ActivityRecord）保存至DisplayContent中 dc.reParentWindowToken(this); // WindowContainer.onDisplayChanged super.onDisplayChanged(dc);&#125;// WindowContainer.java:onDisplayChangedvoid onDisplayChanged(DisplayContent dc) &#123; if (mDisplayContent != null &amp;&amp; mDisplayContent.mChangingContainers.remove(this)) &#123; // Cancel any change transition queued-up for this container on the old display. mSurfaceFreezer.unfreeze(getPendingTransaction()); &#125; mDisplayContent = dc; if (dc != null &amp;&amp; dc != this) &#123; dc.getPendingTransaction().merge(mPendingTransaction); &#125; // 将mChildren中的每个WC的DisplayContent也同步更改 for (int i = mChildren.size() - 1; i &gt;= 0; --i) &#123; final WindowContainer child = mChildren.get(i); child.onDisplayChanged(dc); &#125; for (int i = mListeners.size() - 1; i &gt;= 0; --i) &#123; mListeners.get(i).onDisplayChanged(dc); &#125;&#125; 这里最主要的是理清ActivityRecord、WindowToken、Task和WindowContainer之间的继承关系： 1.9 DisplayContent.reParentWindowToken1234567891011121314void reParentWindowToken(WindowToken token) &#123; // prevDc目前还是null的 final DisplayContent prevDc = token.getDisplayContent(); if (prevDc == this) &#123; return; &#125; if (prevDc != null) &#123; ...... &#125; // 将ActivityRecord添加到该DC中,key为WindowToken的.token值 addWindowToken(token.token, token); ......&#125; 由于此时还处于ActivityRecord刚被创建，正在第一次被设置DisplayContent时，所以其DisplayContent此时还是null的。那么就直接将该WindowToken(即ActivityRecord)保存在此DisplayContent中，注意token.token其实是WindowToken.token, 这个值我们之前分析过，是attrs.token,也就是从App进程传入的LocalActivityRecord. 1.10 DisplayContent.addWindowToken12345678910void addWindowToken(IBinder binder, WindowToken token) &#123; final DisplayContent dc = mWmService.mRoot.getWindowTokenDisplay(token); ...... // 将ActivityRecord保存在DisplayContent中，key为WindowToken的token变量，即app传入的LayoutParam中的token mTokenMap.put(binder, token); // WindowToken（其实是ActivityRecord）的asActivityRecord函数返回值不为null if (token.asActivityRecord() == null) &#123; ...... &#125;&#125; 好了，我们终于明白了一个ActivityRecord是如何被添加进DisplayContent中了，看到这里是不是似曾相识呢？Bingo, 之前我们的windowToken创建时会抛出一个异常，就是因为这个WindowToken.asActivityRecord返回值为null, 导致DisplayContent中添加该WindowToken时找不到合适layer！ 1234567int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType, ownerCanManageAppTokens, roundedCornerOverlay);// 所以这里就会抛出异常？？？if (windowLayerFromType == APPLICATION_LAYER) &#123; throw new IllegalArgumentException( &quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;);&#125; 现在我们知道了，在app的Activity被resume时，早就已经有了其WindowToken（ActivityRecord）被保存在DisplayContent的mTokenMap中。所以回过头我们看WMS.addWindow方法: 1234567891011121314151617181920212223242526272829303132public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility, int displayId, int requestUserId, InsetsState requestedVisibility, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; ...... // 窗口类型保存在LayoutParams中 final int type = attrs.type; synchronized (mGlobalLock) &#123; ...... // 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord! WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); ...... // 所以这里就不会进入了，疑问解除！ if (token == null) &#123; ..... &#125; ... // 初始化WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); ...... // 创建SurfaceSession, 用来和SurfaceFlinger通信 win.attach(); // 保存WindowState mWindowMap.put(client.asBinder(), win); ...... win.mToken.addWindow(win); ...... ......&#125; 啊哈，异常解除，因为Activity需要resume必须先start, 而start过程中就会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中！ 最后附上一张时序图以备忘： 接下来，我们继续看WMS.addWindow的流程：WindowState的创建及其管理。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"}]},{"title":"WMS(2)-WMS中RootDisplayArea的创建","slug":"WMS(2)-WMS中RootDisplayArea的创建","date":"2022-05-01T17:35:34.000Z","updated":"2022-06-18T09:56:52.960Z","comments":true,"path":"2022/05/02/WMS(2)-WMS中RootDisplayArea的创建/","link":"","permalink":"https://swallowjoe.github.io/2022/05/02/WMS(2)-WMS%E4%B8%ADRootDisplayArea%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"以下分析基于Android S. 简述在我们开始分析WMS是怎么管理不同应用的Window的时，有点一头雾水，不知如何下手。那么我们还是从单个Activity的Window被添加至WMS中来入手。 从上文中我们知道PhoneWindow是通过IWindowSession被添加的，在ViewRoontImpl中调用了addToDisplayAsUser: 1234res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), userId, mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets, mTempControls); 这里的mWindow是ViewRootImpl.W类的对象，用于WMS和该Window通信。","text":"以下分析基于Android S. 简述在我们开始分析WMS是怎么管理不同应用的Window的时，有点一头雾水，不知如何下手。那么我们还是从单个Activity的Window被添加至WMS中来入手。 从上文中我们知道PhoneWindow是通过IWindowSession被添加的，在ViewRoontImpl中调用了addToDisplayAsUser: 1234res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), userId, mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets, mTempControls); 这里的mWindow是ViewRootImpl.W类的对象，用于WMS和该Window通信。 一. Activity的Window被添加至WMSmWindowSession是ViewRootImpl被创建时通过IWindowManager在WMS中创建并返回的。这个我们回顾下： 1.1 Session.addToDisplayAsUser1234567public int addToDisplayAsUser(IWindow window, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, int userId, InsetsState requestedVisibility, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; return mService.addWindow(this, window, attrs, viewVisibility, displayId, userId, requestedVisibility, outInputChannel, outInsetsState, outActiveControls);&#125; 这里的mService自然就是WMS本身了。 1.2 WMS.addWindow12345678910111213141516171819202122232425262728293031323334353637383940414243public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility, int displayId, int requestUserId, InsetsState requestedVisibility, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; ...... // 窗口类型保存在LayoutParams中 final int type = attrs.type; synchronized (mGlobalLock) &#123; ...... // 1.2.1 获取该token对应的DisplayContent final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token); ...... ActivityRecord activity = null; final boolean hasParent = parentWindow != null; // 当该Activity没有parent时，此时获取的token还是null WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); ...... if (token == null) &#123; if (hasParent) &#123; ...... &#125; else &#123; // 1.2.2 一般走这里创建WindowToken final IBinder binder = attrs.token != null ? attrs.token : client.asBinder(); token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow, isRoundedCornerOverlay); &#125; &#125; ... // 初始化WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); ...... // 创建SurfaceSession, 用来和SurfaceFlinger通信 win.attach(); // 保存WindowState mWindowMap.put(client.asBinder(), win); ...... win.mToken.addWindow(win); ...... ......&#125; 1.2.1 WMS.getDisplayContentOrCreate1234567891011private DisplayContent getDisplayContentOrCreate(int displayId, IBinder token) &#123; if (token != null) &#123; // 遍历所有的DisplayContent找到保存该token的WindowToken final WindowToken wToken = mRoot.getWindowToken(token); if (wToken != null) &#123; return wToken.getDisplayContent(); &#125; &#125; return mRoot.getDisplayContentOrCreate(displayId);&#125; 这里首先遍历所有的DisplayContent尝试找到保存该token的WindowToken，自然是没有的，我们是第一次添加。 mRoot是WMS服务启动时创建的RootWindowContainer对象: 123456789101112131415161718192021222324252627282930DisplayContent getDisplayContentOrCreate(int displayId) &#123; // 是否已被创建，假设已创建 DisplayContent displayContent = getDisplayContent(displayId); if (displayContent != null) &#123; return displayContent; &#125; if (mDisplayManager == null) &#123; // The system isn&#x27;t fully initialized yet. return null; &#125; final Display display = mDisplayManager.getDisplay(displayId); if (display == null) &#123; // The display is not registered in DisplayManager. return null; &#125; // 1.2.1.1 创建DisplayContent displayContent = new DisplayContent(display, this); addChild(displayContent, POSITION_BOTTOM); return displayContent;&#125;DisplayContent getDisplayContent(int displayId) &#123; for (int i = getChildCount() - 1; i &gt;= 0; --i) &#123; final DisplayContent displayContent = getChildAt(i); if (displayContent.mDisplayId == displayId) &#123; return displayContent; &#125; &#125; return null;&#125; 这里为了便于后续分析，先看看相关的类图: 从类的成员变量上推测： WindowState: 代表Activity在WMS中的Window DisplayContent: 管理显示窗口以及显示区域 DisplayPolicy: 管理显示窗口的可视化，决定哪些窗口可以有焦点，可以被”看见”(mFocusedWindow) 注意到这些类图里有很多都使用了WindowContainer，这个类中最重要的是一个WindowList类的成员，该类就是一个继承了ArrayList的类： 1234567891011121314class WindowList&lt;E&gt; extends ArrayList&lt;E&gt; &#123; void addFirst(E e) &#123; add(0, e); &#125; E peekLast() &#123; return size() &gt; 0 ? get(size() - 1) : null; &#125; E peekFirst() &#123; return size() &gt; 0 ? get(0) : null; &#125;&#125; 简单包装了ArrayList, 实现了三个方法： addFirst: 将元素添加至index为0的位置，原先元素的index依次+1 peekLast: 获取集合最后一个元素 peekFirst: 获取集合第一个元素 1.2.1.1 DisplayContent 的创建1234567891011121314DisplayContent(Display display, RootWindowContainer root) &#123; super(root.mWindowManager, &quot;DisplayContent&quot;, FEATURE_ROOT); ...... mRootWindowContainer = root; ...... // 创建DisplayPolicy mDisplayPolicy = new DisplayPolicy(mWmService, this); ...... // 初始化DisplayAreaPolicy mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate( mWmService, this /* content */, this /* root */, mImeWindowsContainer); ......&#125; DisplayContent的初始化中做了很多工作，包括创建SurfaceControl等等，但这不是我们目前关注的。 DisplayContent是继承了RootDisplayArea, 其对应的Feature是FEATURE_ROOT，表示是该逻辑显示设备上的根显示区域 DisplayPolicy暂时不是我们关注的，主要了解下其是在这里初始化即可, 重点是初始化DisplayAreaPolicy。 1.2.1.2 DisplayAreaPolicy的初始化12345678910111213141516171819202122232425262728293031323334353637383940414243// getDisplayAreaPolicyProvider拿到的就是WMS初始化时创建的mDisplayAreaPolicyProvider// 初始化时的代码：// mDisplayAreaPolicyProvider = DisplayAreaPolicy.Provider.fromResources(// mContext.getResources());mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate( mWmService, this /* content */, this /* root */, mImeWindowsContainer);// DisplayAreaPolicy.javastatic Provider fromResources(Resources res) &#123; // config_deviceSpecificDisplayAreaPolicyProvider用于特定屏幕设备的DisplayAreaPolicy初始化 // 一般都是个空值，除非屏幕设备特殊 String name = res.getString( com.android.internal.R.string.config_deviceSpecificDisplayAreaPolicyProvider); if (TextUtils.isEmpty(name)) &#123; // 使用默认的DisplayAreaPolicy初始化构造器 return new DisplayAreaPolicy.DefaultProvider(); &#125; ...&#125;// static final class DefaultProvider implements DisplayAreaPolicy.Providerpublic DisplayAreaPolicy instantiate(WindowManagerService wmService, DisplayContent content, RootDisplayArea root, DisplayArea.Tokens imeContainer) &#123; // FEATURE_DEFAULT_TASK_CONTAINER 默认任务容器所在的显示区域 final TaskDisplayArea defaultTaskDisplayArea = new TaskDisplayArea(content, wmService, &quot;DefaultTaskDisplayArea&quot;, FEATURE_DEFAULT_TASK_CONTAINER); final List&lt;TaskDisplayArea&gt; tdaList = new ArrayList&lt;&gt;(); tdaList.add(defaultTaskDisplayArea); // 层次结构生成， 将在此基础上构建DisplayArea层次结构。 final HierarchyBuilder rootHierarchy = new HierarchyBuilder(root); // 设置基本容器（即使显示器不支持输入法）以及设置mTaskDisplayAreas集合 rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList); // 这个就是确认Display是否包含FLAG_TRUSTED, 一般是包含的 if (content.isTrusted()) &#123; // 1.2.1.3 设置rootHierarchy中的feature configureTrustedHierarchyBuilder(rootHierarchy, wmService, content); &#125; // 1.2.1.4 实例化DisplayAreaPolicy return new DisplayAreaPolicyBuilder().setRootHierarchy(rootHierarchy).build(wmService);&#125; 创建了名为”DefaultTaskDisplayArea”的显示区域-TaskDisplayArea，并将其放入层次结构生成器中，然后设置该层次结构生成器的相应参数，最后通过DisplayAreaPolicyBuilder实例化DisplayAreaPolicy。 注意传入的content和root都是DisplayContent本身。 1.2.1.3 DisplayAreaPolicy.DefaultProvider.configureTrustedHierarchyBuilder1234567891011121314151617181920private void configureTrustedHierarchyBuilder(HierarchyBuilder rootHierarchy, WindowManagerService wmService, DisplayContent content) &#123; // 窗口放大应该在顶部，因为只有一个表面被放大 rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;, FEATURE_WINDOWED_MAGNIFICATION) ...... if (content.isDefaultDisplay) &#123; // 只有默认显示可以有剪切 // See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked. rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;HideDisplayCutout&quot;, FEATURE_HIDE_DISPLAY_CUTOUT) ...... .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHandedBackgroundPanel&quot;, FEATURE_ONE_HANDED_BACKGROUND_PANEL) ...... .addFeature(new Feature.Builder(wmService.mPolicy, &quot;OneHanded&quot;, FEATURE_ONE_HANDED) &#125; rootHierarchy .addFeature(new Feature.Builder(wmService.mPolicy, &quot;FullscreenMagnification&quot;, FEATURE_FULLSCREEN_MAGNIFICATION) ...... .addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;, FEATURE_IME_PLACEHOLDER) ......&#125; 因为这里的层次结构对应DisplayContent所处的DisplayId是默认的显示设备即DEFAULT_DISPLA，默认是添加6个FEATURE： FEATURE_WINDOWED_MAGNIFICATION: 可以放大的显示区域(比如无障碍里的放大镜) FEATURE_HIDE_DISPLAY_CUTOUT: 用于隐藏显示裁剪功能的显示区域 FEATURE_ONE_HANDED_BACKGROUND_PANEL:显示区域为单手背景层 FEATURE_ONE_HANDED: 单手功能的显示区域 FEATURE_FULLSCREEN_MAGNIFICATION: 可以放大的显示区域,但这个是整个显示放大 FEATURE_IME_PLACEHOLDER: 可以放置IME(输入法窗口)容器的显示区域 注意这里的顺序比较重要。 1.2.1.4 DisplayAreaPolicyBuilder.build可以看到DisplayAreaPolicy的构建其实是采用build设计模式，最后由DisplayAreaPolicyBuilder生成DisplayAreaPolicy： 12345678910111213141516171819202122232425262728293031// DisplayAreaPolicyBuilder.javaResult build(WindowManagerService wmService) &#123; validate(); // 在将窗口添加到组层次结构之前，将DisplayArea组根附加到屏幕层次结构 // 这里的mRootHierarchyBuilder就是上面DefaultProvider.instantiate初始化的rootHierarchy mRootHierarchyBuilder.build(mDisplayAreaGroupHierarchyBuilders); List&lt;RootDisplayArea&gt; displayAreaGroupRoots = new ArrayList&lt;&gt;( mDisplayAreaGroupHierarchyBuilders.size()); for (int i = 0; i &lt; mDisplayAreaGroupHierarchyBuilders.size(); i++) &#123; HierarchyBuilder hierarchyBuilder = mDisplayAreaGroupHierarchyBuilders.get(i); hierarchyBuilder.build(); displayAreaGroupRoots.add(hierarchyBuilder.mRoot); &#125; // 使用默认的DefaultSelectRootForWindowFunction if (mSelectRootForWindowFunc == null) &#123; // RootHierarchyBuilder.mRoot就是创建的DisplayContent mSelectRootForWindowFunc = new DefaultSelectRootForWindowFunction( mRootHierarchyBuilder.mRoot, displayAreaGroupRoots); &#125; return new Result(wmService, mRootHierarchyBuilder.mRoot, displayAreaGroupRoots, mSelectRootForWindowFunc);&#125;// DefaultSelectRootForWindowFunction的构造DefaultSelectRootForWindowFunction(RootDisplayArea displayRoot, List&lt;RootDisplayArea&gt; displayAreaGroupRoots) &#123; // 所以mDisplayRoot其实就是拥有该DisplayAreaPolicy的DisplayContent mDisplayRoot = displayRoot; mDisplayAreaGroupRoots = Collections.unmodifiableList(displayAreaGroupRoots);&#125; 这里返回的是DisplayAreaPolicyBuilder.Result类对象。并且其TaskDisplayArea是FEATURE_DEFAULT_TASK_CONTAINER，表示默认任务容器所在的显示区域。 1.2.2 WindowToken的创建123final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow, isRoundedCornerOverlay); 这里的attrs.token我们之前也分析了，其实就是Activity里的mToken. 123456789101112131415161718WindowToken(WindowManagerService service, IBinder _token, int type, boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay, boolean fromClientToken, @Nullable Bundle options) &#123; super(service); // WindowToken中保存了来自Activity的mToken token = _token; windowType = type; mOptions = options; mPersistOnEmpty = persistOnEmpty; mOwnerCanManageAppTokens = ownerCanManageAppTokens; mRoundedCornerOverlay = roundedCornerOverlay; mFromClientToken = fromClientToken; // DisplayContent 不是null的 if (dc != null) &#123; // 将该WindowToken添加到DisplayContent中 dc.addWindowToken(token, this); &#125;&#125; 将该WindowToken添加到DisplayContent中： 123456789101112131415161718192021void addWindowToken(IBinder binder, WindowToken token) &#123; ...... // 将该token保存至mTokenMap中，注意这里的key是binder，即对应Activity中的mToken(LocalActivityRecord) mTokenMap.put(binder, token); // 判断该WindowToken是否是ActivityRecord，这里并不是 if (token.asActivityRecord() == null) &#123; // 将该WindowToken的DisplayContent赋值为当前DisplayContent token.mDisplayContent = this; // 该token对应Activity的Window类型是TYPE_BASE_APPLICATION switch (token.windowType) &#123; case TYPE_INPUT_METHOD: case TYPE_INPUT_METHOD_DIALOG: mImeWindowsContainer.addChild(token); break; default: // 将该token保存至mDisplayAreaPolicy中 mDisplayAreaPolicy.addWindow(token); break; &#125; &#125;&#125; 这里的mDisplayAreaPolicy是该DisplayContent初始化时创建的，所以 mDisplayAreaPolicy.addWindow(token) 其实是调用了 DisplayAreaPolicyBuilder.Result.addWindow： 12345678910public void addWindow(WindowToken token) &#123; DisplayArea.Tokens area = findAreaForToken(token); area.addChild(token);&#125;DisplayArea.Tokens findAreaForToken(WindowToken token) &#123; // mSelectRootForWindowFunc就是DefaultSelectRootForWindowFunction return mSelectRootForWindowFunc.apply(token.windowType, token.mOptions) .findAreaForToken(token);&#125; mSelectRootForWindowFunc一般都是DefaultSelectRootForWindowFunction： 12345678910111213141516171819public RootDisplayArea apply(Integer windowType, Bundle options) &#123; if (mDisplayAreaGroupRoots.isEmpty()) &#123; return mDisplayRoot; &#125; // 默认mDisplayAreaGroupRoots中只有一个RootDisplayArea，也就是mDisplayRoot，（CTS测试会有多个） if (options != null &amp;&amp; options.containsKey(KEY_ROOT_DISPLAY_AREA_ID)) &#123; final int rootId = options.getInt(KEY_ROOT_DISPLAY_AREA_ID); if (mDisplayRoot.mFeatureId == rootId) &#123; return mDisplayRoot; &#125; for (int i = mDisplayAreaGroupRoots.size() - 1; i &gt;= 0; i--) &#123; if (mDisplayAreaGroupRoots.get(i).mFeatureId == rootId) &#123; return mDisplayAreaGroupRoots.get(i); &#125; &#125; &#125; return mDisplayRoot;&#125; mSelectRootForWindowFunc.apply(token.windowType, token.mOptions).findAreaForToken(token)其实是根据Window类型和Window所在的显示屏幕来选择应该将此WindowToken放入哪个RootDisplayArea中存储。 一般来说，mDisplayAreaGroupRoots中只有一个元素，即mDisplayRoot，也就是DisplayContent（猜猜什么情况下会有多个DisplayContent？）。所以这个方法其实等效于：mDisplayRoot.findAreaForToken，这里的mDisplayRoot就是DisplayContent： 123456789101112131415161718192021@NullableDisplayArea.Tokens findAreaForToken(WindowToken token) &#123; return findAreaForToken(token.windowType, token.mOwnerCanManageAppTokens, token.mRoundedCornerOverlay);&#125;@NullableDisplayArea.Tokens findAreaForToken(int windowType, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123; // 获取window类型对应的layer，getWindowLayerFromTypeLw看[Window类型转Layer](#222-windowmanagerpolicygetwindowlayerfromtypelw)。 // 一般应用的window类型是 TYPE_BASE_APPLICATION （值为1，handleResumeActivity中赋值的） // 所以windowLayerFromType就是APPLICATION_LAYER！ int windowLayerFromType = mWmService.mPolicy.getWindowLayerFromTypeLw(windowType, ownerCanManageAppTokens, roundedCornerOverlay); // 所以这里就会抛出异常？？？ if (windowLayerFromType == APPLICATION_LAYER) &#123; throw new IllegalArgumentException( &quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;); &#125; return mAreaForLayer[windowLayerFromType];&#125; 因为Activity对应的windowType是TYPE_BASE_APPLICATION，所以拿到的windowLayerFromType就是APPLICATION_LAYER，那么这里必然会抛出异常！这个疑问我们后续分析，先看返回值，这里最终是返回了RootDisplayArea中mAreaForLayer数组对应存储的对象，接下来我们看看这个数组是如何被创建。 二. RootDisplayArea的构造2.1 HierarchyBuilder.build1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private void build(@Nullable List&lt;HierarchyBuilder&gt; displayAreaGroupHierarchyBuilders) &#123; // ------ 第一部分 -------- // 这个mPolicy就是WMS服务初始化时候创建的PhoneWindowManager final WindowManagerPolicy policy = mRoot.mWmService.mPolicy; // getMaxWindowLayer值目前是固定的36，也就是窗口Layer最大不能超过36，稍后我们就知道为什么是36了！ final int maxWindowLayerCount = policy.getMaxWindowLayer() + 1; final DisplayArea.Tokens[] displayAreaForLayer = new DisplayArea.Tokens[maxWindowLayerCount]; // 由前面的分析可知，这里的feature数目是6个 final Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; featureAreas = new ArrayMap&lt;&gt;(mFeatures.size()); for (int i = 0; i &lt; mFeatures.size(); i++) &#123; featureAreas.put(mFeatures.get(i), new ArrayList&lt;&gt;()); &#125; // PendingArea是一个树形结构, 以下使用PA替代 PendingArea[] areaForLayer = new PendingArea[maxWindowLayerCount]; // 创建根PA，并用其填充上面创建的36个PA数组，也就是每一个PA对应一个WindowLayer final PendingArea root = new PendingArea(null, 0, null); // 注意这里areaForLayer数组中每一个元素都是root，而不是copy了一个PA Arrays.fill(areaForLayer, root); // ------ 第二部分 -------- // 创建显示区域以覆盖所有的Feature final int size = mFeatures.size(); for (int i = 0; i &lt; size; i++) &#123; // 按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部。 final Feature feature = mFeatures.get(i); PendingArea featureArea = null; for (int layer = 0; layer &lt; maxWindowLayerCount; layer++) &#123; // Feature的mWindowLayers是一个boolean类型的数组，但是该值又是什么意思呢？ // 这里我们先打断一下，看看Feature是怎么构造的--[2.2.3](DisplayAreaPolicyBuilder.Feature的构造) if (feature.mWindowLayers[layer]) &#123; // 此功能将应用于此窗口层。为它找到一个显示区： // 可以重用现有的一个，如果它是为上一层的此功能创建的，并且应用到上一层的最后一个功能与应用到当前层的功能相同（因此它们可以共享相同的父显示区域） if (featureArea == null || featureArea.mParent != areaForLayer[layer]) &#123; // 没有合适的显示区域： // 在该层的上一个区域（作为父对象）下创建一个新区域。 featureArea = new PendingArea(feature, layer, areaForLayer[layer]); areaForLayer[layer].mChildren.add(featureArea); &#125; areaForLayer[layer] = featureArea; &#125; else &#123; // 此功能不会应用于此窗口层。如果需要应用到下一层，需要为此创建一个新的显示区域。 featureArea = null; &#125; &#125; &#125; // ------ 第三部分 -------- // 为每个层创建Tokens作为叶子 PendingArea leafArea = null; int leafType = LEAF_TYPE_TOKENS; for (int layer = 0; layer &lt; maxWindowLayerCount; layer++) &#123; // 2.2.1 获取当前layer类型 int type = typeOfLayer(policy, layer); // 检查我们是否可以重用上一层的相同Tokens。如果上一个图层与当前图层的类型相同，并且没有仅应用于其中一个图层的功能，则会发生这种情况。 if (leafArea == null || leafArea.mParent != areaForLayer[layer] || type != leafType) &#123; // 为当前layer创建新的Tokens leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]); areaForLayer[layer].mChildren.add(leafArea); leafType = type; if (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123; // 我们使用传入的TaskDisplayAreas作为层的任务容器类型。 // 即使没有TaskDisplayArea，也不要创建Tokens。 addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]); addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer], displayAreaGroupHierarchyBuilders); leafArea.mSkipTokens = true; &#125; else if (leafType == LEAF_TYPE_IME_CONTAINERS) &#123; // 我们使用传入的ImeContainer作为层的ime容器类型。 // 即使没有ime容器，也不要创建Tokens。 leafArea.mExisting = mImeContainer; leafArea.mSkipTokens = true; &#125; &#125; leafArea.mMaxLayer = layer; &#125; // ------ 第四部分 -------- // [2.5.1]计算最大layer root.computeMaxLayer(); // [2.5.2]构建了一个PendingAreas树，其中包含表示层次结构的所有必要信息，现在创建并将真实的显示区域附加到根目录 root.instantiateChildren(mRoot, displayAreaForLayer, 0, featureAreas); // [2.5.3]完成DisplayArea的创建，缓存结果便于快速访问 mRoot.onHierarchyBuilt(mFeatures, displayAreaForLayer, featureAreas);&#125; 此方法使用以下属性构造图层层次结构： 每个Feature映射到一组显示区域(PendingArea) 添加窗口后，对于该窗口类型所属的每个要素，它都是该要素的相应显示区域之一的后代。 保持Z顺序，即如果Z范围（区域）表示显示区域内的窗口层集： 对于每对DisplayArea同级(a，b)，其中a低于b，它保持 max(z-range(a)) &lt;&#x3D; min(z-range(b)) 下面的算法迭代地创建这样一个层次结构：-最初，所有窗口都附加到根目录。-对于每个feature，我们通过在层上循环创建一组显示区域-如果该feature确实适用于当前层，我们需要为它找到一个显示区域以满足（2）-如果当前feature也适用于前一层（满足（3）），并且应用于前一层的最后一个特征与应用于当前层的最后一个特征相同（满足（2）），我们可以重用前一层的区域-否则，我们将在应用于当前层的最后一个功能下面创建一个新的显示区域 云里雾里的，看不懂啊, 将这段代码分成四个部分，逐一解析。 2.2 build的第一部分 - layer, feature2.2.1 layer类型 – HierarchyBuilder.typeOfLayer此方法获取layer对应的类型： 1234567891011private static int typeOfLayer(WindowManagerPolicy policy, int layer) &#123; if (layer == APPLICATION_LAYER) &#123; return LEAF_TYPE_TASK_CONTAINERS; // 2.2.2 获取输入法对应的layer类型 &#125; else if (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD) || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) &#123; return LEAF_TYPE_IME_CONTAINERS; &#125; else &#123; return LEAF_TYPE_TOKENS; &#125;&#125; 首先这里的layer类型有三种: LEAF_TYPE_TOKENS: tokens的layer LEAF_TYPE_TASK_CONTAINERS: 作为Task的layer LEAF_TYPE_IME_CONTAINERS: 作为输入法的layer 其次当layer&#x3D;2时，其type为LEAF_TYPE_TASK_CONTAINERS；当layer&#x3D;15或16时，其type为LEAF_TYPE_IME_CONTAINERS；其余layer都是LEAF_TYPE_TOKENS类型。 2.2.2 WindowManagerPolicy.getWindowLayerFromTypeLw1234567891011121314151617181920212223242526default int getWindowLayerFromTypeLw(int type, boolean canAddInternalSystemWindow, boolean roundedCornerOverlay) &#123; // 始终将圆角层放在最上面, 所以返回的layer类型就是对应最大的layer index // 所谓圆角层是指手机屏幕的四个角，现在大多时候圆角，会用一层黑色覆盖避免硬件显示的毛刺 // 这样也容易调整角的弧度，使得出厂机器表现一致 if (roundedCornerOverlay &amp;&amp; canAddInternalSystemWindow) &#123; return getMaxWindowLayer(); &#125; // 窗口类型是应用窗口时，返回的layer就是APPLICATION_LAYER（2） if (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123; return APPLICATION_LAYER; &#125; switch (type) &#123; case TYPE_WALLPAPER: // 墙纸在底部，不过可能会被WindowManager移动 return 1; ...... case TYPE_POINTER: // （鼠标）指针层 return 35; default: Slog.e(&quot;WindowManager&quot;, &quot;Unknown window type: &quot; + type); return 3; &#125;&#125; 这里就可以解答刚刚的疑问了，为什么layer数量是36了，在考虑上面Window类型和Layer类型的对应，可以想到，layer类型的也是其Z轴的位置！ Window类型 值 作用 Layer(Z轴) TYPE_WALLPAPER 2013 壁纸窗口 1 [FIRST_APPLICATION_WINDOW,LAST_APPLICATION_WINDOW] [1, 99] 应用窗口 2 TYPE_PRESENTATIONTYPE_PRIVATE_PRESENTATIONTYPE_DOCK_DIVIDERTYPE_QS_DIALOGTYPE_PHONE 20372030203420352002 *在外部显示器上显示的窗口*在专用屏幕上方显示的窗口*显示调整docked堆栈大小的窗口*用于快速设置的窗口*phone窗口，比如来电窗口 3 TYPE_SEARCH_BARTYPE_VOICE_INTERACTION_STARTING 20012033 *搜索栏窗口,位于屏幕顶部*语音交互层的启动窗口 4 TYPE_VOICE_INTERACTION 2031 语音交互层窗口 5 TYPE_INPUT_CONSUMER 2022 systemUI栏隐藏时使用输入事件的窗口 6 TYPE_SYSTEM_DIALOG 2008 从状态栏滑出的面板窗口 7 TYPE_TOAST 2005 临时通知窗口，即toast窗口 8 TYPE_PRIORITY_PHONE 2007 优先电话UI界面 9 TYPE_SYSTEM_ALERT 2003 系统窗口，比如低电Dialog或者ANR之类 10或者13 TYPE_APPLICATION_OVERLAY 2038 应用覆盖窗口,在所有窗口的上方但在关键系统窗口（如状态栏）的下方需要SYSTEM_ALERT_WINDOW权限 12 TYPE_INPUT_METHOD 2011 内部输入法窗口，显示在普通用户界面上方。可以调整应用窗口的大小或平移，以在显示此窗口时保持输入焦点可见 15 TYPE_INPUT_METHOD_DIALOG 2012 显示在当前输入法窗口上方的内部输入法对话框窗口 16 TYPE_STATUS_BAR 2000 状态栏 17 TYPE_STATUS_BAR_ADDITIONAL 2041 用于在屏幕的非常规部分（即屏幕的左侧或底部）显示状态栏窗口 18 TYPE_NOTIFICATION_SHADE 2040 状态栏下拉的通知栏窗口和keyguard 19 TYPE_STATUS_BAR_SUB_PANEL 2017 从状态栏滑出的面板窗口 20 TYPE_KEYGUARD_DIALOG 2009 keyguard创建的对话框窗口 21 TYPE_VOLUME_OVERLAY 2020 音量调整窗口 22 TYPE_SYSTEM_OVERLAY 2006 系统覆盖窗口，需要显示在所有其他窗口之上。这些窗口不能获取输入焦点，否则会干扰keyguard 23或者11 TYPE_NAVIGATION_BAR 2019 导航栏窗口，即虚拟按键的窗口 24 TYPE_NAVIGATION_BAR_PANEL 2024 导航栏面板窗口 25 TYPE_SCREENSHOT 2036 截图窗口,用于屏幕截图动画、区域选择和UI 26 TYPE_SYSTEM_ERROR 2010 内部系统错误窗口 27或者10 TYPE_MAGNIFICATION_OVERLAY 2027 放大覆盖窗口。启用辅助功能放大时，用于突出显示的放大部分 28 TYPE_DISPLAY_OVERLAY 2026 显示覆盖窗口。用于模拟辅助显示设备 29 TYPE_DRAG 2016 拖放窗口 30 TYPE_ACCESSIBILITY_OVERLAY 2032 无障碍辅助窗口 31 TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY 2039 无障碍辅助放大窗口 32 TYPE_SECURE_SYSTEM_OVERLAY 2015 安全系统覆盖窗口。这些窗口不能获取输入焦点，否则会干扰keyguard 33 TYPE_BOOT_PROGRESS 2021 开机动画之后的启动对话框窗口 34 TYPE_POINTER 2018 鼠标指针窗口。如轨迹追踪球 35 - roundedCornerOverlay&#x3D;truecanAddInternalSystemWindow&#x3D;true 圆角层，始终在最上面 36 在分析DisplayArea的构造时，首先需要了解下这些类的作用：Feature、Feature.Builder、HierarchyBuilder： 2.2.3 DisplayAreaPolicyBuilder.Feature的构造1234567static class Feature &#123; private final String mName; private final int mId; private final boolean[] mWindowLayers; private final NewDisplayAreaSupplier mNewDisplayAreaSupplier; ......&#125; 注意mWindowLayers是一个boolean数组，这里的feature有如下几种： Feature Name ID Function FEATURE_ROOT 0 表示该逻辑显示设备上的根显示区域 FEATURE_DEFAULT_TASK_CONTAINER 1 默认任务容器所在的显示区域 FEATURE_WINDOW_TOKENS 2 无Activity的显示区域 FEATURE_ONE_HANDED 3 单手功能的显示区域 FEATURE_WINDOWED_MAGNIFICATION 4 可以放大的显示区域。包含在{@link WindowManager.LayoutParams#TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY}下面的所有窗口 FEATURE_FULLSCREEN_MAGNIFICATION 5 可以放大的显示区域,但这个是整个显示放大 FEATURE_HIDE_DISPLAY_CUTOUT 6 用于隐藏显示裁剪功能的显示区域 FEATURE_IME_PLACEHOLDER 7 可以放置IME容器的显示区域。当IME目标改变时，如果IME容器可能被重表示为该层次结构，那么应该在每个根层次结构上启用。 FEATURE_ONE_HANDED_BACKGROUND_PANEL 8 显示区域为单手背景层，防止用户在打开暗主题时，无法清楚地识别屏幕已进入单手模式。 FEATURE_SYSTEM_LAST 10000 系统特征显示区的最后一个id，作为边界 FEATURE_VENDOR_FIRST 10001 供应商特定的显示区域定义可以从该值开始 FEATURE_VENDOR_LAST 20001 供应商特定的显示区域定义用该值作为边界 FEATURE_RUNTIME_TASK_CONTAINER_FIRST 20002 可以在运行时创建的任务显示区域以此值开始 2.2.4 DisplayAreaPolicyBuilder.Feature.Builder1234567891011121314151617181920212223242526static class Builder &#123; private final WindowManagerPolicy mPolicy; private final String mName; private final int mId; private final boolean[] mLayers; private NewDisplayAreaSupplier mNewDisplayAreaSupplier = DisplayArea::new; private boolean mExcludeRoundedCorner = true; Builder(WindowManagerPolicy policy, String name, int id) &#123; mPolicy = policy; mName = name; mId = id; // mPolicy.getMaxWindowLayer = 36 mLayers = new boolean[mPolicy.getMaxWindowLayer() + 1]; &#125; Feature build() &#123; if (mExcludeRoundedCorner) &#123; // 将mLayers[36]置为false mLayers[mPolicy.getMaxWindowLayer()] = false; &#125; // builder中的mLayers就是Feature中的mWindowLayers return new Feature(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier); &#125; ......&#125; 注意看这里的mLayers，也是一个boolean数组，是一一对应36个layer的。 接下来看看 DisplayAreaPolicyBuilder.Feature.Builder 中关键方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 将mLayers中所有元素都置为trueBuilder all() &#123; Arrays.fill(mLayers, true); return this;&#125;// 传入一个int数组，其元素值代表Window类型,标记这些window窗口对应的layer为trueBuilder and(int... types) &#123; for (int i = 0; i &lt; types.length; i++) &#123; int type = types[i]; // 将该Window类型对应的layer置位true set(type, true); &#125; return this;&#125;// 传入一个int数组，其元素值代表Window类型, 标记这些window窗口对应的layer为falseBuilder except(int... types) &#123; for (int i = 0; i &lt; types.length; i++) &#123; int type = types[i]; set(type, false); &#125; return this;&#125;// 从layer所处z轴从低往高直到typeInclusive类型窗口对应的layer，全部标记为true// 注意是包含typeInclusive类型的Builder upTo(int typeInclusive) &#123; final int max = layerFromType(typeInclusive, false); for (int i = 0; i &lt; max; i++) &#123; mLayers[i] = true; &#125; set(typeInclusive, true); return this;&#125;// 将window类型为type对应的layer在mLayers中标记为valueprivate void set(int type, boolean value) &#123; mLayers[layerFromType(type, true)] = value; // 当window类型是应用覆盖窗口时，其在所有窗口的上方, 但在关键系统窗口（如状态栏）的下方 if (type == TYPE_APPLICATION_OVERLAY) &#123; // 这是多余的一句了。。。 mLayers[layerFromType(type, true)] = value; // 将TYPE_SYSTEM_ALERT、TYPE_SYSTEM_OVERLAY、TYPE_SYSTEM_ERROR的Layer对应的数组元素也置为true mLayers[layerFromType(TYPE_SYSTEM_ALERT, false)] = value; mLayers[layerFromType(TYPE_SYSTEM_OVERLAY, false)] = value; mLayers[layerFromType(TYPE_SYSTEM_ERROR, false)] = value; &#125;&#125;private int layerFromType(int type, boolean internalWindows) &#123; // 所以这个type是window的类型 return mPolicy.getWindowLayerFromTypeLw(type, internalWindows);&#125; 接下来我们通过分析FEATURE_WINDOWED_MAGNIFICATION和FEATURE_IME_PLACEHOLDER的构造，来理解，这个Feature的作用 2.2.4.1 FEATURE_WINDOWED_MAGNIFICATION1234567rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;WindowedMagnification&quot;, FEATURE_WINDOWED_MAGNIFICATION) .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY) .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY) // Make the DA dimmable so that the magnify window also mirrors the dim layer. .setNewDisplayAreaSupplier(DisplayArea.Dimmable::new) .build()); FEATURE_WINDOWED_MAGNIFICATION的feature构造，注释上标记的是代表可以放大的显示区域(比如无障碍里的放大镜)，名称是”WindowedMagnification”： 首先调用 Builder.upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY), TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY的layer对应Z轴值为32，也就是mLayer中0~31的值都是true 调用except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)，将其对应的layer值32置为false 2.2.4.2 FEATURE_IME_PLACEHOLDER1234rootHierarchy.addFeature(new Feature.Builder(wmService.mPolicy, &quot;ImePlaceholder&quot;, FEATURE_IME_PLACEHOLDER) .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG) .build()); FEATURE_IME_PLACEHOLDER的feature构造，注释上标记的是代表可以放置IME(输入法窗口)容器的显示区域，只有一个最简单的and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG), 也就是仅仅将该feature中mWindowLayers里对应TYPE_INPUT_METHOD(15)和TYPE_INPUT_METHOD_DIALOG(16)的layer置位true, 其他都是false. 好了，大致明白Feature的构造过程，以及mWindowLayers中的值来源，现在在回过头继续看 HierarchyBuilder.build 过程。 2.3 build第二部分–PendingArea的构造123456789101112131415161718192021222324final int size = mFeatures.size();for (int i = 0; i &lt; size; i++) &#123; // 按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部。 final Feature feature = mFeatures.get(i); PendingArea featureArea = null; for (int layer = 0; layer &lt; maxWindowLayerCount; layer++) &#123; // Feature的mWindowLayers是一个boolean类型的数组，但是该值又是什么意思呢？ // 这里我们先打断一下，看看Feature是怎么构造的--[2.2.3](DisplayAreaPolicyBuilder.Feature的构造) if (feature.mWindowLayers[layer]) &#123; // 此功能将应用于此窗口层。为它找到一个显示区： // 可以重用现有的一个，如果它是为上一层的此功能创建的，并且应用到上一层的最后一个功能与应用到当前层的功能相同（因此它们可以共享相同的父显示区域） if (featureArea == null || featureArea.mParent != areaForLayer[layer]) &#123; // 没有合适的显示区域： // 在该层的上一个区域（作为父对象）下创建一个新区域。 featureArea = new PendingArea(feature, layer, areaForLayer[layer]); areaForLayer[layer].mChildren.add(featureArea); &#125; areaForLayer[layer] = featureArea; &#125; else &#123; // 此功能不会应用于此窗口层。如果需要应用到下一层，需要为此创建一个新的显示区域。 featureArea = null; &#125; &#125;&#125; 以默认的DisplayContent为例，有6个FEATURE： Feature名 操作 mWindowLayers中为true的元素 mWindowLayers中为false的元素 FEATURE_WINDOWED_MAGNIFICATION .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY).except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY) [0,31] [32,36] FEATURE_HIDE_DISPLAY_CUTOUT .all().except(TYPE_NAVIGATION_BAR,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_STATUS_BAR,TYPE_NOTIFICATION_SHADE) all 17,19,24,25 FEATURE_ONE_HANDED_BACKGROUND_PANEL .upTo(TYPE_WALLPAPER) 0 [1,36] FEATURE_ONE_HANDED .all().except(TYPE_NAVIGATION_BAR, &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL) all 24,25 FEATURE_FULLSCREEN_MAGNIFICATION .all().except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD_DIALOG&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_MAGNIFICATION_OVERLAY,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL) all 15,16,24,25,32 FEATURE_IME_PLACEHOLDER .and(TYPE_INPUT_METHOD,&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD_DIALOG) 15,16 all 第一个feature-FEATURE_WINDOWED_MAGNIFICATION里的mWindowLayers是[0,31]为true,其他位为false, 当此feature遍历完毕之后，areaForLayer数组中[0,31]的元素都是同一个新创建的PA，记为PA_for_WF_0(其mParent为root)， 其他元素都是指向root，而且现在root.mChildren中的唯一元素就是PA_for_WF_0. areaForLayer中的结果如下: [0,31] &#x3D; PA_for_WF_0(其mParent为root) [32,36]&#x3D; root FEATURE_HIDE_DISPLAY_CUTOUT里除了17,19,24,25号其余都是true： 当第二个for循环开始时，featureArea为null, 会新建一个PA, 记为PA_for_HDC_0， 并将其保存到root.mChildren中 依次将areaForLayer[0,16]置为PA_for_HDC_0 当layer为17时，因为FEATURE_HIDE_DISPLAY_CUTOUT.mWindowLayers[17]为false, 所以会将featureArea重置为null, 继续 当layer为18时，而FEATURE_HIDE_DISPLAY_CUTOUT.mWindowLayers[18]为true, 所以又创建一个PA, 记为PA_for_HDC_18，并将areaForLayer[18]置为PA_for_HDC_18 重复制止遍历完毕 现在areaForLayer中的结果如下: [0,16] &#x3D; PA_for_HDC_0 (此PA的mParent为PA_for_WF_0) [17] &#x3D; PA_for_WF_0 [18] &#x3D; PA_for_HDC_18 (此PA的mParent为PA_for_WF_0) [19] &#x3D; PA_for_WF_0 [20,23]&#x3D; PA_for_HDC_20 (此PA的mParent为PA_for_WF_0) [24,25]&#x3D; PA_for_WF_0 [26,31]&#x3D; PA_for_HDC_26 (此PA的mParent为PA_for_WF_0) [32,35]&#x3D; PA_for_HDC_32 (此PA的mParent为root) [36] &#x3D; root root.mChildren结果中保存PA_for_WF_0、PA_for_HDC_0、PA_for_HDC_18、PA_for_HDC_20及PA_for_HDC_26,PA_for_HDC_32 这么分析不够直观，我们画个图来看看: 然后其他的feature过程省略，直接看结果: 于此同时，各个PA中的mParent指向如下： 注意每个PA中的mChildren集合包含所有以该PA为mParent的PA. 其子PA按从上到下，从左到右的顺序依次被添加到该PA中。 2.4 build第三部分–创建Tokens123456789101112131415161718192021222324252627282930// ------ 第三部分 --------// 为每个层创建Tokens作为叶子PendingArea leafArea = null;int leafType = LEAF_TYPE_TOKENS;for (int layer = 0; layer &lt; maxWindowLayerCount; layer++) &#123; // 2.2.1 获取当前layer类型 int type = typeOfLayer(policy, layer); // 检查我们是否可以重用上一层的相同Tokens。如果上一个图层与当前图层的类型相同，并且没有仅应用于其中一个图层的功能，则会发生这种情况。 if (leafArea == null || leafArea.mParent != areaForLayer[layer] || type != leafType) &#123; // 为当前layer创建新的Tokens leafArea = new PendingArea(null /* feature */, layer, areaForLayer[layer]); areaForLayer[layer].mChildren.add(leafArea); leafType = type; if (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123; // 使用传入的TaskDisplayAreas作为任务容器类型。 // [2.4.1] 即 DisplayAreaPolicy的初始化 的时候创建的 DefaultTaskDisplayArea addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]); addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer], displayAreaGroupHierarchyBuilders); leafArea.mSkipTokens = true; &#125; else if (leafType == LEAF_TYPE_IME_CONTAINERS) &#123; // 我们使用传入的ImeContainer作为层的ime容器类型。 // 即使没有ime容器，也不要创建Tokens。 leafArea.mExisting = mImeContainer; leafArea.mSkipTokens = true; &#125; &#125; leafArea.mMaxLayer = layer;&#125; 这段循环看起来和第二段中的循环类似，从Z轴最底层往上依次遍历37个layer。typeOfLayer这个我们已经分析过了: 其次当layer&#x3D;2(也就是APPLICATION_LAYER)时，其type为LEAF_TYPE_TASK_CONTAINERS；当layer&#x3D;15或16时，其type为LEAF_TYPE_IME_CONTAINERS；其余layer都是LEAF_TYPE_TOKENS类型： layer&#x3D;0时，layerType&#x3D;LEAF_TYPE_TOKENS， 创建一个PA,记为PA_TOKENS_0, 其mParent指向areaForLayer[0], 也即是 PA_for_FM_0, 并将该PA添加到PA_for_FM_0的mChildren中。 layer&#x3D;1时，layerType&#x3D;LEAF_TYPE_TOKENS， 现在leafArea就是PA_TOKENS_0, 所以此次循环仅仅是将PA_TOKENS_0.mMaxLayer改成当前layer也就是1. layer&#x3D;2时，layerType&#x3D;LEAF_TYPE_TASK_CONTAINERS, 新建一个PA, 记为 PA_TASK_2, 其mParent指向areaForLayer[2],即 PA_for_FM_2 layer&#x3D;3时，layerType&#x3D;LEAF_TYPE_TOKENS， 创建一个PA,记为PA_TOKENS_3, 其mParent指向areaForLayer[3], 还是 PA_for_FM_2 最终结果如下: 上图中，leafArea的命名方式是 PA_layerType_minLayer_max_Layer. 箭头指向的方向就是其parent方向。 2.4.1 HierarchyBuilder.addTaskDisplayAreasToApplicationLayer12345678910111213private void addTaskDisplayAreasToApplicationLayer(PendingArea parentPendingArea) &#123; // mTaskDisplayAreas中仅包含一个名为&quot;DefaultTaskDisplayArea&quot;的TaskDisplayArea final int count = mTaskDisplayAreas.size(); for (int i = 0; i &lt; count; i++) &#123; PendingArea leafArea = new PendingArea(null /* feature */, APPLICATION_LAYER, parentPendingArea); // 将mTaskDisplayAreas中的DisplayArea放入该PA中 leafArea.mExisting = mTaskDisplayAreas.get(i); leafArea.mMaxLayer = APPLICATION_LAYER; // 添加一个新的PA, 记为 PA_Task_2_2_tda parentPendingArea.mChildren.add(leafArea); &#125;&#125; 现在我们知道传入的parentPendingArea就是上面构造的areaForLayer[APPLICATION_LAYER], 即 PA_for_FM_2! 这里就是把mTaskDisplayAreas中所有的TaskDisplayArea保存到PA_for_FM_2中, 最后结果如下: 2.5 build第四部分–创建DisplayArea123456789// ------ 第四部分 --------// [2.5.1]计算最大layerroot.computeMaxLayer();// [2.5.2]构建了一个PendingAreas树，其中包含表示层次结构的所有必要信息，现在创建并将真实的显示区域附加到根目录root.instantiateChildren(mRoot, displayAreaForLayer, 0, featureAreas);// [2.5.3]完成DisplayArea的创建，缓存结果便于快速访问mRoot.onHierarchyBuilt(mFeatures, displayAreaForLayer, featureAreas); 2.5.1 计算最大layer123456int computeMaxLayer() &#123; for (int i = 0; i &lt; mChildren.size(); i++) &#123; mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer()); &#125; return mMaxLayer;&#125; 有上面的图可以知道，root的children中最大的mMaxLayer为PA_TOKENS_36_36, 值为36。 2.5.2 遍历PA树生成DisplayArea123456789101112131415161718192021222324void instantiateChildren(DisplayArea&lt;DisplayArea&gt; parent, DisplayArea.Tokens[] areaForLayer, int level, Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; areas) &#123; // 将root里面的mChildren按照mMinLayer的大小排序，最小的在前面 mChildren.sort(Comparator.comparingInt(pendingArea -&gt; pendingArea.mMinLayer)); // 遍历所有的children for (int i = 0; i &lt; mChildren.size(); i++) &#123; final PendingArea child = mChildren.get(i); // 为该children创建DisplayArea final DisplayArea area = child.createArea(parent, areaForLayer); if (area == null) &#123; // TaskDisplayArea 和 ImeContainer 可以不用设置 continue; &#125; // 为父DisplayArea添加新建的DisplayArea,且放在最前面 // POSITION_TOP的值是Integer.MAX_VALUE, 这里的意思就是放在parent.mChildren集合的最末尾（Z轴来看就是最上面） // parent就是DisplayContent本身 parent.addChild(area, WindowContainer.POSITION_TOP); if (child.mFeature != null) &#123; areas.get(child.mFeature).add(area); &#125; // 为每一个子PA遍历生成其子树的DisplayArea child.instantiateChildren(area, areaForLayer, level + 1, areas); &#125;&#125; mChildren中只有三个PA, 分别是: PA_for_WF_0, PA_for_HDC_32以及PA_TOKENS_36_36. 这个方法不难看出，就是简单的遍历我们之前创建的PA树，然后给出了root之外的所有PA生成其对应的DisplayArea。 注意这里的传入的parent就是mRoot, 也就是DisplayContent，所以DisplayContent.mChildren中存入的元素就是此时构建的DisplayArea。 2.5.2.1 PendingArea.createArea1234567891011121314151617181920212223242526272829303132private DisplayArea createArea(DisplayArea&lt;DisplayArea&gt; parent, DisplayArea.Tokens[] areaForLayer) &#123; // 对于PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16 if (mExisting != null) &#123; if (mExisting.asTokens() != null) &#123; // 为layer存储WindowToken的容器 fillAreaForLayers(mExisting.asTokens(), areaForLayer); &#125; return mExisting; &#125; if (mSkipTokens) &#123; return null; &#125; DisplayArea.Type type; if (mMinLayer &gt; APPLICATION_LAYER) &#123; type = DisplayArea.Type.ABOVE_TASKS; &#125; else if (mMaxLayer &lt; APPLICATION_LAYER) &#123; type = DisplayArea.Type.BELOW_TASKS; &#125; else &#123; type = DisplayArea.Type.ANY; &#125; // 注意只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建） if (mFeature == null) &#123; final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type, &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer); fillAreaForLayers(leaf, areaForLayer); return leaf; &#125; else &#123; return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type, mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId); &#125;&#125; 这里会创建PendingArea对应的DisplayArea，对于我们的PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16！ 这里我们先看看PA_TASK_2_2_tda的DisplayArea的创建： 12345678// 对于PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16if (mExisting != null) &#123; if (mExisting.asTokens() != null) &#123; // 为layer存储WindowToken的容器 fillAreaForLayers(mExisting.asTokens(), areaForLayer); &#125; return mExisting;&#125; 我们知道PA_TASK_2_2_tda的mExisting就是1.2.1.2 DisplayAreaPolicy的初始化中创建的”DefaultTaskDisplayArea” final TaskDisplayArea defaultTaskDisplayArea &#x3D; new TaskDisplayArea(content, wmService, “DefaultTaskDisplayArea”, FEATURE_DEFAULT_TASK_CONTAINER); 而TaskDisplayArea又是继承了DisplayArea， 其asTokens直接返回了null, 所以说PA_TASK_2_2_tda的DisplayArea就是其mExisting! 接下来是PA_IME_15_16的DisplayArea的创建： 因为mImeContainer是在DisplayContent初始化过程中创建的ImeContainer类的对象，其就是Tokens的子类。所以mExisting.asTokens()确实不为null： 12345private void fillAreaForLayers(DisplayArea.Tokens leaf, DisplayArea.Tokens[] areaForLayer) &#123; for (int i = mMinLayer; i &lt;= mMaxLayer; i++) &#123; areaForLayer[i] = leaf; &#125;&#125; 其实就是将displayAreaForLayer中从minLayer到maxLayer都改成该PA的mExisting. 也就是 displayAreaForLayer[15], displayAreaForLayer[16]为mImeContainer! 当mExisting为null时PA对应的DisplayArea的创建： 123456789101112131415161718DisplayArea.Type type;if (mMinLayer &gt; APPLICATION_LAYER) &#123; type = DisplayArea.Type.ABOVE_TASKS;&#125; else if (mMaxLayer &lt; APPLICATION_LAYER) &#123; type = DisplayArea.Type.BELOW_TASKS;&#125; else &#123; type = DisplayArea.Type.ANY;&#125;// 注意只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）if (mFeature == null) &#123; final DisplayArea.Tokens leaf = new DisplayArea.Tokens(parent.mWmService, type, &quot;Leaf:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer); fillAreaForLayers(leaf, areaForLayer); return leaf;&#125; else &#123; return mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type, mFeature.mName + &quot;:&quot; + mMinLayer + &quot;:&quot; + mMaxLayer, mFeature.mId);&#125; PA的mFeature只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）: 当mFeature为null时，也就是当前PA是leafArea(即PA为TOKENS、TASK或者IME时)，直接创建Tokens,然后进行displayAreaForLayer的填充 当mFeature不为null时，通过mNewDisplayAreaSupplier创建DisplayArea 当feature为FEATURE_WINDOWED_MAGNIFICATION，通过DisplayArea.Dimmable::new创建一个Dimmable 其余feature通过DisplayArea::new创建一个DisplayArea 所以遍历PA树生成DisplayArea就是将PA树除root节点之外，给每一个子PA创建一个DisplayArea. 经过这步骤之后，displayAreaForLayer[0~36]中的元素如下： displayAreaForLayer[2] &#x3D; PA_TASK_2_2_tda displayAreaForLayer[15,16] &#x3D; mImeContainer 其余元素皆为新建的DisplayArea.Tokens 2.5.3 RootDisplayArea.onHierarchyBuilt1234567891011void onHierarchyBuilt(ArrayList&lt;Feature&gt; features, DisplayArea.Tokens[] areaForLayer, Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; featureToDisplayAreas) &#123; if (mHasBuiltHierarchy) &#123; throw new IllegalStateException(&quot;Root should only build the hierarchy once&quot;); &#125; mHasBuiltHierarchy = true; mFeatures = Collections.unmodifiableList(features); // 注意这里将构建的displayAreaForLayer保存在了mAreaForLayer中 mAreaForLayer = areaForLayer; mFeatureToDisplayAreas = featureToDisplayAreas;&#125; 很简单，仅仅是将传入的参数保存起来。并且将mHasBuiltHierarchy标记为true, 表明RootTaskDisplayArea仅仅需要构建一次层次结构。 三. 小结Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。 这里的DisplayContent是继承了RootDisplayArea, 其对应的Feature是FEATURE_ROOT，表示是该逻辑显示设备上的根显示区域。DisplayContent的初始化中做了很多工作，包括创建SurfaceControl，创建DisplayPolicy等等，重点是初始化DisplayAreaPolicy，而DisplayAreaPolicy的初始化过程中也同时构建了DisplayContent的层次结构器。 这个层次结构的初始化过程稍显复杂，可以看 HierarchyBuilder.build 上面的分析，大致分为四个部分: 第一部分 Layer的数量为37个,最上层是root, 默认DisplayArea的Feature有六个 第二部分 构造PA树 按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部 依次编译该feature中定义的mWindowLayer数组，该数组由37个boolean值组成，从小到大一次对应37层layer 如果mWindowLayer[layer]的值为true, 那么根据需要创建子PA 第三部分 遍历第二部分创建的PA树，根据window类型创建对应叶子节点的PA 第四部分 为PA树的每个PA创建对应的DisplayArea，并将结果存储在RootDisplayArea（DisplayContent）中 接下来我们分析WindowToke到底是如何管理的，包括WindowState的作用，而且我们分析WindowState创建的时候发现会抛出异常，这个问题我们下篇文章分析。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"}]},{"title":"WMS(1)-服务启动和Activity窗口回顾","slug":"WMS(1)-服务启动和Activity窗口回顾","date":"2022-04-30T17:35:34.000Z","updated":"2022-06-18T09:56:31.787Z","comments":true,"path":"2022/05/01/WMS(1)-服务启动和Activity窗口回顾/","link":"","permalink":"https://swallowjoe.github.io/2022/05/01/WMS(1)-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%92%8CActivity%E7%AA%97%E5%8F%A3%E5%9B%9E%E9%A1%BE/","excerpt":"以下分析基于Android S. 简述之前我们通过Vsync这个Android绘制的脉搏疏通了绘制的流程，在Activity的显示研究过程中，粗略接触了WindowManagerService，也即Android的窗口管理。 接下来我们深入探讨一下Android中的窗口管理设计，以便我们理解View、Activity、Window、Task等之间的关系。 首先还是从WindowManagerService服务的启动开始，在Android开机流程中，我们知道WMS是在引导服务和核心服务启动之后才会开始的:","text":"以下分析基于Android S. 简述之前我们通过Vsync这个Android绘制的脉搏疏通了绘制的流程，在Activity的显示研究过程中，粗略接触了WindowManagerService，也即Android的窗口管理。 接下来我们深入探讨一下Android中的窗口管理设计，以便我们理解View、Activity、Window、Task等之间的关系。 首先还是从WindowManagerService服务的启动开始，在Android开机流程中，我们知道WMS是在引导服务和核心服务启动之后才会开始的: 123456789101112131415161718192021222324private void startOtherServices(@NonNull TimingsTraceAndSlog t) &#123; ... t.traceBegin(&quot;StartWindowManagerService&quot;); // WMS needs sensor service ready ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE); mSensorServiceStart = null; // 1.1 WMS的初始化 wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore, new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager); // 发布WMS ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); t.traceEnd(); t.traceBegin(&quot;SetWindowManagerService&quot;); mActivityManagerService.setWindowManager(wm); t.traceEnd(); t.traceBegin(&quot;WindowManagerServiceOnInitReady&quot;); wm.onInitReady(); t.traceEnd();&#125; 这里眼尖的同学发现了，WMS的启动必须等待SensorService的启动完毕，为什么呢,后面给出答案。 一. WMS启动从上面也看出了，WMS的启动是先调用了其静态方法main, 并传入context, inputManager及ActivityTaskManager等，还有一个WindowManagerPolicy子类PhoneWindowManager的对象. 1.1 WindowManagerService.main123456789101112131415161718192021222324public static WindowManagerService main(final Context context, final InputManagerService im, final boolean showBootMsgs, final boolean onlyCore, WindowManagerPolicy policy, ActivityTaskManagerService atm) &#123; return main(context, im, showBootMsgs, onlyCore, policy, atm, SurfaceControl.Transaction::new, Surface::new, SurfaceControl.Builder::new);&#125;/** * Creates and returns an instance of the WindowManagerService. This call allows the caller * to override factories that can be used to stub native calls during test. */@VisibleForTestingpublic static WindowManagerService main(final Context context, final InputManagerService im, final boolean showBootMsgs, final boolean onlyCore, WindowManagerPolicy policy, ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory, Supplier&lt;Surface&gt; surfaceFactory, Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory) &#123; // 使用&quot;android.display&quot;线程初始化WindowManagerService // 初始化没有结束时，调用main的线程会被阻塞 DisplayThread.getHandler().runWithScissors(() -&gt; sInstance = new WindowManagerService(context, im, showBootMsgs, onlyCore, policy, atm, transactionFactory, surfaceFactory, surfaceControlFactory), 0); return sInstance;&#125; 这里使用的双冒号”::”、Supplier以及Function都是java8引入的函数式编程语法。这里值得注意的是runWithScissors方法。 1.2 DisplayThread.getHandler123456789101112131415161718192021222324252627public final class DisplayThread extends ServiceThread &#123; private static DisplayThread sInstance; private static Handler sHandler; private DisplayThread() &#123; // DisplayThread runs important stuff, but these are not as important as things running in // AnimationThread. Thus, set the priority to one lower. super(&quot;android.display&quot;, Process.THREAD_PRIORITY_DISPLAY + 1, false /*allowIo*/); &#125; private static void ensureThreadLocked() &#123; if (sInstance == null) &#123; sInstance = new DisplayThread(); sInstance.start(); sInstance.getLooper().setTraceTag(Trace.TRACE_TAG_SYSTEM_SERVER); sHandler = new Handler(sInstance.getLooper()); &#125; &#125; public static Handler getHandler() &#123; synchronized (DisplayThread.class) &#123; ensureThreadLocked(); return sHandler; &#125; &#125; ...&#125; 由此可以看出DisplayThread其实就是Android里的”android.display”线程，优先级仅仅比THREAD_PRIORITY_DISPLAY低一档。 1.2.1 Handler.runWithScissors12345678910111213141516171819/** * @hide */public final boolean runWithScissors(@NonNull Runnable r, long timeout) &#123; if (r == null) &#123; throw new IllegalArgumentException(&quot;runnable must not be null&quot;); &#125; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeout must be non-negative&quot;); &#125; if (Looper.myLooper() == mLooper) &#123; r.run(); return true; &#125; BlockingRunnable br = new BlockingRunnable(r); return br.postAndWait(this, timeout);&#125; 这里可以看到该方法首先检查了参数合法性，然后判断当前允许的线程是否是Handler处理线程: 如果是Handler处理线程，则执行runnable 如果不是，则创建一个BlockingRunnable，执行其postAndWait方法 从postAndWait名字中可以推测，必定是需要等待指定runnable在Handler处理线程上执行完毕后，调用runWithScissors的线程才能继续运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static final class BlockingRunnable implements Runnable &#123; private final Runnable mTask; private boolean mDone; public BlockingRunnable(Runnable task) &#123; mTask = task; &#125; @Override public void run() &#123; try &#123; mTask.run(); &#125; finally &#123; // runnable执行完毕后标记mDone为true,然后通知所以等待线程 synchronized (this) &#123; mDone = true; notifyAll(); &#125; &#125; &#125; public boolean postAndWait(Handler handler, long timeout) &#123; // 当handler中已经存在此runnable时，返回false if (!handler.post(this)) &#123; return false; &#125; synchronized (this) &#123; if (timeout &gt; 0) &#123; final long expirationTime = SystemClock.uptimeMillis() + timeout; while (!mDone) &#123; long delay = expirationTime - SystemClock.uptimeMillis(); if (delay &lt;= 0) &#123; return false; // timeout &#125; try &#123; // 等待delay时长 wait(delay); &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; else &#123; while (!mDone) &#123; try &#123; wait(); &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; &#125; return true; &#125;&#125; 所以runWithScissors方法为啥会标记为hide呢，明明很好的实现了将某个任务放到指定线程执行并等待该任务执行完毕后继续。 考虑到如果等待超时，postAndWait返回的也是false,但是对应runnable的message仍旧处于Handler的MessageQueue之中，这样该runnable最终还是会被执行的。 可能造成死锁，因为runWithScissors所处线程会一直等待，除非超时。比如任务所处的handler的Looper被调用了quit()退出时。我们知道quit方法是会清理Looper的MessageQueue中所有消息，如果此时timeout的时间设置的是0，那么runWithScissors方法所处的线程会一直等到天荒地老。除非Looper退出时是调用的quitSafely(), 该方法只会清空MessageQueue中当前时间点之后的message,在这之前的message仍会被执行。 而我们知道，DisplayThread代表线程是不会退出的(除非关机), 所以这里调用runWithScissors是安全的。 1.3 WindowManagerService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private WindowManagerService(Context context, InputManagerService inputManager, boolean showBootMsgs, boolean onlyCore, WindowManagerPolicy policy, ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory, Supplier&lt;Surface&gt; surfaceFactory, Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory) &#123; // 在LockGuard中创建代表WINDOW的Lock, 可以帮助检测系统服务内部锁的机制 installLock(this, INDEX_WINDOW); ... // 标记当前设备是否是可触摸的 mInTouchMode = context.getResources().getBoolean( com.android.internal.R.bool.config_defaultInTouchMode); // 设置是否允许触摸，现在手机、平板设备一般都是可触摸的 inputManager.setInTouchMode(mInTouchMode); ... // 通过surfaceControlFactory可以直接生成SurfaceControl.Builder的对象 mSurfaceControlFactory = surfaceControlFactory; // 其实是实现了Supplier接口的SurfaceControl.Transaction::new mTransactionFactory = transactionFactory; // 其实是实现了Supplier接口Surface::new mSurfaceFactory = surfaceFactory; // 创建Transaction对象, 注意每次调用get方法生成的都是新的SurfaceControl.Transaction对象 mTransaction = mTransactionFactory.get(); // 这个policy就是PhoneWindowPolicy mPolicy = policy; // 创建WindowAnimator mAnimator = new WindowAnimator(this); // 创建RootWindowContainer mRoot = new RootWindowContainer(this); ... // 創建WindowSurfacePlacer，如其名，用於定位窗口及其表面 // 通过计算窗口的框架来设置窗口的位置，然后根据这些框架来定位Surface mWindowPlacerLocked = new WindowSurfacePlacer(this); // 創建TaskSnapshotController，用於获取相应任务的快照(位图)并将其放入缓存 mTaskSnapshotController = new TaskSnapshotController(this); ... // 创建WakeLock,用于在转屏等动作时保持cpu不休眠 mScreenFrozenLock = mPowerManager.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, &quot;SCREEN_FROZEN&quot;); mScreenFrozenLock.setReferenceCounted(false); // 用于管理监听Display的层次属性变化的监听器 mDisplayNotificationController = new DisplayWindowListenerController(this); ... // 创建WakeLock,在必要时保持屏幕常量 mHoldingScreenWakeLock = mPowerManager.newWakeLock( PowerManager.SCREEN_BRIGHT_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG_WM); mHoldingScreenWakeLock.setReferenceCounted(false); // 用于执行不需要持有WindowManager的锁的窗口动画 mSurfaceAnimationRunner = new SurfaceAnimationRunner(mTransactionFactory, mPowerManagerInternal); ... // 用于任务拖动定位的控制器 mTaskPositioningController = new TaskPositioningController( this, mInputManager, mActivityTaskManager, mH.getLooper()); // 该类处理并组合从多个视图中生成的拖动事件，然后向任何已经注册了回调的ondragdroplistener触发事件。 mDragDropController = new DragDropController(this, mH.getLooper()); // 用于强制显示高刷新率的包的Denylist mHighRefreshRateDenylist = HighRefreshRateDenylist.create(context.getResources()); ... // 创建DisplayAreaPolicyProvider，用于后续的DisplayAreaPolicy的构建 mDisplayAreaPolicyProvider = DisplayAreaPolicy.Provider.fromResources( mContext.getResources()); ... // 设置全局阴影 setGlobalShadowSettings(); mAnrController = new AnrController(this); // 管理创建和释放启动窗口Surface mStartingSurfaceController = new StartingSurfaceController(this);&#125; 这里省略的很多设置代码，仅贴了一些比较重要或者有趣的类对象初始化。 二. Activity的Window创建之前我们在*Activity的显示(1)*一文中有分析过，应用的Activity在onCreate方法中setContentView设置了UI布局，之后在该Activity第一次resume时，初始化ViewRootImpl，当该Activity是应用进程第一个被resume的Activity时，建立进程与WMS的通信通道，也就是WindowSession! 最后ViewRootImpl的setView方法中，通过binder调用WindowManager的addToDisplay,之后进入到SystemServer进程调用到WMS.addWindow，在这里创建该Activity对应的WindowState,并保存在mWindowMap中。 如下即是WMS中addWindow的关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public int addWindow(Session session, IWindow client, LayoutParams attrs, int viewVisibility, int displayId, int requestUserId, InsetsState requestedVisibility, InputChannel outInputChannel, InsetsState outInsetsState, InsetsSourceControl[] outActiveControls) &#123; ...... synchronized (mGlobalLock) &#123; ...... final DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token); ...... ActivityRecord activity = null; final boolean hasParent = parentWindow != null; WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); final int rootType = hasParent ? parentWindow.mAttrs.type : type; boolean addToastWindowRequiresToken = false; final IBinder windowContextToken = attrs.mWindowContextToken; if (token == null) &#123; if (hasParent) &#123; ...... &#125; else &#123; // 一般走这里创建WindowToken final IBinder binder = attrs.token != null ? attrs.token : client.asBinder(); token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow, isRoundedCornerOverlay); &#125; &#125; ... // 初始化WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], attrs, viewVisibility, session.mUid, userId, session.mCanAddInternalSystemWindow); ...... // 创建SurfaceSession, 用来和SurfaceFlinger通信 win.attach(); // 保存WindowState mWindowMap.put(client.asBinder(), win); ...... win.mToken.addWindow(win); ...... ......&#125; 如上，我们可以看到WMS中几个关键的类: WindowState,WindowToken,ActivityRecord等。之前我们就绘制过这个类图： WindowToken: 是在WindowManagerService 中定义的一个基类，顾名思义，它是用来标识某一个窗口。可以把WindowToken看成是一个显示令牌，无论是系统窗口还是应用窗口，添加新的窗口时需要使用这个令牌向WMS表明自己的身份，添加窗口(addWindow)时会创建WindowToken，销毁窗口的时候移除WindowToken(removeWindowToken方法)。 ActivityRecord(原AppWindowToken): 顾名思义，它是用来标识app, 跟准确的说法，是用来标识某个具体的Activity. App每个的Activity对应一個ActivityRecord。其中的appToken為IApplicationToken.Stub类型，有了它就可以找到对应的ActivityRecord. 从上面的关系图也能发现，这个WindowToken中token是关键点，我们尚未理清这个值的含义，接下来我们分析一下这个token的来源： 2.1 PhoneWindow的创建简单回顾一下 Activity 对应的 PhoneWindow的创建，注意这里仅仅是App进程中的Window. 我们从handleLaunchActivity开始: 123456public Activity handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent) &#123; ...... final Activity a = performLaunchActivity(r, customIntent); ......&#125; 2.1.1 performLaunchActivity12345678910111213141516171819202122232425262728293031private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; ...... Activity activity = null; try &#123; java.lang.ClassLoader cl = appContext.getClassLoader(); // 通过反射生成Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ...... &#125; try &#123; // 创建应用Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) &#123; ...... // 这里传入的window一般是null的 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback, r.assistToken, r.shareableActivityToken); ...... synchronized (mResourcesManager) &#123; // 将该Activity保存至mActivities集合中，key值就是ActivityClientRecord中的token mActivities.put(r.token, r); &#125; &#125; ......&#125; 每次调用performLaunchActivity就一定会创建一个新的Activity对象，并保存在mActivities集合中。 2.1.2 Activity.attach123456789101112131415161718192021222324252627282930313233final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken, IBinder shareableActivityToken) &#123; ...... // 创建Activity对应的PhoneWindow mWindow = new PhoneWindow(this, window, activityConfigCallback); mWindow.setWindowControllerCallback(mWindowControllerCallback); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; ...... // 设置PhoneWindow的WindowManager mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); // 当Activity的parent不为空时，该Activity的PhoneWindow对应的容器就是其parent对应的窗口 if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; ......&#125; 可以看到一个Activity对应一个PhoneWindow, 而且PhoneWindow是在Activity launch的时候才创建的。 2.2 WindowToken中token的作用我们假设添加window的Activity是该应用第一个被resume的activity： 123456789101112131415161718192021222324252627//WMS.addWindow函数中：final IBinder binder = attrs.token != null ? attrs.token : client.asBinder();token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);// WindowToken.javaWindowToken(WindowManagerService service, IBinder _token, int type, boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay) &#123; this(service, _token, type, persistOnEmpty, dc, ownerCanManageAppTokens, roundedCornerOverlay, false /* fromClientToken */, null /* options */);&#125;WindowToken(WindowManagerService service, IBinder _token, int type, boolean persistOnEmpty, DisplayContent dc, boolean ownerCanManageAppTokens, boolean roundedCornerOverlay, boolean fromClientToken, @Nullable Bundle options) &#123; super(service); token = _token; windowType = type; mOptions = options; mPersistOnEmpty = persistOnEmpty; mOwnerCanManageAppTokens = ownerCanManageAppTokens; mRoundedCornerOverlay = roundedCornerOverlay; mFromClientToken = fromClientToken; if (dc != null) &#123; dc.addWindowToken(token, this); &#125;&#125; 从WindowToken的构造函数和其初始化的传参中可以看到，WindowToken中的token就是attrs的token,或者是client(IWindow)转换来的。 2.2.1 LayoutParams中的token溯源addWindow, 在ViewRootImpl.setView时，会将该LayoutParams作为参数传入，注意，有两个LayoutParams，一个是WindowManager.LayoutParams, 一个是其父类ViewGroup.LayoutParams: 而ViewRootImpl.setView也是在 WindowManagerGlobal.addView 时调用的,也就是ActivityThread处理该Activity的Resume状态时： 1234567891011121314151617181920212223242526272829public void handleResumeActivity(ActivityClientRecord r, boolean finalStateRequest, boolean isForward, String reason) &#123; ...... final Activity a = r.activity; ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); // 现将该View设置为不可见 decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); // 从这里拿到的params, 所以token也需要查一下这个LayoutParams // 最后可以发现是在PhoneWindow创建时候创建的默认值，token还是null的 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; // 注意这里type表示为应用窗口 l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; // 这里的wm是Activity中保存的WindowManager, 是该Activity被创建 // 后调用其attach函数创建Window时的WindowManagerImpl,这一部分我 // 们在Activity的显示(1)中有分析 wm.addView(decor, l); ...... ...... ......&#125; 从上可以看出只有当该Activity的window是尚未被添加且此次resume状态时是需要可见的时候，才会将该Activity对应View添加至WindowManager中： 1234567891011121314151617181920212223// WindowManagerImpl.addView@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyTokens(params); // 这里的WMI是在Activity调用attach时通过createLocalWindowManager创建的 // mParentWindow就是创建该WMI的window,即Activity里的PhoneWindow mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow, mContext.getUserId());&#125;private void applyTokens(@NonNull ViewGroup.LayoutParams params) &#123; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; // Only use the default token if we don&#x27;t have a parent window and a token. if (mDefaultToken != null &amp;&amp; mParentWindow == null &amp;&amp; wparams.token == null) &#123; // token在此赋值吗？其实一般不是的，这个mDefaultToken只有AccessibilityService中会设置 // 所以mDefaultToken还是null的 wparams.token = mDefaultToken; &#125; wparams.mWindowContextToken = mWindowContextToken;&#125; 虽然不是在此追踪，但是我们可以发现mGlobal.addView中的LayoutParams仍然是ViewGroup.LayoutParams类型，其并不带有token成员。 123456789101112131415161718192021// WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) &#123; ...... // 因为WindowManager.LayoutParams是ViewGroup.LayoutParams子类，所以可以强制转换 // 但是token默认是null的 final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; // parentWindow一般不为null,如果是ApplicationType的window，这就是resume的Activity里的PhoneWindow自身 if (parentWindow != null) &#123; // 调整 WindowManager.LayoutParams parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; ...... synchronized (mLock) &#123; // 2.3 创建ViewRootImpl root = new ViewRootImpl(view.getContext(), display); ...... root.setView(view, wparams, panelParentView, userId); ...... &#125;&#125; 注意每个Activity对应一个PhoneWindow, 一个PhoneWindow对应一个WindowManager(即WindowManagerImpl), 而PhoneWindow继承自Window。PhoneWindow在其对应的Activity被调用attach时创建， 然后会创建WindowManagerImpl，保存在PhoneWindow的mWindowManager成员中。 12345678910111213141516171819202122232425262728293031// Window.java// Activity.attach -&gt; PhoneWindow.setWindowManager-&gt;public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; // 这个就是Activity中的 mToken, 对应的是LocalActivityManager.LocalActivityRecord // 顺便说一下这个token是在startActivity时创建的 mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated; if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);&#125;// ActivityThread.handleResumeActivity-&gt;WindowManagerImpl.addView-&gt;WindowManagerGlobal.addView-&gt;void adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123; CharSequence curTitle = wp.getTitle(); // 在handleResumeActivity我们可以看到这个type被指明为TYPE_BASE_APPLICATION if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; ...... &#125; else &#123; // 到目前为止，token确实是null的 if (wp.token == null) &#123; // mContainer是包含此窗户的容器，没有设置时，DecorWindow将作为顶级窗口 wp.token = mContainer == null ? mAppToken : mContainer.mAppToken; &#125; ...... ......&#125; 一般Window的mContainer是null的，所以wp.token就是Window的mAppToken,也即Activity中的mToken, 对应LocalActivityManager.LocalActivityRecord, 通过此变量可以快速找到Activity、ActivityInfo、Window等。所以最后Activity对应的WindowState中对应的WindowToken里的token成员变量就是Activity中的mToken. 2.3 Activity的View与Window的关系在应用的一个Activity对象即将resume时，会通过WindowManagerImpl将View与该Activity对应的PhoneWindow关联起来。这部分发生WindowManagerGlobal.addView中： 123456789101112// WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow, int userId) &#123; ...... synchronized (mLock) &#123; // 创建ViewRootImpl root = new ViewRootImpl(view.getContext(), display); ...... root.setView(view, wparams, panelParentView, userId); ...... &#125;&#125; 这里传入的View 就是 r.window.getDecorView() 获取的decorView; 而parentWindow就是该Activity首次launch时创建的PhoneWindow（如果没有parent Activity时） 简单回顾下 PhoneWindow 的 DecorView是怎么来的： 在Activity被launch后，会调用其onCreate方法 应用会在这个方法中调用setContentView, 将该Activity对应的View或者layout资源ID传入 然后在调用该Activity对应PhoneWindow的setContentView方法 如果是首次调用，则先调用installDecor方法创建DecorView 之后通过PhoneWindow中的mLayoutInflater将该View实例化 最后将该View保存在PhoneWindow的ViewGroup对象mContentParent中 这部分的流程比如installDecor方法我们之后讨论View的生成时再详细分析。所以简单来说，Activity对应的layout视图作为一个子视图保存在这个Activity对应PhoneWindow的DecorView中。 2.4 IWindowSession - PhoneWindow与WMS的交互Activity对应的Window和WMS的交互肯定是双向的，那么: Activity对应的PhoneWindow需要保存WMS的client端 WMS需要保存该PhoneWindow的client端 毫无疑问，PhoneWindow中保存WMS的client端就是对应的IWindowManager, 保存在WindowManagerGlobal中。而PhoneWindow会用在其对应的ViewRootImpl中继承了IWindow.Stub的W类的对象，通过binder传递到WMS中，作为PhoneWindow在WMS中的client端： 12345678910111213141516171819202122232425// ViewRootImpl.javapublic ViewRootImpl(Context context, Display display) &#123; this(context, display, WindowManagerGlobal.getWindowSession(), false /* useSfChoreographer */);&#125;public ViewRootImpl(@UiContext Context context, Display display, IWindowSession session, boolean useSfChoreographer) &#123; mContext = context; mWindowSession = session; ...... // 创建W对象 mWindow = new W(this); ......&#125;public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView, int userId) &#123; ....... res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), userId, mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets, mTempControls); ......&#125; 由此可见，ViewRootImpl发挥这至关重要的作用，其不仅包含Activity对应的View, PhoneWindow及该Window的属性LayoutParams, 还保存着作为WMS中该Activity的Window的服务端W类的对象。 之前我们略有分析mWindowSession的创建，这里我们直接给出时序图： 之前我们也说过: IWindowManager 对应WindowManagerService, 应用进程端通过这个接口即可向WMS传递消息. IWindowSession 通过这个Session和WMS中的Session交互.暂时还不理解这个作用 W extends IWindow 对应应用进程端的窗口, WMS通过这个向应用进程的Window发送消息. 现在我们分析IWindowSession的方法其实不难理解，IWindowSession是为了方便管理某个应用的某个Window与WMS通信的，虽然最后也是与WMS通信，但是将通信过程也视为一个对象，方便了管理。 三. 小结本文中分析了Android显示框架中Framework层最重要的WMS服务启动过程，以及复习了Activity窗口的创建过程。 3.1 WMS服务启动 WMS服务是在引导服务和核心服务启动之后启动的，而且必须等待Sensor服务的启动完毕。 WMS服务的启动首先初始化了”android.display”线程，然后将启动过程放在此线程中处理，主线程阻塞等待该启动完毕。 WMS服务的创建过程： 创建了WindowAnimator 创建RootWindowContainer 创建WindowSurfacePlacer，如其名，用於定位窗口及其表面 创建TaskSnapshotController，用於获取相应任务的快照(位图)并将其放入缓存 设置全局阴影等等 WMS服务创建完毕后，通过ServiceManager将其发布，服务名为Context.WINDOW_SERVICE 3.2 Activity、Window与WindowManagerService Activity在第一次启动后，调用attach方法时，会创建PhoneWindow以及对应的WindowManagerImpl 在Activity第一次resume时，调用该Activity的WindowManagerImpl创建ViewRootImpl 在创建ViewRootImpl之前，会通过adjustLayoutParamsForSubWindow将该Activity的mToken保存在PhoneWindow的LayoutParams中 创建ViewRootImpl过程中，会通过IWindowManager与WMS通信，创建IWindowSession, 用于该Activity的Window和WMS通信 创建ViewRootImpl之后，再通过期间创建的IWindowSession与将该Activity的IWindow、相关Window属性传递给WMS. 接下来我们看看WMS是怎么管理不同应用的Window的。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"}]},{"title":"Binder(5)--binder驱动响应ioctl","slug":"Binder-5-binder驱动响应ioctl","date":"2022-04-04T02:38:44.000Z","updated":"2022-04-04T02:44:23.947Z","comments":true,"path":"2022/04/04/Binder-5-binder驱动响应ioctl/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/","excerpt":"简介接上文，我们现在了解了binder驱动的加载过程，回过头继续分析App使用Binder通信的过程。 先回顾下App使用binder通信的大致过程： 创建AIDL文件，定义接口函数并在服务端app中实现,并注册进SystemServer 客户端app通过SystemServer获取服务端注册的Service所代表的IBinder(BpBinder) Client app &lt;–&gt; SystemServer &lt;–&gt; Server app Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。 客户端app通过该IBinder与服务端app直接通信。 之前我们分析到最后一步是：IPCThreadState#talkWithDriver","text":"简介接上文，我们现在了解了binder驱动的加载过程，回过头继续分析App使用Binder通信的过程。 先回顾下App使用binder通信的大致过程： 创建AIDL文件，定义接口函数并在服务端app中实现,并注册进SystemServer 客户端app通过SystemServer获取服务端注册的Service所代表的IBinder(BpBinder) Client app &lt;–&gt; SystemServer &lt;–&gt; Server app Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。 客户端app通过该IBinder与服务端app直接通信。 之前我们分析到最后一步是：IPCThreadState#talkWithDriver 123456789101112131415161718192021222324status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; // ...... do &#123; // ..... // 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno; // ..... if (mProcess-&gt;mDriverFD &lt; 0) &#123; err = -EBADF; &#125; IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Finished read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125; &#125; while (err == -EINTR); // ...... return err;&#125; 在前面我们也了解了ioctl的用法，简单回顾下: int ioctl(int fd, unsigned long request, …); fd 必须是打开文件描述符。 cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作 argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。 这里我们还不知道此处的ioctl是怎么和binder驱动勾搭上的，是因为我们之前分析客户端app使用ioctl的时候忽略了IPCThreadState的初始化。 传入的参数mProcess-&gt;mDriverFD这个文件描述符是怎么获取的呢，接下来先看IPCThreadState的初始化。 一. IPCThreadState的初始化我们在调用transact的时候，会先调用self()函数，这个函数就是初始化用的。 12IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); 1.1 IPCThreadState::self123456789101112131415161718192021222324252627282930313233343536373839404142434445static pthread_mutex_t gTLSMutex = PTHREAD_MUTEX_INITIALIZER;static std::atomic&lt;bool&gt; gHaveTLS(false);static pthread_key_t gTLS = 0;static std::atomic&lt;bool&gt; gShutdown = false;static std::atomic&lt;bool&gt; gDisableBackgroundScheduling = false;IPCThreadState* IPCThreadState::self()&#123; // gHaveTLS为true说明之前已经初始化过 // 或者说pthread_key_create有被调用过，及本线程私有数据内存空间已开辟 if (gHaveTLS.load(std::memory_order_acquire)) &#123;restart: const pthread_key_t k = gTLS; // 取得本线程对应关键字gTLS所关联的私有数据空间首址 IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); // 如果不为null,直接返回, 当然如果是第一次进入肯定为null的。 if (st) return st; // 1.2 实例化IPCThreadState return new IPCThreadState; &#125; // 处于shutdown时直接返回null if (gShutdown.load(std::memory_order_relaxed)) &#123; ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\\n&quot;); return nullptr; &#125; pthread_mutex_lock(&amp;gTLSMutex); if (!gHaveTLS.load(std::memory_order_relaxed)) &#123; // 创建关键字gTLS及其对应的内存释放函数threadDestructor // 关键字关联线程私有数据空间首址，初始化时是NULL int key_create_value = pthread_key_create(&amp;gTLS, threadDestructor); if (key_create_value != 0) &#123; pthread_mutex_unlock(&amp;gTLSMutex); ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\\n&quot;, strerror(key_create_value)); return nullptr; &#125; // 表明线程私有数据内存空间已开辟 gHaveTLS.store(true, std::memory_order_release); &#125; pthread_mutex_unlock(&amp;gTLSMutex); // 回到restart中准备实例化IPCThreadState goto restart;&#125; 在Linux 中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone() 。该系统copy 了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。copy 后的进程和原先的进程共享了所有的变量，运行环境（clone的实现是可以指定新进程与老进程之间的共享关系，100%共享就表示创建了一个线程）。这样，原先进程中的变量变动在copy 后的进程中便能体现出来。 1.2 IPCThreadState实例化12345678910111213141516IPCThreadState::IPCThreadState() // 1.2.1 创建ProcessState : mProcess(ProcessState::self()), mServingStackPointer(nullptr), mWorkSource(kUnsetWorkSource), mPropagateWorkSource(false), mStrictModePolicy(0), mLastTransactionBinderFlags(0), mCallRestriction(mProcess-&gt;mCallRestriction)&#123; // 将自身存入关键字gTLS对应的线程私有数据空间中，缓存以备后续使用 pthread_setspecific(gTLS, this); clearCaller(); mIn.setDataCapacity(256); mOut.setDataCapacity(256);&#125; 1.３ ProcessState::self12345678910111213141516#ifdef __ANDROID_VNDK__const char* kDefaultDriver = &quot;/dev/vndbinder&quot;;#elseconst char* kDefaultDriver = &quot;/dev/binder&quot;;#endifsp&lt;ProcessState&gt; ProcessState::self()&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != nullptr) &#123; return gProcess; &#125; // 这里假定kDefaultDriver为&quot;/dev/binder&quot; gProcess = new ProcessState(kDefaultDriver); return gProcess;&#125; 1.４ ProcessState实例化123456789101112131415161718192021222324252627282930ProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) // 1.5 打开binder驱动，获取其文件描述符 , mDriverFD(open_driver(driver)) , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mBinderContextCheckFunc(nullptr) , mBinderContextUserData(nullptr) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE)&#123; // ...... if (mDriverFD &gt;= 0) &#123; // 将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。 mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) &#123; // *sigh* ALOGE(&quot;Using %s failed: unable to mmap transaction memory.\\n&quot;, mDriverName.c_str()); close(mDriverFD); mDriverFD = -1; mDriverName.clear(); &#125; &#125; // ......&#125; 1.5 open_driver - 打开binder驱动1234567891011121314151617181920212223242526272829303132static int open_driver(const char *driver)&#123; // 1.5.1 打开/dev/binder驱动 int fd = open(driver, O_RDWR | O_CLOEXEC); if (fd &gt;= 0) &#123; int vers = 0; // 1.5.2 ioctl通信!!! status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result == -1) &#123; ALOGE(&quot;Binder ioctl to obtain version failed: %s&quot;, strerror(errno)); close(fd); fd = -1; &#125; if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123; ALOGE(&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;, vers, BINDER_CURRENT_PROTOCOL_VERSION, result); close(fd); fd = -1; &#125; // #define DEFAULT_MAX_BINDER_THREADS 15 // 默认最大binder线程数目是15个 size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; // 1.5.2 ioctl通信，设置当前进程的最大binder线程数为15 result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); if (result == -1) &#123; ALOGE(&quot;Binder ioctl to set max threads failed: %s&quot;, strerror(errno)); &#125; &#125; else &#123; ALOGW(&quot;Opening &#x27;%s&#x27; failed: %s\\n&quot;, driver, strerror(errno)); &#125; return fd;&#125; 这里首先使用open函数打开对应目录的驱动文件，成功打开后调用ioctl函数获取Binder版本，最后还是通过ioctl设置最大binder线程。 我们常听闻在Linux中，一切皆文件，这里就体现出来了。回顾下binder驱动注册进文件系统时的操作函数集: 1234567891011// android/kernel/msm-4.19/drivers/android/binder.cconst struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 1.5.1 open函数-binder_open在app进程中通过open函数打开&#x2F;dev&#x2F;binder文件，就会调用到binder.c中的binder_open函数了。 我们来看看这个open的时候驱动里面具体做了什么吧，至于用户进程中调用open进而使用系统调用进入内核态调用到binder_open的方式我们后续分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114static int binder_open(struct inode *nodp, struct file *filp)&#123; // binder_proc代表一个进程 struct binder_proc *proc; struct binder_device *binder_dev; struct binderfs_info *info; struct dentry *binder_binderfs_dir_entry_proc = NULL; binder_debug(BINDER_DEBUG_OPEN_CLOSE, &quot;%s: %d:%d\\n&quot;, __func__, current-&gt;group_leader-&gt;pid, current-&gt;pid); // 给binder_proc分配内核内存 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; // 初始化自旋锁lock,其实是将自旋锁指针lock 指向SPIN_LOCK_UNLOCKED宏 // 该宏的定义在内核文件spinlock_types.h中，它表示自旋锁的状态为未加锁 spin_lock_init(&amp;proc-&gt;inner_lock); spin_lock_init(&amp;proc-&gt;outer_lock); // current是一个内核宏，它是当前进程的指针 // get_task_struct的最终实现是将传入的task_struct的usage加1: // #define get_task_struct(tsk) do &#123; atomic_inc(&amp;(tsk)-&gt;usage); &#125; while(0) // 这个宏的作用是标记传入的task_struct，当期有人在用。 // usage的数量代表正在使用该task_struct的程序数量。 get_task_struct(current-&gt;group_leader); // 将binder_proc的tsk标记为当前进程的主进程 proc-&gt;tsk = current-&gt;group_leader; // 加上互斥锁 mutex_init(&amp;proc-&gt;files_lock); INIT_LIST_HEAD(&amp;proc-&gt;todo); // 确定进程调度策略 if (binder_supported_policy(current-&gt;policy)) &#123; proc-&gt;default_priority.sched_policy = current-&gt;policy; proc-&gt;default_priority.prio = current-&gt;normal_prio; &#125; else &#123; proc-&gt;default_priority.sched_policy = SCHED_NORMAL; proc-&gt;default_priority.prio = NICE_TO_PRIO(0); &#125; // 判断nodp是否是binder_device: // inode-&gt;i_sb-&gt;s_magic == BINDERFS_SUPER_MAGIC // s_magic是在binderfs_fill_super也就是binder驱动挂载时赋值的 if (is_binderfs_device(nodp)) &#123; // 如果是binder_device: // 回忆下上一篇文章3.4 binderfs.c#binderfs_binder_device_create // 我们将创建的binder_device存入了i_private数据中 binder_dev = nodp-&gt;i_private; info = nodp-&gt;i_sb-&gt;s_fs_info; binder_binderfs_dir_entry_proc = info-&gt;proc_log_dir; &#125; else &#123; binder_dev = container_of(filp-&gt;private_data, struct binder_device, miscdev); &#125; // 标记binder_device的引用计数+1 refcount_inc(&amp;binder_dev-&gt;ref); // binder_proc的上下文 proc-&gt;context = &amp;binder_dev-&gt;context; binder_alloc_init(&amp;proc-&gt;alloc); // binder_stats中BINDER_STAT_PROC类型的创建数加+1 binder_stats_created(BINDER_STAT_PROC); // binder_proc的pid为当前进程的主进程的pid proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads); filp-&gt;private_data = proc; mutex_lock(&amp;binder_procs_lock); // 将当前binder_proc的proc_node加入binder_procs列表中 // binder_procs是binder驱动中存储一系列binder_proc的链表 // 关于binder_proc是如何插入链表中的，我们后续分析，涉及‘传说中’的红黑树操作 // 注意当前虽然是在应用进程中，但此时已经进入内核态了。 hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); mutex_unlock(&amp;binder_procs_lock); // sys/kernel/debug/binder/proc目录存在时 if (binder_debugfs_dir_entry_proc) &#123; char strbuf[11]; snprintf(strbuf, sizeof(strbuf), &quot;%u&quot;, proc-&gt;pid); // proc调试条目是在上下文之间共享的 // 创建当前binder_proc的目录，可以看到在sys/kernel/debug/binder/proc目录下有很多pid的目录 proc-&gt;debugfs_entry = debugfs_create_file(strbuf, 0444, binder_debugfs_dir_entry_proc, (void *)(unsigned long)proc-&gt;pid, &amp;proc_fops); &#125; // 也是binderfs_fill_super中创建的一个目录：/dev/binderfs/binder_logs/proc if (binder_binderfs_dir_entry_proc) &#123; char strbuf[11]; struct dentry *binderfs_entry; snprintf(strbuf, sizeof(strbuf), &quot;%u&quot;, proc-&gt;pid); // 与debugfs类似，进程特定的日志文件在上下文之间共享。 // 如果已经为进程创建了文件，如果同一进程的另一个上下文调用binder_open（） // 则以下binderfs_create_file（）调用将失败，错误代码为EEXIST。 // 因为与debugfs相同，日志文件将包含给定PID的所有上下文的信息。 binderfs_entry = binderfs_create_file(binder_binderfs_dir_entry_proc, strbuf, &amp;proc_fops, (void *)(unsigned long)proc-&gt;pid); if (!IS_ERR(binderfs_entry)) &#123; proc-&gt;binderfs_entry = binderfs_entry; &#125; else &#123; int error; error = PTR_ERR(binderfs_entry); if (error != -EEXIST) &#123; pr_warn(&quot;Unable to create file %s in binderfs (error %d)\\n&quot;, strbuf, error); &#125; &#125; &#125; return 0;&#125; binder_open的函数做的事情也不复杂： 创建binder_proc, 其pid为当前进程的主进程pid 标记binder_device的引用计数+1 将当前binder_proc的proc_node加入binder_procs列表中 创建当前binder_proc的目录，目录名为: sys&#x2F;kernel&#x2F;debug&#x2F;binder&#x2F;proc&#x2F;pid &#x2F;dev&#x2F;binderfs&#x2F;binder_logs&#x2F;proc存在时，也在这个目录下创建对应pid目录 顺便说一下很多Linux内核宏都用 do { code; } while(0) 的形式,这个是确保code不会被打乱，比如： 12345#define demo do &#123; codeA; codeB; &#125; while(0)if (A) demo; //这里展开就不会因为宏内有多行代码而出现逻辑异常nextCodeLine; 1.5.2 binder_ioctl - BINDER_VERSION &amp; BINDER_SET_CONTEXT_MGR_EXT status_t result &#x3D; ioctl(fd, BINDER_VERSION, &amp;vers); 从参数名称可以看到，这里是获取binder版本号。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; /*pr_info(&quot;binder_ioctl: %d:%d %x %lx\\n&quot;, proc-&gt;pid, current-&gt;pid, cmd, arg);*/ // 分配BUFFER_NUM buffers以覆盖所有页面对齐情况，然后以所有可能的顺序释放它们。 // 检查页面是否正确分配，在释放缓冲区时放在lru上，在调用binder_alloc_free_page时释放。 binder_selftest_alloc(&amp;proc-&gt;alloc); trace_binder_ioctl(cmd, arg); // binder_stop_on_user_error是一个int变量，当出现binder_stop_on_user_error错误 // 时为2, 这里的意思是只要这个不为2,使得cpu不休眠。 ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret) goto err_unlocked; // 根据binder_proc获取binder_thread, 后续分析 thread = binder_get_thread(proc); if (thread == NULL) &#123; ret = -ENOMEM; goto err; &#125; switch (cmd) &#123; // ...... case BINDER_SET_CONTEXT_MGR_EXT: &#123; struct flat_binder_object fbo; // 从用户空间拷贝ubuf内容至fbo中，其实就是15，单个进程的最大binder线程数 if (copy_from_user(&amp;fbo, ubuf, sizeof(fbo))) &#123; ret = -EINVAL; goto err; &#125; // 设置单个进程的最大binder数目，默认是15个(app进程) ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo); if (ret) goto err; break; &#125; // ...... case BINDER_VERSION: &#123; struct binder_version __user *ver = ubuf; if (size != sizeof(struct binder_version)) &#123; ret = -EINVAL; goto err; &#125; // 从内核空间获取BINDER_CURRENT_PROTOCOL_VERSION拷贝到用户空间 if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;ver-&gt;protocol_version)) &#123; ret = -EINVAL; goto err; &#125; break; &#125; // ...... return ret;&#125; copy_from_user函数的目的是从用户空间拷贝数据到内核空间，失败返回没有被拷贝的字节数，成功返回0. 123456copy_from_user(void *to, const void __user *from, unsigned long n)1. *to 将数据拷贝到内核的地址2. *from 需要拷贝数据的地址3. n 拷贝数据的长度（字节）也就是将from地址中的数据拷贝到to地址中去，拷贝长度是n 二. ioctl - BINDER_WRITE_READ现在万事具备了，我们继续分析进程间的ioctl通信传输数据, 回到最开始：IPCThreadState#talkWithDriver 其实我们在open_driver - 打开binder驱动的过程中就有分析看到ioctl了。 从代码的角度理解为什么说binder跨进程通信只需要一次内存拷贝。 123// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; 2.1 binder_ioctl - BINDER_WRITE_READ1234567891011121314151617181920212223static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; // ...... switch (cmd) &#123; case BINDER_WRITE_READ: // thread是根据binder_proc获取的binder_thread // 这里的arg就是上面的ioctl的最后一个参数bwr的地址 ret = binder_ioctl_write_read(filp, cmd, arg, thread); if (ret) goto err; break; // ...... ret = 0;err: if (thread) thread-&gt;looper_need_return = false; wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret &amp;&amp; ret != -ERESTARTSYS) pr_info(&quot;%d:%d ioctl %x %lx returned %d\\n&quot;, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);err_unlocked: trace_binder_ioctl_done(ret); return ret;&#125; 2.2 binder.c:binder_ioctl_write_read12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static int binder_ioctl_write_read(struct file *filp, unsigned int cmd, unsigned long arg, struct binder_thread *thread)&#123; int ret = 0; struct binder_proc *proc = filp-&gt;private_data; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; struct binder_write_read bwr; if (size != sizeof(struct binder_write_read)) &#123; ret = -EINVAL; goto out; &#125; // 从用户空间拷贝ubuf内容至bwr中, 一次拷贝：从用户空间到内核空间 if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125; binder_debug(BINDER_DEBUG_READ_WRITE, &quot;%d:%d write %lld at %016llx, read %lld at %016llx\\n&quot;, proc-&gt;pid, thread-&gt;pid, (u64)bwr.write_size, (u64)bwr.write_buffer, (u64)bwr.read_size, (u64)bwr.read_buffer); // 还记得么，这个bwr是在IPCThreadState#talkWithDriver中填充的数据 // write_size 代表 binder in parcel数据大小 // read_size 代表 binder out parcel数据大小 if (bwr.write_size &gt; 0) &#123; // 处理用户进程传来的数据 ret = binder_thread_write(proc, thread, bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); trace_binder_write_done(ret); if (ret &lt; 0) &#123; bwr.read_consumed = 0; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; if (bwr.read_size &gt; 0) &#123; // 处理需要回传的数据 ret = binder_thread_read(proc, thread, bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); trace_binder_read_done(ret); binder_inner_proc_lock(proc); if (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo)) binder_wakeup_proc_ilocked(proc); binder_inner_proc_unlock(proc); if (ret &lt; 0) &#123; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) ret = -EFAULT; goto out; &#125; &#125; binder_debug(BINDER_DEBUG_READ_WRITE, &quot;%d:%d wrote %lld of %lld, read return %lld of %lld\\n&quot;, proc-&gt;pid, thread-&gt;pid, (u64)bwr.write_consumed, (u64)bwr.write_size, (u64)bwr.read_consumed, (u64)bwr.read_size); // 将从内核空间拷贝bwr内容至ubuf中, 一次拷贝：从内核空间到用户空间 // 但是这里是新的数据了，不算是内容的重复拷贝，如果说不需要回传数据，oneway的方式，这个拷贝也不是必要的 if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto out; &#125;out: return ret;&#125; copy_from_user函数的目的是从内核空间拷贝数据到用户空间，失败返回没有被拷贝的字节数，成功返回0. unsigned long copy_to_user(void *to, const void *from, unsigned long n) *to 目标地址（用户空间） *from 源地址（内核空间） n 将要拷贝数据的字节数 返回：成功返回0，失败返回没有拷贝成功的数据字节数 总结可以看到用户进程IPCThreadState的初始化之后会将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。这里就拿到了binder的fd, 保存在用户进程的mDriverFD中, 现在就可以愉快的通信了。 鉴于 binder_thread_write 和 binder_thread_read 函数都特别大，接下来单开两篇分开论述。 之前看 红茶一杯话Binder（传输机制篇_中） 有一张图特别清晰的展现了这里的流程，在此贴出: 参考资料 module_init解析及内核initcall的初始化顺序 https://www.cnblogs.com/chaozhu/p/6410271.html 各种initcall的执行先后顺序 https://blog.csdn.net/fenzhikeji/article/details/6860143 binder 驱动的操作 https://blog.csdn.net/qq_15893929/article/details/103965668 Android的IPC机制Binder的各个部分 http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml 字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 https://blog.csdn.net/weixin_42314225/article/details/81112217 linux文件系统 - 初始化(一) https://www.cnblogs.com/alantu2018/p/8447303.html mount过程分析之五(mount_bdev-&gt;fill_super) https://blog.csdn.net/ZR_Lang/article/details/40115013 VFS四大对象之一 struct super_block https://www.cnblogs.com/linhaostudy/p/7427027.html Linux字符设备驱动file_operations https://www.cnblogs.com/chen-farsight/p/6181341.html 一种linux线程私有数据技术 http://blog.163.com/william_djj@126/blog/static/3516650120085111193035/ pthread_key_t和pthread_key_create()详解 https://www.cnblogs.com/klcf0220/p/5807148.html 腾讯面试题——谈一谈Binder的原理和实现一次拷贝的流程 https://blog.csdn.net/AndroidStudyDay/article/details/93749470 红茶一杯话Binder（传输机制篇_中） https://my.oschina.net/youranhongcha/blog/152963","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Binder","slug":"Android/Binder","permalink":"https://swallowjoe.github.io/categories/Android/Binder/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://swallowjoe.github.io/tags/Binder/"}]},{"title":"Binder(4)--binder驱动的加载","slug":"Binder-4-binder驱动的加载","date":"2022-04-04T02:38:31.000Z","updated":"2022-04-04T02:43:26.817Z","comments":true,"path":"2022/04/04/Binder-4-binder驱动的加载/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/Binder-4-binder%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD/","excerpt":"简介接上文，想要了解binder驱动的工作原理，我们从binder驱动加载过程开始： 在android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c中，我们可以看到有这么一行： 1device_initcall(binder_init); 在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它的initcall 的level为6。 他可以将驱动设备加载进内核中，以供后续使用。","text":"简介接上文，想要了解binder驱动的工作原理，我们从binder驱动加载过程开始： 在android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c中，我们可以看到有这么一行： 1device_initcall(binder_init); 在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它的initcall 的level为6。 他可以将驱动设备加载进内核中，以供后续使用。 一. Linux内核init call过程在Android开机流程(一)一文中有阐述Android开机过程。 我们知道系统加电自检后，引导程序执行完毕，内核映像被加载到内存并获得控制权之后，会启动kernel_init。 1.1 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c12345678static int __ref kernel_init(void *unused)&#123; int ret; // 初始化kernel参数 kernel_init_freeable() ......&#125; 1.2 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:kernel_init_freeable1234567891011121314151617181920212223static noinline void __init kernel_init_freeable(void)&#123; // ...... do_basic_setup(); // ......&#125;static void __init do_basic_setup(void)&#123; // ...... // 调用各种initcall do_initcalls();&#125;static void __init do_initcalls(void)&#123; int level; // initcall_levels 的大小是9，所以这里level是从0到7的 for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++) do_initcall_level(level);&#125; 1.3 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:do_initcall_level12345678910111213141516171819/* Keep these in sync with initcalls in include/linux/init.h */static char *initcall_level_names[] __initdata = &#123; &quot;pure&quot;, &quot;core&quot;, &quot;postcore&quot;, &quot;arch&quot;, &quot;subsys&quot;, &quot;fs&quot;, &quot;device&quot;, &quot;late&quot;,&#125;;static void __init do_initcall_level(int level)&#123; // ...... // 按顺序执行initcall_levels，其实就是initcall_level_names中的顺序。 for (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++) do_one_initcall(initcall_from_entry(fn));&#125; 其实Andorid开机过程中的init.rc中各种init进程和这里类似。 二. binder驱动的初始化在了解Linux内核各种init call之后, 我们注意到binder.c最后几行代码中有这么一行: 1device_initcall(binder_init); 而在android&#x2F;kernel&#x2F;msm-4.9&#x2F;include&#x2F;linux&#x2F;init.h中可以看到定义： 123456789101112131415161718#define pure_initcall(fn) __define_initcall(fn, 0)#define core_initcall(fn) __define_initcall(fn, 1)#define core_initcall_sync(fn) __define_initcall(fn, 1s)#define postcore_initcall(fn) __define_initcall(fn, 2)#define postcore_initcall_sync(fn) __define_initcall(fn, 2s)#define arch_initcall(fn) __define_initcall(fn, 3)#define arch_initcall_sync(fn) __define_initcall(fn, 3s)#define subsys_initcall(fn) __define_initcall(fn, 4)#define subsys_initcall_sync(fn) __define_initcall(fn, 4s)#define fs_initcall(fn) __define_initcall(fn, 5)#define fs_initcall_sync(fn) __define_initcall(fn, 5s)#define rootfs_initcall(fn) __define_initcall(fn, rootfs)// HERE!!!#define device_initcall(fn) __define_initcall(fn, 6)#define device_initcall_sync(fn) __define_initcall(fn, 6s)#define late_initcall(fn) __define_initcall(fn, 7)#define late_initcall_sync(fn) __define_initcall(fn, 7s) 所以binder驱动的加载时机是先于Android的init进程的，在Linux内核启动中是以level为6（device）的优先级加载的。 2.1 binder.c:binder_init1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static int __init binder_init(void)&#123; int ret; char *device_name, *device_tmp; struct binder_device *device; struct hlist_node *tmp; char *device_names = NULL; // 初始化binder缓冲区,其实就是一个list_lru结构体:binder_alloc_lru ret = binder_alloc_shrinker_init(); // ...... // 创建binder相关文件 // 在sys/kernel/debug目录下，创建binder目录 - debugfs是一种用户内核调试的虚拟文件系统 binder_debugfs_dir_entry_root = debugfs_create_dir(&quot;binder&quot;, NULL); // 创建sys/kernel/debug/binder/proc目录 if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(&quot;proc&quot;, binder_debugfs_dir_entry_root); // 创建其余文件 if (binder_debugfs_dir_entry_root) &#123; debugfs_create_file(&quot;state&quot;, 0444, binder_debugfs_dir_entry_root, NULL, // 2.1.1 操作函数的定义 &amp;binder_state_fops); debugfs_create_file(&quot;stats&quot;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_stats_fops); debugfs_create_file(&quot;transactions&quot;, 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_transactions_fops); debugfs_create_file(&quot;transaction_log&quot;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log, &amp;binder_transaction_log_fops); debugfs_create_file(&quot;failed_transaction_log&quot;, 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log_failed, &amp;binder_transaction_log_fops); &#125; // CONFIG_ANDROID_BINDERFS是编译配置,一般都是定义的，所以这个分支不进入 if (!IS_ENABLED(CONFIG_ANDROID_BINDERFS) &amp;&amp; strcmp(binder_devices_param, &quot;&quot;) != 0) &#123; // ...... &#125; // 2.2 初始化binder文件系统 ret = init_binderfs(); if (ret) goto err_init_binder_device_failed; return ret; // ......&#125; 这里主要是创建了sys&#x2F;kernel&#x2F;debug&#x2F;binder目录，以及其子目录或文件: proc:记录调用Binder各个进程的内容 state:记录状态信息，操作函数binder_state_fops stats:记录统计信息，操作函数binder_stats_fops transactions:记录transaction相关信息，操作函数binder_transactions_fops transaction_log:记录transaction日志，操作函数binder_transaction_log_fops failed_transaction_log:记录失败的transaction日志信息，操作函数binder_transaction_log_fops 这里比较奇怪的是没有找到创建文件(目录)时的操作函数的定义,比如binder_state_fops。 2.1.1 操作函数的定义以binder_state_fops为例，其实这些函数的定义是通过宏定义统一实现的。 在文件android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h中我们可以看到有如下函数的声明: 1234567891011int binder_stats_show(struct seq_file *m, void *unused);DEFINE_SHOW_ATTRIBUTE(binder_stats);int binder_state_show(struct seq_file *m, void *unused);DEFINE_SHOW_ATTRIBUTE(binder_state);int binder_transactions_show(struct seq_file *m, void *unused);DEFINE_SHOW_ATTRIBUTE(binder_transactions);int binder_transaction_log_show(struct seq_file *m, void *unused);DEFINE_SHOW_ATTRIBUTE(binder_transaction_log); 我们看binder_state_show这个函数下面的DEFINE_SHOW_ATTRIBUTE这个宏。 2.1.2 DEFINE_SHOW_ATTRIBUTE这个宏的申明是在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;include&#x2F;linux&#x2F;seq_file.h#148 12345678910111213#define DEFINE_SHOW_ATTRIBUTE(__name) \\static int __name ## _open(struct inode *inode, struct file *file) \\&#123; \\ return single_open(file, __name ## _show, inode-&gt;i_private); \\&#125; \\ \\static const struct file_operations __name ## _fops = &#123; \\ .owner = THIS_MODULE, \\ .open = __name ## _open, \\ .read = seq_read, \\ .llseek = seq_lseek, \\ .release = single_release, \\&#125; 把这个宏展开就是: 123456789101112static int __name_open(struct inode *inode, struct file *file)&#123; return single_open(file, __name_show, inode-&gt;i_private);&#125;static const struct file_operations __name_fops = &#123; .owner = THIS_MODULE, .open = __name_open, .read = seq_read, .llseek = seq_lseek, .release = single_release,&#125; 所以，当声明函数binder_state_show时，也就通过DEFINE_SHOW_ATTRIBUTE(binder_state)申明了： 函数: binder_state_open 结构体: binder_state_fops 2.2 init_binderfs 初始化binder文件系统在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h#init_binderfs 12345678#ifdef CONFIG_ANDROID_BINDERFSextern int __init init_binderfs(void);#elsestatic inline int __init init_binderfs(void)&#123; return 0;&#125;#endif 这里的CONFIG_ANDROID_BINDERFS就对应内核编译时的配置:android-base.config#20 1CONFIG_ANDROID_BINDERFS=y y就是定义该宏。 这里是引用了外部文件的函数: init_binderfs, 在该头文件的同目录下的文件binderfs.c可以找到对应函数实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int __init init_binderfs(void)&#123; int ret; const char *name; size_t len; // binder_devices_param是定义在binder.c文件中的： // char *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES; // 而CONFIG_ANDROID_BINDER_DEVICES 是编译配置: // CONFIG_ANDROID_BINDER_DEVICES=&quot;binder,hwbinder,vndbinder&quot; // 所以这里的name就是&quot;binder,hwbinder,vndbinder&quot; name = binder_devices_param; // 验证默认的binderfs设备名是否合法有效 // 检验的方式是判断名字中是否含有字符&#x27;,&#x27; for (len = strcspn(name, &quot;,&quot;); len &gt; 0; len = strcspn(name, &quot;,&quot;)) &#123; // BINDERFS_MAX_NAME = 255 if (len &gt; BINDERFS_MAX_NAME) return -E2BIG; name += len; if (*name == &#x27;,&#x27;) name++; &#125; // 动态分配binder设备编号 ret = alloc_chrdev_region(&amp;binderfs_dev, 0, BINDERFS_MAX_MINOR, &quot;binder&quot;); if (ret) return ret; // 2.2.1 注册binder文件系统 ret = register_filesystem(&amp;binder_fs_type); if (ret) &#123; unregister_chrdev_region(binderfs_dev, BINDERFS_MAX_MINOR); return ret; &#125; return ret;&#125;static struct file_system_type binder_fs_type = &#123; .name = &quot;binder&quot;, .mount = binderfs_mount, .kill_sb = binderfs_kill_super, .fs_flags = FS_USERNS_MOUNT,&#125;; 初始化binder文件系统，三件事： 验证binder_devices_param也就是编译配置文件中的：CONFIG_ANDROID_BINDER_DEVICES是否合法 分配binder设备编号 注册binder文件系统 在这一步之后我们就可以通过 cat proc&#x2F;devices 查到binder驱动对应的设备号了: 12345SS9805:/ # cat proc/devicesCharacter devices:......488 binder...... 比如这次我们机器中binder驱动的设备号为488，而且还可以看到这里是注册成字符设备的。 Linux 中的设备有2种类型：字符设备(无缓冲且只能顺序存取)、块设备(有缓冲且可以随机存取)。 在Linux下，一切皆文件，设备也不例外，为了管理这些设备，系统为它们各自都编了号，而每个设备号又分为主设备号和次设备号。主设备号用来区分不同类型的设备，而次设备号用来区分同一类型内的多个设备（及其设备分区）。 2.2.1 register_filesystem定义在android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;filesystems.c中: 12345678910111213141516171819202122232425262728293031int register_filesystem(struct file_system_type * fs)&#123; int res = 0; struct file_system_type ** p; BUG_ON(strchr(fs-&gt;name, &#x27;.&#x27;)); if (fs-&gt;next) return -EBUSY; write_lock(&amp;file_systems_lock); // 在file_systems链表中找到合适位置，插入 p = find_filesystem(fs-&gt;name, strlen(fs-&gt;name)); // 如果不为空，说明已经注册过了，不能重复注册 if (*p) res = -EBUSY; else *p = fs; write_unlock(&amp;file_systems_lock); return res;&#125;EXPORT_SYMBOL(register_filesystem);static struct file_system_type **find_filesystem(const char *name, unsigned len)&#123; struct file_system_type **p; for (p = &amp;file_systems; *p; p = &amp;(*p)-&gt;next) if (strncmp((*p)-&gt;name, name, len) == 0 &amp;&amp; !(*p)-&gt;name[len]) break; return p;&#125; 主要是将传入的fs插入file_systems链表的末尾，且不能重复注册。 三.binder设备创建及挂载－debugfs挂载上面的步骤我们分析了binder驱动的初始化，最后会注册binder文件系统。这一过程都是在kernel初始化的device_initcall中完成的。 当kernel启动到一定程度，将文件系统挂载后，自然binder驱动会运作起来: 123456static struct file_system_type binder_fs_type = &#123; .name = &quot;binder&quot;, .mount = binderfs_mount, // 文件系统挂载后调用函数 .kill_sb = binderfs_kill_super, .fs_flags = FS_USERNS_MOUNT,&#125;; 文件系统挂载后，就会调用binderfs_mount函数. 3.1 binderfs.c#binderfs_mount1234567static struct dentry *binderfs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)&#123; // 留意这个binderfs_fill_super return mount_nodev(fs_type, flags, data, binderfs_fill_super);&#125; 3.2 android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;super.c#mount_nodev1234567891011121314151617181920212223struct dentry *mount_nodev(struct file_system_type *fs_type, int flags, void *data, int (*fill_super)(struct super_block *, void *, int))&#123; int error; // 获取超级块 // 超级块代表了整个文件系统，超级块是文件系统的控制块，有整个文件系统信息 // 一个文件系统所有的inode都要连接到超级块上，可以说，一个超级块就代表了一个文件系统。 struct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL); if (IS_ERR(s)) return ERR_CAST(s); // 调用传入的函数fill_super error = fill_super(s, data, flags &amp; SB_SILENT ? 1 : 0); if (error) &#123; deactivate_locked_super(s); return ERR_PTR(error); &#125; s-&gt;s_flags |= SB_ACTIVE; return dget(s-&gt;s_root);&#125;EXPORT_SYMBOL(mount_nodev); 这些设计文件系统挂载知识，后续我们在研究一下。 调用mount_nodev后，获取超级块如果一切正常，会调用传入的fill_super函数，这里对应的就是binderfs_fill_super! 3.3 binderfs.c#binderfs_fill_super1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static int binderfs_fill_super(struct super_block *sb, void *data, int silent)&#123; int ret; struct binderfs_info *info; struct inode *inode = NULL; struct binderfs_device device_info = &#123; &#123; 0 &#125; &#125;; const char *name; size_t len; // 设置文件系统中数据块大小，以字节单位为一页(一般为4096) sb-&gt;s_blocksize = PAGE_SIZE; sb-&gt;s_blocksize_bits = PAGE_SHIFT; // ...... // kmalloc用于内核空间申请内存，申请的内存位于物理内存映射区域，而且在物理上也是连续的 // 与真实的物理地址只有一个固定的偏移,因为存在较简单的转换关系，所以对申请的内存大小有限制，不能超过128KB。 // GFP_KERNEL —— 正常分配内存； sb-&gt;s_fs_info = kzalloc(sizeof(struct binderfs_info), GFP_KERNEL); // ...... // inode 保存的其实是实际的数据的一些信息，这些信息称为“元数据”(也就是对文件属性的描述)。 // 例如：文件大小，设备标识符，用户标识符，用户组标识符，文件模式，扩展属性，文件读取或 // 修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等等。 inode = new_inode(sb); // ...... // 此函数在@sb引用的binderfs中创建一个新的binderfs控制设备节点。 ret = binderfs_binder_ctl_create(sb); if (ret) return ret; name = binder_devices_param; // 遍历并创建所有binder设备，三种:&quot;binder,hwbinder,vndbinder&quot; // 1. binder // 2. hwbinder // 3. vndbinder for (len = strcspn(name, &quot;,&quot;); len &gt; 0; len = strcspn(name, &quot;,&quot;)) &#123; strscpy(device_info.name, name, len + 1); // 3.4 创建对应binder设备 ret = binderfs_binder_device_create(inode, NULL, &amp;device_info); if (ret) return ret; name += len; if (*name == &#x27;,&#x27;) name++; &#125; if (info-&gt;mount_opts.stats_mode == STATS_GLOBAL) return init_binder_logs(sb); return 0;&#125; 3.4 binderfs.c#binderfs_binder_device_create1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static int binderfs_binder_device_create(struct inode *ref_inode, struct binderfs_device __user *userp, struct binderfs_device *req)&#123; int minor, ret; struct dentry *dentry, *root; struct binder_device *device; char *name = NULL; size_t name_len; struct inode *inode = NULL; struct super_block *sb = ref_inode-&gt;i_sb; struct binderfs_info *info = sb-&gt;s_fs_info; // ...... // 给binder_device分配内核内存空间 device = kzalloc(sizeof(*device), GFP_KERNEL); if (!device) goto err; // 创建一个新的inode节点 inode = new_inode(sb); // ...... // 重点, 这里将加载文件操作集－binder操作 inode-&gt;i_fop = &amp;binder_fops; inode-&gt;i_uid = info-&gt;root_uid; inode-&gt;i_gid = info-&gt;root_gid; req-&gt;name[BINDERFS_MAX_NAME] = &#x27;\\0&#x27;; /* NUL-terminate */ name_len = strlen(req-&gt;name); // 分配一块长度为name_len + 1的内存（kmalloc+gfp） // 然后将req-&gt;name到(req-&gt;name + len)内存的内容copy到新分配的内存中 // 最后后返回该内存的首地址 name = kmemdup(req-&gt;name, name_len + 1, GFP_KERNEL); if (!name) goto err; // 初始化binder_device的相关设置 refcount_set(&amp;device-&gt;ref, 1); device-&gt;binderfs_inode = inode; device-&gt;context.binder_context_mgr_uid = INVALID_UID; device-&gt;context.name = name; device-&gt;miscdev.name = name;// 分别是binder, hwbinder, vndbinder device-&gt;miscdev.minor = minor; mutex_init(&amp;device-&gt;context.context_mgr_node_lock); // ...... // 将创建的binder_device保存在inode中 inode-&gt;i_private = device; d_instantiate(dentry, inode); fsnotify_create(root-&gt;d_inode, dentry); inode_unlock(d_inode(root)); return 0; // ......&#125; 创建binder_device的步骤分为: 给binder_device分配内核内存空间 根据超级块创建一个新的inode节点 加载文件操作集－binder_fops 至inode中 初始化binder_device的相关设置 将创建的binder_device保存在inode中 最重要的是关注步骤3,这里我们还要看看binder_fops的文件操作集具体指向的函数： 1234567891011// android/kernel/msm-4.19/drivers/android/binder.cconst struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 哦偶, 终于看到ioctl了，这里先解释下文件操作集的含义及作用: Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用。用户进程利用在对设备文件进行诸如read&#x2F;write操作的时候，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。 其实驱动程序可以理解为一个被动服务，当有上层调用时，才会进入，内核调用的具体实现后续分析。 比如我们在应用进程中调用ioctl，通过syscall进入内核态，但此时进程上下文还是该应用进程的上下文，对应进程状态为S状态。 所以我们在上一篇文章中 ##1.6 IPCThreadState#talkWithDriver 里面调用ioctl最后是调用了binder_ioctl这个函数！ 参考资料 module_init解析及内核initcall的初始化顺序 https://www.cnblogs.com/chaozhu/p/6410271.html 各种initcall的执行先后顺序 https://blog.csdn.net/fenzhikeji/article/details/6860143 binder 驱动的操作 https://blog.csdn.net/qq_15893929/article/details/103965668 Android的IPC机制Binder的各个部分 http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml 字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 https://blog.csdn.net/weixin_42314225/article/details/81112217 linux文件系统 - 初始化(一) https://www.cnblogs.com/alantu2018/p/8447303.html mount过程分析之五(mount_bdev-&gt;fill_super) https://blog.csdn.net/ZR_Lang/article/details/40115013 VFS四大对象之一 struct super_block https://www.cnblogs.com/linhaostudy/p/7427027.html Linux字符设备驱动file_operations https://www.cnblogs.com/chen-farsight/p/6181341.html","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Binder","slug":"Android/Binder","permalink":"https://swallowjoe.github.io/categories/Android/Binder/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://swallowjoe.github.io/tags/Binder/"}]},{"title":"Binder(3)--sayHello之ioctl","slug":"Binder-3-sayHello之ioctl","date":"2022-04-04T02:38:20.000Z","updated":"2022-04-04T02:51:16.414Z","comments":true,"path":"2022/04/04/Binder-3-sayHello之ioctl/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/Binder-3-sayHello%E4%B9%8Bioctl/","excerpt":"简介接上文，首先回顾一下IBinder相关接口的类图： 我们知道在Client App中获取的IBinder实际上是BinderProxy类型的对象。那么在上一文中Client App调用sayHello方法过程的的#2.3.2中，我们卡住了，现在可以继续了： 1234virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) = 0;","text":"简介接上文，首先回顾一下IBinder相关接口的类图： 我们知道在Client App中获取的IBinder实际上是BinderProxy类型的对象。那么在上一文中Client App调用sayHello方法过程的的#2.3.2中，我们卡住了，现在可以继续了： 1234virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) = 0; 一. IBinder.transact Service.onServiceConnected IDemoInterface.Stub.Proxy.sayHello BinderProxy.transact(Stub.TRANSACTION_sayHello, ……) 1.1 BinderProxy.transact12345678public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // ...... try &#123; // 不多废话，直接开始, 注意我们现在的进程环境是Client App哦 return transactNative(code, data, reply, flags); &#125; // ......&#125; 1.2 android_util_Binder#android_os_BinderProxy_transact1234567891011121314151617static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; // ...... // 获取IBinder对象，这里我们已经知道了，是BinderProxy对应Native的IBinder对象 // 也就是对应Server App存入的JavaBBinder, 是Parcel:flattenBinder中存入cookie的BBinder // 然后在通信过程中经过Binder驱动转成了对应的BpBinder IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); // ...... // 1.3 上一篇文章我们就分析了，这个target就是BpBinder status_t err = target-&gt;transact(code, *data, reply, flags); // ...... return JNI_FALSE;&#125; 1.3 BpBinder#transact123456789101112131415161718// NOLINTNEXTLINE(google-default-arguments)status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; // 一旦Binder对象死掉，就不会复活 if (mAlive) &#123; // ...... // 1.4 IPCThreadState! status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; 1.4 IPCThreadState#transact1234567891011121314151617181920212223242526272829303132status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err; flags |= TF_ACCEPT_FDS; // 1.4.1 将数据写入mOut中存储, cmd 是BC_TRANSACTION err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, nullptr); // ...... if ((flags &amp; TF_ONE_WAY) == 0) &#123; // TF_ONE_WAY 是代表这个binder调用是one_way的，不需要等待回传 // 这个分支表示需要回传数据 // ...... if (reply) &#123; // 1.5 当传入的reply Parcel不为null时 err = waitForResponse(reply); &#125; else &#123; // 当直接传入一个null的Parcel作为reply时 // 创建一个假的Parcel接收可能的回写数据 Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; // ...... &#125; else &#123; // 不需要回传数据 err = waitForResponse(nullptr, nullptr); &#125; return err;&#125; transaction的flag一共有四种： name value function TF_ONE_WAY 0x01 代表oneway的binder调用，不需要回传数据 TF_ROOT_OBJECT 0x04 内容是组件的根对象 TF_STATUS_CODE 0x08 内容是32位的状态代码 TF_ACCEPT_FDS 0x10 允许使用文件描述符答复 首先将需要传递的数据写入out中存储，然后去和binder driver通信。 这里我们先忽略IPCThreadState的初始化过程。 1.4.1 IPCThreadState#writeTransactionData12345678910111213141516171819202122232425262728status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don&#x27;t pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; // ...... // cmd为BC_TRANSACTION mOut.writeInt32(cmd); // 将data保存在mOut中 mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 这里折后就是将数据保存在mOut中，这里是怎么保证多线程并发的时的处理呢？稍后我们研究IPC的初始化就知道了。 1.5 IPCThreadState#waitForResponse从名字也可以猜出来，这里应该就是与binder.c驱动通信。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; uint32_t cmd; int32_t err; while (1) &#123; // 1.6 显而易见, 与驱动通信 if ((err=talkWithDriver()) &lt; NO_ERROR) break; // ...... // #1.6中已经通过ioctl与binder驱动通信了，回传的输入也写入了mIn中 // 读取的第一个uint32_t的数据代表binder通信类型 cmd = (uint32_t)mIn.readInt32(); // ...... switch (cmd) &#123; case BR_TRANSACTION_COMPLETE: if (!reply &amp;&amp; !acquireResult) goto finish; break; case BR_DEAD_REPLY: err = DEAD_OBJECT; goto finish; case BR_FAILED_REPLY: err = FAILED_TRANSACTION; goto finish; case BR_ACQUIRE_RESULT: &#123; ALOG_ASSERT(acquireResult != NULL, &quot;Unexpected brACQUIRE_RESULT&quot;); const int32_t result = mIn.readInt32(); if (!acquireResult) continue; *acquireResult = result ? NO_ERROR : INVALID_OPERATION; &#125; goto finish; // 一般非oneway的通信就是走的这里 case BR_REPLY: &#123; binder_transaction_data tr; // 读取从binder驱动回传的数据 err = mIn.read(&amp;tr, sizeof(tr)); ALOG_ASSERT(err == NO_ERROR, &quot;Not enough command data for brREPLY&quot;); if (err != NO_ERROR) goto finish; if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; // 将回传的数据存入reply中 reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; else &#123; err = *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer); freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); &#125; &#125; else &#123; freeBuffer(nullptr, reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), this); continue; &#125; &#125; goto finish; default: err = executeCommand(cmd); if (err != NO_ERROR) goto finish; break; &#125; &#125;finish: if (err != NO_ERROR) &#123; if (acquireResult) *acquireResult = err; if (reply) reply-&gt;setError(err); mLastError = err; &#125; return err;&#125; 1.6 IPCThreadState#talkWithDriver12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; if (mProcess-&gt;mDriverFD &lt; 0) &#123; return -EBADF; &#125; // binder_write_read是一个保存了传输数据以及回传数据信息的结构体 binder_write_read bwr; // 判断读缓冲区是否为空 const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); // 仍在从输入缓冲区中剩余的数据中读取数据，并且调用者已请求读取下一个数据，则不编写任何内容 const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; // 将待传入的数据存入bwr中，以便通过binder驱动传输 bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // 如果需要回传的数据时 if (doReceive &amp;&amp; needRead) &#123; // 读缓冲区大小设置为可接受的最大大小 bwr.read_size = mIn.dataCapacity(); // 将bwr中读缓冲区指针指向mIn中的data，后续驱动直接将数据填充到这里 bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; // ...... do &#123; // ..... // 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动 if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; else err = -errno; // ..... if (mProcess-&gt;mDriverFD &lt; 0) &#123; err = -EBADF; &#125; IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;Finished read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125; &#125; while (err == -EINTR); // ...... if (err &gt;= NO_ERROR) &#123; // ...... if (bwr.read_consumed &gt; 0) &#123; // 如果存在回传的数据，则标记 mIn.setDataSize(bwr.read_consumed); mIn.setDataPosition(0); &#125; // ...... return NO_ERROR; &#125; return err;&#125; ok, 到这里我们对Binder通信已经有了一个初步的认知,最核心跨进程的通信手段是通过ioctl这个东东。 二. ioctl介绍本身对Linux内核驱动不太了解，可以参考这篇博文: https://blog.csdn.net/qq_19923217/article/details/82698787 ioctl（）系统调用操作特殊文件的底层设备参数。特别是，字符特殊文件（例如终端）的许多操作特性可以通过ioctl（）请求来控制。 ioctl 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。 参数 描述 fd 文件描述符 cmd 交互协议，设备驱动将根据 cmd 执行对应操作 … 可变参数 arg，依赖 cmd 指定长度以及类型 2.1 API 头文件: #include &lt;sys&#x2F;ioctl.h&gt;, 用于指定ioctl（）请求的宏和定义位于文件&lt;sys&#x2F;ioctl.h&gt;中。 参数: int ioctl(int fd, unsigned long request, …); fd 必须是打开文件描述符。 cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作 argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。 返回值: ioctl() 函数执行成功时返回 0，失败则返回 -1 并设置全局变量 errorno 值 EBADF fd不是有效的文件描述符。 EFAULT 默认argp引用不可访问的内存区域。 EINVAL 请求或argp无效。 ENOTTY fd与字符专用设备不关联。 ENOTTY 指定的请求不适用于文件描述符fd引用的对象类型。 2.2 ioctl用户与驱动之间的协议 参考:https://blog.csdn.net/zifehng/article/details/59576539 总结通过这个sayHello的过程，我们对binder通信有了基本概念。知道BBinder, BpBinder, IBinder, IInterface等等类的作用。 接下来我们先看看Binder驱动的加载过程，之后在继续分析ioctl接下来的流程：比如Client发送请求后，binder驱动是怎么找到对应Server的。 参考资料 Android Binder详解 https://mr-cao.gitbooks.io/android/content/android-binder.html msm-4.14 Code https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c linux 内核 - ioctl 函数详解 https://blog.csdn.net/qq_19923217/article/details/82698787 ioctl(2) — Linux manual page https://man7.org/linux/man-pages/man2/ioctl.2.html ioctl()分析——从用户空间到设备驱动 https://blog.csdn.net/zifehng/article/details/59576539","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Binder","slug":"Android/Binder","permalink":"https://swallowjoe.github.io/categories/Android/Binder/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://swallowjoe.github.io/tags/Binder/"}]},{"title":"Binder(2)--sayHello之BinderProxy的创建过程","slug":"Binder-2-sayHello之BinderProxy的创建过程","date":"2022-04-04T02:38:09.000Z","updated":"2022-04-04T02:50:23.037Z","comments":true,"path":"2022/04/04/Binder-2-sayHello之BinderProxy的创建过程/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/","excerpt":"简介接上文，首先回顾一下IBinder相关接口的类图： 现在我们Client进程已经拿到Server端IDemoInterface中的IBinder对象，但是这个IBinder对象到底是哪个呢，Stub本身？还是Proxy亦或是Proxy中的mRemote？ 还是看sayHello的调用过程先: 123456789101112override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) &#123; Log.d(&quot;Client&quot;, &quot;DemoService connected&quot;) // 远程服务连接成功，打个招呼 // 1.1 这个asInterface是做了什么操作呢？ val mProxyBinder = IDemoInterface.Stub.asInterface(p1) try &#123; // 2.1 sayHello! mProxyBinder.sayHello(5000, &quot;Hello?&quot;) &#125; catch (e:RemoteException) &#123; &#125;&#125;","text":"简介接上文，首先回顾一下IBinder相关接口的类图： 现在我们Client进程已经拿到Server端IDemoInterface中的IBinder对象，但是这个IBinder对象到底是哪个呢，Stub本身？还是Proxy亦或是Proxy中的mRemote？ 还是看sayHello的调用过程先: 123456789101112override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) &#123; Log.d(&quot;Client&quot;, &quot;DemoService connected&quot;) // 远程服务连接成功，打个招呼 // 1.1 这个asInterface是做了什么操作呢？ val mProxyBinder = IDemoInterface.Stub.asInterface(p1) try &#123; // 2.1 sayHello! mProxyBinder.sayHello(5000, &quot;Hello?&quot;) &#125; catch (e:RemoteException) &#123; &#125;&#125; 一. asInterface方法1.1 IDemoInterface.Stub.asInterface12345678910111213public static com.oneplus.opbench.server.IDemoInterface asInterface(android.os.IBinder obj)&#123; if ((obj==null)) &#123; return null; &#125; // 1.2 生成IInterface android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof com.oneplus.opbench.server.IDemoInterface))) &#123; return ((com.oneplus.opbench.server.IDemoInterface)iin); &#125; // 1.3 转换成Proxy对象 return new com.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj);&#125; 这个方法是自动生成的，看起来就是通过IBinder生成一个IInterface或者Proxy？ 1.2 Binder.queryLocalInterface1234567891011public @Nullable IInterface queryLocalInterface(@NonNull String descriptor) &#123; if (mDescriptor != null &amp;&amp; mDescriptor.equals(descriptor)) &#123; return mOwner; &#125; return null;&#125;public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor) &#123; mOwner = owner; mDescriptor = descriptor;&#125; 看类图我们也知道，只有Binder实现了IBinder接口，而也只有IDemoInterface.Stub继承了Binder。这么说起来，SystemServer回传的IBinder对象实际上是服务端的IDemoInterface.Stub？然而mOwner此时还是null的，注意我们现在在Client进程中。这里我们直接debug client进程发现queryLocalInterface返回的null值，而且传入的IBinder的类型居然是BinderProxy的！这里什么时候返回非null，传入的IBinder是什么时候变成BinderProxy的呢，先留个疑问。 1.3 创建IDemoInterface.Stub.Proxy对象12345private android.os.IBinder mRemote;Proxy(android.os.IBinder remote)&#123; mRemote = remote;&#125; 明白了，现在这个mRemote对象实际上是指代的BinderProxy! 二. sayHello2.1 Proxy.sayHello12345678910111213141516171819202122@Override public void sayHello(long aLong, java.lang.String aString) throws android.os.RemoteException&#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; // 按顺序写入参数, 注意DESCRIPTOR _data.writeInterfaceToken(DESCRIPTOR); _data.writeLong(aLong); _data.writeString(aString); // 2.2 实质上是mRemote起作用的，在1.3中我们通过Debug知道这个其实是BinderProxy对象 boolean _status = mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; getDefaultImpl().sayHello(aLong, aString); return; &#125; _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125;&#125; 2.2 BinderProxy.transact123456public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // ...... // 2.3 忽略其他代码，这个是call了一个native方法，通过JNI调用 return transactNative(code, data, reply, flags); // ......&#125; 2.3 android_util_Binder.cpp#android_os_BinderProxy_transact1234567891011static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj, jint code, jobject dataObj, jobject replyObj, jint flags) // throws RemoteException&#123; // ...... // 2.3.1 首先从名字中可以推出是获取远程通信的目标 IBinder* target = getBPNativeData(env, obj)-&gt;mObject.get(); // ...... // 2.3.2 继续 status_t err = target-&gt;transact(code, *data, reply, flags); // .....&#125; 2.3.1 android_util_Binder.cpp#getBPNativeData12345678910111213141516171819202122232425262728struct BinderProxyNativeData &#123; // Both fields are constant and not null once javaObjectForIBinder returns this as // part of a BinderProxy. // The native IBinder proxied by this BinderProxy. sp&lt;IBinder&gt; mObject; // Death recipients for mObject. Reference counted only because DeathRecipients // hold a weak reference that can be temporarily promoted. sp&lt;DeathRecipientList&gt; mOrgue; // Death recipients for mObject.&#125;;static struct binderproxy_offsets_t&#123; // Class state. jclass mClass; jmethodID mGetInstance; jmethodID mSendDeathNotice; // Object state. jfieldID mNativeData; // Field holds native pointer to BinderProxyNativeData.&#125; gBinderProxyOffsets;BinderProxyNativeData* getBPNativeData(JNIEnv* env, jobject obj) &#123; // 其实就是读取BinderProxy对象中保存的long类型的mNativeData数据 // 然后强制转换成BinderProxyNativeData类型 return (BinderProxyNativeData *) env-&gt;GetLongField(obj, gBinderProxyOffsets.mNativeData);&#125; 这里并不知道BinderProxy从哪儿来的，Native层也没有定义，应该就是指代java层的BinderProxy。 2.3.2 IBinder#transact1234virtual status_t transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0) = 0; 这里我们知道getBpNativeData中的mObject是IBinder类型的。但是是一个虚函数，没有具体实现，怎么往下查呢。 Native的Debug方式也有，但是总归不方便，那我们先梳理一下Native层关于IBinder的类图吧。注意现在我们还是在Client进程内的。 IBinder相关类之间的关系大致理清楚了，从这个函数名称getBPNativeData可以猜出来应该是指代的BpBinder! 但是怎么确认呢，那我们回到Client App和Server App建立通信的过程中，溯源BinderProxy。 三. BinderProxy的创建过程3.1 publishServiceLocked ServerApp: ActivityThread.handleBindService(BindServiceData data) SystemServer: ActivityManagerService.publishService(IBinder token, Intent intent, IBinder service) SystemServer: ActiveService.publishServiceLocked(ServiceRecord r, Intent intent, IBinder service) 123456789101112131415161718192021222324252627private void handleBindService(BindServiceData data) &#123; // 这个mService就是Service在被调用onCreate方法的时候存入的 Service s = mServices.get(data.token); if (DEBUG_SERVICE) Slog.v(TAG, &quot;handleBindService s=&quot; + s + &quot; rebind=&quot; + data.rebind); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; // 3.1.1 所以这个onBind，就是Service中我们实现的onBind方法了 // 这里的binder就是对应我们实现的IDemoInterface.Stub IBinder binder = s.onBind(data.intent); // 告诉SystemServer该服务已准备就绪 ActivityManager.getService().publishService( data.token, data.intent, binder); &#125; else &#123; // 这里就是rebind s.onRebind(data.intent); ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; &#125; // ...... &#125;&#125; 3.1.1 服务端的Stub初始化1234567891011121314class DemoBinder:IDemoInterface.Stub() &#123; override fun sayHello(aLong: Long, aString: String?) &#123; Log.d(&quot;DemoService&quot;, &quot;$aString:$aLong&quot;) &#125;&#125;// 看看这个Stub的初始化过程private val binder = DemoBinder()override fun onBind(intent: Intent?): IBinder? &#123; // 所以Service中的onBind含义就是通知到AMS // 本服务已准备继续，随时可以工作 return binder&#125; 还要注意的是，初始化DemoBinder过程，会调用父类的构造函数哦： 1234567891011public Stub()&#123; this.attachInterface(this, DESCRIPTOR);&#125;public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor) &#123; // 噢噢，这个mOwner就是在这里保存的！ // 它代表的就是IDemoInterface.Stub类的对象，其实就是DemoBinder mOwner = owner; mDescriptor = descriptor;&#125; 但是这里还是没有找到BinderProxy对象的创建。不过我们知道，Binder通信是通过往Parcel中写入数据的； 而AMS.publishService函数中最后一个参数就是IBinder类型的。 3.2 publishService写入参数通过查看IActivityManager.aidl文件编译后生成的IActivityManager.Stub.Proxy.class(想想为啥不是Stub而是Proxy)文件可以知道这个函数的具体内容： 1234567891011121314151617181920212223242526public void publishService(IBinder token, Intent intent, IBinder service) throws RemoteException &#123; Parcel _data = Parcel.obtain(); Parcel _reply = Parcel.obtain(); try &#123; _data.writeInterfaceToken(&quot;android.app.IActivityManager&quot;); _data.writeStrongBinder(token); if (intent != null) &#123; _data.writeInt(1); intent.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; // 3.1.3 IBinder对象是通过writeStrongBinder方法写入的 // 注意这个IBinder就是Service实现的onBind方法中返回的, 就是IDemoInterface.Stub类型 _data.writeStrongBinder(service); boolean _status = this.mRemote.transact(32, _data, _reply, 0); if (!_status &amp;&amp; IActivityManager.Stub.getDefaultImpl() != null) &#123; IActivityManager.Stub.getDefaultImpl().publishService(token, intent, service); return; &#125; _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; 3.2.1 Parcel.writeStrongBinder1234public final void writeStrongBinder(IBinder val) &#123; // 这里的mNativePtr就是此Parcel在Native的对应标识 nativeWriteStrongBinder(mNativePtr, val);&#125; 看样子直接去了Native层干活去了。 3.2.2 android_os_Parcel#android_os_Parcel_writeStrongBinder12345678910111213static void android_os_Parcel_writeStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)&#123; // 转成Native的Parcel Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr); if (parcel != NULL) &#123; // 3.2.2.1 注意这个ibinderForJavaObject方法，将java层IBinder转成Native层的 // 3.2.3 然后是保存这个Native的IBinder const status_t err = parcel-&gt;writeStrongBinder(ibinderForJavaObject(env, object)); if (err != NO_ERROR) &#123; signalExceptionForError(env, clazz, err); &#125; &#125;&#125; 3.2.2.1 android_util_Binder#ibinderForJavaObject1234567891011121314151617181920sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)&#123; if (obj == NULL) return NULL; // Instance of Binder? if (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123; JavaBBinderHolder* jbh = (JavaBBinderHolder*) env-&gt;GetLongField(obj, gBinderOffsets.mObject); // 3.2.2.2 返回一个IBinder return jbh-&gt;get(env, obj); &#125; // Instance of BinderProxy? if (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123; return getBPNativeData(env, obj)-&gt;mObject; &#125; ALOGW(&quot;ibinderForJavaObject: %p is not a Binder object&quot;, obj); return NULL;&#125; 这块首次出现了BinderProxy，不过当前我们还处于Service App进程对吧，而且上层传入的IBinder明显只是一个IDemoInterface.Stub类型。 所以这里还是将这个jobject转换成了JavaBBinderHolder！不过我们有理由猜测，BinderProxy是在AMS所处的SystemServer进程中转换的。 3.2.2.2 android_util_Binder#JavaBBinderHolder#get1234567891011121314151617181920sp&lt;JavaBBinder&gt; get(JNIEnv* env, jobject obj)&#123; AutoMutex _l(mLock); sp&lt;JavaBBinder&gt; b = mBinder.promote(); if (b == NULL) &#123; // 3.2.2.3 创建JavaBBinder b = new JavaBBinder(env, obj); if (mVintf) &#123; ::android::internal::Stability::markVintf(b.get()); &#125; if (mExtension != nullptr) &#123; b.get()-&gt;setExtension(mExtension); &#125; mBinder = b; ALOGV(&quot;Creating JavaBinder %p (refs %p) for Object %p, weakCount=%&quot; PRId32 &quot;\\n&quot;, b.get(), b-&gt;getWeakRefs(), obj, b-&gt;getWeakRefs()-&gt;getWeakCount()); &#125; // 直接返回的JavaBBinder,说明JavaBBinder继承了IBinder return b;&#125; 3.2.2.3 创建Native层的IBinder对象-JavaBBinder12345678JavaBBinder(JNIEnv* env, jobject /* Java Binder */ object) : mVM(jnienv_to_javavm(env)), mObject(env-&gt;NewGlobalRef(object))&#123; ALOGV(&quot;Creating JavaBBinder %p\\n&quot;, this); // 这些先不管 gNumLocalRefsCreated.fetch_add(1, std::memory_order_relaxed); gcIfManyNewRefs(env);&#125; 我们在看看现在Native层和IBinder有关系的类的类图: 果然JavaBBinder继承了IBinder。回到#3.2.2中，继续往下就是writeStrongBinder了。 3.2.3 Parcel#writeStrongBinder12345678910111213141516171819202122232425262728293031323334353637383940414243status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123; return flattenBinder(val);&#125;status_t Parcel::flattenBinder(const sp&lt;IBinder&gt;&amp; binder)&#123; flat_binder_object obj; // ...... if (binder != nullptr) &#123; // 3.2.3.1 是local还是remote？ BBinder *local = binder-&gt;localBinder(); if (!local) &#123; BpBinder *proxy = binder-&gt;remoteBinder(); if (proxy == nullptr) &#123; ALOGE(&quot;null proxy&quot;); &#125; const int32_t handle = proxy ? proxy-&gt;handle() : 0; obj.hdr.type = BINDER_TYPE_HANDLE; obj.binder = 0; /* Don&#x27;t pass uninitialized stack data to a remote process */ obj.handle = handle; obj.cookie = 0; &#125; else &#123; // 进入！ if (local-&gt;isRequestingSid()) &#123; obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX; &#125; // 注意这里的type，是BINDER_TYPE_BINDER！ obj.hdr.type = BINDER_TYPE_BINDER; // 保存BBinder的弱引用，这个是干啥用的? obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs()); // 保存BBinder对象 obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local); &#125; &#125; else &#123; obj.hdr.type = BINDER_TYPE_BINDER; obj.binder = 0; obj.cookie = 0; &#125; // 3.2.4 完成IBinder的写入 return finishFlattenBinder(binder, obj);&#125; 这里对local和remote存在不同的处理方式，不过我们先仅仅关注其中一个分支。 3.2.3.1 IBinder#localBinder我们这里的IBinder就是JavaBBinder类的对象，前面我们看过了JavaBBinder的初始化 12345678910BBinder* IBinder::localBinder()&#123; return nullptr;&#125;// 注意IBinder调用的是这个BBinder* BBinder::localBinder()&#123; return this;&#125; 因为这里的IBinder指针是指向其子类的子类JavaBBinder,然后其子类BBinder实现了虚函数localBinder，而JavaBBinder并没有。 所以这里是local的！ 3.2.4 Parcel#finishFlattenBinderflatten的意思是压平，其实可以理解为打包，将JavaBBinder打包然后发送出去。 1234567891011status_t Parcel::finishFlattenBinder( const sp&lt;IBinder&gt;&amp; binder, const flat_binder_object&amp; flat)&#123; // 写入内存区域，这一块没有接触过，暂时先不管，后面研究 // 理解为将IBinder保存到内存中的某个特定区域 status_t status = writeObject(flat, false); if (status != OK) return status; internal::Stability::tryMarkCompilationUnit(binder.get()); return writeInt32(internal::Stability::get(binder.get()));&#125; 到这里我们知道了Java层的IBinder对象是如何通过Parcel保存到Native中的。 3.3 SystemServer接收参数这里我们先不去细究通信的过程，因为这本身就是一次Binder通信。先看AMS收到Server App发布Service的IBinder对象是什么。 还是通过看编译后生成的IActivityManager.Stub.Class文件中对应的publishService方法，注意我们现在切换到了SystemServer进程(忽略进程切换过程)。 123456789101112131415161718public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // ...... data.enforceInterface(descriptor); // 读取IBinder对象，不过这个是token, 不是我们想要的Service的IBinder // 用过Binder通信知道，是按顺序来读写的，所以我们看最后一个IBinder iBinder11 = data.readStrongBinder(); if (0 != data.readInt()) &#123; intent6 = (Intent)Intent.CREATOR.createFromParcel(data); &#125; else &#123; intent6 = null; &#125; // 3.3.1 这里就是我们想要的Service的IBinder了 iBinder26 = data.readStrongBinder(); publishService(iBinder11, intent6, iBinder26); reply.writeNoException(); return true; // ......&#125; 3.3.1 Parcel.readStrongBinder123public final IBinder readStrongBinder() &#123; return nativeReadStrongBinder(mNativePtr);&#125; 还是直接切到Native. 3.3.2 android_os_Parcel#android_os_Parcel_readStrongBinder12345678910static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr)&#123; Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr); if (parcel != NULL) &#123; // 3.3.2.1 先看Parce-&gt;readStrongBinder // 3.3.3 将IBinder转换成jobject return javaObjectForIBinder(env, parcel-&gt;readStrongBinder()); &#125; return NULL;&#125; 3.3.2.1 Parcel#readStrongBinder12345678910111213141516171819202122sp&lt;IBinder&gt; Parcel::readStrongBinder() const&#123; sp&lt;IBinder&gt; val; // 暂时不明确IBinder指代的是具体哪个子类吼 readNullableStrongBinder(&amp;val); return val;&#125;status_t Parcel::readStrongBinder(sp&lt;IBinder&gt;* val) const&#123; status_t status = readNullableStrongBinder(val); if (status == OK &amp;&amp; !val-&gt;get()) &#123; status = UNEXPECTED_NULL; &#125; return status;&#125;status_t Parcel::readNullableStrongBinder(sp&lt;IBinder&gt;* val) const&#123; // 来了，解压的过程 return unflattenBinder(val);&#125; 3.3.2.2 Parcel#unflattenBinder1234567891011121314151617181920212223status_t Parcel::unflattenBinder(sp&lt;IBinder&gt;* out) const&#123; // 从内存区域中读取当前位置的数据 const flat_binder_object* flat = readObject(false); // 存在 if (flat) &#123; switch (flat-&gt;hdr.type) &#123; // 我们在flatten中的Type就是这个！ case BINDER_TYPE_BINDER: &#123; // 转成IBinder，没有问题，我们存入的JavaBBinder，其父类的父类就是IBinder sp&lt;IBinder&gt; binder = reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie); // 3.3.2.3 完成数据解压 return finishUnflattenBinder(binder, out); &#125; case BINDER_TYPE_HANDLE: &#123; sp&lt;IBinder&gt; binder = ProcessState::self()-&gt;getStrongProxyForHandle(flat-&gt;handle); return finishUnflattenBinder(binder, out); &#125; &#125; &#125; return BAD_TYPE;&#125; 这个地方留个心眼哦，这里的flat-&gt;hdr.type真的还是原来的BINDER_TYPE_BINDER吗？ 3.3.2.3 Parcel#finishUnflattenBinder1234567891011121314status_t Parcel::finishUnflattenBinder( const sp&lt;IBinder&gt;&amp; binder, sp&lt;IBinder&gt;* out) const&#123; int32_t stability; status_t status = readInt32(&amp;stability); if (status != OK) return status; status = internal::Stability::set(binder.get(), stability, true /*log*/); if (status != OK) return status; // out指向这个内存区域 *out = binder; return OK;&#125; 所以这个IBinder到底是什么类型的呢？先回到#3.3.2中，继续readStrongBinder的过程 3.3.3 android_util_Binder#javaObjectForIBinder123456789101112131415161718192021222324jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; // ...... // 3.3.3.1 这里决定是不是直接返回JavaBBinder的类型 if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123; // It&#x27;s a JavaBBinder created by ibinderForJavaObject. Already has Java object. jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object(); LOGDEATH(&quot;objectForBinder %p: it&#x27;s our own %p!\\n&quot;, val.get(), object); return object; &#125; // 3.3.4 终于看到和BinderProxy相关的了, 至少名字上看都有关系 BinderProxyNativeData* nativeData = new BinderProxyNativeData(); nativeData-&gt;mOrgue = new DeathRecipientList; // 将从内存中读取的IBinder对象存起来 nativeData-&gt;mObject = val; // 3.3.5 调用到java方法mGetInstance，生成BinderProxy！ jobject object = env-&gt;CallStaticObjectMethod(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.get()); // ...... // 所以这里最终返回是BinderProxy对象对应JNI的jobject. return object;&#125; 3.3.3.1 IBinder#checkSubclass1234567891011bool IBinder::checkSubclass(const void* /*subclassID*/) const&#123; return false;&#125;// JavaBBinder:bool checkSubclass(const void* subclassID) const&#123; // 3.3.3.2 gBinderOffsets的初始化 return subclassID == &amp;gBinderOffsets;&#125; 这里思考一个问题，注意我们现在已经处于SystemServer进程了，这里的IBinder指向一块内存区域，是从Server App中拷贝而来的，与JavaBBinder数据保持一致。 那我们强制转换转成了IBinder，然后调用IBinder中的函数是调用IBinder中函数实现还是JavaBBinder中的函数实现呢？ 3.3.3.2 android_util_Binder#int_register_android_os_Binder首先gBinderOffsets是bindernative_offsets_t类型的结构体，其在int_register_android_os_Binder中被填充数据。 1234567891011121314static int int_register_android_os_Binder(JNIEnv* env)&#123; jclass clazz = FindClassOrDie(env, kBinderPathName); gBinderOffsets.mClass = MakeGlobalRefOrDie(env, clazz); gBinderOffsets.mExecTransact = GetMethodIDOrDie(env, clazz, &quot;execTransact&quot;, &quot;(IJJI)Z&quot;); gBinderOffsets.mGetInterfaceDescriptor = GetMethodIDOrDie(env, clazz, &quot;getInterfaceDescriptor&quot;, &quot;()Ljava/lang/String;&quot;); gBinderOffsets.mObject = GetFieldIDOrDie(env, clazz, &quot;mObject&quot;, &quot;J&quot;); return RegisterMethodsOrDie( env, kBinderPathName, gBinderMethods, NELEM(gBinderMethods));&#125; 我们知道，在Java中，每个进程都有自己的虚拟机环境，所以对于不同进程来说，JNIEnv肯定也是不同的，这就导致gBinderOffsets也是不同的。 所以对于3.3.3.1中checkSubclass来说，返回的就是false了。 3.3.4 创建BinderProxyNativeData1234567891011struct BinderProxyNativeData &#123; // Both fields are constant and not null once javaObjectForIBinder returns this as // part of a BinderProxy. // The native IBinder proxied by this BinderProxy. sp&lt;IBinder&gt; mObject; // Death recipients for mObject. Reference counted only because DeathRecipients // hold a weak reference that can be temporarily promoted. sp&lt;DeathRecipientList&gt; mOrgue; // Death recipients for mObject.&#125;; 哦噢，空欢喜？这里只是一个结构体，将IBinder和DeathRecipientList组合起来。 3.3.5 gBinderProxyOffsets.mGetInstance &#x3D;&gt; BinderProxy.getInstance123456789101112131415161718192021222324252627private static BinderProxy getInstance(long nativeData, long iBinder) &#123; BinderProxy result; synchronized (sProxyMap) &#123; try &#123; result = sProxyMap.get(iBinder); if (result != null) &#123; return result; &#125; // 创建BinderProxy对象！ result = new BinderProxy(nativeData); &#125; catch (Throwable e) &#123; // We&#x27;re throwing an exception (probably OOME); don&#x27;t drop nativeData. NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer, nativeData); throw e; &#125; NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData); // The registry now owns nativeData, even if registration threw an exception. sProxyMap.set(iBinder, result); &#125; return result;&#125;private BinderProxy(long nativeData) &#123; // 所以这个nativeData原来是代表的BinderProxyNativeData mNativeData = nativeData;&#125; 通过JNI调用到Java方法，最终生成BinderProxy对象。 四. 总结到这里我们就理清了BinderProxy这个是怎么来的了。总结一下： Server App实现Service的onBind方法，返回一个IBinder对象，这个IBinder对象是继承了某个aidl接口的Stub类，记为StubIBinder Server App调用publishService，将StubIBinder通过一系列方法，在Native层转成JavaBBinder，保存在Parce的内存区域中 Binder驱动拷贝Parcel并将其传给SystemServer进程(这个过程我们稍后分析) SystemServer接收到Parcel内存数据，将其中JavaBBinder所在的内存区域强制转成IBinder类型，并将其保存为Java层的BinderProxy对象 同理我们知道Client App通过调用bindService获取了一个IBinder对象，那这个IBinder对象也是BinderProxy类型的, 只不过这里有点点小差异: SystemServer通过IServiceConnection向Client App发送Server App注册的BinderProxy对象时，在Parcel.writeStrongBinder过程中，存入cookie的是BinderProxy: 1234567891011121314151617181920sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)&#123; if (obj == NULL) return NULL; // 是否为Binder对象 if (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123; JavaBBinderHolder* jbh = (JavaBBinderHolder*) env-&gt;GetLongField(obj, gBinderOffsets.mObject); return jbh-&gt;get(env, obj); &#125; // 是否为BinderProxy对象 if (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123; // SystemServer向Client App发送Server App的BinderProxy对象，走这里 return getBPNativeData(env, obj)-&gt;mObject; &#125; ALOGW(&quot;ibinderForJavaObject: %p is not a Binder object&quot;, obj); return NULL;&#125; 那么在接下来打包flattenBinder的过程中, type 的类型其实是 BINDER_TYPE_HANDLE 123456789101112131415161718192021222324status_t Parcel::flattenBinder(const sp&lt;IBinder&gt;&amp; binder) // ...... // 注意此时我们身处SystemServer进程，传入的IBinder实际上是对应BinderProxy BBinder *local = binder-&gt;localBinder(); if (!local) &#123; BpBinder *proxy = binder-&gt;remoteBinder(); if (proxy == nullptr) &#123; ALOGE(&quot;null proxy&quot;); &#125; const int32_t handle = proxy ? proxy-&gt;handle() : 0; obj.hdr.type = BINDER_TYPE_HANDLE; obj.binder = 0; /* Don&#x27;t pass uninitialized stack data to a remote process */ obj.handle = handle; obj.cookie = 0; &#125; else &#123; if (local-&gt;isRequestingSid()) &#123; obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX; &#125; obj.hdr.type = BINDER_TYPE_BINDER; obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs()); obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local); &#125; // ......&#125; 4.1 新的疑问哦吼，新的问题来了，这个binder-&gt;localBinder()调用的到底是那个方法呢？IBinder, BBinder中都有实现。 如果是直接拷贝的话，那么按理说也是会调用到BBinder的localBinder，这样这里还是个local! 如果拷贝后在新进程中调用的是IBinder的localBinder，那么接下来的remoteBinder也是IBinder的，还是返回null！ 这样也说不通，因为如果remoteBinder返回的也是空，那么打包后传入的信息就不能识别Server App的IDemoInterface了。 这里曾困扰我一段时间，这个IBinder到底是什么是我们理解Binder通信的基础。 按照网上一大堆的文章来说，从Binder通信到了另一个进程，那么BBinder就会转成了BpBinder。 然而我们梳理了上层代码，并没有发现这个转变过程。在Parcel整个压缩和解包的过程中都没有发现将IBinder强制转成BpBinder。 4.2 binder驱动其实这里是在驱动层做的处理：android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c 12345678910111213141516171819202122232425262728293031323334static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply, binder_size_t extra_buffers_size)&#123; // ...... for (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset; buffer_offset += sizeof(binder_size_t)) &#123; // ...... switch (hdr-&gt;type) &#123; case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct flat_binder_object *fp; fp = to_flat_binder_object(hdr); ret = binder_translate_binder(fp, t, thread); // ...... &#125; // ......&#125;static int binder_translate_binder(struct flat_binder_object *fp, struct binder_transaction *t, struct binder_thread *thread)&#123; // ...... if (fp-&gt;hdr.type == BINDER_TYPE_BINDER) // 这里，如果读取的hdr.type是BINDER_TYPE_BINDER // 将会被改成BINDER_TYPE_HANDLE！！！ fp-&gt;hdr.type = BINDER_TYPE_HANDLE; else fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE; // ......&#125; 在驱动层传输数据的时候会加工一次！怪不得上层找不到任何信息，这个可真的是太容易误导了。 4.3 SystemServer &#x3D;&gt; Parcel#unflattenBinder所以在 #3.3.2.2 中 Parcel#unflattenBinder 解包数据时，对IBinder对象的处理是另外一条路径了： 1234567891011121314151617181920212223242526status_t Parcel::unflattenBinder(sp&lt;IBinder&gt;* out) const&#123; // 从内存区域中读取当前位置的数据 const flat_binder_object* flat = readObject(false); // 存在 if (flat) &#123; switch (flat-&gt;hdr.type) &#123; case BINDER_TYPE_BINDER: &#123; sp&lt;IBinder&gt; binder = reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie); return finishUnflattenBinder(binder, out); &#125; case BINDER_TYPE_HANDLE: &#123; // 注意此时收到的数据是经过Binder驱动加工过的，我们现在是在SystemServer进程 // 所以这个hdr.type从BINDER_TYPE_BINDER转成了BINDER_TYPE_HANDLE！ // 这里解包，注意flat_binder_object这个结构体，他里面的binder和handle是被组合成union结构的! // 所以封包的时候写存入的binder就是此时读取的handle，这也代表了Server App中对应的BBinder sp&lt;IBinder&gt; binder = ProcessState::self()-&gt;getStrongProxyForHandle(flat-&gt;handle); // 这里我们在回到#3.3.2中android_os_Parcel#android_os_Parcel_readStrongBinder // 就可以知道，其实SystemServer自始至终都是保存了来自Server App的BBinder相同数据但是转成了BpBinder的IBinder对象 return finishUnflattenBinder(binder, out); &#125; &#125; &#125; return BAD_TYPE;&#125; 这里有个疑问吼，我们看这个flat_binder_object结构的内容: 123456789101112131415typedef __u32 binder_size_t;struct flat_binder_object &#123; struct binder_object_header hdr; __u32 flags; /* 8 bytes of data. */ union &#123; binder_uintptr_t binder; /* local object */ __u32 handle; /* remote object */ &#125;; /* extra data associated with local object */ binder_uintptr_t cookie;&#125;; 这个handle是一个__u32类型的数据，说明该变量占4字节。 4.3.1 ProcessState#getStrongProxyForHandle(int32_t handle)12345678910111213141516171819202122232425262728293031sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); // 4.3.2 从mHandleToObject中获取handle对应的handle_entry handle_entry* e = lookupHandleLocked(handle); if (e != nullptr) &#123; IBinder* b = e-&gt;binder; // 第一次当然是null的 if (b == nullptr || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; if (handle == 0) &#123; Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, nullptr, 0); if (status == DEAD_OBJECT) return nullptr; &#125; // 4.3.3 创建BpBinder!!! b = BpBinder::create(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; // 这个result就是新创建的BpBinder,或者之前创建缓存的BpBinder return result;&#125; 4.3.2 ProcessState#lookupHandleLocked12345678910111213ProcessState::handle_entry* ProcessState::lookupHandleLocked(int32_t handle)&#123; // mHandleToObject 是Vector类型的数据集合 const size_t N=mHandleToObject.size(); if (N &lt;= (size_t)handle) &#123; handle_entry e; e.binder = nullptr; e.refs = nullptr; status_t err = mHandleToObject.insertAt(e, N, handle+1-N); if (err &lt; NO_ERROR) return nullptr; &#125; return &amp;mHandleToObject.editItemAt(handle);&#125; 这里传入的handle其实是Server App在打包数据时，获取的：obj.binder &#x3D; reinterpret_cast(local-&gt;getWeakRefs()), 然后经过驱动加工，可以视为BBinder的映射BpBinder的Token. 这里的细节我们后面分析。 一般来说每个BBinder都不一样(为什么呢，涉及到binder驱动以及Android的智能指针)，所以，这里的mHandleToObject是缓存IBinder对象，防止频繁创建销毁消耗资源。 4.3.3 创建BpBinder123456789101112131415161718192021222324252627282930313233343536373839404142434445464748BpBinder* BpBinder::create(int32_t handle) &#123; int32_t trackedUid = -1; // sCountByUidEnabled默认是false的，SystemServer进程是再开机过程中打开的 if (sCountByUidEnabled) &#123; // 获取Server App的UID trackedUid = IPCThreadState::self()-&gt;getCallingUid(); // 接下来是判断Server App是否存在过多的binder proxy对象 // 默认2500个, 对于SystemServer进程是6000个(也是开机过程中设置的nSetBinderProxyCountWatermarks) AutoMutex _l(sTrackingLock); uint32_t trackedValue = sTrackingMap[trackedUid]; if (CC_UNLIKELY(trackedValue &amp; LIMIT_REACHED_MASK)) &#123; if (sBinderProxyThrottleCreate) &#123; return nullptr; &#125; &#125; else &#123; if ((trackedValue &amp; COUNTING_VALUE_MASK) &gt;= sBinderProxyCountHighWatermark) &#123; ALOGE(&quot;Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)&quot;, getuid(), trackedUid, trackedValue); sTrackingMap[trackedUid] |= LIMIT_REACHED_MASK; if (sLimitCallback) sLimitCallback(trackedUid); if (sBinderProxyThrottleCreate) &#123; ALOGI(&quot;Throttling binder proxy creates from uid %d in uid %d until binder proxy&quot; &quot; count drops below %d&quot;, trackedUid, getuid(), sBinderProxyCountLowWatermark); return nullptr; &#125; &#125; &#125; // 该UID创建了新的BpBinder sTrackingMap[trackedUid]++; &#125; return new BpBinder(handle, trackedUid);&#125;BpBinder::BpBinder(int32_t handle, int32_t trackedUid) : mHandle(handle) , mStability(0) , mAlive(1) , mObitsSent(0) , mObituaries(nullptr) , mTrackedUid(trackedUid)&#123; ALOGV(&quot;Creating BpBinder %p handle %d\\n&quot;, this, mHandle); extendObjectLifetime(OBJECT_LIFETIME_WEAK); // 给此BpBinder新增一个弱引用 IPCThreadState::self()-&gt;incWeakHandle(handle, this);&#125; 最后补上一张IBinder类图: 了解了IBinder转换过程的原理，BinderProxy的生成过程，也知道了BBinder和BpBinder的映射关系，接下来就是在Client App和Server App之间的通信了。 参考资料 Android Binder详解 https://mr-cao.gitbooks.io/android/content/android-binder.html msm-4.14 Code https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Binder","slug":"Android/Binder","permalink":"https://swallowjoe.github.io/categories/Android/Binder/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://swallowjoe.github.io/tags/Binder/"}]},{"title":"Binder(1)--App使用Binder通信","slug":"Binder-1-App使用Binder通信","date":"2022-04-04T02:37:56.000Z","updated":"2022-04-04T02:56:11.761Z","comments":true,"path":"2022/04/04/Binder-1-App使用Binder通信/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/","excerpt":"简介在初学Android的时候，一般是从四大组件开始学起的。最开始学，是通过追代码流程的方式快速熟悉Android系统框架。 在这个速学的过程中，很多细节部分就被忽略掉了(这也是必须的，否则学起来极其痛苦且缓慢)。 比如四大组件之一的Service，在跨进程通信的时候，我们只知道是通过Binder通信的。至于内部实现是如何就不甚了了。 接下来我们通过一个简单的Demo深入探究这个跨进程通信的过程。","text":"简介在初学Android的时候，一般是从四大组件开始学起的。最开始学，是通过追代码流程的方式快速熟悉Android系统框架。 在这个速学的过程中，很多细节部分就被忽略掉了(这也是必须的，否则学起来极其痛苦且缓慢)。 比如四大组件之一的Service，在跨进程通信的时候，我们只知道是通过Binder通信的。至于内部实现是如何就不甚了了。 接下来我们通过一个简单的Demo深入探究这个跨进程通信的过程。 一. 在App之间使用Binder通信目标是在AppClient中给AppServer发送一个简单的字符串 1.1 创建Interface首先在服务端提供接口文件：IDemoInterface. Android Studio中通过”File-&gt;New-&gt;AIDL”创建这个 aidl 文件。 1234567interface IDemoInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void sayHello(long aLong, String aString);&#125; 创建之后需要在 “Build-&gt;Rebuild Project”, 生成对应可用的文件 1.2 实现服务端接口123456789101112131415class DemoService : Service() &#123; val mName = &quot;DemoService&quot; class DemoBinder:IDemoInterface.Stub() &#123; override fun sayHello(aLong: Long, aString: String?) &#123; Log.d(&quot;DemoService&quot;, &quot;$aString:$aLong&quot;) &#125; &#125; private val binder = DemoBinder() override fun onBind(intent: Intent?): IBinder? &#123; return binder &#125;&#125; 很简单，就是将传入的字符串输出出来。但是这个地方就有一个疑问，为啥是继承IDemoInterface.Stub呢？直接看这个文件的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* * This file is auto-generated. DO NOT MODIFY. */package com.oneplus.opbench.server;// Declare any non-default types here with import statementspublic interface IDemoInterface extends android.os.IInterface&#123; /** Default implementation for IDemoInterface. */ public static class Default implements com.oneplus.opbench.server.IDemoInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public void sayHello(long aLong, java.lang.String aString) throws android.os.RemoteException &#123; &#125; @Override public android.os.IBinder asBinder() &#123; return null; &#125; &#125; /** Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.oneplus.opbench.server.IDemoInterface &#123; private static final java.lang.String DESCRIPTOR = &quot;com.oneplus.opbench.server.IDemoInterface&quot;; /** Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.oneplus.opbench.server.IDemoInterface interface, * generating a proxy if needed. */ public static com.oneplus.opbench.server.IDemoInterface asInterface(android.os.IBinder obj) &#123; if ((obj==null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof com.oneplus.opbench.server.IDemoInterface))) &#123; return ((com.oneplus.opbench.server.IDemoInterface)iin); &#125; return new com.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; java.lang.String descriptor = DESCRIPTOR; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(descriptor); return true; &#125; case TRANSACTION_sayHello: &#123; data.enforceInterface(descriptor); long _arg0; _arg0 = data.readLong(); java.lang.String _arg1; _arg1 = data.readString(); this.sayHello(_arg0, _arg1); reply.writeNoException(); return true; &#125; default: &#123; return super.onTransact(code, data, reply, flags); &#125; &#125; &#125; private static class Proxy implements com.oneplus.opbench.server.IDemoInterface &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ @Override public void sayHello(long aLong, java.lang.String aString) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeLong(aLong); _data.writeString(aString); boolean _status = mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, 0); if (!_status &amp;&amp; getDefaultImpl() != null) &#123; getDefaultImpl().sayHello(aLong, aString); return; &#125; _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; public static com.oneplus.opbench.server.IDemoInterface sDefaultImpl; &#125; static final int TRANSACTION_sayHello = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); public static boolean setDefaultImpl(com.oneplus.opbench.server.IDemoInterface impl) &#123; if (Stub.Proxy.sDefaultImpl == null &amp;&amp; impl != null) &#123; Stub.Proxy.sDefaultImpl = impl; return true; &#125; return false; &#125; public static com.oneplus.opbench.server.IDemoInterface getDefaultImpl() &#123; return Stub.Proxy.sDefaultImpl; &#125; &#125; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ public void sayHello(long aLong, java.lang.String aString) throws android.os.RemoteException;&#125; 注释的就很清楚，是自动生成的文件。Stub是一个静态内部抽象类，继承了Binder和接口IDemoInterface。 1.3 客户端调用注意把服务端aidl文件夹内容拷贝到客户端项目的aidl文件内，然后客户端也rebuild一下project. 12345678910111213141516171819202122232425262728293031323334353637383940/* &lt;!-- for binder(aidl) --&gt; &lt;service android:name=&quot;.server.DemoService&quot; android:process=&quot;.DemoService&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.DemoService&quot;/&gt; &lt;/intent-filter&gt; &lt;/service&gt;*/ private fun attemptToBindService() &#123; val intent = Intent() Log.e(&quot;client&quot;, &quot; connected now&quot;) intent.action = &quot;android.intent.action.DemoService&quot; //服务类的Action intent.`package` = &quot;com.oneplus.opbench&quot; //服务端包名 // 建立通信 bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE) &#125; private val mDemoServiceConnection = object : ServiceConnection &#123; override fun onBindingDied(name: ComponentName?) &#123; Log.d(&quot;Client&quot;, &quot;DemoService died!&quot;) &#125; override fun onServiceDisconnected(p0: ComponentName?) &#123; Log.d(&quot;Client&quot;, &quot;DemoService disconnected!&quot;) &#125; override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) &#123; Log.d(&quot;Client&quot;, &quot;DemoService connected&quot;) // 远程服务连接成功，打个招呼 val mProxyBinder = IDemoInterface.Stub.asInterface(p1) try &#123; mProxyBinder.sayHello(5000, &quot;Hello?&quot;) &#125; catch (e:RemoteException) &#123; &#125; &#125; &#125; 相关类图 接下来我们从客户端的bindService建立远程连接开始看看是怎么通信的，当然这里我们重点是binder通信，而不是service的bind流程。 二. 通信过程分析跨进程通信的过程，一定要时刻谨记当前代码所处的进程哦, 为了方便和聚焦, 忽略非紧要代码。 2.1 Client&#x3D;&gt;ContextImpl.bindService12345678910111213141516171819202122232425262728@Overridepublic boolean bindService(Intent service, ServiceConnection conn, int flags) &#123; warnIfCallingFromSystemProcess(); return bindServiceCommon(service, conn, flags, null, mMainThread.getHandler(), null, getUser());&#125;private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, String instanceName, Handler handler, Executor executor, UserHandle user) &#123; // Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser. IServiceConnection sd; // ...... if (mPackageInfo != null) &#123; if (executor != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags); &#125; else &#123; // 2.1.1 获取IServiceConnection对象 sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags); &#125; &#125; // ....... // 2.2 看来是先与Android系统中的AMS服务通信 int res = ActivityManager.getService().bindIsolatedService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, instanceName, getOpPackageName(), user.getIdentifier()); // ......&#125; 2.1.1 LoadedApk.getServiceDispatcher1234567891011121314151617181920212223242526272829303132333435@UnsupportedAppUsagepublic final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; return getServiceDispatcherCommon(c, context, handler, null, flags);&#125; private IServiceConnection getServiceDispatcherCommon(ServiceConnection c, Context context, Handler handler, Executor executor, int flags) &#123; synchronized (mServices) &#123; LoadedApk.ServiceDispatcher sd = null; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); if (map != null) &#123; if (DEBUG) Slog.d(TAG, &quot;Returning existing dispatcher &quot; + sd + &quot; for conn &quot; + c); sd = map.get(c); &#125; if (sd == null) &#123; if (executor != null) &#123; sd = new ServiceDispatcher(c, context, executor, flags); &#125; else &#123; // 第一次建立连接，当然需要新建 sd = new ServiceDispatcher(c, context, handler, flags); &#125; if (DEBUG) Slog.d(TAG, &quot;Creating new dispatcher &quot; + sd + &quot; for conn &quot; + c); if (map == null) &#123; map = new ArrayMap&lt;&gt;(); mServices.put(context, map); &#125; map.put(c, sd); &#125; else &#123; sd.validate(context, handler, executor); &#125; // 返回的是ServiceDispatcher里的mIServiceConnection对象,是InnerConnection return sd.getIServiceConnection(); &#125;&#125; 这里就是将ServiceConnection做一个打包，存起来，隐藏细节，注意到返回的是 InnerConnection 类型哦。相关类图如下： 2.2 SytemServer&#x3D;&gt;AMS.bindIsolatedService这里其实就存在Binder通信，但是我们先不看，假设直接call过来了（四大组件之Service）. 我们知道，当服务端app进程没有启动时，会先将进程启动，然后继续进行bindService操作，为了方便，这里假设服务端进程已启动。 这里忽略中间一系列调用，走到ActiveServices.bindServiceLocked中: 123456789101112131415161718192021222324252627282930313233343536373839int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, final IServiceConnection connection, int flags, String instanceName, String callingPackage, final int userId) throws TransactionTooLargeException &#123; // ...... // 注意这里传入的connection是IServiceConnection // retrieveServiceLocked是从已安装的package中找到对应包以及指定Service组件 ServiceLookupResult res = retrieveServiceLocked(service, instanceName, resolvedType, callingPackage, Binder.getCallingPid(), Binder.getCallingUid(), userId, true, callerFg, isBindExternal, allowInstant); // ...... ServiceRecord s = res.record; // ...... // 根据我们之前的研究过的Service知识，这个AppBindRecord就是记录App之间Service通信的 AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp); ConnectionRecord c = new ConnectionRecord(b, activity, connection, flags, clientLabel, clientIntent, callerApp.uid, callerApp.processName, callingPackage); // 注意这里的connection.asBinder调用的就是IServiceConnection.Stub.Proxy.asBinder // 返回的就是mRemote IBinder binder = connection.asBinder(); // ...... if (s.app != null &amp;&amp; b.intent.received) &#123; // Service is already running, so we can immediately // publish the connection. try &#123; // c.conn就是Client端传入的IServiceConnection // 所以这里又调回去Client进程了，注意传入的b.intent.binder对象 // 这个传入的b.intent.binder对象就是服务端App发布Service时传入的（publishServiceLocked） // 其实可以猜得到是这个就是对应服务端App的IDemoInterface对象 // 2.3 转到Client进程 c.conn.connected(s.name, b.intent.binder, false); &#125; catch (Exception e) &#123; Slog.w(TAG, &quot;Failure sending service &quot; + s.shortInstanceName + &quot; to connection &quot; + c.conn.asBinder() + &quot; (in &quot; + c.binding.client.processName + &quot;)&quot;, e); &#125;&#125; 2.3 Client&#x3D;&gt;LoadedApk.ServiceDispatcher.InnerConnection.connected1234567public void connected(ComponentName name, IBinder service, boolean dead) throws RemoteException &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) &#123; sd.connected(name, service, dead); &#125;&#125; 2.3.1 LoadedApk.ServiceDispatcher.connected12345678910public void connected(ComponentName name, IBinder service, boolean dead) &#123; if (mActivityExecutor != null) &#123; mActivityExecutor.execute(new RunConnection(name, service, 0, dead)); &#125; else if (mActivityThread != null) &#123; // 2.3.2 这里其实最后还是调用到了doConnected mActivityThread.post(new RunConnection(name, service, 0, dead)); &#125; else &#123; doConnected(name, service, dead); &#125;&#125; 2.3.2 LoadedApk.ServiceDispatcher.doConnected123456789101112public void doConnected(ComponentName name, IBinder service, boolean dead) &#123; // ...... // 这个service就是服务端App中的DemoBinder中的mRemote了 if (service != null) &#123; // mDemoServiceConnection通知已经建立连接 mConnection.onServiceConnected(name, service); &#125; else &#123; // The binding machinery worked, but the remote returned null from onBind(). mConnection.onNullBinding(name); &#125;&#125; 2.3.3 客户端的ServiceConnection12345678910override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) &#123; Log.d(&quot;Client&quot;, &quot;DemoService connected&quot;) // 远程服务连接成功，打个招呼 val mProxyBinder = IDemoInterface.Stub.asInterface(p1) try &#123; mProxyBinder.sayHello(5000, &quot;Hello?&quot;) &#125; catch (e:RemoteException) &#123; &#125;&#125; 到这里，Android系统中两个进程通过四大组件之一的Service进行跨进程通信的连接已经建立了。 简单来说这个过程借助了SystemServer的帮助：Client app &lt;–&gt; SystemServer &lt;–&gt; Server app Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。这样Client App就有了和Server App通信的基础。 搞清楚是怎么建立连接的过程，接下来深入探究下mProxyBinder.sayHello调用到不同进程对应的方法的细节。 参考资料 Android Binder详解 https://mr-cao.gitbooks.io/android/content/android-binder.html","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Binder","slug":"Android/Binder","permalink":"https://swallowjoe.github.io/categories/Android/Binder/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"https://swallowjoe.github.io/tags/Binder/"}]},{"title":"SurfaceFlinger(5)--composer","slug":"SurfaceFlinger-5-composer","date":"2022-04-04T01:58:09.000Z","updated":"2022-04-04T02:30:13.509Z","comments":true,"path":"2022/04/04/SurfaceFlinger-5-composer/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-5-composer/","excerpt":"Andorid Q 接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。前面我们也稍微分析了一下，直接看handleMessageRefresh方法： 从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。 这里重点分析handleMessageRefresh.","text":"Andorid Q 接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。前面我们也稍微分析了一下，直接看handleMessageRefresh方法： 从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。 这里重点分析handleMessageRefresh. 一. handleMessageRefresh1.1 SurfaceFlinger:handleMessageRefresh1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void SurfaceFlinger::handleMessageRefresh() &#123; ATRACE_CALL(); mRefreshPending = false; const bool repaintEverything = mRepaintEverything.exchange(false); // 1.2 合成前再过一遍Layer是否被更新了 // 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。 preComposition(); // 1.3 重建layer堆栈, 提取可见的Laye并计算可见区域 // 并将数据更新给对应的Display rebuildLayerStacks(); // 1.4 hwcomposer的设定，将Layer数据更新给HWC calculateWorkingSet(); // 遍历所有Display，依次合成处理 for (const auto&amp; [token, display] : mDisplays) &#123; // 1.5 其实beginFrame和prepareFrame最终都是调用到FrameBufferSurface中，没有做特别的事情 beginFrame(display); prepareFrame(display); doDebugFlashRegions(display, repaintEverything); // 1.6 正式的合成处理，简单来说就是申请GraphicBuffer，向其中填充帧数据 // 最终给到硬件帧缓冲区 doComposition(display, repaintEverything); &#125; logLayerStats(); // 通知composer,即HWC postFrame(); // 回调每个layer的onPostComposition postComposition(); mHadClientComposition = false; mHadDeviceComposition = false; for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto displayId = display-&gt;getId(); mHadClientComposition = mHadClientComposition || getHwComposer().hasClientComposition(displayId); mHadDeviceComposition = mHadDeviceComposition || getHwComposer().hasDeviceComposition(displayId); &#125; // 根据状况决定是否更新Vsync Offset mVsyncModulator.onRefreshed(mHadClientComposition); // 清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加 mLayersWithQueuedFrames.clear();&#125; 1.2 SurfaceFlinger:perComposition12345678910111213141516171819202122232425262728293031void SurfaceFlinger::preComposition()&#123; ATRACE_CALL(); ALOGV(&quot;preComposition&quot;); // 记录刷新时间 mRefreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC); bool needExtraInvalidate = false; // 1.2.1 遍历所有layer, 处理处于Drawing状态的layer // 这里使用了lambda函数 mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; // 1.2.3 判断Layer是否需要更新 if (layer-&gt;onPreComposition(mRefreshStartTime)) &#123; // 如果有layer有frame更新，则标记该值为true，表示需要下一个vsync // 做合成 needExtraInvalidate = true; &#125; &#125;); if (needExtraInvalidate) &#123; signalLayerUpdate(); &#125;&#125;void SurfaceFlinger::State::traverseInZOrder(const LayerVector::Visitor&amp; visitor) const &#123; // 这里的mDrawingState里面的stateSet为StateSet::Drawing layersSortedByZ.traverseInZOrder(stateSet, visitor);&#125;// SurfaceFlinger.hState mDrawingState&#123;LayerVector::StateSet::Drawing&#125;; layersSortedByZ中存储的layer都是SurfaceFlinger.addClientLayer过程中添加的。 1.2.1 LayerVector:traverseInZOrder1234567891011121314151617void LayerVector::traverseInZOrder(StateSet stateSet, const Visitor&amp; visitor) const &#123; for (size_t i = 0; i &lt; size(); i++) &#123; const auto&amp; layer = (*this)[i]; // 遍历所有layer，拿到合适State的Layer做处理 // 这里是拿所有Drawing状态的Layer auto&amp; state = (stateSet == StateSet::Current) ? layer-&gt;getCurrentState() : layer-&gt;getDrawingState(); // zOrderRelativeOf中的layer是上层调用setRelativeLayer后添加的 // 如果为非null，则表示此Surface的Z顺序相对于此进行解释 // 默认是null的。 if (state.zOrderRelativeOf != nullptr) &#123; continue; &#125; // 处理Layer layer-&gt;traverseInZOrder(stateSet, visitor); &#125;&#125; 1.2.2 Layer:traverseInZOrder1234567891011121314151617181920212223242526272829303132333435363738void Layer::traverseInZOrder(LayerVector::StateSet stateSet, const LayerVector::Visitor&amp; visitor) &#123; bool skipRelativeZUsers = false; // 1.2.2.1 按顺序将当前Layer所有z轴相关的layer和子layer添加至列表 const LayerVector list = makeTraversalList(stateSet, &amp;skipRelativeZUsers); // 也就是说首先遍历Z轴相关的Layer size_t i = 0; for (; i &lt; list.size(); i++) &#123; const auto&amp; relative = list[i]; if (skipRelativeZUsers &amp;&amp; relative-&gt;usingRelativeZ(stateSet)) &#123; continue; &#125; // 注意Layer的添加都是按照Z轴顺序插入排序的 // 这里的意思就是首先要遍历并对所有z轴小于0的Layer调用onPreComposition方法 // 所以需要理解z轴小于0的意义，什么时候z轴值才会小于0？ // 因为P/Q上Layer组合的数据结构是：树形结构+Z轴排序。现在Z轴的大小一般为 [-2, 2] // Z轴小的在下面会被覆盖。现在可以理解了，这里为什么碰到z大于0就要退出循环了 if (relative-&gt;getZ() &gt;= 0) &#123; break; &#125; relative-&gt;traverseInZOrder(stateSet, visitor); &#125; // 对本Layer做onPreComposition visitor(this); // 最后对所有Z轴不小于0的Layer做onPreComposition for (; i &lt; list.size(); i++) &#123; const auto&amp; relative = list[i]; if (skipRelativeZUsers &amp;&amp; relative-&gt;usingRelativeZ(stateSet)) &#123; continue; &#125; relative-&gt;traverseInZOrder(stateSet, visitor); &#125;&#125; visitor这个就是lambda表达式： 1234567mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; // 1.2.3 调用onPreComposition if (layer-&gt;onPreComposition(mRefreshStartTime)) &#123; needExtraInvalidate = true; &#125;&#125;); 总的来说就是按顺序依次调用layer的onPreComposition方法，标记其mRefreshPending为false。 1.2.2.1 Layer:makeTraversalList12345678910111213141516171819202122232425262728293031323334// __attribute__((no_sanitize(&quot;unsigned-integer-overflow&quot;)))的意思// 是不进行无符号int溢出检测__attribute__((no_sanitize(&quot;unsigned-integer-overflow&quot;))) LayerVector Layer::makeTraversalList( LayerVector::StateSet stateSet, bool* outSkipRelativeZUsers) &#123; LOG_ALWAYS_FATAL_IF(stateSet == LayerVector::StateSet::Invalid, &quot;makeTraversalList received invalid stateSet&quot;); // 这里useDrawing为true const bool useDrawing = stateSet == LayerVector::StateSet::Drawing; const LayerVector&amp; children = useDrawing ? mDrawingChildren : mCurrentChildren; const State&amp; state = useDrawing ? mDrawingState : mCurrentState; // 假设没有zOrderRelatives，所以直接返回children if (state.zOrderRelatives.size() == 0) &#123; *outSkipRelativeZUsers = true; return children; &#125; // 如果存在，则将相关的layer按照Z轴顺序加入stateSet.Drawing中 LayerVector traverse(stateSet); for (const wp&lt;Layer&gt;&amp; weakRelative : state.zOrderRelatives) &#123; sp&lt;Layer&gt; strongRelative = weakRelative.promote(); if (strongRelative != nullptr) &#123; traverse.add(strongRelative); &#125; &#125; // 遍历所有children，将children的相关Layer添加至traverse for (const sp&lt;Layer&gt;&amp; child : children) &#123; const State&amp; childState = useDrawing ? child-&gt;mDrawingState : child-&gt;mCurrentState; if (childState.zOrderRelativeOf != nullptr) &#123; continue; &#125; traverse.add(child); &#125; return traverse;&#125; 回到1.2.2中。 1.2.3 Layer:BufferLayer::onPreComposition12345678bool BufferLayer::onPreComposition(nsecs_t refreshStartTime) &#123; if (mBufferLatched) &#123; Mutex::Autolock lock(mFrameEventHistoryMutex); mFrameEventHistory.addPreComposition(mCurrentFrameNumber, refreshStartTime); &#125; mRefreshPending = false; return hasReadyFrame();&#125; 记录开始刷新的时间，并返回该Layer是否具有可被合成的条件。 1.2.3.1 Layer:BufferLayer::hasReadyFrame123bool BufferLayer::hasReadyFrame() const &#123; return hasFrameUpdate() || getSidebandStreamChanged() || getAutoRefresh();&#125; 1.2.3.2 Layer:BufferLayer:BufferQueueLayer123456789101112bool BufferQueueLayer::hasFrameUpdate() const &#123; // 是否具有绘制完成的frame return mQueuedFrames &gt; 0;&#125;bool BufferQueueLayer::getAutoRefresh() const &#123; return mAutoRefresh;&#125;bool BufferQueueLayer::getSidebandStreamChanged() const &#123; return mSidebandStreamChanged;&#125; 1.3 SurfaceFlinger:rebuildLayerStacks这个方法比较长，慢慢看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106void SurfaceFlinger::rebuildLayerStacks() &#123; ATRACE_CALL(); ALOGV(&quot;rebuildLayerStacks&quot;); Mutex::Autolock lock(mDolphinStateLock); // 对每个display重建其layer列表 // mVisibleRegionsDirty的这个变量在如下条件会被置为true: // 1. 有layer的增删时 // 2. layer可视化面积发生变化 // 3. display显示设备变化 // 4. set power mode on - 即亮屏时 if (CC_UNLIKELY(mVisibleRegionsDirty)) &#123; ATRACE_NAME(&quot;rebuildLayerStacks VR Dirty&quot;); mVisibleRegionsDirty = false; // 就是将mGeometryInvalid置为true // 这个值影响后续是否需要hwc合成 invalidateHwcGeometry(); // 对每一个Display做处理，适配多屏场景 // mDisplays的类型是：std::map&lt;wp&lt;IBinder&gt;, sp&lt;DisplayDevice&gt;&gt; for (const auto&amp; pair : mDisplays) &#123; const auto&amp; displayDevice = pair.second; auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); Region opaqueRegion; Region dirtyRegion; compositionengine::Output::OutputLayers layersSortedByZ; Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ; Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences; const ui::Transform&amp; tr = displayState.transform; const Rect bounds = displayState.bounds; if (displayState.isEnabled) &#123; // 2.1 计算可视区域 computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion); // 顺序遍历Z轴Layer mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; auto compositionLayer = layer-&gt;getCompositionLayer(); if (compositionLayer == nullptr) &#123; return; &#125; const auto displayId = displayDevice-&gt;getId(); sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;getLayerFE(); LOG_ALWAYS_FATAL_IF(layerFE.get() == nullptr); bool needsOutputLayer = false; // 对属于给定图层堆栈上的layer, 将其可视区域与其所在Display相交 // 相交结果不为空，则说明其在或者其一部分在显示屏幕上 // needsOutputLayer标记为true if (display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123; Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion)); drawRegion.andSelf(bounds); if (!drawRegion.isEmpty()) &#123; needsOutputLayer = true; &#125; &#125; // Layer有内容在屏幕上 if (needsOutputLayer) &#123; layersSortedByZ.emplace_back( display-&gt;getOrCreateOutputLayer(displayId, compositionLayer, layerFE)); deprecated_layersSortedByZ.add(layer); auto&amp; outputLayerState = layersSortedByZ.back()-&gt;editState(); outputLayerState.visibleRegion = tr.transform(layer-&gt;visibleRegion.intersect(displayState.viewport)); &#125; else if (displayId) &#123; // 到这个分支里说明Layer之前有内容显示，但现在没有内容显示在屏幕上 // 此时我们需要清理该Layer对应的Fence，销毁HWC Layer bool hasExistingOutputLayer = display-&gt;getOutputLayerForLayer(compositionLayer.get()) != nullptr; // mLayersWithQueuedFrames 这个变量还记不，是在handlePageFlip方法中，顺序 // 遍历Z轴Layer时添加进入的。 bool hasQueuedFrames = std::find(mLayersWithQueuedFrames.cbegin(), mLayersWithQueuedFrames.cend(), layer) != mLayersWithQueuedFrames.cend(); if (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123; layersNeedingFences.add(layer); &#125; &#125; &#125;); &#125; // 将数据更新到Display中 display-&gt;setOutputLayersOrderedByZ(std::move(layersSortedByZ)); displayDevice-&gt;setVisibleLayersSortedByZ(deprecated_layersSortedByZ); displayDevice-&gt;setLayersNeedingFences(layersNeedingFences); // 未定义的区域。也就是屏幕的大小减去屏幕的非透明区域opaqueRegion余下的部分。 Region undefinedRegion&#123;bounds&#125;; undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); display-&gt;editState().undefinedRegion = undefinedRegion; display-&gt;editState().dirtyRegion.orSelf(dirtyRegion); &#125; &#125;&#125; 总的来说，rebuildLayerStacks就是反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。 1.4 SurfaceFlinger::calculateWorkingSet再看这个方法之前先瞄一眼各个Layer之前的关系： 上图中标红的appId就是在此方法内的latchCompositionState方法中赋值的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182void SurfaceFlinger::calculateWorkingSet() &#123; ATRACE_CALL(); ALOGV(__FUNCTION__); // 建立HWC中的Layer列表 if (CC_UNLIKELY(mGeometryInvalid)) &#123; mGeometryInvalid = false; // 同样需要针对各个Display做处理 for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); uint32_t zOrder = 0; // 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射 for (auto&amp; layer : display-&gt;getOutputLayersOrderedByZ()) &#123; auto&amp; compositionState = layer-&gt;editState(); compositionState.forceClientComposition = false; if (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123; compositionState.forceClientComposition = true; &#125; // Z轴顺序依次递增 compositionState.z = zOrder++; // 更新与显示无关的合成状态，其实就是将Layer的状态信息放在CompositionState中了。 // 也就是frontEnd（LayerFECompositionState）中 layer-&gt;getLayerFE().latchCompositionState(layer-&gt;getLayer().editState().frontEnd, true); // 重新计算OutputLayer的几何状态 // 比如根据显示屏全局矩阵调整该Layer的DisplayFrame、 // 变换窗口裁剪以匹配缓冲区坐标系等等。 layer-&gt;updateCompositionState(true); // 将Layer更新完毕的几何状态写入HWC layer-&gt;writeStateToHWC(true); &#125; &#125; &#125; // 设置每帧的数据 for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto displayId = display-&gt;getId(); if (!displayId) &#123; continue; &#125; auto* profile = display-&gt;getDisplayColorProfile(); if (mDrawingState.colorMatrixChanged) &#123; display-&gt;setColorTransform(mDrawingState.colorMatrix); &#125; Dataspace targetDataspace = Dataspace::UNKNOWN; if (useColorManagement) &#123; ColorMode colorMode; RenderIntent renderIntent; pickColorMode(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent); display-&gt;setColorMode(colorMode, targetDataspace, renderIntent); &#125; for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123; ...... const auto&amp; displayState = display-&gt;getState(); // 将Layer的mActiveBuffer设置到HWComposer中 layer-&gt;setPerFrameData(displayDevice, displayState.transform, displayState.viewport, displayDevice-&gt;getSupportedPerFrameMetadata(), isHdrColorMode(displayState.colorMode) ? Dataspace::UNKNOWN : targetDataspace); &#125; &#125; mDrawingState.colorMatrixChanged = false; for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123; auto&amp; layerState = layer-&gt;getCompositionLayer()-&gt;editState().frontEnd; layerState.compositionType = static_cast&lt;Hwc2::IComposerClient::Composition&gt;( layer-&gt;getCompositionType(displayDevice)); &#125; &#125;&#125; 这里建立HWC中的Layer列表： 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC 将Layer的mActiveBuffer设置到HWComposer中 1.5 SurfaceFlinger::beginFrame开始合成前的准备。 12345678910111213141516171819202122232425262728void SurfaceFlinger::beginFrame(const sp&lt;DisplayDevice&gt;&amp; displayDevice) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); // 是否有待更新的区域 bool dirty = !display-&gt;getDirtyRegion(false).isEmpty(); // 可见Layer数量是否为0 bool empty = displayDevice-&gt;getVisibleLayersSortedByZ().size() == 0; // 上次合成是否有可见Layer bool wasEmpty = !displayState.lastCompositionHadVisibleLayers; // 没有变化时或者有变化但此时没有可见Layer且上次合成时也没有就跳过 bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty); const char flagPrefix[] = &#123;&#x27;-&#x27;, &#x27;+&#x27;&#125;; static_cast&lt;void&gt;(flagPrefix); ALOGV_IF(displayDevice-&gt;isVirtual(), &quot;%s: %s composition for %s (%cdirty %cempty %cwasEmpty)&quot;, __FUNCTION__, mustRecompose ? &quot;doing&quot; : &quot;skipping&quot;, displayDevice-&gt;getDebugName().c_str(), flagPrefix[dirty], flagPrefix[empty], flagPrefix[wasEmpty]); // 这里面其实没有做什么特殊的操作，我们看一下DisplayDevice相关的类 display-&gt;getRenderSurface()-&gt;beginFrame(mustRecompose); if (mustRecompose) &#123; display-&gt;editState().lastCompositionHadVisibleLayers = !empty; &#125;&#125; 这个DiplayDevice是怎么初始化的呢，后续再看。 1.6 SurfaceFlinger::doComposition123456789101112131415161718192021void SurfaceFlinger::doComposition(const sp&lt;DisplayDevice&gt;&amp; displayDevice, bool repaintEverything) &#123; ATRACE_CALL(); ALOGV(&quot;doComposition&quot;); auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); if (displayState.isEnabled) &#123; // 将脏区转换为该屏幕的坐标空间 const Region dirtyRegion = display-&gt;getDirtyRegion(repaintEverything); // 1.6.1 请求buffer,做合成操作 doDisplayComposition(displayDevice, dirtyRegion); display-&gt;editState().dirtyRegion.clear(); display-&gt;getRenderSurface()-&gt;flip(); &#125; // Fence同步相关处理，暂时忽略 postFramebuffer(displayDevice);&#125; 1.6.1 SurfaceFlinger::doDisplayComposition12345678910111213141516171819202122void SurfaceFlinger::doDisplayComposition(const sp&lt;DisplayDevice&gt;&amp; displayDevice, const Region&amp; inDirtyRegion) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); // 仅在以下情况下才需要实际构成显示： // 1）由HWC处理，它可能需要此操作以使其虚拟显示状态机保持同步 // 2）有工作要做（脏区不为空） if (!displayDevice-&gt;getId() &amp;&amp; inDirtyRegion.isEmpty()) &#123; ALOGV(&quot;Skipping display composition&quot;); return; &#125; ALOGV(&quot;doDisplayComposition&quot;); base::unique_fd readyFence; // 1.6.2 合成Surface if (!doComposeSurfaces(displayDevice, Region::INVALID_REGION, &amp;readyFence)) return; // 交换缓冲区，buffer已经被填充了合成所有Layer后的帧数据。 // 将FrameBuffer发送给HWC, 也就是将内容渲染到硬件帧缓冲区中去 display-&gt;getRenderSurface()-&gt;queueBuffer(std::move(readyFence));&#125; 1.6.2 SurfaceFlinger::doComposeSurfaces123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128bool SurfaceFlinger::doComposeSurfaces(const sp&lt;DisplayDevice&gt;&amp; displayDevice, const Region&amp; debugRegion, base::unique_fd* readyFence) &#123; ATRACE_CALL(); ALOGV(&quot;doComposeSurfaces&quot;); auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); const auto displayId = display-&gt;getId(); auto&amp; renderEngine = getRenderEngine(); const bool supportProtectedContent = renderEngine.supportsProtectedContent(); const Region bounds(displayState.bounds); const DisplayRenderArea renderArea(displayDevice); const bool hasClientComposition = getHwComposer().hasClientComposition(displayId); ATRACE_INT(&quot;hasClientComposition&quot;, hasClientComposition); bool applyColorMatrix = false; renderengine::DisplaySettings clientCompositionDisplay; std::vector&lt;renderengine::LayerSettings&gt; clientCompositionLayers; sp&lt;GraphicBuffer&gt; buf; base::unique_fd fd; if (hasClientComposition) &#123; ALOGV(&quot;hasClientComposition&quot;); ...... // 请求GraphicBuffer, 通过ANativeWindow向GPU申请 buf = display-&gt;getRenderSurface()-&gt;dequeueBuffer(&amp;fd); if (buf == nullptr) &#123; ALOGW(&quot;Dequeuing buffer for display [%s] failed, bailing out of &quot; &quot;client composition for this frame&quot;, displayDevice-&gt;getDisplayName().c_str()); return false; &#125; // 将DisplayState相关信息赋值给clientCompositionDisplay，以供HWC使用 clientCompositionDisplay.physicalDisplay = displayState.scissor; clientCompositionDisplay.clip = displayState.scissor; const ui::Transform&amp; displayTransform = displayState.transform; clientCompositionDisplay.globalTransform = displayTransform.asMatrix4(); clientCompositionDisplay.orientation = displayState.orientation; const auto* profile = display-&gt;getDisplayColorProfile(); Dataspace outputDataspace = Dataspace::UNKNOWN; if (profile-&gt;hasWideColorGamut()) &#123; outputDataspace = displayState.dataspace; &#125; clientCompositionDisplay.outputDataspace = outputDataspace; clientCompositionDisplay.maxLuminance = profile-&gt;getHdrCapabilities().getDesiredMaxLuminance(); const bool hasDeviceComposition = getHwComposer().hasDeviceComposition(displayId); const bool skipClientColorTransform = getHwComposer() .hasDisplayCapability(displayId, HWC2::DisplayCapability::SkipClientColorTransform); // Compute the global color transform matrix. applyColorMatrix = !hasDeviceComposition &amp;&amp; !skipClientColorTransform; if (applyColorMatrix) &#123; clientCompositionDisplay.colorTransform = displayState.colorTransformMat; &#125; &#125; /* * 现在渲染以帧缓冲区为目标的图层 */ ALOGV(&quot;Rendering client layers&quot;); bool firstLayer = true; Region clearRegion = Region::INVALID_REGION; // 遍历所有可见Layer for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123; const Region viewportRegion(displayState.viewport); const Region clip(viewportRegion.intersect(layer-&gt;visibleRegion)); ALOGV(&quot;Layer: %s&quot;, layer-&gt;getName().string()); ALOGV(&quot; Composition type: %s&quot;, toString(layer-&gt;getCompositionType(displayDevice)).c_str()); if (!clip.isEmpty()) &#123; switch (layer-&gt;getCompositionType(displayDevice)) &#123; ...... case Hwc2::IComposerClient::Composition::CLIENT: &#123; renderengine::LayerSettings layerSettings; // 根据相关配置设置Layer状态：渲染区域、alpha通道、颜色变换等等 bool prepared = layer-&gt;prepareClientLayer(renderArea, clip, clearRegion, supportProtectedContent, layerSettings); if (prepared) &#123; // 放入clientCompositionLayers中备用 clientCompositionLayers.push_back(layerSettings); &#125; break; &#125; default: break; &#125; &#125; else &#123; ALOGV(&quot; Skipping for empty clip&quot;); &#125; firstLayer = false; &#125; // hasClientComposition为true说明使用GPU合成 if (hasClientComposition) &#123; clientCompositionDisplay.clearRegion = clearRegion; // 在这里提高GPU频率，因为会进行色彩空间转换，比较耗时。 // 提高了GPU频率，以便GPU合成可以及时完成。 // 之后必须重新设置GPU频率，因为高频率会消耗额外的电池。 const bool expensiveRenderingExpected = clientCompositionDisplay.outputDataspace == Dataspace::DISPLAY_P3; if (expensiveRenderingExpected &amp;&amp; displayId) &#123; mPowerAdvisor.setExpensiveRenderingExpected(*displayId, true); &#125; ....... // 使用渲染引擎（renderengine/gl/GLESRenderEngine.cpp）合成所有Layer renderEngine.drawLayers(clientCompositionDisplay, clientCompositionLayers, buf-&gt;getNativeBuffer(), /*useFramebufferCache=*/true, std::move(fd), readyFence); &#125; else if (displayId) &#123; mPowerAdvisor.setExpensiveRenderingExpected(*displayId, false); &#125; return true;&#125; 先请求GraphicBuffer，然后通过GLESRenderEngine合成所有Layer. 二. 计算Layer可视区域一般来讲，我们手机App Layer如下： 计算可视区域的时候，从Z轴大的开始遍历计算。这样做的好处是，如果计算到某一层Layer时，完全不透明的可视化区域已经占满整个屏幕，那么这之下的Layer可视化区域就可以不用计算了。 在开始阅读代码之前，还是有必要理清楚： 可见区域（Visible Region） 透明区域（Transparent Region） 半透明区域（Translucent Region） 完全不透明区域（Opaque Region） 被覆盖区域（Covered Region） 如下图: 如果A1为W2中半透明区域，A2在W1中全透明，W2中不透明，A3为W1中完全不透明区域。则对于Surface W2而言，可见区域为W2-A1-A3. 2.1 SurfaceFlinger:computeVisibleRegions123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173void SurfaceFlinger::computeVisibleRegions(const sp&lt;const DisplayDevice&gt;&amp; displayDevice, Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion) &#123; ATRACE_CALL(); ALOGV(&quot;computeVisibleRegions&quot;); auto display = displayDevice-&gt;getCompositionDisplay(); Region aboveOpaqueLayers; Region aboveCoveredLayers; Region dirty; outDirtyRegion.clear(); // 先找到“感兴趣的”Layer，也就是这个layer是属于SecureDisplay的 // 暂时没有找到相关的说明，忽略好了 Layer* layerOfInterest = NULL; bool bIgnoreLayer = false; mDrawingState.traverseInReverseZOrder([&amp;](Layer* layer) &#123; if (layer-&gt;isSecureDisplay()) &#123; bIgnoreLayer = true; if (displayDevice-&gt;isPrimary()) &#123; layerOfInterest = layer; &#125; return; &#125; &#125;); // 反向遍历Z轴计算可视化区域 mDrawingState.traverseInReverseZOrder([&amp;](Layer* layer) &#123; // 获取当前绘制中的Surface const Layer::State&amp; s(layer-&gt;getDrawingState()); // 只考虑给定图层堆栈上的layer if (!display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123; return; &#125; // 忽略SecureDisplay中的layer if (bIgnoreLayer &amp;&amp; layerOfInterest != layer) &#123; Region visibleNonTransRegion; visibleNonTransRegion.set(Rect(0, 0)); layer-&gt;setVisibleNonTransparentRegion(visibleNonTransRegion); return; &#125; // 完全不透明的Surface区域 Region opaqueRegion; // 在屏幕上可见且不完全透明的Surface区域。 // 这实际上是该层的足迹减去其上方的不透明区域。 // 半透明Surface覆盖的区域被认为是可见的。 Region visibleRegion; // 被其上方所有可见区域覆盖的Surface区域（包括半透明区域）。 Region coveredRegion; // 暗示完全透明的表面区域。 这仅用于告诉图层何时没有可见的非透明区域，可以将其从图层列表中删除。 // 它不会影响此层或它下面的任何层的visibleRegion。 // 如果应用程序不遵守SurfaceView限制（不幸的是，有些不遵守），则提示可能不正确。 Region transparentRegion; // 处理不可见或者被隐藏的Surface的方式就是将其可视化的区域设置为空 if (CC_LIKELY(layer-&gt;isVisible())) &#123; // 如果该Surface不是完全不透明的，则视为半透明 const bool translucent = !layer-&gt;isOpaque(s); Rect bounds(layer-&gt;getScreenBounds()); // 当前Surface的可视区域默认为屏幕大小或者Surface在屏幕中的大小 visibleRegion.set(bounds); ui::Transform tr = layer-&gt;getTransform(); // Region为空则说明没有可视区域 // 注意 Region 是一个矩形（Rect）集合 if (!visibleRegion.isEmpty()) &#123; // 首先从可见区域移除透明区域 if (translucent) &#123; // 函数preserveRects的返回值为false // 说明需要忽略掉当前正在处理的应用程序窗口的透明区域 if (tr.preserveRects()) &#123; // 标记透明区域，这个透明区域就是transparentRegionHint遍历 // 在 SurfaceFlinger.setClientStateLocked过程中设置的 transparentRegion = tr.transform(layer-&gt;getActiveTransparentRegion(s)); &#125; else &#123; // 转换太复杂，无法进行透明区域优化。 transparentRegion.clear(); &#125; &#125; // 计算不透明区域 const int32_t layerOrientation = tr.getOrientation(); if (layer-&gt;getAlpha() == 1.0f &amp;&amp; !translucent &amp;&amp; layer-&gt;getRoundedCornerState().radius == 0.0f &amp;&amp; ((layerOrientation &amp; ui::Transform::ROT_INVALID) == false)) &#123; // 当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时 // 那么它的完全不透明区域opaqueRegion就等于计算所得到的可见区域visibleRegion opaqueRegion = visibleRegion; &#125; &#125; &#125; // 该Surface没有可视区域，则清空相关变量，直接返回 if (visibleRegion.isEmpty()) &#123; layer-&gt;clearVisibilityRegions(); return; &#125; // 将覆盖区域裁剪到可见区域 // aboveCoveredLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的可见区域 // 将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相交，就可以得到当前正在处理的应用程序窗口的被覆盖区域coveredRegion // 而将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相或一下，就可以得到下一个应用程序窗口的所有上层应用程序窗口所组成的可见区域aboveCoveredLayers。 coveredRegion = aboveCoveredLayers.intersect(visibleRegion); // aboveOpaqueLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的完全不透明区域 aboveCoveredLayers.orSelf(visibleRegion); // 这个区域从当前正在处理的应用程序窗口的可见区域visibleRegion减去后，就可以得到当前正在处理的应用程序窗口的最终可见区域visibleRegion。 visibleRegion.subtractSelf(aboveOpaqueLayers); // 计算Layer的脏区域，所谓脏区域就是需要重新执行渲染操作的 if (layer-&gt;contentDirty) &#123; // 成员变量contentDirty的值为true，则说明当前正在处理的Layer上一次的状态还未来得及处理 // 即它当前的内容是脏的。在这个状况下，只需要将此次的可见区域与上一次的可见区域合并即可 dirty = visibleRegion; // as well, as the old visible region dirty.orSelf(layer-&gt;visibleRegion); layer-&gt;contentDirty = false; &#125; else &#123; // 当上一次状态已经处理了，也就是显示内容没有更新,则无需重新渲染所有区域。 // 现在只需要处理一下两种情况： // 1. 之前是被覆盖的区域，但现在不被覆盖了 // 2. 由于窗口大小变化而引发的新增不被覆盖区域 // 针对第一种情况: // 将当前可见区域visibleRegion与它的上一次被覆盖区域oldCoveredRegion相交 // 就可以得到之前是被覆盖的而现在不被覆盖了的区域，即可以得到第一部分需要重新渲染的区域 // 上一次可见区域和被覆盖区域分别oldVisibleRegion, oldCoveredRegion // 针对第二种情况: // 由于将一个应用程序窗口的当前可见区域减去被覆盖区域即为它的当前不被覆盖的区域newExposed // 同理上一次不被覆盖的区域oldExposed就是上一次可见区域减去上一次被覆盖区域 // 那么将一个应用程序窗口的当前不被覆盖的区域newExposed减去它的上一次不被覆盖的区域oldExposed，就可以得到新增的不被覆盖区域 const Region newExposed = visibleRegion - coveredRegion; const Region oldVisibleRegion = layer-&gt;visibleRegion; const Region oldCoveredRegion = layer-&gt;coveredRegion; const Region oldExposed = oldVisibleRegion - oldCoveredRegion; // 将第一部分和第二部分需要重新渲染的区域组合起来，就可以得到当前Layer的脏区域dirty。 dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed); &#125; // 从该脏区域dirty减去上层的完全不透明区域 // 因为后者的渲染不需要当前Layer参与 dirty.subtractSelf(aboveOpaqueLayers); // 新的脏区域dirty累计到输出参数dirtyRegion中. outDirtyRegion.orSelf(dirty); // 更新计算到目前为止所得到的Layer的完全不透明区域 // 这个是方便下一层Layer的计算 aboveOpaqueLayers.orSelf(opaqueRegion); // 保存当前正在处理的Layer的可见区域和被覆盖区域以及可见非透明区域. layer-&gt;setVisibleRegion(visibleRegion); layer-&gt;setCoveredRegion(coveredRegion); layer-&gt;setVisibleNonTransparentRegion( visibleRegion.subtract(transparentRegion)); &#125;); // 将前面所有的Layer组成的完全不透明区域aboveOpaqueLayers保存在输出参数opaqueRegion中 outOpaqueRegion = aboveOpaqueLayers;&#125; 三. 小结handleMessageRefresh – SF合成所有Layer大概步骤如下： preComposition合成前遍历所有layer, 处理处于Drawing状态的Layer是否被更新了 rebuildLayerStacks反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。 calculateWorkingSet这里建立HWC中的Layer列表： 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC 将Layer的mActiveBuffer设置到HWComposer中 doComposition正式的合成处理，使用渲染引擎合成所有layer，然后就是申请GraphicBuffer，向其中填充帧数据, 最终给到硬件帧缓冲区 postComposition &amp;&amp; clear mLayersWithQueuedFrames回调每个layer的onPostComposition并清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加 大概流程搞清楚了，接下来细细分析比如GraphicBuffer和Fence机制的工作原理, 等等，HWC好像还没有了解，先看看这个是怎么工作的。 参考资料 [Android Synchronization Fences – An Introduction]http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html [Android 4.0.3 显示系统深入理解]https://www.linuxidc.com/Linux/2012-03/55898p4.htm [Clang 10 documentation ATTRIBUTES IN CLANG]https://clang.llvm.org/docs/AttributeReference.html [「Android」SurfaceFlinger分析]https://www.cnblogs.com/1996swg/p/9790209.html [显示系统：第005课_Vsync机制:第007节_rebuildLayerStacks源码分析]http://www.pianshen.com/article/8541345041/ [Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析]https://blog.csdn.net/luoshengyang/article/details/8079456 [Android Region代码分析]https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"SurfaceFlinger","slug":"Android/SurfaceFlinger","permalink":"https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"https://swallowjoe.github.io/tags/SurfaceFlinger/"}]},{"title":"SurfaceFlinger(4)--Layer&Surface","slug":"SurfaceFlinger-4-Layer-Surface","date":"2022-04-04T01:57:56.000Z","updated":"2022-04-04T02:29:13.183Z","comments":true,"path":"2022/04/04/SurfaceFlinger-4-Layer-Surface/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-4-Layer-Surface/","excerpt":"Android Q 前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。接下来我们先看看SurfaceFlinger合成帧的部分。","text":"Android Q 前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。接下来我们先看看SurfaceFlinger合成帧的部分。 一. SF EventThread接收vsync的准备在SFEventThread一文中已经探明，当产生Vsync信号后，会通过BitTube发送事件(EventThreadConnection.postEvent): 1234status_t EventThreadConnection::postEvent(const DisplayEventReceiver::Event&amp; event) &#123; ssize_t size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);&#125; 这里我们就需要知道 mChannel 是被谁监听了。 1.1 SurfaceFlinger.init123456789101112void SurfaceFlinger::init() &#123; ... // 1.1.1 创建SfEventThread以及EventThreadConnection mSfConnectionHandle = mScheduler-&gt;createConnection(&quot;sf&quot;, mPhaseOffsets-&gt;getCurrentSfOffset(), resyncCallback, [this](nsecs_t timestamp) &#123; mInterceptor-&gt;saveVSyncEvent(timestamp); &#125;); // 1.2 赋值 BitTube, 用来通信 mEventQueue-&gt;setEventConnection(mScheduler-&gt;getEventConnection(mSfConnectionHandle)); ...&#125; 这里的mEventQueue是在SurfaceFlinger.onFirstRef中初始化的。 1234567891011void SurfaceFlinger::onFirstRef()&#123; mEventQueue-&gt;init(this); ...&#125;void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123; mFlinger = flinger; mLooper = new Looper(true); mHandler = new Handler(*this);&#125; 这个Looper就是SurfaceFlinger主线程的Looper. 1.1.1 Scheduler.createConnection1234567891011121314151617181920212223242526sp&lt;Scheduler::ConnectionHandle&gt; Scheduler::createConnection( const char* connectionName, int64_t phaseOffsetNs, ResyncCallback resyncCallback, impl::EventThread::InterceptVSyncsCallback interceptCallback) &#123; const int64_t id = sNextId++; ALOGV(&quot;Creating a connection handle with ID: %&quot; PRId64 &quot;\\n&quot;, id); // 创建 sfEventThread std::unique_ptr&lt;EventThread&gt; eventThread = makeEventThread(connectionName, mPrimaryDispSync.get(), phaseOffsetNs, std::move(interceptCallback)); // 创建EventThreadConnection auto eventThreadConnection = createConnectionInternal(eventThread.get(), std::move(resyncCallback)); // 保存创建的connection mConnections.emplace(id, std::make_unique&lt;Connection&gt;(new ConnectionHandle(id), eventThreadConnection, std::move(eventThread))); return mConnections[id]-&gt;handle;&#125;sp&lt;EventThreadConnection&gt; Scheduler::createConnectionInternal(EventThread* eventThread, ResyncCallback&amp;&amp; resyncCallback) &#123; return eventThread-&gt;createEventConnection(std::move(resyncCallback));&#125; 1.1.2 EventThread.createEventConnection12345678910sp&lt;EventThreadConnection&gt; EventThread::createEventConnection(ResyncCallback resyncCallback) const &#123; return new EventThreadConnection(const_cast&lt;EventThread*&gt;(this), std::move(resyncCallback));&#125;EventThreadConnection::EventThreadConnection(EventThread* eventThread, ResyncCallback resyncCallback) : resyncCallback(std::move(resyncCallback)), mEventThread(eventThread), // 注意这里创建了 BitTube, 此时是在SurfaceFlinger主线程 mChannel(gui::BitTube::DefaultSize) &#123;&#125; 1.2 MessageQueue.setEventConnection123456789101112void MessageQueue::setEventConnection(const sp&lt;EventThreadConnection&gt;&amp; connection) &#123; if (mEventTube.getFd() &gt;= 0) &#123; mLooper-&gt;removeFd(mEventTube.getFd()); &#125; mEvents = connection; // 1.2.1 通过BitTube建立与SFEventThread的通信通道 mEvents-&gt;stealReceiveChannel(&amp;mEventTube); // 有vsync事件会回调cb_eventReceiver事件 mLooper-&gt;addFd(mEventTube.getFd(), 0, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, this);&#125; 这里的mLooper就是SurfaceFlinger主线程的Looper. 1.2.1 EventThreadConnection.stealReceiveChannel12345status_t EventThreadConnection::stealReceiveChannel(gui::BitTube* outChannel) &#123; // 这里的mChannel就是[1.1.2]中新建的BitTube outChannel-&gt;setReceiveFd(mChannel.moveReceiveFd()); return NO_ERROR;&#125; 二. SF EventThread接收vsync上面我们知道了，当SFEventThread发出Vsync信号时，会通过BitTube发送该消息至SurfaceFlinger主线程，并调用MessageQueue.cb_eventReceiver方法处理。 2.1 MessageQueue.cb_eventReceiver123456789101112131415161718192021int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123; MessageQueue* queue = reinterpret_cast&lt;MessageQueue*&gt;(data); return queue-&gt;eventReceiver(fd, events);&#125;int MessageQueue::eventReceiver(int /*fd*/, int /*events*/) &#123; ssize_t n; DisplayEventReceiver::Event buffer[8]; // 读取消息内容 while ((n = DisplayEventReceiver::getEvents(&amp;mEventTube, buffer, 8)) &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; // 只关心VSYNC消息 if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123; // 2.2 触发composition mHandler-&gt;dispatchInvalidate(); break; &#125; &#125; &#125; return 1;&#125; 2.2 MessageQueue.Handler.dispatchInvalidate1234567891011121314151617181920void MessageQueue::Handler::dispatchInvalidate() &#123; if ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123; // 这里通过Looper发送INVALIDATE消息 mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE)); &#125;&#125;void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); // 处理INVALIDATE消息 mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125;&#125; 2.3 SurfaceFlinger.onMessageReceived1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768void SurfaceFlinger::onMessageReceived(int32_t what) NO_THREAD_SAFETY_ANALYSIS &#123; ATRACE_CALL(); switch (what) &#123; case MessageQueue::INVALIDATE: &#123; // 通过fence机制来判断是否掉帧 bool frameMissed = previousFrameMissed(); bool hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed; bool gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed; ATRACE_INT(&quot;FrameMissed&quot;, static_cast&lt;int&gt;(frameMissed)); ATRACE_INT(&quot;HwcFrameMissed&quot;, static_cast&lt;int&gt;(hwcFrameMissed)); ATRACE_INT(&quot;GpuFrameMissed&quot;, static_cast&lt;int&gt;(gpuFrameMissed)); if (frameMissed) &#123; mFrameMissedCount++; mTimeStats-&gt;incrementMissedFrames(); &#125; if (hwcFrameMissed) &#123; mHwcFrameMissedCount++; &#125; if (gpuFrameMissed) &#123; mGpuFrameMissedCount++; &#125; // 执行相关参数更新，比如Vsync切换 if (performSetActiveConfig()) &#123; break; &#125; // 如果丢帧，则不处理此次VSYNC if (frameMissed &amp;&amp; mPropagateBackpressure) &#123; if ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) || mPropagateBackpressureClientComposition) &#123; signalLayerUpdate(); break; &#125; &#125; ...... // transaction主要针对Layer和Display的变化更新脏区域 // 通过Layer的变化来计算脏区域，目的是需要更新我才刷新 bool refreshNeeded = handleMessageTransaction(); // 2.4 主要是调用handlePageFlip()函数，该函数在systrace图上对应latchBuffer及其所包含的方法。 // 作用是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域 // 并且把GraphicBuffer映射为OpenGL的texture refreshNeeded |= handleMessageInvalidate(); updateCursorAsync(); updateInputFlinger(); refreshNeeded |= mRepaintEverything; if (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123; // 发送刷新合成请求 signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; if (mDolphinFuncsEnabled) &#123; mDolphinRefresh(); &#125; // 2.6 SF 处理合成 handleMessageRefresh(); break; &#125; &#125;&#125; 这里我们先忽略Fence机制，先看看大致流程。 2.4 SurfaceFlinger.handleMessageInvalidate12345678910111213141516171819bool SurfaceFlinger::handleMessageInvalidate() &#123; ATRACE_CALL(); bool refreshNeeded = handlePageFlip(); if (mVisibleRegionsDirty) &#123; computeLayerBounds(); if (mTracingEnabled) &#123; mTracing.notify(&quot;visibleRegionsDirty&quot;); &#125; &#125; for (auto&amp; layer : mLayersPendingRefresh) &#123; Region visibleReg; visibleReg.set(layer-&gt;getScreenBounds()); invalidateLayerStack(layer, visibleReg); &#125; mLayersPendingRefresh.clear(); return refreshNeeded;&#125; 2.5 SurfaceFlinger.handlePageFlip123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263bool SurfaceFlinger::handlePageFlip()&#123; ATRACE_CALL(); ALOGV(&quot;handlePageFlip&quot;); nsecs_t latchTime = systemTime(); bool visibleRegions = false; bool frameQueued = false; bool newDataLatched = false; // 存储需要更新的图层集。 当缓冲区被锁存时，不得更改，因为可能导致死锁。 mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; if (layer-&gt;hasReadyFrame()) &#123; frameQueued = true; nsecs_t expectedPresentTime; expectedPresentTime = mScheduler-&gt;expectedPresentTime(); if (layer-&gt;shouldPresentNow(expectedPresentTime)) &#123; // mLayersWithQueuedFrames用于标记那些已经有Frame的Layer mLayersWithQueuedFrames.push_back(layer); &#125; else &#123; ATRACE_NAME(&quot;!layer-&gt;shouldPresentNow()&quot;); layer-&gt;useEmptyDamage(); &#125; &#125; else &#123; layer-&gt;useEmptyDamage(); &#125; &#125;); if (!mLayersWithQueuedFrames.empty()) &#123; // mStateLock is needed for latchBuffer as LayerRejecter::reject() // writes to Layer current state. See also b/119481871 Mutex::Autolock lock(mStateLock); for (auto&amp; layer : mLayersWithQueuedFrames) &#123; if (layer-&gt;latchBuffer(visibleRegions, latchTime)) &#123; mLayersPendingRefresh.push_back(layer); &#125; layer-&gt;useSurfaceDamage(); if (layer-&gt;isBufferLatched()) &#123; newDataLatched = true; &#125; &#125; &#125; mVisibleRegionsDirty |= visibleRegions; // If we will need to wake up at some time in the future to deal with a // queued frame that shouldn&#x27;t be displayed during this vsync period, wake // up during the next vsync period to check again. if (frameQueued &amp;&amp; (mLayersWithQueuedFrames.empty() || !newDataLatched)) &#123; signalLayerUpdate(); &#125; // enter boot animation on first buffer latch if (CC_UNLIKELY(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123; ALOGI(&quot;Enter boot animation&quot;); mBootStage = BootStage::BOOTANIMATION; &#125; // Only continue with the refresh if there is actually new work to do return !mLayersWithQueuedFrames.empty() &amp;&amp; newDataLatched;&#125; 2.6 SurfaceFlinger.handleMessageRefresh1234567891011121314151617181920212223242526272829303132333435363738394041424344void SurfaceFlinger::handleMessageRefresh() &#123; ATRACE_CALL(); mRefreshPending = false; const bool repaintEverything = mRepaintEverything.exchange(false); // 合成前再过一遍Layer是否被更新了 // 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。 preComposition(); // 重建layer堆栈, 提取可见的Laye并计算可见区域，为合成准备好数据材料。 rebuildLayerStacks(); // hwcomposer的设定 calculateWorkingSet(); for (const auto&amp; [token, display] : mDisplays) &#123; beginFrame(display); prepareFrame(display); doDebugFlashRegions(display, repaintEverything); doComposition(display, repaintEverything); //正式的合成处理 &#125; logLayerStats(); postFrame(); // 将图像传递到物理屏幕。但是在下一个vsync信号才被消费。 // 回调每个layer的onPostComposition postComposition(); mHadClientComposition = false; mHadDeviceComposition = false; for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto displayId = display-&gt;getId(); mHadClientComposition = mHadClientComposition || getHwComposer().hasClientComposition(displayId); mHadDeviceComposition = mHadDeviceComposition || getHwComposer().hasDeviceComposition(displayId); &#125; mVsyncModulator.onRefreshed(mHadClientComposition); mLayersWithQueuedFrames.clear();&#125; 再继续分析之前，我们需要先了解Layer的结构，以及他是如何被添加至SurfaceFlinger中的。 三. Layer的产生Layer, 即图层。Layer是图像合成中最重要的单元。图层是Surface和SurfaceControl的组合。说到底也就是每个Window都有对应Surface，也就对应一个Layer;SurfaceFlinger的合成就是将所有图层按照顺序和特定属性合成一帧画面。每个图层都有一组属性，用于定义它与其他图层的交互方式。 属性 描述 Positional 定义图层在其显示屏上显示的位置。 包括诸如图层边缘的位置及其相对于其他图层的Z顺序的信息 Content 定义图层上显示的内容应如何在位置属性定义的边界内显示。 包括裁剪和变换等信息 Composition 定义图层应如何与其他图层合成。 包括混合模式和alpha合成的图层范围Alpha值等信息 Optimization 提供正确合成图层非必要的信息，但硬件编写器（HWC）设备可以使用该信息来优化其执行合成的方式。 包括诸如图层的可见区域以及自上一帧以来图层的哪个部分已更新的信息。 在创建Window或者Window产生变化时就会更新对应的Surface所属的Layer. 12345678910111213141516171819202122232425ViewRootImpl.performTraversals() --[App进程] 绘制三部曲Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新 WindowManagerService.relayoutWindow(...) --[SystemServer进程] WindowManagerService.createSurfaceControl(...) --[SystemServer进程] WindowStateAnimator.createSurfaceLocked(...) --[SystemServer进程] 这里传入Surface的FLAG WindowSurfaceController.new() --[SystemServer进程] WindowContainer.makeSurface() --[SystemServer进程] WindowContainer.makeSurface(WindowContainer) --[SystemServer进程] SurfaceControl.Builder.build() --[SystemServer进程] SurfaceControl.new() --[SystemServer进程] android_view_SurfaceControl:nativeCreate() --[JNI][SystemServer进程] SurfaceComposerClient:getDefault() --[SystemServer进程] DefaultComposerClient:getComposerClient() --[SystemServer进程] SurfaceComposerClient:new() --[SystemServer进程] SurfaceComposerClient:onFirstRef() --[SystemServer进程]通过Binder从SF获取SurfaceComposerClient SurfaceFlinger:createConnection() --[SurfaceFlinger进程] 创建SurfaceComposerClient SurfaceComposerClient:createSurfaceChecked(...) --[SystemServer进程]Binder调用 Client:createSurface(...) --[SurfaceFlinger进程] SurfaceFlinger:createLayer(...) --[SurfaceFlinger进程] 这里假设创建一个默认Surface SurfaceFlinger:createBufferQueueLayer(...) --[SurfaceFlinger进程] SurfaceFlingerFactory:createBufferQueueLayer(...) --[SurfaceFlinger进程] BufferQueueLayer:new(LayerCreationArgs) --[SurfaceFlinger进程] BufferLayer:new(LayerCreationArgs) --[SurfaceFlinger进程] SurfaceControl:new(...) --[SystemServer进程] Surface FLAG一览 名称 值 作用 HIDDEN 0x00000004 Surface是隐藏的 SECURE 0x00000080 包含安全内容，禁止内容被其他进程复制。而且屏幕截图和VNC服务器将被禁用，但可能不会采用硬件加速。Window带有FLAG_SECURE标签，或者该应用禁止截图就会带有这个FLAG NON_PREMULTIPLIED 0x00000100 预乘透明度，创建一个Surface，其中颜色分量被Alpha通道解释为“非预乘”。对于没有alpha通道的Surface，这个标志是没有意义的。 默认情况下，Surface是预乘的，这意味着每个颜色分量已经乘以其alpha值。 OPAQUE 0x00000400 表示Surface必须为不透明，即使其像素格式包含Alpha通道。 PROTECTED_APP 0x00000800 应用程序需要通过外部显示接收器的硬件保护路径。 如果硬件保护路径不可用，则此表面将不会显示在外部接收器上。 CURSOR_WINDOW 0x00002000 窗口表示光标字形。 FX_SURFACE_NORMAL 0x00000000 创建一个默认Surface FX_SURFACE_DIM 0x00020000 创建一个暗淡的Surface。 此Surface后面的所有内容都会被{@link #setAlpha}中指定的数量调暗。 锁定Dim Surface是错误的，因为它没有后备存储。 FX_SURFACE_CONTAINER 创建容器Surface。 此Surface将没有缓冲区，仅用作其他Surface或其InputInfo的容器。 SURFACE_HIDDEN 0x01 隐藏该Surface, 等同于调用Surface.hide() SURFACE_OPAQUE 0x02 尽可能不混合的复合材料。 更新Surface创建期间设置的值（请参阅{@link #OPAQUE}）。 3.1 SurfaceFlinger:createLayer当上次Window变化时，或者会创建Layer，并保存在SurfaceFlinger中. 123456789101112131415161718192021222324252627282930status_t SurfaceFlinger::createLayer(const String8&amp; name, const sp&lt;Client&gt;&amp; client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, LayerMetadata metadata, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, const sp&lt;IBinder&gt;&amp; parentHandle, const sp&lt;Layer&gt;&amp; parentLayer) &#123; ...... // 假设创建默认的Surface switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123; case ISurfaceComposerClient::eFXSurfaceBufferQueue: result = createBufferQueueLayer(client, uniqueName, w, h, flags, std::move(metadata), format, handle, gbp, &amp;layer); break; ...... &#125; ...... // 检查是否有访问SurfaceFlinger的权限 bool addToCurrentState = callingThreadHasUnscopedSurfaceFlingerAccess(); // 3.2 保存新建的Layer result = addClientLayer(client, *handle, *gbp, layer, parentHandle, parentLayer, addToCurrentState); if (result != NO_ERROR) &#123; return result; &#125; mInterceptor-&gt;saveSurfaceCreation(layer); setTransactionFlags(eTransactionNeeded); return result;&#125; 3.1.1 SurfaceFlinger.createBufferQueueLayer中间细琐流程略过，最终是创建了一个Layer对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Layer::Layer(const LayerCreationArgs&amp; args) : mFlinger(args.flinger), mName(args.name), mClientRef(args.client), mWindowType(args.metadata.getInt32(METADATA_WINDOW_TYPE, 0)) &#123; mCurrentCrop.makeInvalid(); uint32_t layerFlags = 0; if (args.flags &amp; ISurfaceComposerClient::eHidden) layerFlags |= layer_state_t::eLayerHidden; if (args.flags &amp; ISurfaceComposerClient::eOpaque) layerFlags |= layer_state_t::eLayerOpaque; if (args.flags &amp; ISurfaceComposerClient::eSecure) layerFlags |= layer_state_t::eLayerSecure; mTransactionName = String8(&quot;TX - &quot;) + mName; mCurrentState.active_legacy.w = args.w; mCurrentState.active_legacy.h = args.h; mCurrentState.flags = layerFlags; mCurrentState.active_legacy.transform.set(0, 0); mCurrentState.crop_legacy.makeInvalid(); mCurrentState.requestedCrop_legacy = mCurrentState.crop_legacy; mCurrentState.z = 0; // 这里就是layer在Z轴的位置 mCurrentState.color.a = 1.0f; mCurrentState.layerStack = 0; // layer所在layerStack mCurrentState.sequence = 0; // layer序号 mCurrentState.requested_legacy = mCurrentState.active_legacy; mCurrentState.active.w = UINT32_MAX; mCurrentState.active.h = UINT32_MAX; mCurrentState.active.transform.set(0, 0); mCurrentState.transform = 0; mCurrentState.transformToDisplayInverse = false; mCurrentState.crop.makeInvalid(); mCurrentState.acquireFence = new Fence(-1); mCurrentState.dataspace = ui::Dataspace::UNKNOWN; mCurrentState.hdrMetadata.validTypes = 0; mCurrentState.surfaceDamageRegion.clear(); mCurrentState.cornerRadius = 0.0f; mCurrentState.api = -1; mCurrentState.hasColorTransform = false; mCurrentState.colorSpaceAgnostic = false; mCurrentState.metadata = args.metadata; // drawing state &amp; current state are identical mDrawingState = mCurrentState; CompositorTiming compositorTiming; args.flinger-&gt;getCompositorTiming(&amp;compositorTiming); mFrameEventHistory.initializeCompositorTiming(compositorTiming); mFrameTracker.setDisplayRefreshPeriod(compositorTiming.interval); mSchedulerLayerHandle = mFlinger-&gt;mScheduler-&gt;registerLayer(mName.c_str(), mWindowType); mFlinger-&gt;onLayerCreated();&#125; 重点关注的是： 名称 作用 z z-order，表示x,y,z轴的z轴上的顺序。数字越大，表示越在上面，数字越小，表示越在下面。 layerStack layerStack是存储layer的容器,我们知道每个display只会有一个layerstack来存储他要显示的layer,但是不同的display可以使用同一个layerStack,也可以使用不同的layerStack。可以理解为组的含义。也就是说属于不同组的layer之间互不干扰。SurfaceFlinger中有一个DisplayDevice类，他表示用来显示的设备，譬如LCD或者是HDMI。DisplayDevice里也有一个成员变量mLayerStack，在进行composition的时候，只有和这个device的layerstack相同的layer才可能被显示在这个设备上。 sequence sSequence是一个static的变量，所以递加的效果就是为每一个layer设置一个唯一且递增的序列号。 3.2 SurfaceFlinger.addClientLayer123456789101112131415161718192021222324252627282930313233343536status_t SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, const sp&lt;IGraphicBufferProducer&gt;&amp; gbc, const sp&lt;Layer&gt;&amp; lbc, const sp&lt;IBinder&gt;&amp; parentHandle, const sp&lt;Layer&gt;&amp; parentLayer, bool addToCurrentState) &#123; // add this layer to the current state list &#123; Mutex::Autolock _l(mStateLock); ...... if (parent == nullptr &amp;&amp; addToCurrentState) &#123; // 3.2.1 将新创建的Layer按照Z轴顺序存储至队列中 mCurrentState.layersSortedByZ.add(lbc); &#125; else if (parent == nullptr) &#123; lbc-&gt;onRemovedFromCurrentState(); &#125; else if (parent-&gt;isRemovedFromCurrentState()) &#123; parent-&gt;addChild(lbc); lbc-&gt;onRemovedFromCurrentState(); &#125; else &#123; parent-&gt;addChild(lbc); &#125; if (gbc != nullptr) &#123; mGraphicBufferProducerList.insert(IInterface::asBinder(gbc).get()); LOG_ALWAYS_FATAL_IF(mGraphicBufferProducerList.size() &gt; mMaxGraphicBufferProducerListSize, &quot;Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers&quot;, mGraphicBufferProducerList.size(), mMaxGraphicBufferProducerListSize, mNumLayers); &#125; mLayersAdded = true; &#125; // 3.2.2 将该Layer保存至mClient的mLayers中,键为IBinder,供后续使用 client-&gt;attachLayer(handle, lbc); return NO_ERROR;&#125; 搞清楚Layer的Z轴顺序，对与我们理解Layer合成过程有很大帮助。Layer排序建议参考：https://www.cnblogs.com/riskyer/p/3297226.html 3.2.1 LayerVector.add将新创建的Layer按照Z轴顺序存储至队列中.LayerVector继承了SortedVector,并且重载了函数 do_compare. 1234567891011121314151617181920212223242526int LayerVector::do_compare(const void* lhs, const void* rhs) const&#123; // 先对LayerStack排序，然后是Z轴排序，最后是序号 const auto&amp; l = *reinterpret_cast&lt;const sp&lt;Layer&gt;*&gt;(lhs); const auto&amp; r = *reinterpret_cast&lt;const sp&lt;Layer&gt;*&gt;(rhs); const auto&amp; lState = (mStateSet == StateSet::Current) ? l-&gt;getCurrentState() : l-&gt;getDrawingState(); const auto&amp; rState = (mStateSet == StateSet::Current) ? r-&gt;getCurrentState() : r-&gt;getDrawingState(); uint32_t ls = lState.layerStack; uint32_t rs = rState.layerStack; if (ls != rs) return (ls &gt; rs) ? 1 : -1; int32_t lz = lState.z; int32_t rz = rState.z; if (lz != rz) return (lz &gt; rz) ? 1 : -1; if (l-&gt;sequence == r-&gt;sequence) return 0; return (l-&gt;sequence &gt; r-&gt;sequence) ? 1 : -1;&#125; 先比较layerstack，不同的layerstack分开。然后再比较z，假设都相同，就比较唯一的layer序列号。但是至今为止，layerStack和z都还只是初始化时的0，所以在创建layer的时候，只是把他根据序列号放进layersSortedByZ而已，其实他的顺序还是没有设置的。 3.2.2 SurfaceFlinger:addClientLayer12345void Client::attachLayer(const sp&lt;IBinder&gt;&amp; handle, const sp&lt;Layer&gt;&amp; layer)&#123; Mutex::Autolock _l(mLock); mLayers.add(handle, layer);&#125; 3.4 Layer更新流程当java层调用setLayer时就会确定对应Layer的Z-Order顺序。 1234567891011121314151617181920212223242526272829303132ViewRootImpl.performTraversals() --[App进程] 绘制三部曲ViewRootImpl.relayoutWindow(...) --[App进程]Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新WindowManagerService.relayoutWindow(...) --[SystemServer进程]WindowSurfacePlacer.performSurfacePlacement(...) --[SystemServer进程]WindowSurfacePlacer.performSurfacePlacementLoop() --[SystemServer进程]RootWindowContainer.performSurfacePlacement(boolean) --[SystemServer进程]RootWindowContainer.performSurfacePlacementNoTrace(boolean) --[SystemServer进程]WindowManagerService.openSurfaceTransaction() --[SystemServer进程] SurfaceControl.openTransaction() --[SystemServer进程] 创建Transaction, 或者计数+1 android_view_SurfaceControl:nativeCreateTransaction(...) --[SystemServer进程] SurfaceComposerClient:Transaction:new() --[SystemServer进程]WindowManagerService.applySurfaceChangesTransaction(boolean) --[SystemServer进程] SurfaceControl.mergeToGlobalTransaction(Transaction) --[SystemServer进程] SurfaceControl.Transaction.merge(Transaction) --[SystemServer进程]合并更新后的属性 android_view_SurfaceControl:nativeMergeTransaction(...) --[SystemServer进程] SurfaceComposerClient:Transaction:merge(Transaction) --[SystemServer进程]也就是保存新的属性WindowManagerService.closeSurfaceTransaction(String) --[SystemServer进程] SurfaceControl.closeTransaction() --[SystemServer进程] SurfaceControl.Transaction.apply() --[SystemServer进程] android_view_SurfaceControl:nativeApplyTransaction(...) --[SystemServer进程] SurfaceComposerClient:Transaction:apply(bool) --[SystemServer进程] SurfaceFlinger:setTransactionState(...) --[SurfaceFlinger进程]传递更新后的属性到sf SurfaceFlinger:applyTransactionState(...) --[SurfaceFlinger进程] TransactionCompletedThread:run() --[SurfaceFlinger进程] TransactionCompletedThread:threadMain() --[SurfaceFlinger子线程] mConditionVariable.wait(mMutex);// 等待执行 TransactionCompletedListener:onTransactionCompleted(...)--[SurfaceFlinger子线程] TransactionCompletedThread:addCallback() --[SurfaceFlinger进程] TransactionCompletedThread:sendCallbacks() --notify TransactionCompletedThread执行 SurfaceFlinger:setClientStateLocked(...) --[SurfaceFlinger进程] Layer:setLayer(int32_t) --[SurfaceFlinger进程] 更新Layer所处Z轴的位置 如图： 到目前为止还只是创建了一个SurfaceControl，对应SurfaceFlinger中的BufferQueueLayer。真正的Surface还没有被创建，那是什么时候创建的呢？ 四. Surface的生成一个ViewRootImpl对应一个Suface, 也就是一个Layer.当我们创建了Layer之后，总要向其中填充数据内容，SurfaceFlinger才好做合成。在RendererThread中，我们知道了Surface数据是通过渲染引擎OpenGL(android Q上是Vulkan)生成的。 4.1 Suface的生成参阅：RenderThread深入分析(三)–绑定窗口对应的Surface到RenderThread的过程 1234567891011121314151617181920ViewRootImpl.performTraversals(...) --[App UI进程] 绘制三部曲ViewRootImpl.relayoutWindow(...) --[App UI进程] mSurface.copyFrom(mSurfaceControl) 注意这里会将赋值mSurface android_view_Surface:nativeCreateFromSurfaceControl(...) --[App UI进程] SurfaceControl:createSurface() --[App UI进程] SurfaceControl:generateSurfaceLocked() Surface:new() 这里创建了native SurfaceThreadedRenderer.initializeIfNeeded(...) --[App UI进程] ThreadedRenderer.initialize(Surface) --[App UI进程] ThreadedRenderer.setSurface(Surface) --[App UI进程] HardwareRenderer.setSurface(Surface) --[App UI进程] android_view_ThreadedRenderer:setSurface(...) --[App UI进程] android_view_Surface:getSurface(...) --[App UI进程] 这里返回上面创建的native Surface RenderProxy:setSurface(Surface) --[App UI进程] 接下来转进RenderThread线程处理 CanvasContext:setSurface(...) --[RenderThread线程] SkiaVulkanPipeline:setSurface(...) --[RenderThread线程] VulkanManager:createSurface(...) --[RenderThread线程] VulkanSurface:Create(...) --[RenderThread线程] VulkanManager.mGetPhysicalDeviceSurfaceCapabilitiesKHR(...) 获取Vulkan引擎中的Surface 大致流程如下图： 现在我们已经获取了渲染引擎中的Surface，向其中填充数据的过程就是performDraw的流程；这个部分在RenderThread中有分析，不在赘述。 那当我们的Surface中已经被填充了数据后，是如何传递给SurfaceFlinger做合成的呢？这个部分我们稍后详细分析，目前仅从trace上也可以看出来： 上图中eglSwapBuffer最终就是通过binder通知到surfaceflinger中处理的： 五. Layer实例以如下图为例，看看对应Layer： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687Display 19260235133379457 HWC layers:------------------------------------------------------------------------------------------- Layer name Z | Window Type | Comp Type | Transform | Disp Frame (LTRB) | Source Crop (LTRB)------------------------------------------------------------------------------------------- com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0 rel 0 | 1 | DEVICE | 0 | 0 0 1080 2340 | 0.0 0.0 1080.0 2340.0- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - PopupWindow:b04e24#0 rel 0 | 1002 | DEVICE | 0 | 646 56 1080 656 | 0.0 0.0 434.0 600.0- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - StatusBar#0 rel 0 | 2000 | DEVICE | 0 | 0 0 1080 80 | 0.0 0.0 1080.0 80.0- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - NavigationBar0#0 rel 0 | 2019 | DEVICE | 0 | 0 2214 1080 2340 | 0.0 0.0 1080.0 126.0- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - ScreenDecorOverlay#0 rel 0 | 2024 | DEVICE | 0 | 0 0 1080 240 | 0.0 0.0 1080.0 240.0- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - ScreenDecorOverlayBottom#0 rel 0 | 2024 | DEVICE | 0 | 0 2100 1080 2340 | 0.0 0.0 1080.0 240.0- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -+ ContainerLayer (5fd44db PopupWindow:b04e24#0) Region TransparentRegion (this=0 count=0) Region VisibleRegion (this=0 count=0) Region SurfaceDamageRegion (this=0 count=0) layerStack= 0, z= 2, pos=(646,56), size=( 0, 0), crop=[ 0, 0, -1, -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00] parent=9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0 zOrderRelativeOf=none activeBuffer=[ 0x 0: 0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;+ ContainerLayer (9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0) Region TransparentRegion (this=0 count=0) Region VisibleRegion (this=0 count=0) Region SurfaceDamageRegion (this=0 count=0) layerStack= 0, z= 0, pos=(0,0), size=( 0, 0), crop=[ 0, 0, -1, -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00] parent=AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0 zOrderRelativeOf=none activeBuffer=[ 0x 0: 0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;+ ContainerLayer (AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0) Region TransparentRegion (this=0 count=0) Region VisibleRegion (this=0 count=0) Region SurfaceDamageRegion (this=0 count=0) layerStack= 0, z= 0, pos=(0,0), size=( 0, 0), crop=[ 0, 0, -1, -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00] parent=Task=5#0 zOrderRelativeOf=none activeBuffer=[ 0x 0: 0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;+ ContainerLayer (Task=5#0) Region TransparentRegion (this=0 count=0) Region VisibleRegion (this=0 count=0) Region SurfaceDamageRegion (this=0 count=0) layerStack= 0, z= 0, pos=(0,0), size=( 0, 0), crop=[ 0, 0, -1, -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00] parent=Stack=2#0 zOrderRelativeOf=none activeBuffer=[ 0x 0: 0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;taskId:5&#125;+ ContainerLayer (Stack=2#0) Region TransparentRegion (this=0 count=0) Region VisibleRegion (this=0 count=0) Region SurfaceDamageRegion (this=0 count=0) layerStack= 0, z= 5, pos=(0,0), size=( 0, 0), crop=[ 0, 0, 1080, 2340], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00] parent=com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0 zOrderRelativeOf=none activeBuffer=[ 0x 0: 0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;+ ContainerLayer (com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0) Region TransparentRegion (this=0 count=0) Region VisibleRegion (this=0 count=0) Region SurfaceDamageRegion (this=0 count=0) layerStack= 0, z= 1, pos=(0,0), size=( 0, 0), crop=[ 0, 0, -1, -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00] parent=Display Root#0 zOrderRelativeOf=none activeBuffer=[ 0x 0: 0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;+ ContainerLayer (Display Root#0) Region TransparentRegion (this=0 count=0) Region VisibleRegion (this=0 count=0) Region SurfaceDamageRegion (this=0 count=0) layerStack= 0, z= 0, pos=(0,0), size=( 0, 0), crop=[ 0, 0, -1, -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000002, tr=[0.00, 0.00][0.00, 0.00] parent=none zOrderRelativeOf=none activeBuffer=[ 0x 0: 0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125; 示意图如下： 总的来说就是，树形结构+Z order排序。 六. 类图 现在我们Surface有了，也有渲染的内容了，那SurfaceFlinger是如何将这些Surface对应的Layer合成为一帧并显示出来的呢? 参考资料 [Android Synchronization Fences – An Introduction]http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html [Android中的GraphicBuffer同步机制-Fence]https://blog.csdn.net/jinzhuojun/article/details/39698317 [深入浅出Android BufferQueue]https://blog.51cto.com/13591395/2380727 [从systrace看app冷启动过程（三）-首帧的合成与送显]https://www.jianshu.com/p/3829158b4699 [Android显示Surface]https://www.jianshu.com/p/fc3c3d6f9bf7 [surfaceflinger中各个layer的排序]https://www.cnblogs.com/riskyer/p/3297226.html [Android 4.0.3 显示系统深入理解]https://www.linuxidc.com/Linux/2012-03/55898p4.htm [Android窗口管理分析（3）：窗口分组及Z-order的确定]https://www.jianshu.com/p/90ede7b2a64a","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"SurfaceFlinger","slug":"Android/SurfaceFlinger","permalink":"https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"https://swallowjoe.github.io/tags/SurfaceFlinger/"}]},{"title":"SurfaceFlinger(3)--AppEventThread接受vsync信号","slug":"SurfaceFlinger-3-AppEventThread接受vsync信号","date":"2022-04-04T01:57:41.000Z","updated":"2022-04-04T02:28:58.320Z","comments":true,"path":"2022/04/04/SurfaceFlinger-3-AppEventThread接受vsync信号/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/","excerpt":"Andorid Q 一. 前言前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。","text":"Andorid Q 一. 前言前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。 一图以概之： 我们知道android app绘制是离不开编舞者 Choreographer 的，关于 Choreographer 这里就不赘叙，详细可以参考这篇博文。接下来重点分析一下应用app进程是如何与sw vsync信号同步的。 二. App进程与AppEventThread建立通信过程回忆一下，我们知道当应用进程的第一个具有布局的Activity启动时，会初始化Choreographer. 2.1 Choerographer初始化Choerographer是个单例，意味着一个应用进程中只会存在一个实例化对象。 12345678910111213141516171819202122232425262728293031323334353637383940// Thread local storage for the choreographer.private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() &#123; @Override protected Choreographer initialValue() &#123; Looper looper = Looper.myLooper(); if (looper == null) &#123; throw new IllegalStateException(&quot;The current thread must have a looper!&quot;); &#125; // 主线程中初始化，注意传入的第二个参数 VSYNC_SOURCE_APP // 这个值是DisplayEventReceiver.VSYNC_SOURCE_APP 也就是 0 // 与ISurfaceComposer.h中的VsyncSource.eVsyncSourceApp值保持同步 // 代表的就是 AppEventThread. Choreographer choreographer = new Choreographer(looper, VSYNC_SOURCE_APP); if (looper == Looper.getMainLooper()) &#123; mMainInstance = choreographer; &#125; return choreographer; &#125;&#125;;private Choreographer(Looper looper, int vsyncSource) &#123; mLooper = looper; mHandler = new FrameHandler(looper); // 初始化 DisplayEventReceiver // USE_VSYNC 值默认为true，读取属性debug.choreographer.vsync mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper, vsyncSource) : null; mLastFrameTimeNanos = Long.MIN_VALUE; mFrameIntervalNanos = (long)(1000000000 / getRefreshRate()); mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1]; for (int i = 0; i &lt;= CALLBACK_LAST; i++) &#123; mCallbackQueues[i] = new CallbackQueue(); &#125; // b/68769804: For low FPS experiments. setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, 1));&#125; 2.2 FrameDisplayEventReceiver初始化123public FrameDisplayEventReceiver(Looper looper, int vsyncSource) &#123; super(looper, vsyncSource);&#125; FrameDisplayEventReceiver类继承了DisplayEventReceiver类。 123456789101112public DisplayEventReceiver(Looper looper, int vsyncSource) &#123; if (looper == null) &#123; throw new IllegalArgumentException(&quot;looper must not be null&quot;); &#125; mMessageQueue = looper.getQueue(); // 转到jni层 mReceiverPtr = nativeInit(new WeakReference&lt;DisplayEventReceiver&gt;(this), mMessageQueue, vsyncSource); mCloseGuard.open(&quot;dispose&quot;);&#125; 这里注意FrameDisplayEventReceiver类是DisplayEventReceiver的子类。 2.3 android_view_DisplayEventReceiver.cpp:nativeInit1234567891011121314151617181920212223static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj, jint vsyncSource) &#123; sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); if (messageQueue == NULL) &#123; jniThrowRuntimeException(env, &quot;MessageQueue is not initialized.&quot;); return 0; &#125; // 2.4 根据传入的参数初始化NativeDisplayEventReceiver sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env, receiverWeak, messageQueue, vsyncSource); // 2.8 连接BitTube通信信道 status_t status = receiver-&gt;initialize(); if (status) &#123; String8 message; message.appendFormat(&quot;Failed to initialize display event receiver. status=%d&quot;, status); jniThrowRuntimeException(env, message.string()); return 0; &#125; receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; 2.4 NativeDisplayEventReceiver 初始化12345678910NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverWeak, const sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource) : // 注意这里 DisplayEventDispatcher(messageQueue-&gt;getLooper(), // 将传入的vsyncSource（0）强制转换为VsyncSource.eVsyncSourceApp static_cast&lt;ISurfaceComposer::VsyncSource&gt;(vsyncSource)), mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)), mMessageQueue(messageQueue) &#123; ALOGV(&quot;receiver %p ~ Initializing display event receiver.&quot;, this);&#125; NativeDisplayEventReceiver 继承了 DisplayEventDispatcher。 2.5 DisplayEventDispatcher 初始化123456DisplayEventDispatcher::DisplayEventDispatcher(const sp&lt;Looper&gt;&amp; looper, ISurfaceComposer::VsyncSource vsyncSource) : // 这里的looper是app主线程的looper，mReceiver是我们所寻找的纽带 mLooper(looper), mReceiver(vsyncSource), mWaitingForVsync(false) &#123; ALOGV(&quot;dispatcher %p ~ Initializing display event dispatcher.&quot;, this);&#125; mReceiver是DisplayEventReceiver类型。 2.6 DisplayEventReceiver初始化12345678910111213DisplayEventReceiver::DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource) &#123; sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); if (sf != nullptr) &#123; // vsyncSource就是VsyncSource.eVsyncSourceApp // 2.6.1 通过binder通信，在surfaceFlinger中创建DisplayEventConnection mEventConnection = sf-&gt;createDisplayEventConnection(vsyncSource); if (mEventConnection != nullptr) &#123; // 2.7 取出EventThread类中新创建的BitTube的Fd（文件描述符表索引） mDataChannel = std::make_unique&lt;gui::BitTube&gt;(); mEventConnection-&gt;stealReceiveChannel(mDataChannel.get()); &#125; &#125;&#125; 之前的博文中也分析了，这里的ComposerService就是获取的SurfaceFlinger服务。 2.6.1 SurfaceFlinger.createDisplayEventConnection进入SurfaceFlinger主线程。 123456789101112sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection( ISurfaceComposer::VsyncSource vsyncSource) &#123; auto resyncCallback = mScheduler-&gt;makeResyncCallback([this] &#123; Mutex::Autolock lock(mStateLock); return getVsyncPeriod(); &#125;); // 这里的handle为mAppConnectionHandle const auto&amp; handle = vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle; // 2.6.2 创建连接 return mScheduler-&gt;createDisplayEventConnection(handle, std::move(resyncCallback));&#125; 2.6.2 Scheduler.cpp:createDisplayEventConnection123456789101112131415sp&lt;IDisplayEventConnection&gt; Scheduler::createDisplayEventConnection( const sp&lt;Scheduler::ConnectionHandle&gt;&amp; handle, ResyncCallback resyncCallback) &#123; RETURN_VALUE_IF_INVALID(nullptr); // mConnections是map类型，key值表示对应的EventThread类型 // 这个初始化就是在SurfaceFlinger.init方法内，创建EventThread时同步生成的 // 最终mConnections[handle-&gt;id]-&gt;thread.get()拿到的就是AppEventThread return createConnectionInternal(mConnections[handle-&gt;id]-&gt;thread.get(), std::move(resyncCallback));&#125;sp&lt;EventThreadConnection&gt; Scheduler::createConnectionInternal(EventThread* eventThread, ResyncCallback&amp;&amp; resyncCallback) &#123; // 这里传入的eventThread就是appEventThread return eventThread-&gt;createEventConnection(std::move(resyncCallback));&#125; 这里mConnections[handle-&gt;id]-&gt;thread.get()拿到的是handle对应的EventThread. 2.6.3 EventThread.createEventConnection12345678910sp&lt;EventThreadConnection&gt; EventThread::createEventConnection(ResyncCallback resyncCallback) const &#123; return new EventThreadConnection(const_cast&lt;EventThread*&gt;(this), std::move(resyncCallback));&#125;EventThreadConnection::EventThreadConnection(EventThread* eventThread, ResyncCallback resyncCallback) : resyncCallback(std::move(resyncCallback)), mEventThread(eventThread), // 注意这里创建的BitTube管道 mChannel(gui::BitTube::DefaultSize) &#123;&#125; 创建EventThreadConnection时新建了个BitTube管道，看来就是通信枢纽就是这个了。 注意到这个类有onFirstRef方法，在生成对象后，就会调用。 2.6.4 EventThreadConnection.onFirstRef1234void EventThreadConnection::onFirstRef() &#123; // NOTE: mEventThread doesn&#x27;t hold a strong reference on us mEventThread-&gt;registerDisplayEventConnection(this);&#125; 2.6.5 EventThread.registerDisplayEventConnection12345678910111213141516status_t EventThread::registerDisplayEventConnection(const sp&lt;EventThreadConnection&gt;&amp; connection) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); // this should never happen auto it = std::find(mDisplayEventConnections.cbegin(), mDisplayEventConnections.cend(), connection); if (it != mDisplayEventConnections.cend()) &#123; ALOGW(&quot;DisplayEventConnection %p already exists&quot;, connection.get()); mCondition.notify_all(); return ALREADY_EXISTS; &#125; // 有新的连接了，就需要唤醒AppEventThread线程使能Vsync信号了。 mDisplayEventConnections.push_back(connection); mCondition.notify_all(); return NO_ERROR;&#125; 现在注意到我们仅仅是得到了一个BitTube，然而并没有用上这个管道。接下来，回到[2.6 DisplayEventReceiver初始化] 创建DisplayEventReceiver的地方。 2.7 EventThreadConnection.stealReceiveChannel1234status_t EventThreadConnection::stealReceiveChannel(gui::BitTube* outChannel) &#123; outChannel-&gt;setReceiveFd(mChannel.moveReceiveFd()); return NO_ERROR;&#125; 将新建的BitTube的Fd复制给outChannel, 也就是DisplayEventReceiver中的 mDataChannel.虽然还是没有用上这个BitTube，不着急，继续看。 2.8 BitTube信道连接过程2.8.1 DisplayEventDispatcher.initialize1234567891011121314151617status_t DisplayEventDispatcher::initialize() &#123; // 这里的mReceiver 就是DisplayEventReceiver // 这一步就是确认BitTube创建无误 status_t result = mReceiver.initCheck(); if (result) &#123; ALOGW(&quot;Failed to initialize display event receiver, status=%d&quot;, result); return result; &#125; // 这个mLooper就是应用app进程的主线程Looper，所以这一步就是将 // 创建的BitTube信道Fd添加到Looper中 int rc = mLooper-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL); if (rc &lt; 0) &#123; return UNKNOWN_ERROR; &#125; return OK;&#125; 注意这个DisplayEventDispatcher是继承了LooperCallback, 所以这里的this方法就是handleEvent。 到这里这里整个Vsync流程已经跑通： SurfaceFlinger主线程收到硬件Vsync, 经过误差修正, 通知给DispSyncThread线程 DispSyncThread线程计算各个EventThread的SW Vsync信号时间并及时发出 AppEventThread收到sw Vsync信号，遍历各个Connection，调用sendEvent向对应BitTube管道发送事件 App进程的主线程收到事件，并处理 接下来我们就看app收到sw vsync信号的处理过程。 三. App进程收到SW VSYNC信号3.1 DisplayEventDispatcher.handleEvent1234567891011121314int DisplayEventDispatcher::handleEvent(int, int events, void*) &#123; ...... nsecs_t vsyncTimestamp; PhysicalDisplayId vsyncDisplayId; uint32_t vsyncCount; // 3.1.1 读取BitTube管道中的数据，返回值为true表示读取到了数据 if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123; mWaitingForVsync = false; // 3.2 分发收到的sw vsync信号 dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount); &#125; return 1; // keep the callback&#125; 3.1.1 DisplayEventDispatcher.processPendingEvents1234567891011121314151617181920212223242526272829303132333435bool DisplayEventDispatcher::processPendingEvents( nsecs_t* outTimestamp, PhysicalDisplayId* outDisplayId, uint32_t* outCount) &#123; bool gotVsync = false; DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE]; ssize_t n; // 读取管道中的所有数据 while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123; ALOGV(&quot;dispatcher %p ~ Read %d events.&quot;, this, int(n)); for (ssize_t i = 0; i &lt; n; i++) &#123; const DisplayEventReceiver::Event&amp; ev = buf[i]; switch (ev.header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: // 拿到最新的sw vsync信号时间 gotVsync = true; *outTimestamp = ev.header.timestamp; *outDisplayId = ev.header.displayId; *outCount = ev.vsync.count; break; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: dispatchHotplug(ev.header.timestamp, ev.header.displayId, ev.hotplug.connected); break; case DisplayEventReceiver::DISPLAY_EVENT_CONFIG_CHANGED: dispatchConfigChanged(ev.header.timestamp, ev.header.displayId, ev.config.configId); break; default: ALOGW(&quot;dispatcher %p ~ ignoring unknown event type %#x&quot;, this, ev.header.type); break; &#125; &#125; &#125; if (n &lt; 0) &#123; ALOGW(&quot;Failed to get events from display event dispatcher, status=%d&quot;, status_t(n)); &#125; return gotVsync;&#125; 3.2 NativeDisplayEventReceiver.dispatchVsync1234567891011121314void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, PhysicalDisplayId displayId, uint32_t count) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); ScopedLocalRef&lt;jobject&gt; receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal)); if (receiverObj.get()) &#123; ALOGV(&quot;receiver %p ~ Invoking vsync handler.&quot;, this); env-&gt;CallVoidMethod(receiverObj.get(), gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, displayId, count); ALOGV(&quot;receiver %p ~ Returned from vsync handler.&quot;, this); &#125; mMessageQueue-&gt;raiseAndClearException(env, &quot;dispatchVsync&quot;);&#125; 通过JNI回调到java层的DisplayEventReceiver.dispatchVsync方法 3.3 DisplayEventReceiver.dispatchVsync123456// Called from native code.@SuppressWarnings(&quot;unused&quot;)@UnsupportedAppUsageprivate void dispatchVsync(long timestampNanos, long physicalDisplayId, int frame) &#123; onVsync(timestampNanos, physicalDisplayId, frame);&#125; 参考2.2中，这里的DisplayEventReceiver 对象就是其子类FrameDisplayEventReceiver的对象。 3.4 FrameDisplayEventReceiver.onVsync12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void onVsync(long timestampNanos, long physicalDisplayId, int frame) &#123; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f) + &quot; ms in the future! Check that graphics HAL is generating vsync &quot; + &quot;timestamps using the correct timebase.&quot;); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, &quot;Already have a pending vsync event. There should only be &quot; + &quot;one at a time.&quot;); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; mFrame = frame; // mHandler就是mFrameHandler，传入runnable立刻执行，也就是执行run里面的 // doFrame方法。 Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);&#125;@Overridepublic void run() &#123; mHavePendingVsync = false; // 进入Choreographer的绘图，接下来就是measure,layout,draw的过程了、 doFrame(mTimestampNanos, mFrame);&#125; 完整的VSYNC流程图如下： 参考资料 Android SurfaceFlinger SW Vsync模型 DispSync DispSync详解","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"SurfaceFlinger","slug":"Android/SurfaceFlinger","permalink":"https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"https://swallowjoe.github.io/tags/SurfaceFlinger/"}]},{"title":"SurfaceFlinger(2)--DispSync","slug":"SurfaceFlinger-2-DispSync","date":"2022-04-04T01:52:26.000Z","updated":"2022-04-04T02:28:38.138Z","comments":true,"path":"2022/04/04/SurfaceFlinger-2-DispSync/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-2-DispSync/","excerpt":"Andorid Q 一. DispSyncDispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。 接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。我们先看DispSync线程的创建过程。","text":"Andorid Q 一. DispSyncDispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。 接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。我们先看DispSync线程的创建过程。 二. DispSync初始化2.1 SurfaceFlinger12345678SurfaceFlinger::SurfaceFligner(SurfaceFlinger::SkipInitializationTag) : BnSurfaceComposer(), mTransactionFlags(0), ...... mPrimaryDispSync(&quot;PrimaryDispSync&quot;), mPrimaryHWVsyncEnabled(false), ...... &#123;&#125; 在SurfaceFlinger初始化的时候创建的。 2.2 DispSync创建1234567891011DispSync::DispSync(const char* name) : mName(name), mRefreshSkipCount(0), mThread(new DispSyncThread(name)) &#123;&#125;explicit DispSyncThread(const char* name) : mName(name), mStop(false), mPeriod(0), // 注意这里的mPeriod初始化为0 mPhase(0), mReferenceTime(0), mWakeupLatency(0), mFrameNumber(0) &#123;&#125; 2.3 SurfaceFlinger::SurfaceFlinger1234567SurfaceFlinger::SurfaceFlinger() : SurfaceFlinger(SkipInitialization) &#123; ALOGI(&quot;SurfaceFlinger is starting&quot;); ...... mPrimaryDispSync.init(SurfaceFlinger::hasSyncFramework, SurfaceFlinger::dispSyncPresentTimeOffset); ......&#125; 2.4 DispSync.init12345678910111213141516171819202122232425262728void DispSync::init(bool hasSyncFramework, int64_t dispSyncPresentTimeOffset) &#123; mIgnorePresentFences = !hasSyncFramework; mPresentTimeOffset = dispSyncPresentTimeOffset; // 线程改名为 DispSync，调整线程优先级 mThread-&gt;run(&quot;DispSync&quot;, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE); // set DispSync to SCHED_FIFO to minimize jitter struct sched_param param = &#123;0&#125;; param.sched_priority = 2; if (sched_setscheduler(mThread-&gt;getTid(), SCHED_FIFO, &amp;param) != 0) &#123; ALOGE(&quot;Couldn&#x27;t set SCHED_FIFO for DispSyncThread&quot;); &#125; reset(); beginResync(); if (kTraceDetailedInfo) &#123; // If we&#x27;re not getting present fences then the ZeroPhaseTracer // would prevent HW vsync event from ever being turned off. // Even if we&#x27;re just ignoring the fences, the zero-phase tracing is // not needed because any time there is an event registered we will // turn on the HW vsync events. if (!mIgnorePresentFences &amp;&amp; kEnableZeroPhaseTracer) &#123; mZeroPhaseTracer = std::make_unique&lt;ZeroPhaseTracer&gt;(); addEventListener(&quot;ZeroPhaseTracer&quot;, 0, mZeroPhaseTracer.get()); &#125; &#125;&#125; 2.4.1 DispSyncThread.threadLoop123456789101112131415161718192021222324252627282930313233virtual bool threadLoop() &#123; status_t err; // 获取开机到现在的时长 nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); while (true) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; nsecs_t targetTime = 0; &#123; // Scope for lock Mutex::Autolock lock(mMutex); if (kTraceDetailedInfo) &#123; ATRACE_INT64(&quot;DispSync:Frame&quot;, mFrameNumber); &#125; ALOGV(&quot;[%s] Frame %&quot; PRId64, mName, mFrameNumber); ++mFrameNumber; if (mStop) &#123; return false; &#125; // 由于此时mPeriod为0，所以会进入该分支一直等待。 if (mPeriod == 0) &#123; err = mCond.wait(mMutex); if (err != NO_ERROR) &#123; ALOGE(&quot;error waiting for new events: %s (%d)&quot;, strerror(-err), err); return false; &#125; continue; &#125; ......&#125; 三. enableVysncLocked后续SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked 3.1 DispSync.addEventListener1234status_t DispSync::addEventListener(const char* name, nsecs_t phase, Callback* callback) &#123; Mutex::Autolock lock(mMutex); return mThread-&gt;addEventListener(name, phase, callback);&#125; 3.2 DispSync.DispSyncThread.addEventListener1234567891011121314151617181920212223242526status_t addEventListener(const char* name, nsecs_t phase, DispSync::Callback* callback) &#123; if (kTraceDetailedInfo) ATRACE_CALL(); Mutex::Autolock lock(mMutex); for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; if (mEventListeners[i].mCallback == callback) &#123; return BAD_VALUE; &#125; &#125; EventListener listener; listener.mName = name; listener.mPhase = phase; listener.mCallback = callback; // We want to allow the firstmost future event to fire without // allowing any past events to fire listener.mLastEventTime = systemTime() - mPeriod / 2 + mPhase - mWakeupLatency; mEventListeners.push(listener); // threadLooper可以继续执行了 mCond.signal(); return NO_ERROR;&#125; 注意这里还是运行在SurfaceFlinger主线程，在mCond.signal之后，DispSync线程就可以继续执行了。但是注意看： 12345678if (mPeriod == 0) &#123; err = mCond.wait(mMutex); if (err != NO_ERROR) &#123; ALOGE(&quot;error waiting for new events: %s (%d)&quot;, strerror(-err), err); return false; &#125; continue;&#125; 这里的continue意味着如果mPeriod为0，还是会一直等待。 四. setPeriod这样我们就需要看mPeriod是什么时候被更改的。在SurfaceFlinger初始化Display后，会调用resyncToHardwareVsync跟硬件vsync进行同步。 12345initializeDisplays(); flinger-&gt;onInitializeDisplays(); setPowerModeInternal() resyncToHardwareVsync(true); repaintEverything(); 4.1 SurfaceFlinger.resyncToHardwareVsync12345678910111213141516171819202122232425262728293031void SurfaceFlinger::resyncToHardwareVsync(bool makeAvailable) &#123; Mutex::Autolock _l(mHWVsyncLock); if (makeAvailable) &#123; // mHWVsyncAvailable 表示 HW vsync 被 enable mHWVsyncAvailable = true; &#125; else if (!mHWVsyncAvailable) &#123; // Hardware vsync is not currently available, so abort the resync // attempt for now return; &#125; //获得显示设备的刷新率，比如60HZ, 那么period就是16.6667ms,即每隔16.6667就会产生一个硬件vsync信号 const auto&amp; activeConfig = getBE().mHwc-&gt;getActiveConfig(HWC_DISPLAY_PRIMARY); const nsecs_t period = activeConfig-&gt;getVsyncPeriod(); // 这里就是设置DispSync线程中的period mPrimaryDispSync.reset(); // 4.2 设置period mPrimaryDispSync.setPeriod(period); //mPrimaryHWVsyncEnabled表示当前的硬件vsync是否enable, if (!mPrimaryHWVsyncEnabled) &#123; mPrimaryDispSync.beginResync(); // 如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC // 这个和DispSync的setVsyncEnabled是不一样的 // 5.1 硬件Vsync控制 mEventControlThread-&gt;setVsyncEnabled(true); mPrimaryHWVsyncEnabled = true; &#125;&#125; 4.2 DispSync.setPeriod12345678void DispSync::setPeriod(nsecs_t period) &#123; Mutex::Autolock lock(mMutex); mPeriod = period; mPhase = 0; mReferenceTime = 0; // Ignore recompute as mReferenceTime is zero. // mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);&#125; mPeriod表示具体的硬件产生vsync的时间间隔。这样，之后的DispSync线程中的threadLoop就可以继续执行了。 五. 硬件Vsync的开关控制接上面 4.1，当设置DispSync的mPeriod之后，如果硬件Vsync开关是开启状态，则会通过EventControlThread打开HW Vsync我们先看看EventControlThread线程的启动，其启动在SurfaceFlinger的初始化，EventThread启动之后，显示屏初始化之前。 5.1 EventControlThread的启动12345678910111213void SurfaceFlinger::init() &#123; ...... mEventControlThread = std::make_unique&lt;impl::EventControlThread&gt;( [this](bool enabled) &#123; setVsyncEnabled(HWC_DISPLAY_PRIMARY, enabled); &#125;); ......&#125;void SurfaceFlinger::setVsyncEnabled(int disp, int enabled) &#123; ATRACE_CALL(); Mutex::Autolock lock(mStateLock); getHwComposer().setVsyncEnabled(disp, enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);&#125; 这里初始化时传入了函数 setVsyncEnabled。 注意EventControlThread中线程的初始化是在成员变量中： 12// Must be last so that everything is initialized before the thread starts.std::thread mThread&#123;&amp;EventControlThread::threadMain, this&#125;; 所以先调用threadMain，后调用构造函数。 5.1.1 EventControlThread.threadMain123456789101112131415161718// Unfortunately std::unique_lock gives warnings with -Wthread-safetyvoid EventControlThread::threadMain() NO_THREAD_SAFETY_ANALYSIS &#123; auto keepRunning = true; auto currentVsyncEnabled = false; while (keepRunning) &#123; // 5.3 此时currentVsyncEnabled为false mSetVSyncEnabled(currentVsyncEnabled); std::unique_lock&lt;std::mutex&gt; lock(mMutex); // 在这里等待 mCondition.wait(lock, [this, currentVsyncEnabled, keepRunning]() NO_THREAD_SAFETY_ANALYSIS &#123; return currentVsyncEnabled != mVsyncEnabled || keepRunning != mKeepRunning; &#125;); currentVsyncEnabled = mVsyncEnabled; keepRunning = mKeepRunning; &#125;&#125; 5.1.2 EventControlThread初始化12345678EventControlThread::EventControlThread(EventControlThread::SetVSyncEnabledFunction function) : mSetVSyncEnabled(function) &#123; pthread_setname_np(mThread.native_handle(), &quot;EventControlThread&quot;); pid_t tid = pthread_gettid_np(mThread.native_handle()); setpriority(PRIO_PROCESS, tid, ANDROID_PRIORITY_URGENT_DISPLAY); set_sched_policy(tid, SP_FOREGROUND);&#125; 构造函数里面设置了线程名和优先级 5.2 EventControlThread.setVsyncEnabled12345void EventControlThread::setVsyncEnabled(bool enabled) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); mVsyncEnabled = enabled; mCondition.notify_all();&#125; mVsyncEnabled设置为true, 表明开启硬件Vsync.mCondition.notify_all() 则通知EventControlThread线程继续执行，回到5.1.1的循环内。mSetVSyncEnabled是传入的函数SurfaceFlinger.setVsyncEnabled. 5.3 SurfaceFlinger.setVsyncEnabled123456789void SurfaceFlinger::setVsyncEnabled(int disp, int enabled) &#123; ATRACE_CALL(); Mutex::Autolock lock(mStateLock); getHwComposer().setVsyncEnabled(disp, enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);&#125;HWComposer&amp; getHwComposer() const &#123; return *getBE().mHwc; &#125;SurfaceFlingerBE&amp; getBE() &#123; return mBE; &#125; 这里的disp &#x3D; HWC_DISPLAY_PRIMARY 5.4 HWComposer.setVsyncEnabled123456789101112131415161718192021222324252627void HWComposer::setVsyncEnabled(DisplayId displayId, HWC2::Vsync enabled) &#123; RETURN_IF_INVALID_DISPLAY(displayId); auto&amp; displayData = mDisplayData[displayId]; if (displayData.isVirtual) &#123; LOG_DISPLAY_ERROR(displayId, &quot;Invalid operation on virtual display&quot;); return; &#125; // NOTE: we use our own internal lock here because we have to call // into the HWC with the lock held, and we want to make sure // that even if HWC blocks (which it shouldn&#x27;t), it won&#x27;t // affect other threads. std::lock_guard lock(displayData.vsyncEnabledLock); if (enabled == displayData.vsyncEnabled) &#123; return; &#125; ATRACE_CALL(); auto error = displayData.hwcDisplay-&gt;setVsyncEnabled(enabled); RETURN_IF_HWC_ERROR(error, displayId); displayData.vsyncEnabled = enabled; const auto tag = &quot;HW_VSYNC_ON_&quot; + to_string(displayId); ATRACE_INT(tag.c_str(), enabled == HWC2::Vsync::Enable ? 1 : 0);&#125; 六. 硬件Vsync信号更新经过HWComposer使能硬件Vsync信号后，只要有硬件Vsync信号产生，就可回调 hook_vsync函数。hook_vsync函数在HWComposer的初始化的时候被注册的。 6.1 HWC初始化123456789void SurfaceFlinger::init() &#123; ...... // 获取硬件HWC getBE().mHwc.reset( new HWComposer(std::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName))); // 注册回调 getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId); ......&#125; 这里这里先创建的是 Hwc2::impl::Composer,然后创建HWComposer 6.1.1 ComposerHal.cpp:Composer123456789101112131415161718192021222324252627282930313233343536Composer::Composer(const std::string&amp; serviceName) : mWriter(kWriterInitialSize), mIsUsingVrComposer(serviceName == std::string(&quot;vr&quot;))&#123; mComposer = V2_1::IComposer::getService(serviceName); if (mComposer == nullptr) &#123; LOG_ALWAYS_FATAL(&quot;failed to get hwcomposer service&quot;); &#125; mComposer-&gt;createClient( [&amp;](const auto&amp; tmpError, const auto&amp; tmpClient) &#123; if (tmpError == Error::NONE) &#123; mClient = tmpClient; &#125; &#125;); if (mClient == nullptr) &#123; LOG_ALWAYS_FATAL(&quot;failed to create composer client&quot;); &#125; // 2.2 support is optional sp&lt;IComposer&gt; composer_2_2 = IComposer::castFrom(mComposer); if (composer_2_2 != nullptr) &#123; mClient_2_2 = IComposerClient::castFrom(mClient); LOG_ALWAYS_FATAL_IF(mClient_2_2 == nullptr, &quot;IComposer 2.2 did not return IComposerClient 2.2&quot;); &#125; if (mIsUsingVrComposer) &#123; sp&lt;IVrComposerClient&gt; vrClient = IVrComposerClient::castFrom(mClient); if (vrClient == nullptr) &#123; LOG_ALWAYS_FATAL(&quot;failed to create vr composer client&quot;); &#125; &#125;&#125; 获取composer服务。 6.1.2 HWComposer创建12HWComposer::HWComposer(std::unique_ptr&lt;android::Hwc2::Composer&gt; composer) : mHwcDevice(std::make_unique&lt;HWC2::Device&gt;(std::move(composer))) &#123;&#125; 6.2 注册回调HWComposer.registerCallback12345678910111213141516171819202122232425void HWComposer::registerCallback(HWC2::ComposerCallback* callback, int32_t sequenceId) &#123; mHwcDevice-&gt;registerCallback(callback, sequenceId);&#125;void Device::registerCallback(ComposerCallback* callback, int32_t sequenceId) &#123; if (mRegisteredCallback) &#123; ALOGW(&quot;Callback already registered. Ignored extra registration &quot; &quot;attempt.&quot;); return; &#125; mRegisteredCallback = true; sp&lt;ComposerCallbackBridge&gt; callbackBridge( new ComposerCallbackBridge(callback, sequenceId)); mComposer-&gt;registerCallback(callbackBridge);&#125;void Composer::registerCallback(const sp&lt;IComposerCallback&gt;&amp; callback)&#123; // mClient就是composer服务在SurfaceFlinger中的客户端 auto ret = mClient-&gt;registerCallback(callback); if (!ret.isOk()) &#123; ALOGE(&quot;failed to register IComposerCallback&quot;); &#125;&#125; ComposerCallbackBridge类就是实现onHotplug, onVsync等回调。当HWC硬件产生vsync信号时，就会回调onVsync方法。 6.3 Vsync信号更新6.3.1 ComposerCallbackBridge.onVsync12345Return&lt;void&gt; onVsync(Hwc2::Display display, int64_t timestamp) override&#123; mCallback-&gt;onVsyncReceived(mSequenceId, display, timestamp); return Void();&#125; 这里的mCallback就是SurfaceFlinger[6.1]. 6.3.2 SurfaceFlinger.onVsyncReceived123456789101112131415161718192021222324252627282930void SurfaceFlinger::onVsyncReceived(int32_t sequenceId, hwc2_display_t displayId, int64_t timestamp) &#123; Mutex::Autolock lock(mStateLock); // Ignore any vsyncs from a previous hardware composer. if (sequenceId != getBE().mComposerSequenceId) &#123; return; &#125; int32_t type; // 按条件决定是否过滤，记录此次HWC接收到的硬件Vsync if (!getBE().mHwc-&gt;onVsync(displayId, timestamp, &amp;type)) &#123; return; &#125; bool needsHwVsync = false; &#123; // Scope for the lock Mutex::Autolock _l(mHWVsyncLock); // DISPLAY_PRIMARY为0，mPrimaryHWVsyncEnabled为true if (type == DisplayDevice::DISPLAY_PRIMARY &amp;&amp; mPrimaryHWVsyncEnabled) &#123; needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp); &#125; &#125; if (needsHwVsync) &#123; enableHardwareVsync(); &#125; else &#123; disableHardwareVsync(false); &#125;&#125; 6.3.3 DispSync.addResyncSample1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950bool DispSync::addResyncSample(nsecs_t timestamp) &#123; Mutex::Autolock lock(mMutex); ALOGV(&quot;[%s] addResyncSample(%&quot; PRId64 &quot;)&quot;, mName, ns2us(timestamp)); // MAX_RESYNC_SAMPLES = 32，即最大只保存32次硬件vsync时间戳，用来计算SW vsync模型. // mNumResyncSamples 表示已经有多少个硬件vsync 样本了 ，最多记录MAX_RESYNC_SAMPLES // size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES; mResyncSamples[idx] = timestamp; // 第一次收到Vsync信号，直接更新 if (mNumResyncSamples == 0) &#123; mPhase = 0; // 参考时间设置为第一个硬件vsync的时间戳 mReferenceTime = timestamp; ALOGV(&quot;[%s] First resync sample: mPeriod = %&quot; PRId64 &quot;, mPhase = 0, &quot; &quot;mReferenceTime = %&quot; PRId64, mName, ns2us(mPeriod), ns2us(mReferenceTime)); // 6.3.5 通知更新DispSync线程收到Vsync信号 mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime); &#125; // 更新 mNumResyncSamples 或 mFirstResyncSample的值 if (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123; mNumResyncSamples++; &#125; else &#123; mFirstResyncSample = (mFirstResyncSample + 1) % MAX_RESYNC_SAMPLES; &#125; // 6.3.4 开始计算更新SW vsync 模型 updateModelLocked(); if (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123; resetErrorLocked(); &#125; if (mIgnorePresentFences) &#123; // If we don&#x27;t have the sync framework we will never have // addPresentFence called. This means we have no way to know whether // or not we&#x27;re synchronized with the HW vsyncs, so we just request // that the HW vsync events be turned on whenever we need to generate // SW vsync events. return mThread-&gt;hasAnyEventListeners(); &#125; // Check against kErrorThreshold / 2 to add some hysteresis before having to // resync again bool modelLocked = mModelUpdated &amp;&amp; mError &lt; (kErrorThreshold / 2); ALOGV(&quot;[%s] addResyncSample returning %s&quot;, mName, modelLocked ? &quot;locked&quot; : &quot;unlocked&quot;); return !modelLocked;&#125; 这里是收到硬件Vsync信号, 在SurfaceFlinger主线程执行，在经过误差更正后，通知DispSync线程处理分发事件。 6.3.4 DispSync.updateModelLocked这一步是计算模型参数如偏移、硬件Vsync更新间隔等。在分析前，我们先了解下几个重要参数的含义： 参数名 默认值 含义 mNumResyncSamples - 当前保存的硬件Vsyc信号数量，最大值为32 MIN_RESYNC_SAMPLES_FOR_UPDATE 6 更新模型参数的最小硬件Vsync数量 mPeriod - 硬件刷新率，根据保存的Vsync去掉最大和最小求得的平均值 mPhase - 偏移时间，仅作为针对mPeriod的一个偏移 mReferenceTime 第一个硬件Vsync事件 每次计算sw vsync模型时的基准时间，以减少误差 mRefreshSkipCount 0 多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void DispSync::updateModelLocked() &#123; ALOGV(&quot;[%s] updateModelLocked %zu&quot;, mName, mNumResyncSamples); // MIN_RESYNC_SAMPLES_FOR_UPDATE = 6, 也就是收到6次硬件Vsync之后，开始计算sw vsync模型 if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123; ALOGV(&quot;[%s] Computing...&quot;, mName); nsecs_t durationSum = 0; nsecs_t minDuration = INT64_MAX; nsecs_t maxDuration = 0; // 这里计算总时长，以及拿到最长和最短的硬件vsync间隔 for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES; nsecs_t duration = mResyncSamples[idx] - mResyncSamples[prev]; durationSum += duration; minDuration = min(minDuration, duration); maxDuration = max(maxDuration, duration); &#125; // 计算平均间隔，去掉一个最大和一个最小的间隔 durationSum -= minDuration + maxDuration; mPeriod = durationSum / (mNumResyncSamples - 3); ALOGV(&quot;[%s] mPeriod = %&quot; PRId64, mName, ns2us(mPeriod)); double sampleAvgX = 0; double sampleAvgY = 0; double scale = 2.0 * M_PI / double(mPeriod); // 跳过第一个Vsync，因为第一个Vsync已经更新到DispSync中了。 // mReferenceTime是第一个Vsync的时间 for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; nsecs_t sample = mResyncSamples[idx] - mReferenceTime; double samplePhase = double(sample % mPeriod) * scale; sampleAvgX += cos(samplePhase); sampleAvgY += sin(samplePhase); &#125; sampleAvgX /= double(mNumResyncSamples - 1); sampleAvgY /= double(mNumResyncSamples - 1); mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale); ALOGV(&quot;[%s] mPhase = %&quot; PRId64, mName, ns2us(mPhase)); // 如果偏移值是负值，绝对值超过了mPeroid的一半 // 则调整偏移值为对应正值 if (mPhase &lt; -(mPeriod / 2)) &#123; mPhase += mPeriod; ALOGV(&quot;[%s] Adjusting mPhase -&gt; %&quot; PRId64, mName, ns2us(mPhase)); &#125; if (kTraceDetailedInfo) &#123; ATRACE_INT64(&quot;DispSync:Period&quot;, mPeriod); ATRACE_INT64(&quot;DispSync:Phase&quot;, mPhase + mPeriod / 2); &#125; // mRefreshSkipCount表示多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率) mPeriod += mPeriod * mRefreshSkipCount; // 6.3.5 更新sw model. 这个方法会唤醒DispSync线程 mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime); mModelUpdated = true; &#125;&#125; 这里算偏移还用上了反三角函数。mPeriod的含义就是圆周长，最终算出来的 mPhase 就是弧BC的长度。也就是基于mPeriod的偏移值，如下图： 这个偏移值有什么用处呢？ 6.3.5 DispSync.DispSyncThread.updateModel123456789101112void updateModel(nsecs_t period, nsecs_t phase, nsecs_t referenceTime) &#123; if (kTraceDetailedInfo) ATRACE_CALL(); Mutex::Autolock lock(mMutex); mPeriod = period; mPhase = phase; mReferenceTime = referenceTime; ALOGV(&quot;[%s] updateModel: mPeriod = %&quot; PRId64 &quot;, mPhase = %&quot; PRId64 &quot; mReferenceTime = %&quot; PRId64, mName, ns2us(mPeriod), ns2us(mPhase), ns2us(mReferenceTime)); // 这里通知正在等待的DispSync线程开始执行 mCond.signal();&#125; 更新mPeriod和时间戳。mCond.signal 后转DispSyncThread线程[2.4.1]DispSyncThread.threadLoop继续执行 七. SW Vsync更新硬件Vsync信号经过DispSync的简单加工，会将相应的值更新，然后唤醒DispSyncThread线程 7.1 DispSync.DispSyncThread.threadLoop123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778virtual bool threadLoop() &#123; status_t err; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); while (true) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; nsecs_t targetTime = 0; &#123; // Scope for lock Mutex::Autolock lock(mMutex); if (kTraceDetailedInfo) &#123; ATRACE_INT64(&quot;DispSync:Frame&quot;, mFrameNumber); &#125; ALOGV(&quot;[%s] Frame %&quot; PRId64, mName, mFrameNumber); ++mFrameNumber; if (mStop) &#123; return false; &#125; if (mPeriod == 0) &#123; err = mCond.wait(mMutex); if (err != NO_ERROR) &#123; ALOGE(&quot;error waiting for new events: %s (%d)&quot;, strerror(-err), err); return false; &#125; continue; &#125; // 7.2 计算下一个SW Vsync时间点 targetTime = computeNextEventTimeLocked(now); bool isWakeup = false; // 如果计算出来的下一次vsync事件还没有到来，就等时间到了，才发送SW VSYNC信号 // 可以看出 DispSyncThread的发送的vsync信号和真正硬件发生的vsync信号没有直接的关系， // 发送给app/sf的vsync信号都是由 DispSyncThread发送出去的. if (now &lt; targetTime) &#123; if (kTraceDetailedInfo) ATRACE_NAME(&quot;DispSync waiting&quot;); if (targetTime == INT64_MAX) &#123; ALOGV(&quot;[%s] Waiting forever&quot;, mName); err = mCond.wait(mMutex); &#125; else &#123; ALOGV(&quot;[%s] Waiting until %&quot; PRId64, mName, ns2us(targetTime)); err = mCond.waitRelative(mMutex, targetTime - now); &#125; // 等待超时，主动醒来，发送SW Vsync信号 if (err == TIMED_OUT) &#123; isWakeup = true; &#125; else if (err != NO_ERROR) &#123; ALOGE(&quot;error waiting for next event: %s (%d)&quot;, strerror(-err), err); return false; &#125; &#125; now = systemTime(SYSTEM_TIME_MONOTONIC); // 计算wake up消耗的时间, 但是不能超过1.5 ms static const nsecs_t kMaxWakeupLatency = us2ns(1500); if (isWakeup) &#123; // 乍一看没明白为什么这么算。仔细想，每次wakeup时间是累加的，这个为了减小抖动？ mWakeupLatency = ((mWakeupLatency * 63) + (now - targetTime)) / 64; mWakeupLatency = min(mWakeupLatency, kMaxWakeupLatency); if (kTraceDetailedInfo) &#123; ATRACE_INT64(&quot;DispSync:WakeupLat&quot;, now - targetTime); ATRACE_INT64(&quot;DispSync:AvgWakeupLat&quot;, mWakeupLatency); &#125; &#125; // 7.3 搜集EventListener回调，一般就两个：SF和App EventThread // 并不是所有的wakeup都是等待了sw vsync的targetTime，如果SurfaceFlinger // 主线程收到硬件Vsync,也会唤醒此线程，此时isWakeup为false // 这里的callbackInvocations集合就为null，只有now&gt;=targetTime才不为null callbackInvocations = gatherCallbackInvocationsLocked(now); &#125; if (callbackInvocations.size() &gt; 0) &#123; fireCallbackInvocations(callbackInvocations); &#125; &#125; return false;&#125; 7.2 DispSync.DispSyncThread.computeNextEventTimeLocked123456789101112131415nsecs_t computeNextEventTimeLocked(nsecs_t now) &#123; if (kTraceDetailedInfo) ATRACE_CALL(); ALOGV(&quot;[%s] computeNextEventTimeLocked&quot;, mName); nsecs_t nextEventTime = INT64_MAX; // 对所有的EventListener进行分别计算，里面的mLastEventTime值不同 // 找出一个最小的Vsync时间，即最近的时间 for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i], now); if (t &lt; nextEventTime) &#123; nextEventTime = t; &#125; &#125; ALOGV(&quot;[%s] nextEventTime = %&quot; PRId64, mName, ns2us(nextEventTime)); return nextEventTime;&#125; 这里的EventListeners里面只有两个，一个是SF EventThread，另一个就是App EventThread. 7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked12345678910111213141516171819202122232425262728293031323334353637383940414243nsecs_t computeListenerNextEventTimeLocked(const EventListener&amp; listener, nsecs_t baseTime) &#123; // listener.mLasteEventTime就是上次SW VSync的时间点，mWakeupLatency就是上次线程醒来的耗时 nsecs_t lastEventTime = listener.mLastEventTime + mWakeupLatency; // 一般baseTime也就是nowTime, 是大于lasterEventTime，除了第一次进入 if (baseTime &lt; lastEventTime) &#123; baseTime = lastEventTime; &#125; // baseTime减去第一次硬件Vsync的时间，算duration时长 baseTime -= mReferenceTime; // 偏移就是SW Vsync本身的偏移值加上各EventThread本身的偏移 // sf 使用的是 SF_VSYNC_EVENT_PHASE_OFFSET_NS // APP使用的VSYNC_EVENT_PHASE_OFFSET_NS nsecs_t phase = mPhase + listener.mPhase; // baseTime也减去偏移 baseTime -= phase; // baseTime小于0，只有第一次进入的时候才会发生。 // 此时硬件Vsync已经发生了，所以设置baseTime为-mPeriod这样后面算的numPeriod为-1 if (baseTime &lt; 0) &#123; baseTime = -mPeriod; &#125; // 算出下一个SW Vsync的时间点 // 先得到baseTime对应第几个sw Vsync，也就是现在时间点发送了多少个sw Vsync nsecs_t numPeriods = baseTime / mPeriod; // numberPeriods+1也就是下一个sw Vysnc，再加上偏移 nsecs_t t = (numPeriods + 1) * mPeriod + phase; t += mReferenceTime; ALOGV(&quot;[%s] Absolute t = %&quot; PRId64, mName, ns2us(t)); // 如果这个vsync距离上一个vsync时间小于3/5个mPeriod的话， // 为了避免连续的两个sw vsync, 那么这次sw vsync就放弃了，直接放到下一个周期里 if (t - listener.mLastEventTime &lt; (3 * mPeriod / 5)) &#123; t += mPeriod; &#125; // 算出来的时间减掉wakeup累积时间，最大1.5ms t -= mWakeupLatency; return t;&#125; 如下图： 看到这里就有一个疑问，sw vsync信号是在DispSyncThread收到第一个硬件Vsync更新sw model后就可以不依赖硬件Vsync信号了，后续可以自己产生。那为什么google没有在这里disable硬件Vsync呢，因为sw vsync还是有误差并不能与硬件Vsync完全保持一致，所以需要updateModelLocked持续消减误差。重新梳理一下完整流程： SurfaceFlinger主线程收到硬件Vsync DispSync.updateModelLocked及时更新sw model，并通知DispSyncThread线程 DispSyncThread线程更新mPeriod，mPhase等参数通过computeNextEventTimeLocked计算新的targetTime 继续等待直到新的targetTime，通知SF EventThread或者AppEventThread有sw vsync信号 我们知道SF EventThread和App EventThread是有间隔的，并不同步，这里是如何实现的呢？注意我们计算出来的targetTime是sf和app中最近的一次，那么继续看往下看。 7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLockednow是当前应该被触发的sw vsync时间点，可能是sf vsync也可能是app vsync。 1234567891011121314151617181920212223Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(nsecs_t now) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; // 这里为什么是拿一个vsync周期前的时间点呢？ nsecs_t onePeriodAgo = now - mPeriod; // 计算各个EventListener(也就是sf 和app EventThread)的对应的下一次vsync时间. // 因为对于时间点now来讲，sf 和 app的下一次vsync时间可能尚未到来。 for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i], onePeriodAgo); // 如果下一次vsync时间尚未到达，这一次就不通知给对应EventListener if (t &lt; now) &#123; CallbackInvocation ci; ci.mCallback = mEventListeners[i].mCallback; ci.mEventTime = t; callbackInvocations.push(ci); // 记录本次sw Vsync时间点 mEventListeners.editItemAt(i).mLastEventTime = t; &#125; &#125; return callbackInvocations;&#125; 看完这个方法，其实不难理解，DispSyncThread中的targetTime是变化的值，有可能是app EventThread的下一次sw vsync时间，也可能是sf的。如下图： 到这里，sw vsync的流程基本梳理完毕了。 接下来继续看EventThread. 参考资料 Android SurfaceFlinger SW Vsync模型 DispSync DispSync详解","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"SurfaceFlinger","slug":"Android/SurfaceFlinger","permalink":"https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"https://swallowjoe.github.io/tags/SurfaceFlinger/"}]},{"title":"SurfaceFlinger(1)--SFEventThread","slug":"SurfaceFlinger-1-SFEventThread","date":"2022-04-04T01:52:04.000Z","updated":"2022-04-04T02:28:02.020Z","comments":true,"path":"2022/04/04/SurfaceFlinger-1-SFEventThread/","link":"","permalink":"https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-1-SFEventThread/","excerpt":"Andorid Q 一. SFEventThread EventControlThread: 控制硬件vsync的开关 DispSyncThread: 软件产生vsync的线程 SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染 App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图 从这4个线程，可以将vsync分为4种不同的类型 HW vsync, 真实由硬件产生的vsync信号 SW vsync, 由DispSync产生的vsync信号 SF vsync, SF接收到的vsync信号 App vsync, App接收到的vsync信号 这里我们着重看看SF EventThread.","text":"Andorid Q 一. SFEventThread EventControlThread: 控制硬件vsync的开关 DispSyncThread: 软件产生vsync的线程 SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染 App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图 从这4个线程，可以将vsync分为4种不同的类型 HW vsync, 真实由硬件产生的vsync信号 SW vsync, 由DispSync产生的vsync信号 SF vsync, SF接收到的vsync信号 App vsync, App接收到的vsync信号 这里我们着重看看SF EventThread. 1.1 BitTube先大致了解下BitTube，其实现是socketpairt套接字，用于传递消息。Buffer大小是4KB。 二. EventThread启动2.1 SurfaceFlinger.init1234567891011121314151617181920212223void SurfaceFlinger::init() &#123; ... // start the EventThread mEventThreadSource = std::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs, true, &quot;app&quot;); mEventThread = std::make_unique&lt;impl::EventThread&gt;(mEventThreadSource.get(), [this]() &#123; resyncWithRateLimit(); &#125;, impl::EventThread::InterceptVSyncsCallback(), &quot;appEventThread&quot;); mSfEventThreadSource = std::make_unique&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::sfVsyncPhaseOffsetNs, true, &quot;sf&quot;); mSFEventThread = std::make_unique&lt;impl::EventThread&gt;(mSfEventThreadSource.get(), [this]() &#123; resyncWithRateLimit(); &#125;, [this](nsecs_t timestamp) &#123; mInterceptor-&gt;saveVSyncEvent(timestamp); &#125;, &quot;sfEventThread&quot;); ......&#125; 这里注意传入的偏移是不同的。 app EventThread : vsyncPhaseOffsetNs &#x3D; 2000000ns sf EventThread : sfVsyncPhaseOffsetNs &#x3D; 6000000ns 这个值是编译期间固定的，定义在BoardConfig.mk中 2.2 EventThread初始化1234567891011121314151617181920212223242526272829EventThread::EventThread(VSyncSource* src, ResyncWithRateLimitCallback resyncWithRateLimitCallback, InterceptVSyncsCallback interceptVSyncsCallback, const char* threadName) : mVSyncSource(src), mResyncWithRateLimitCallback(resyncWithRateLimitCallback), mInterceptVSyncsCallback(interceptVSyncsCallback) &#123; for (auto&amp; event : mVSyncEvent) &#123; event.header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC; event.header.id = 0; event.header.timestamp = 0; event.vsync.count = 0; &#125; // 绑定thread函数 mThread = std::thread(&amp;EventThread::threadMain, this); // 设置thread名称 pthread_setname_np(mThread.native_handle(), threadName); pid_t tid = pthread_gettid_np(mThread.native_handle()); // Use SCHED_FIFO to minimize jitter constexpr int EVENT_THREAD_PRIORITY = 2; struct sched_param param = &#123;0&#125;; param.sched_priority = EVENT_THREAD_PRIORITY; if (pthread_setschedparam(mThread.native_handle(), SCHED_FIFO, &amp;param) != 0) &#123; ALOGE(&quot;Couldn&#x27;t set SCHED_FIFO for EventThread&quot;); &#125; set_sched_policy(tid, SP_FOREGROUND);&#125; 2.3 EventThread.threadMain12345678910111213141516171819202122232425262728293031void EventThread::threadMain() NO_THREAD_SAFETY_ANALYSIS &#123; std::unique_lock&lt;std::mutex&gt; lock(mMutex); while (mKeepRunning) &#123; DisplayEventReceiver::Event event; Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections; // 2.4 阻塞等待事件 signalConnections = waitForEventLocked(&amp;lock, &amp;event); // 分发事件给connection const size_t count = signalConnections.size(); for (size_t i = 0; i &lt; count; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // 2.5 分发事件 status_t err = conn-&gt;postEvent(event); if (err == -EAGAIN || err == -EWOULDBLOCK) &#123; // The destination doesn&#x27;t accept events anymore, it&#x27;s probably // full. For now, we just drop the events on the floor. // FIXME: Note that some events cannot be dropped and would have // to be re-sent later. // Right-now we don&#x27;t have the ability to do this. //ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;, event.header.type, // conn.get()); &#125; else if (err &lt; 0) &#123; // handle any other error on the pipe as fatal. the only // reasonable thing to do is to clean-up this connection. // The most common error we&#x27;ll get here is -EPIPE. removeDisplayEventConnectionLocked(signalConnections[i]); &#125; &#125; &#125;&#125; 2.4 EventThread.waitForEventLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// This will return when (1) a vsync event has been received, and (2) there was// at least one connection interested in receiving it when we started waiting.Vector&lt;sp&lt;EventThread::Connection&gt; &gt; EventThread::waitForEventLocked( std::unique_lock&lt;std::mutex&gt;* lock, DisplayEventReceiver::Event* event) &#123; Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections; while (signalConnections.isEmpty() &amp;&amp; mKeepRunning) &#123; bool eventPending = false; bool waitForVSync = false; size_t vsyncCount = 0; nsecs_t timestamp = 0; for (int32_t i = 0; i &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; i++) &#123; timestamp = mVSyncEvent[i].header.timestamp; if (timestamp) &#123; // 当timestamp不为0时，说明有事件发生 if (mInterceptVSyncsCallback) &#123; mInterceptVSyncsCallback(timestamp); &#125; *event = mVSyncEvent[i]; // 置timestamp为0，标记为当前事件被消费 mVSyncEvent[i].header.timestamp = 0; vsyncCount = mVSyncEvent[i].vsync.count; break; &#125; &#125; // mDisplayEventConnections保存的是注册的Connection的, // SF EventThread线程里只有一个Connection, 而这个Connection主要是用来渲染 // 而如果是APP EventThread, 这里会有多个connection size_t count = mDisplayEventConnections.size(); if (!timestamp &amp;&amp; count) &#123; // 没有vsync事件， 来看下是否有其它pending的event, 这里主要是hotplug的事件 eventPending = !mPendingEvents.isEmpty(); if (eventPending) &#123; // we have some other event to dispatch *event = mPendingEvents[0]; mPendingEvents.removeAt(0); &#125; &#125; for (size_t i = 0; i &lt; count;) &#123; sp&lt;Connection&gt; connection(mDisplayEventConnections[i].promote()); if (connection != nullptr) &#123; bool added = false; // Connection-&gt;count的值大小含义如下： // 1. &gt;=1: 表示持续接收Vsync信号 // 2. ==0: 只接收一次Vsync信号 // 3. ==-1: 不接收Vsync信号 if (connection-&gt;count &gt;= 0) &#123; // 如果有 connection-&gt;count &gt;= 0，说明需要Vsync信号 waitForVSync = true; if (timestamp) &#123; // 大于0.说明有事件 // 处理本次事件 if (connection-&gt;count == 0) &#123; // fired this time around connection-&gt;count = -1; signalConnections.add(connection); added = true; &#125; else if (connection-&gt;count == 1 || (vsyncCount % connection-&gt;count) == 0) &#123; // continuous event, and time to report it signalConnections.add(connection); added = true; &#125; &#125; &#125; if (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123; // we don&#x27;t have a vsync event to process // (timestamp==0), but we have some pending // messages. signalConnections.add(connection); &#125; ++i; &#125; else &#123; // we couldn&#x27;t promote this reference, the connection has // died, so clean-up! mDisplayEventConnections.removeAt(i); --count; &#125; &#125; // Here we figure out if we need to enable or disable vsyncs if (timestamp &amp;&amp; !waitForVSync) &#123; // 收到Vsync信号，但是没有Connection监听，所以关闭Vsync disableVSyncLocked(); &#125; else if (!timestamp &amp;&amp; waitForVSync) &#123; // 有Connection监听，但是还没有Vsync信号，所以打开Vsync enableVSyncLocked(); &#125; // 没有事件发生 if (!timestamp &amp;&amp; !eventPending) &#123; if (waitForVSync) &#123; // 如果有connection监听，则需要等待Vsync事件 // 以防止硬件Driver出问题，设置一个超时时间16ms bool softwareSync = mUseSoftwareVSync; auto timeout = softwareSync ? 16ms : 1000ms; if (mCondition.wait_for(*lock, timeout) == std::cv_status::timeout) &#123; if (!softwareSync) &#123; ALOGW(&quot;Timed out waiting for hw vsync; faking it&quot;); &#125; // FIXME: how do we decide which display id the fake // vsync came from ? mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC; mVSyncEvent[0].header.id = DisplayDevice::DISPLAY_PRIMARY; mVSyncEvent[0].header.timestamp = systemTime(SYSTEM_TIME_MONOTONIC); mVSyncEvent[0].vsync.count++; &#125; &#125; else &#123; // 没有connection监听，也没有收到事件，则一直等待 mCondition.wait(*lock); &#125; &#125; &#125; // here we&#x27;re guaranteed to have a timestamp and some connections to signal // (The connections might have dropped out of mDisplayEventConnections // while we were asleep, but we&#x27;ll still have strong references to them.) return signalConnections;&#125; 当EventThread初始化进入时，由于没有Connection，timestamp也为0，直接进入waitForEventLocked一直等待。 2.5 EventThread.Connection.postEvent1234status_t EventThread::Connection::postEvent(const DisplayEventReceiver::Event&amp; event) &#123; ssize_t size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);&#125; 通过BitTube发送事件。 三. SF EventThread 添加Connection3.1 SurfaceFlinger.initsfEventThread添加Connection是在这个线程启动后就添加的。 1234567void SurfaceFlinger::init() &#123; ...... // mEventQueue就是MessageQueue类的对象 mEventQueue-&gt;setEventThread(mSFEventThread.get()); mVsyncModulator.setEventThreads(mSFEventThread.get(), mEventThread.get()); ......&#125; 3.2 MessageQueue.setEventThread123456789101112131415161718void MessageQueue::setEventThread(android::EventThread* eventThread) &#123; if (mEventThread == eventThread) &#123; return; &#125; if (mEventTube.getFd() &gt;= 0) &#123; mLooper-&gt;removeFd(mEventTube.getFd()); &#125; mEventThread = eventThread; // 3.3 创建Connection mEvents = eventThread-&gt;createEventConnection(); // 3.4 建立BitTube连接 mEvents-&gt;stealReceiveChannel(&amp;mEventTube); // 3.5 接受BitTube事件，调用cb_eventReceiver方法 mLooper-&gt;addFd(mEventTube.getFd(), 0, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, this);&#125; 3.3 EventThread.createEventConnection1234567sp&lt;BnDisplayEventConnection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this));&#125;EventThread::Connection::Connection(EventThread* eventThread) // 注意这里的count是被赋值为-1，也就是不接收Vsync事件 : count(-1), mEventThread(eventThread), mChannel(gui::BitTube::DefaultSize) &#123;&#125; 3.3.1 EventThread.Connection.onFirstRef1234void EventThread::Connection::onFirstRef() &#123; // NOTE: mEventThread doesn&#x27;t hold a strong reference on us mEventThread-&gt;registerDisplayEventConnection(this);&#125; 在Connection对象生成之后，就被注册到其对应的EventThread中 3.3.2 EventThread.registerDisplayEventConnection123456789status_t EventThread::registerDisplayEventConnection( const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); // 添加到mDisplayEventConnections集合中 mDisplayEventConnections.add(connection); // waitForEventLocked 可以继续执行了。 mCondition.notify_all(); return NO_ERROR;&#125; 注册connection后，waitForEventLocked便可以开始继续执行了。但是由于只有这一个connection，而且这个connection.count 还是 -1，所以最后还是会在waitForEventLocked中一直等待Vsync事件 3.4 EventThread.Connection.stealReceiveChannel12345status_t EventThread::Connection::stealReceiveChannel(gui::BitTube* outChannel) &#123; // 将Connection的mChannel复制 outChannel-&gt;setReceiveFd(mChannel.moveReceiveFd()); return NO_ERROR;&#125; 3.5 SF EventThread connection开始监听Vsync信号12345678SurfaceFlinger::initializeDisplays SurfaceFlinger::onInitializeDisplays SurfaceFlinger::setTransactionState SurfaceFlinger::setTransactionFlags SurfaceFlinger::signalTransaction MessageQueue::invalidate EventThread::Connection::requestNextVsync EventThread::requestNextVsync 也就是说当显示屏准备完毕，sfEventThread就可以开始监听Vsync信号了 123456789101112void EventThread::requestNextVsync(const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); if (mResyncWithRateLimitCallback) &#123; mResyncWithRateLimitCallback(); &#125; if (connection-&gt;count &lt; 0) &#123; connection-&gt;count = 0; // 只接受一次Vsync信号 mCondition.notify_all(); &#125;&#125; 3.6 MessageQueue.cb_eventReceiver 处理Vsync信号当SF EventThread收到Vsync信号时，最终会通过BitTube发送给对应connection的receiver[2.5]。 12345678910111213141516171819int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123; MessageQueue* queue = reinterpret_cast&lt;MessageQueue*&gt;(data); return queue-&gt;eventReceiver(fd, events);&#125;int MessageQueue::eventReceiver(int /*fd*/, int /*events*/) &#123; ssize_t n; DisplayEventReceiver::Event buffer[8]; while ((n = DisplayEventReceiver::getEvents(&amp;mEventTube, buffer, 8)) &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123; mHandler-&gt;dispatchInvalidate(); break; &#125; &#125; &#125; return 1;&#125; 3.6.1 MessageQueue.Handler.dispatchInvalidate123456789101112131415161718void MessageQueue::Handler::dispatchInvalidate() &#123; if ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE)); &#125;&#125;void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125;&#125; 转到SufaceFlinger主线程中处理了。 四. 开启硬件Vsync4.1 EventThread.enableVSyncLocked当显示屏准备完毕后，SF EventThread请求一次Vsync信号。那么走到waitForEventLocked中，会调用enableVSyncLocked方法开启硬件Vsync信号。 123456789101112void EventThread::enableVSyncLocked() &#123; if (!mUseSoftwareVSync) &#123; // mUseSoftwareVSync也就是显示屏power状态 // 灭屏为true，亮屏置为false if (!mVsyncEnabled) &#123; mVsyncEnabled = true; mVSyncSource-&gt;setCallback(this); mVSyncSource-&gt;setVSyncEnabled(true); &#125; &#125; mDebugVsyncEnabled = true;&#125; 4.2 DispSyncSource.setVSyncEnabled1234567891011121314151617181920void DispSyncSource::setVSyncEnabled(bool enable) &#123; std::lock_guard lock(mVsyncMutex); if (enable) &#123; status_t err = mDispSync-&gt;addEventListener(mName, mPhaseOffset, static_cast&lt;DispSync::Callback*&gt;(this), mLastCallbackTime); if (err != NO_ERROR) &#123; ALOGE(&quot;error registering vsync callback: %s (%d)&quot;, strerror(-err), err); &#125; // ATRACE_INT(mVsyncOnLabel.c_str(), 1); &#125; else &#123; status_t err = mDispSync-&gt;removeEventListener(static_cast&lt;DispSync::Callback*&gt;(this), &amp;mLastCallbackTime); if (err != NO_ERROR) &#123; ALOGE(&quot;error unregistering vsync callback: %s (%d)&quot;, strerror(-err), err); &#125; // ATRACE_INT(mVsyncOnLabel.c_str(), 0); &#125; mEnabled = enable;&#125; 开启Vsync信号就是添加EventListener，关闭就是将这个listener移除 4.3 DispSync.addEventListener1234status_t DispSync::addEventListener(const char* name, nsecs_t phase, Callback* callback) &#123; Mutex::Autolock lock(mMutex); return mThread-&gt;addEventListener(name, phase, callback);&#125; 接下来就是到了DispSync部分了。 大致流程如下： 参考资料 Android SurfaceFlinger SW Vsync模型","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"SurfaceFlinger","slug":"Android/SurfaceFlinger","permalink":"https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"https://swallowjoe.github.io/tags/SurfaceFlinger/"}]},{"title":"App申请帧率(4)--SF切换帧率","slug":"App申请帧率-4-SF切换帧率","date":"2022-02-26T19:54:03.000Z","updated":"2022-02-26T20:00:41.253Z","comments":true,"path":"2022/02/27/App申请帧率-4-SF切换帧率/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/","excerpt":"以下分析基于Android R. 简述上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。 接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。","text":"以下分析基于Android R. 简述上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。 接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。 一. SurfaceFlinger接受帧率变化接上一章，从 SurfaceFlinger::setDesiredActiveConfig 开始. 这里的ActiveConfigInfo就是SurfaceFlinger根据Framework传入的帧率范围以及各个Layer投票计算的最终帧率信息。 12345678struct ActiveConfigInfo &#123; HwcConfigIndexType configId; Scheduler::ConfigEvent event = Scheduler::ConfigEvent::None; bool operator!=(const ActiveConfigInfo&amp; other) const &#123; return configId != other.configId || event != other.event; &#125; &#125;; 1.1 SurfaceFlinger.setDesiredActiveConfig1234567891011121314151617181920212223242526272829303132333435363738394041void SurfaceFlinger::setDesiredActiveConfig(const ActiveConfigInfo&amp; info) &#123; ATRACE_CALL(); auto&amp; refreshRate = mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(info.configId); mVsyncPeriod = refreshRate.getVsyncPeriod(); ALOGV(&quot;setDesiredActiveConfig(%s)&quot;, refreshRate.getName().c_str()); std::lock_guard&lt;std::mutex&gt; lock(mActiveConfigLock); if (mDesiredActiveConfigChanged) &#123; // 如果帧率切换正在发生，缓存此次帧率切换 const Scheduler::ConfigEvent prevConfig = mDesiredActiveConfig.event; mDesiredActiveConfig = info; mDesiredActiveConfig.event = mDesiredActiveConfig.event | prevConfig; &#125; else &#123; // 如果当前帧率已经是请求的帧率了，直接返回 const auto display = getDefaultDisplayDeviceLocked(); if (!display || display-&gt;getActiveConfig() == refreshRate.getConfigId()) &#123; return; &#125; // 标记正在做帧率切换 mDesiredActiveConfigChanged = true; // 存储即将切换的帧率配置信息 mDesiredActiveConfig = info; // 1.2 触发HWC刷新而不重置空闲计时器。 repaintEverythingForHWC(); // 1.3 现在开始接收vsync样本，这可以检测到硬件周期切换。 mScheduler-&gt;resyncToHardwareVsync(true, refreshRate.getVsyncPeriod()); // 1.4 调用onRefreshRateChangeCompleted, 通知更新偏移量 mVSyncModulator-&gt;onRefreshRateChangeInitiated(); // 保存即将更新的Fps mPhaseConfiguration-&gt;setRefreshRateFps(refreshRate.getFps()); // 1.5 再次更新偏移量, 不过这一次是根据即将更新的Fps拿到的固定偏移量 mVSyncModulator-&gt;setPhaseOffsets(mPhaseConfiguration-&gt;getCurrentOffsets()); mScheduler-&gt;setConfigChangePending(true); &#125; if (mRefreshRateOverlay) &#123; mRefreshRateOverlay-&gt;changeRefreshRate(refreshRate); &#125;&#125; 1.2 SurfaceFlinger.repaintEverythingForHWC12345678void SurfaceFlinger::repaintEverythingForHWC() &#123; // 标记全部重绘制 mRepaintEverything = true; // 通知Power模组, Display将更新，OEM厂商自行实现这个标准接口 mPowerAdvisor.notifyDisplayUpdateImminent(); // EventThread请求下一帧Vsync mEventQueue-&gt;invalidate();&#125; 1.3 Scheduler.resyncToHardwareVsync123456789101112131415161718void Scheduler::resyncToHardwareVsync(bool makeAvailable, nsecs_t period) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock(mHWVsyncLock); if (makeAvailable) &#123; mHWVsyncAvailable = makeAvailable; &#125; else if (!mHWVsyncAvailable) &#123; // 硬件Vsync被禁止，直接返回 return; &#125; &#125; if (period &lt;= 0) &#123; // 参数不合法 return; &#125; // 通知到软件Vsync产生模块，更新Vsync周期 setVsyncPeriod(period);&#125; 1.3.1 Scheduler.setVsyncPeriod123456789101112void Scheduler::setVsyncPeriod(nsecs_t period) &#123; std::lock_guard&lt;std::mutex&gt; lock(mHWVsyncLock); // 1.3.2 更新软件Vsync周期 mPrimaryDispSync-&gt;setPeriod(period); if (!mPrimaryHWVsyncEnabled) &#123; // 硬件Vsync关闭的情况下, 直接更改软件vsync周期，这里我们加上是开启的 mPrimaryDispSync-&gt;beginResync(); mEventControlThread-&gt;setVsyncEnabled(true); mPrimaryHWVsyncEnabled = true; &#125;&#125; 现在R上软件Vsync产生更改了架构，由Q上DispSync改成VSyncReactor, 不过原理不变就不分析了, 具体可以参考文章-SurfaceFlinger(2)–DispSync。 可以通过将属性debug.sf.vsync_reactor置为false后重启，切回Q上的DispSync机制 1.3.2 VSyncReactor.setPeriod1234567891011121314void VSyncReactor::setPeriod(nsecs_t period) &#123; ATRACE_INT64(&quot;VSR-setPeriod&quot;, period); std::lock_guard lk(mMutex); mLastHwVsync.reset(); // mSupportKernelIdleTimer的是由属性控制的，Google源码中默认是true的 // PRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.surface_flinger.support_kernel_idle_timer=true if (!mSupportKernelIdleTimer &amp;&amp; period == getPeriod()) &#123; endPeriodTransition(); &#125; else &#123; // 开始更新 startPeriodTransition(period); &#125;&#125; 1.3.3 VSyncReactor.startPeriodTransition12345678910111213141516171819void VSyncReactor::startPeriodTransition(nsecs_t newPeriod) &#123; // 标记各个变量，并记录待更新的Fps对应一帧的刷新时长 mPeriodConfirmationInProgress = true; mPeriodTransitioningTo = newPeriod; mMoreSamplesNeeded = true; // 忽略当前Fence，其实就是清空mUnfiredFences中的fence setIgnorePresentFencesInternal(true);&#125;void VSyncReactor::setIgnorePresentFencesInternal(bool ignoration) &#123; mInternalIgnoreFences = ignoration; updateIgnorePresentFencesInternal();&#125;void VSyncReactor::updateIgnorePresentFencesInternal() &#123; if (mExternalIgnoreFences || mInternalIgnoreFences) &#123; mUnfiredFences.clear(); &#125;&#125; 1.4 VSyncModulator.onRefreshRateChangeInitiated12345678910111213141516171819202122232425262728293031323334353637void VSyncModulator::onRefreshRateChangeInitiated() &#123; if (mRefreshRateChangePending) &#123; return; &#125; mRefreshRateChangePending = true; updateOffsets();&#125;void VSyncModulator::updateOffsets() &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); updateOffsetsLocked();&#125;void VSyncModulator::updateOffsetsLocked() &#123; // 1.4.1 选择偏移量 const Offsets&amp; offsets = getNextOffsets(); // 1.4.2 更新对应的偏移量，这个mPhaseOffsetControl其实就是Scheduler mPhaseOffsetControl.setPhaseOffset(mSfConnectionHandle, offsets.sf); mPhaseOffsetControl.setPhaseOffset(mAppConnectionHandle, offsets.app); // 更新偏移量 mOffsets = offsets; // 这个trace的debug开关是由属性: debug.sf.vsync_trace_detailed_info 0/1 决定的 if (!mTraceDetailedInfo) &#123; return; &#125; const bool isEarly = &amp;offsets == &amp;mOffsetsConfig.early; const bool isEarlyGl = &amp;offsets == &amp;mOffsetsConfig.earlyGl; const bool isLate = &amp;offsets == &amp;mOffsetsConfig.late; ATRACE_INT(&quot;Vsync-EarlyOffsetsOn&quot;, isEarly); ATRACE_INT(&quot;Vsync-EarlyGLOffsetsOn&quot;, isEarlyGl); ATRACE_INT(&quot;Vsync-LateOffsetsOn&quot;, isLate);&#125; 1.4.1 VSyncModulator.getNextOffsets1234567891011const VSyncModulator::Offsets&amp; VSyncModulator::getNextOffsets() const &#123; // 如果正在进行刷新率更改，或者最近开始了一个事务，则使用early偏移量。 if (mExplicitEarlyWakeup || mTransactionStart == Scheduler::TransactionStart::EarlyEnd || mRemainingEarlyFrameCount &gt; 0 || mRefreshRateChangePending) &#123; return mOffsetsConfig.early; &#125; else if (mRemainingRenderEngineUsageCount &gt; 0) &#123; return mOffsetsConfig.earlyGl; &#125; else &#123; return mOffsetsConfig.late; &#125;&#125; 1.4.2 DispSyncSource.setPhaseOffset12345678910111213141516171819202122232425void DispSyncSource::setPhaseOffset(nsecs_t phaseOffset) &#123; std::lock_guard lock(mVsyncMutex); const nsecs_t period = mDispSync-&gt;getPeriod(); // 正常来讲偏移量在 [-period, period) 之间 const int numPeriods = phaseOffset / period; phaseOffset -= numPeriods * period; if (mPhaseOffset == phaseOffset) &#123; return; &#125; mPhaseOffset = phaseOffset; // 尚未使能，就不需要通知给各个listener if (!mEnabled) &#123; return; &#125; // 1.4.3 DispSyncSource是继承了DispSync::Callback的 status_t err = mDispSync-&gt;changePhaseOffset(static_cast&lt;DispSync::Callback*&gt;(this), mPhaseOffset); if (err != NO_ERROR) &#123; ALOGE(&quot;error changing vsync offset: %s (%d)&quot;, strerror(-err), err); &#125;&#125; 1.4.3 VSyncReactor.changePhaseOffset123456789status_t VSyncReactor::changePhaseOffset(DispSync::Callback* callback, nsecs_t phase) &#123; std::lock_guard&lt;std::mutex&gt; lk(mMutex); auto const it = mCallbacks.find(callback); LOG_ALWAYS_FATAL_IF(it == mCallbacks.end(), &quot;callback was %p not registered&quot;, callback); // 调用start，更新VSyncDispatchTimerQueue中相关信息 it-&gt;second-&gt;start(phase); return NO_ERROR;&#125; 1.4.4 VSyncReactor.CallbackRepeater.start123456789void start(nsecs_t offset) &#123; std::lock_guard&lt;std::mutex&gt; lk(mMutex); mStopped = false; mOffset = offset; auto const schedule_result = mRegistration.schedule(calculateWorkload(), mLastCallTime); LOG_ALWAYS_FATAL_IF((schedule_result != ScheduleResult::Scheduled), &quot;Error scheduling callback: rc %X&quot;, schedule_result);&#125; 1.4.5 VSyncCallbackRegistration.schedule1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ScheduleResult VSyncCallbackRegistration::schedule(nsecs_t workDuration, nsecs_t earliestVsync) &#123; if (!mValidToken) &#123; return ScheduleResult::Error; &#125; return mDispatch.get().schedule(mToken, workDuration, earliestVsync);&#125;ScheduleResult VSyncDispatchTimerQueue::schedule(CallbackToken token, nsecs_t workDuration, nsecs_t earliestVsync) &#123; auto result = ScheduleResult::Error; &#123; std::lock_guard&lt;decltype(mMutex)&gt; lk(mMutex); auto it = mCallbacks.find(token); if (it == mCallbacks.end()) &#123; return result; &#125; auto&amp; callback = it-&gt;second; auto const now = mTimeKeeper-&gt;now(); // 如果计时器线程即将运行，通过回调计时器重新计算应用此工作更新，以避免取消即将触发的回调。 auto const rearmImminent = now &gt; mIntendedWakeupTime; if (CC_UNLIKELY(rearmImminent)) &#123; callback-&gt;addPendingWorkloadUpdate(workDuration, earliestVsync); return ScheduleResult::Scheduled; &#125; result = callback-&gt;schedule(workDuration, earliestVsync, mTracker, now); if (result == ScheduleResult::CannotSchedule) &#123; return result; &#125; if (callback-&gt;wakeupTime() &lt; mIntendedWakeupTime - mTimerSlack) &#123; rearmTimerSkippingUpdateFor(now, it); &#125; &#125; return result;&#125;ScheduleResult VSyncDispatchTimerQueueEntry::schedule(nsecs_t workDuration, nsecs_t earliestVsync, VSyncTracker&amp; tracker, nsecs_t now) &#123; auto nextVsyncTime = tracker.nextAnticipatedVSyncTimeFrom(std::max(earliestVsync, now + workDuration)); bool const wouldSkipAVsyncTarget = mArmedInfo &amp;&amp; (nextVsyncTime &gt; (mArmedInfo-&gt;mActualVsyncTime + mMinVsyncDistance)); if (wouldSkipAVsyncTarget) &#123; return ScheduleResult::Scheduled; &#125; bool const alreadyDispatchedForVsync = mLastDispatchTime &amp;&amp; ((*mLastDispatchTime + mMinVsyncDistance) &gt;= nextVsyncTime &amp;&amp; (*mLastDispatchTime - mMinVsyncDistance) &lt;= nextVsyncTime); if (alreadyDispatchedForVsync) &#123; nextVsyncTime = tracker.nextAnticipatedVSyncTimeFrom(*mLastDispatchTime + mMinVsyncDistance); &#125; auto const nextWakeupTime = nextVsyncTime - workDuration; mWorkDuration = workDuration; mEarliestVsync = earliestVsync; mArmedInfo = &#123;nextWakeupTime, nextVsyncTime&#125;; return ScheduleResult::Scheduled;&#125; 1.5 VSyncModulator.setPhaseOffsets123456void VSyncModulator::setPhaseOffsets(const OffsetsConfig&amp; config) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); mOffsetsConfig = config; // 见 1.4 流程 updateOffsetsLocked();&#125; 这里传入的OffsetsConfig是通过PhaseOffsets拿到的 1.5.1 PhaseOffsets.getCurrentOffsets1234567891011121314151617181920212223242526Offsets getCurrentOffsets() const override &#123; return getOffsetsForRefreshRate(mRefreshRateFps); &#125;PhaseOffsets::Offsets PhaseOffsets::getOffsetsForRefreshRate(float fps) const &#123; const auto iter = std::find_if(mOffsets.begin(), mOffsets.end(), [&amp;fps](const std::pair&lt;float, Offsets&gt;&amp; candidateFps) &#123; return fpsEqualsWithMargin(fps, candidateFps.first); &#125;); if (iter != mOffsets.end()) &#123; return iter-&gt;second; &#125; // Unknown refresh rate. This might happen if we get a hotplug event for an external display. // In this case just construct the offset. ALOGW(&quot;Can&#x27;t find offset for %.2f fps&quot;, fps); return getPhaseOffsets(fps, static_cast&lt;nsecs_t&gt;(1e9f / fps));&#125;PhaseOffsets::Offsets PhaseOffsets::getPhaseOffsets(float fps, nsecs_t vsyncPeriod) const &#123; // 这里根据帧率大小，分两种情况获取偏移量，具体就不看了，和参数配置相关 if (fps &gt; 65.0f) &#123; return getHighFpsOffsets(vsyncPeriod); &#125; else &#123; return getDefaultOffsets(vsyncPeriod); &#125;&#125; 哦吼，到这里setDesiredActiveConfig的流程也算是差不多分析完了，主要做的事情也就下面这些： 触发HWC刷新而不重置空闲计时器。 软件Vsync产生模块记录更新的Vsync周期到mPeriodTransitioningTo中，且开始接收硬件vsync，这可以检测到硬件刷新率切换。 调用onRefreshRateChangeCompleted, 通知更新偏移量 保存即将更新的Fps到mPhaseConfiguration中 再次根据即将更新的Fps拿到的固定偏移量更新偏移量 二. 硬件切换帧率上面的流程跑完后，实际上硬件帧率在哪儿切换还是没有看到，包括mPeriodTransitioningTo是怎么更新到实际软件Vsync中的呢？ 注意到在步骤#1.2中也就是repaintEverythingForHWC会请求下一帧的Vsync，很自然的想法就是实际帧率切换应该是在下一帧到来的时候才开始的。 我们知道SurfaceFlinger接受到Vsync信号后，会调用onMessageInvalidate（Q上是onMessageReceived）方法开始更新、合成Layer。 回顾这个方法，很快就可以找到实际vsync切换在这一块代码中： 12345678910111213141516171819202122232425262728// 首先注意到这个参数默认是false的，也就是说// 调用setDesiredActiveConfig方法后的第一帧是无法进入该分支的// 我们先跳过这段代码if (mSetActiveConfigPending) &#123; if (framePending) &#123; mEventQueue-&gt;invalidate(); return; &#125; // 从HWC收到了当前的fence，假设它成功地更新了配置，因此更新SF各个状态 mSetActiveConfigPending = false; // 2.2 更新SurfaceFlinger的状态，此时HWC是已经更新了帧率 ON_MAIN_THREAD(setActiveConfigInternal());&#125;// ......&#123; Mutex::Autolock _l(mStateLock); // 因为Layer更新刷新率, 重新来选择刷新率 // 这里涉及到Layer的VoteType、权限等记录，有兴趣自行研究 mScheduler-&gt;chooseRefreshRateForContent();&#125;// 2.1 更新当前帧率设置ON_MAIN_THREAD(performSetActiveConfig());// ...... 2.1 SurfaceFlinger.performSetActiveConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void SurfaceFlinger::performSetActiveConfig() &#123; ATRACE_CALL(); ALOGV(&quot;performSetActiveConfig&quot;); // 判断mDesiredActiveConfigChanged是否为true，获取变量mDesiredActiveConfig // 否则返回nullopt, 说明不需要帧率切换 const auto desiredActiveConfig = getDesiredActiveConfig(); if (!desiredActiveConfig) &#123; // 如果不存在需要切换的帧率配置(mDesiredActiveConfig)，直接返回 return; &#125; auto&amp; refreshRate = mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(desiredActiveConfig-&gt;configId); ALOGV(&quot;performSetActiveConfig changing active config to %d(%s)&quot;, refreshRate.getConfigId().value(), refreshRate.getName().c_str()); const auto display = getDefaultDisplayDeviceLocked(); if (!display || display-&gt;getActiveConfig() == desiredActiveConfig-&gt;configId) &#123; // 显示设备无效，或者已经处于请求的帧率模式下，标记帧率请求已经完成 desiredActiveConfigChangeDone(); return; &#125; // 所需的活动配置已设置，它与当前使用的配置不同，但是在处理刷新时，允许的配置可能已更改。 // 确保所需的配置仍然被允许 if (!isDisplayConfigAllowed(desiredActiveConfig-&gt;configId)) &#123; desiredActiveConfigChangeDone(); return; &#125; mUpcomingActiveConfig = *desiredActiveConfig; const auto displayId = display-&gt;getId(); LOG_ALWAYS_FATAL_IF(!displayId); ATRACE_INT(&quot;ActiveConfigFPS_HWC&quot;, refreshRate.getFps()); // TODO(b/142753666) use constrains hal::VsyncPeriodChangeConstraints constraints; constraints.desiredTimeNanos = systemTime(); constraints.seamlessRequired = false; // 2.1.1 通知HWC更新帧率 hal::VsyncPeriodChangeTimeline outTimeline; auto status = getHwComposer().setActiveConfigWithConstraints(*displayId, mUpcomingActiveConfig.configId.value(), constraints, &amp;outTimeline); if (status != NO_ERROR) &#123; // setActiveConfigWithConstraints may fail if a hotplug event is just about // to be sent. We just log the error in this case. ALOGW(&quot;setActiveConfigWithConstraints failed: %d&quot;, status); return; &#125; mScheduler-&gt;onNewVsyncPeriodChangeTimeline(outTimeline); // 如果需要，Scheduler将向HWC提交一个空帧，回到onMessageInvalidate中处理 // 也就是在下一帧会处理，距离调用setDesiredActiveConfig就是第二个帧了。 mSetActiveConfigPending = true;&#125; 这里做一些合法性判断，最重要的是告诉HWC去更新帧率了。 2.1.1 HWComposer.setActiveConfigWithConstraints123456789101112131415161718status_t HWComposer::setActiveConfigWithConstraints( DisplayId displayId, size_t configId, const hal::VsyncPeriodChangeConstraints&amp; constraints, hal::VsyncPeriodChangeTimeline* outTimeline) &#123; RETURN_IF_INVALID_DISPLAY(displayId, BAD_INDEX); auto&amp; displayData = mDisplayData[displayId]; if (displayData.configMap.count(configId) == 0) &#123; LOG_DISPLAY_ERROR(displayId, (&quot;Invalid config &quot; + std::to_string(configId)).c_str()); return BAD_INDEX; &#125; // hwcDisplay是HWC2::impl::Display，用来描述硬件显示设备的 auto error = displayData.hwcDisplay-&gt;setActiveConfigWithConstraints(displayData.configMap[configId], constraints, outTimeline); RETURN_IF_HWC_ERROR(error, displayId, UNKNOWN_ERROR); return NO_ERROR;&#125; 2.1.2 HWC2::impl::Display.setActiveConfigWithConstraints12345678910111213141516171819202122232425262728293031Error Display::setActiveConfigWithConstraints( const std::shared_ptr&lt;const HWC2::Display::Config&gt;&amp; config, const VsyncPeriodChangeConstraints&amp; constraints, VsyncPeriodChangeTimeline* outTimeline) &#123; ALOGV(&quot;[%&quot; PRIu64 &quot;] setActiveConfigWithConstraints&quot;, mId); if (config-&gt;getDisplayId() != mId) &#123; ALOGE(&quot;setActiveConfigWithConstraints received config %u for the wrong display %&quot; PRIu64 &quot; (expected %&quot; PRIu64 &quot;)&quot;, config-&gt;getId(), config-&gt;getDisplayId(), mId); return Error::BAD_CONFIG; &#125; // 是否支持Vsync Period切换 // 我们假设支持，其实不支持的话无非是换成调用setActiveConfig if (isVsyncPeriodSwitchSupported()) &#123; Hwc2::IComposerClient::VsyncPeriodChangeConstraints hwc2Constraints; hwc2Constraints.desiredTimeNanos = constraints.desiredTimeNanos; hwc2Constraints.seamlessRequired = constraints.seamlessRequired; Hwc2::VsyncPeriodChangeTimeline vsyncPeriodChangeTimeline = &#123;&#125;; // 2.2.2 通知HWComposer切换帧率 auto intError = mComposer.setActiveConfigWithConstraints(mId, config-&gt;getId(), hwc2Constraints, &amp;vsyncPeriodChangeTimeline); outTimeline-&gt;newVsyncAppliedTimeNanos = vsyncPeriodChangeTimeline.newVsyncAppliedTimeNanos; outTimeline-&gt;refreshRequired = vsyncPeriodChangeTimeline.refreshRequired; outTimeline-&gt;refreshTimeNanos = vsyncPeriodChangeTimeline.refreshTimeNanos; return static_cast&lt;Error&gt;(intError); &#125; // ......&#125; 2.1.3 ComposerHal.setActiveConfigWithConstraints1234567891011121314151617181920212223V2_4::Error Composer::setActiveConfigWithConstraints( Display display, Config config, const IComposerClient::VsyncPeriodChangeConstraints&amp; vsyncPeriodChangeConstraints, VsyncPeriodChangeTimeline* outTimeline) &#123; using Error = V2_4::Error; if (!mClient_2_4) &#123; return Error::UNSUPPORTED; &#125; Error error = kDefaultError_2_4; // 转到composer service处理. 也就是给硬件厂商实现 mClient_2_4-&gt;setActiveConfigWithConstraints(display, config, vsyncPeriodChangeConstraints, [&amp;](const auto&amp; tmpError, const auto&amp; tmpTimeline) &#123; error = tmpError; if (error != Error::NONE) &#123; return; &#125; *outTimeline = tmpTimeline; &#125;); return error;&#125; 到这里HWC切换帧率已经完成了。 2.2 SurfaceFlinger.setActiveConfigInternal12345678910111213141516171819202122232425262728293031323334353637383940void SurfaceFlinger::setActiveConfigInternal() &#123; ATRACE_CALL(); const auto display = getDefaultDisplayDeviceLocked(); if (!display) &#123; return; &#125; auto&amp; oldRefreshRate = mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(display-&gt;getActiveConfig()); std::lock_guard&lt;std::mutex&gt; lock(mActiveConfigLock); // 更新配置为最新的帧率信息 mRefreshRateConfigs-&gt;setCurrentConfigId(mUpcomingActiveConfig.configId); mRefreshRateStats-&gt;setConfigMode(mUpcomingActiveConfig.configId); // 将新的帧率保存在DisplayDevice中 display-&gt;setActiveConfig(mUpcomingActiveConfig.configId); auto&amp; refreshRate = mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(mUpcomingActiveConfig.configId); if (refreshRate.getVsyncPeriod() != oldRefreshRate.getVsyncPeriod()) &#123; // 前后帧率不一致，记录此次帧率切换，就是次数（refreshRateSwitches）+1 mTimeStats-&gt;incrementRefreshRateSwitches(); &#125; // 偏移量管理类也要更新FPS信息 mPhaseConfiguration-&gt;setRefreshRateFps(refreshRate.getFps()); // HWC更新帧率了，偏移量再次更新 mVSyncModulator-&gt;setPhaseOffsets(mPhaseConfiguration-&gt;getCurrentOffsets()); ATRACE_INT(&quot;ActiveConfigFPS&quot;, refreshRate.getFps()); // 这里的event就是:Scheduler::ConfigEvent::Changed if (mUpcomingActiveConfig.event != Scheduler::ConfigEvent::None) &#123; const nsecs_t vsyncPeriod = mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(mUpcomingActiveConfig.configId) .getVsyncPeriod(); // 更新AppEventThread中的Vsync间隔信息 mScheduler-&gt;onPrimaryDisplayConfigChanged(mAppConnectionHandle, display-&gt;getId()-&gt;value, mUpcomingActiveConfig.configId, vsyncPeriod); &#125;&#125; 到此帧率切换的过程，差不多就告一段落，当然这里面还有很对细节的部分。 比如硬件Vsync是怎么影响到VsyncRecator产生软件Vsync的，或者软件Vsync和硬件Vsync是怎么校准的。 不过我们先总结一下： SurfaceFlinger收到setDesiredDisplayConfigSpecs更新帧率配置后，根据传入的帧率配置以及当前Layer选择一个最佳帧率 将这个最佳帧率信息存储在mDesiredActiveConfig中，然后请求下一帧Vsync，顺便更新一下偏移量 下一帧Vsync到来后，首先根据Layer再次计算一下最佳帧率，然后通知HWC更新帧率，在等待下一帧 第二个Vsync到来后，实际此时硬件HWC的Vsync已经更新了，现在就是同步更新SurfaceFlinger中各个变量中的状态，然后通知给AppEventThread更新 所以一个完整的帧率切换至少包含2个Vsync周期，不过这两个Vsync周期并不相同哦","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Vsync","slug":"Android/Vsync","permalink":"https://swallowjoe.github.io/categories/Android/Vsync/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"}]},{"title":"App申请帧率(3)--SF计算最佳帧率","slug":"App申请帧率-3-SF计算最佳帧率","date":"2022-02-26T19:53:53.000Z","updated":"2022-02-26T20:00:06.780Z","comments":true,"path":"2022/02/27/App申请帧率-3-SF计算最佳帧率/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/","excerpt":"以下分析基于Android R. 简述上一章我们分析了App是如何通过更改一个小小的WindowManager的LayoutParam的属性，来影响Framework决策帧率变化的。 接来下我们详细看看SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。","text":"以下分析基于Android R. 简述上一章我们分析了App是如何通过更改一个小小的WindowManager的LayoutParam的属性，来影响Framework决策帧率变化的。 接来下我们详细看看SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。 一. SurfaceFlinger接受帧率变化接上一章，从 SurfaceFlinger::setAllowedDisplayConfigs 开始. 但是Android R上入口函数些许变化： 由SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes) &#x3D;》SurfaceControl.setDesiredDisplayConfigSpecs(displayToken, configSpecs); 这里的configSpecs是DesiredDisplayConfigSpecs类型 1.1 SurfaceControl.setDesiredDisplayConfigSpecs12345678public static boolean setDesiredDisplayConfigSpecs(IBinder displayToken, SurfaceControl.DesiredDisplayConfigSpecs desiredDisplayConfigSpecs) &#123; if (displayToken == null) &#123; throw new IllegalArgumentException(&quot;displayToken must not be null&quot;); &#125; return nativeSetDesiredDisplayConfigSpecs(displayToken, desiredDisplayConfigSpecs);&#125; 1.1.1 android_view_SurfaceControl.nativeSetDesiredDisplayConfigSpecs123456789101112131415161718192021222324252627static jboolean nativeSetDesiredDisplayConfigSpecs(JNIEnv* env, jclass clazz, jobject tokenObj, jobject desiredDisplayConfigSpecs) &#123; sp&lt;IBinder&gt; token(ibinderForJavaObject(env, tokenObj)); if (token == nullptr) return JNI_FALSE; jint defaultConfig = env-&gt;GetIntField(desiredDisplayConfigSpecs, gDesiredDisplayConfigSpecsClassInfo.defaultConfig); jfloat primaryRefreshRateMin = env-&gt;GetFloatField(desiredDisplayConfigSpecs, gDesiredDisplayConfigSpecsClassInfo.primaryRefreshRateMin); jfloat primaryRefreshRateMax = env-&gt;GetFloatField(desiredDisplayConfigSpecs, gDesiredDisplayConfigSpecsClassInfo.primaryRefreshRateMax); jfloat appRequestRefreshRateMin = env-&gt;GetFloatField(desiredDisplayConfigSpecs, gDesiredDisplayConfigSpecsClassInfo.appRequestRefreshRateMin); jfloat appRequestRefreshRateMax = env-&gt;GetFloatField(desiredDisplayConfigSpecs, gDesiredDisplayConfigSpecsClassInfo.appRequestRefreshRateMax); size_t result = SurfaceComposerClient::setDesiredDisplayConfigSpecs(token, defaultConfig, primaryRefreshRateMin, primaryRefreshRateMax, appRequestRefreshRateMin, appRequestRefreshRateMax); return result == NO_ERROR ? JNI_TRUE : JNI_FALSE;&#125; 1.1.2 SurfaceComposerClient.setDesiredDisplayConfigSpecs123456789101112status_t SurfaceComposerClient::setDesiredDisplayConfigSpecs(const sp&lt;IBinder&gt;&amp; displayToken, int32_t defaultConfig, float primaryRefreshRateMin, float primaryRefreshRateMax, float appRequestRefreshRateMin, float appRequestRefreshRateMax) &#123; // 转到SurfaceFlinger return ComposerService::getComposerService() -&gt;setDesiredDisplayConfigSpecs(displayToken, defaultConfig, primaryRefreshRateMin, primaryRefreshRateMax, appRequestRefreshRateMin, appRequestRefreshRateMax);&#125; 1.2 SurfaceFlinger.setDesiredDisplayConfigSpecs123456789101112131415161718192021222324252627282930313233343536status_t SurfaceFlinger::setDesiredDisplayConfigSpecs(const sp&lt;IBinder&gt;&amp; displayToken, int32_t defaultConfig, float primaryRefreshRateMin, float primaryRefreshRateMax, float appRequestRefreshRateMin, float appRequestRefreshRateMax) &#123; ATRACE_CALL(); if (!displayToken) &#123; return BAD_VALUE; &#125; // Lambda表达式 auto future = schedule([=]() -&gt; status_t &#123; const auto display = getDisplayDeviceLocked(displayToken); if (!display) &#123; ALOGE(&quot;Attempt to set desired display configs for invalid display token %p&quot;, displayToken.get()); return NAME_NOT_FOUND; &#125; else if (display-&gt;isVirtual()) &#123; ALOGW(&quot;Attempt to set desired display configs for virtual display&quot;); return INVALID_OPERATION; &#125; else &#123; using Policy = scheduler::RefreshRateConfigs::Policy; // 初始化policy const Policy policy&#123;HwcConfigIndexType(defaultConfig), &#123;primaryRefreshRateMin, primaryRefreshRateMax&#125;, &#123;appRequestRefreshRateMin, appRequestRefreshRateMax&#125;&#125;; constexpr bool kOverridePolicy = false; return setDesiredDisplayConfigSpecsInternal(display, policy, kOverridePolicy); &#125; &#125;); return future.get();&#125; 1.2.1 SurfaceFlinger.schedule1234567891011121314151617181920212223242526template &lt;typename F, typename T&gt;inline std::future&lt;T&gt; SurfaceFlinger::schedule(F&amp;&amp; f) &#123; auto [task, future] = makeTask(std::move(f)); mEventQueue-&gt;postMessage(std::move(task)); return std::move(future);&#125;// MessageQueue.htemplate &lt;typename F&gt;inline auto makeTask(F&amp;&amp; f) &#123; sp&lt;Task&lt;F&gt;&gt; task = new Task&lt;F&gt;(std::move(f)); return std::make_pair(task, task-&gt;mTask.get_future());&#125;// MessageQueue.htemplate &lt;typename F&gt;class Task : public MessageHandler &#123; template &lt;typename G&gt; friend auto makeTask(G&amp;&amp;); explicit Task(F&amp;&amp; f) : mTask(std::move(f)) &#123;&#125; void handleMessage(const Message&amp;) override &#123; mTask(); &#125; using T = std::invoke_result_t&lt;F&gt;; std::packaged_task&lt;T()&gt; mTask;&#125;; 1.3 SurfaceFlinger.setDesiredDisplayConfigSpecsInternal12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758status_t SurfaceFlinger::setDesiredDisplayConfigSpecsInternal( const sp&lt;DisplayDevice&gt;&amp; display, const std::optional&lt;scheduler::RefreshRateConfigs::Policy&gt;&amp; policy, bool overridePolicy) &#123; Mutex::Autolock lock(mStateLock); ...... // overridePolicy 一般都是false status_t setPolicyResult = overridePolicy ? mRefreshRateConfigs-&gt;setOverridePolicy(policy) // 1.3.1 更改当前帧率策略 : mRefreshRateConfigs-&gt;setDisplayManagerPolicy(*policy); if (setPolicyResult &lt; 0) &#123; return BAD_VALUE; &#125; if (setPolicyResult == scheduler::RefreshRateConfigs::CURRENT_POLICY_UNCHANGED) &#123; return NO_ERROR; &#125; scheduler::RefreshRateConfigs::Policy currentPolicy = mRefreshRateConfigs-&gt;getCurrentPolicy(); ALOGV(&quot;Setting desired display config specs: defaultConfig: %d primaryRange: [%.0f %.0f]&quot; &quot; expandedRange: [%.0f %.0f]&quot;, currentPolicy.defaultConfig.value(), currentPolicy.primaryRange.min, currentPolicy.primaryRange.max, currentPolicy.appRequestRange.min, currentPolicy.appRequestRange.max); // TODO(b/140204874): Leave the event in until we do proper testing with all apps that might // be depending in this callback. const nsecs_t vsyncPeriod = mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(display-&gt;getActiveConfig()) .getVsyncPeriod(); mScheduler-&gt;onPrimaryDisplayConfigChanged(mAppConnectionHandle, display-&gt;getId()-&gt;value, display-&gt;getActiveConfig(), vsyncPeriod); toggleKernelIdleTimer(); // 1.3.3 获取configId auto configId = mScheduler-&gt;getPreferredConfigId(); // configId是std::optional&lt;HwcConfigIndexType&gt;类型的，这里判断是否存在值，一般存在 // 根据HwcConfigIndexType获取实际的 RefreshRate 参数 auto&amp; preferredRefreshRate = configId ? mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(*configId) // NOTE: Choose the default config ID, if Scheduler doesn&#x27;t have one in mind. : mRefreshRateConfigs-&gt;getRefreshRateFromConfigId(currentPolicy.defaultConfig); ALOGV(&quot;trying to switch to Scheduler preferred config %d (%s)&quot;, preferredRefreshRate.getConfigId().value(), preferredRefreshRate.getName().c_str()); // 判断RefreshRate是否合法 if (isDisplayConfigAllowed(preferredRefreshRate.getConfigId())) &#123; ALOGV(&quot;switching to Scheduler preferred config %d&quot;, preferredRefreshRate.getConfigId().value()); // 1.4 设置帧率 setDesiredActiveConfig( &#123;preferredRefreshRate.getConfigId(), Scheduler::ConfigEvent::Changed&#125;); &#125; else &#123; LOG_ALWAYS_FATAL(&quot;Desired config not allowed: %d&quot;, preferredRefreshRate.getConfigId().value()); &#125; return NO_ERROR;&#125; 1.3.1 RefreshRateConfigs.setDisplayManagerPolicy12345678910111213141516status_t RefreshRateConfigs::setDisplayManagerPolicy(const Policy&amp; policy) &#123; std::lock_guard lock(mLock); if (!isPolicyValid(policy)) &#123; return BAD_VALUE; &#125; // 获取当前策略，如果mOverridePolicy是false，也就是没有覆写 // 就是用的mDisplayManagerPolicy Policy previousPolicy = *getCurrentPolicyLocked(); mDisplayManagerPolicy = policy; if (*getCurrentPolicyLocked() == previousPolicy) &#123; return CURRENT_POLICY_UNCHANGED; &#125; // 1.3.2 根据策略构建最终刷新率 constructAvailableRefreshRates(); return NO_ERROR;&#125; 1.3.2 RefreshRateConfigs.constructAvailableRefreshRates123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475void RefreshRateConfigs::constructAvailableRefreshRates() &#123; // Filter configs based on current policy and sort based on vsync period const Policy* policy = getCurrentPolicyLocked(); const auto&amp; defaultConfig = mRefreshRates.at(policy-&gt;defaultConfig)-&gt;hwcConfig; ALOGV(&quot;constructAvailableRefreshRates: default %d group %d primaryRange=[%.2f %.2f]&quot; &quot; appRequestRange=[%.2f %.2f]&quot;, policy-&gt;defaultConfig.value(), defaultConfig-&gt;getConfigGroup(), policy-&gt;primaryRange.min, policy-&gt;primaryRange.max, policy-&gt;appRequestRange.min, policy-&gt;appRequestRange.max); // lambuda A auto filterRefreshRates = [&amp;](float min, float max, const char* listName, std::vector&lt;const RefreshRate*&gt;* outRefreshRates) &#123; // lambuda B getSortedRefreshRateList( [&amp;](const RefreshRate&amp; refreshRate) REQUIRES(mLock) &#123; const auto&amp; hwcConfig = refreshRate.hwcConfig; return hwcConfig-&gt;getHeight() == defaultConfig-&gt;getHeight() &amp;&amp; hwcConfig-&gt;getWidth() == defaultConfig-&gt;getWidth() &amp;&amp; hwcConfig-&gt;getDpiX() == defaultConfig-&gt;getDpiX() &amp;&amp; hwcConfig-&gt;getDpiY() == defaultConfig-&gt;getDpiY() &amp;&amp; (policy-&gt;allowGroupSwitching || hwcConfig-&gt;getConfigGroup() == defaultConfig-&gt;getConfigGroup()) &amp;&amp; refreshRate.inPolicy(min, max); &#125;, outRefreshRates); LOG_ALWAYS_FATAL_IF(outRefreshRates-&gt;empty(), &quot;No matching configs for %s range: min=%.0f max=%.0f&quot;, listName, min, max); auto stringifyRefreshRates = [&amp;]() -&gt; std::string &#123; std::string str; for (auto refreshRate : *outRefreshRates) &#123; base::StringAppendF(&amp;str, &quot;%s &quot;, refreshRate-&gt;name.c_str()); &#125; return str; &#125;; ALOGV(&quot;%s refresh rates: %s&quot;, listName, stringifyRefreshRates().c_str()); &#125;; filterRefreshRates(policy-&gt;primaryRange.min, policy-&gt;primaryRange.max, &quot;primary&quot;, &amp;mPrimaryRefreshRates); filterRefreshRates(policy-&gt;appRequestRange.min, policy-&gt;appRequestRange.max, &quot;app request&quot;, &amp;mAppRequestRefreshRates);&#125;void RefreshRateConfigs::getSortedRefreshRateList( const std::function&lt;bool(const RefreshRate&amp;)&gt;&amp; shouldAddRefreshRate, std::vector&lt;const RefreshRate*&gt;* outRefreshRates) &#123; outRefreshRates-&gt;clear(); outRefreshRates-&gt;reserve(mRefreshRates.size()); // 遍历所有可能的RefreshRate for (const auto&amp; [type, refreshRate] : mRefreshRates) &#123; // 调用上面的lambuda B方法, 其实就是条件判断 if (shouldAddRefreshRate(*refreshRate)) &#123; ALOGV(&quot;getSortedRefreshRateList: config %d added to list policy&quot;, refreshRate-&gt;configId.value()); outRefreshRates-&gt;push_back(refreshRate.get()); &#125; &#125; // 按照帧率大小排序，VsyncPeriod越大，Fps越小。 // 这里就是按照Fps升序排序了 std::sort(outRefreshRates-&gt;begin(), outRefreshRates-&gt;end(), [](const auto refreshRate1, const auto refreshRate2) &#123; if (refreshRate1-&gt;hwcConfig-&gt;getVsyncPeriod() != refreshRate2-&gt;hwcConfig-&gt;getVsyncPeriod()) &#123; return refreshRate1-&gt;hwcConfig-&gt;getVsyncPeriod() &gt; refreshRate2-&gt;hwcConfig-&gt;getVsyncPeriod(); &#125; else &#123; return refreshRate1-&gt;hwcConfig-&gt;getConfigGroup() &gt; refreshRate2-&gt;hwcConfig-&gt;getConfigGroup(); &#125; &#125;);&#125; 这里吐槽一下，写的很丑。直接说明，在 mRefreshRates中寻找符合要求的configId(modeId)放入对应的集合中。 这里说的符合要求是指： 宽高与所设置的Policy中的defaultConfig的宽高一致 其帧率在所设置的Policy的最小和最大帧率之中 最终将结果保存在变量：mPrimaryRefreshRates以及mAppRequestRefreshRates中。 1.3.3 Scheduler.getPreferredConfigId1234567891011std::optional&lt;HwcConfigIndexType&gt; Scheduler::getPreferredConfigId() &#123; std::lock_guard&lt;std::mutex&gt; lock(mFeatureStateLock); // Make sure that the default config ID is first updated, before returned. // mFeatures 是一个结构体 if (mFeatures.configId.has_value()) &#123; // configId是一个 std:optional的变量 // 计算当前刷新率的configId mFeatures.configId = calculateRefreshRateConfigIndexType(); &#125; return mFeatures.configId;&#125; 这个地方原以为mFeatures.configId一般是存在value的，其实并不是。 1.3.4 Scheduler.calculateRefreshRateConfigIndexType123456789101112131415// consideredSignals 的默认参数是nullptr的HwcConfigIndexType Scheduler::calculateRefreshRateConfigIndexType( scheduler::RefreshRateConfigs::GlobalSignals* consideredSignals) &#123; ATRACE_CALL(); // ...... const bool touchActive = mTouchTimer &amp;&amp; mFeatures.touch == TouchState::Active; const bool idle = mIdleTimer &amp;&amp; mFeatures.idleTimer == TimerState::Expired; // ...... // 1.3.5 获取最佳ConfigId, 根据framework传来的帧率范围, 以及当下Layer投票产生 return mRefreshRateConfigs .getBestRefreshRate(mFeatures.contentRequirements, &#123;.touch = touchActive, .idle = idle&#125;, consideredSignals) .getConfigId();&#125; 1.3.5 RefreshRateConfigs.getBestRefreshRate123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251const RefreshRate&amp; RefreshRateConfigs::getBestRefreshRate( const std::vector&lt;LayerRequirement&gt;&amp; layers, const GlobalSignals&amp; globalSignals, GlobalSignals* outSignalsConsidered) const &#123; ATRACE_CALL(); ALOGV(&quot;getRefreshRateForContent %zu layers&quot;, layers.size()); // 注意传入的outSignalsConsidered是nullptr的 if (outSignalsConsidered) *outSignalsConsidered = &#123;&#125;; const auto setTouchConsidered = [&amp;] &#123; if (outSignalsConsidered) &#123; outSignalsConsidered-&gt;touch = true; &#125; &#125;; const auto setIdleConsidered = [&amp;] &#123; if (outSignalsConsidered) &#123; outSignalsConsidered-&gt;idle = true; &#125; &#125;; std::lock_guard lock(mLock); // 开始投票 // 首先计算所有不同LayerVoteType的数量 // 这里的Type稍后介绍 int noVoteLayers = 0; int minVoteLayers = 0; int maxVoteLayers = 0; int explicitDefaultVoteLayers = 0; int explicitExactOrMultipleVoteLayers = 0; // 记录最大的权重 float maxExplicitWeight = 0; for (const auto&amp; layer : layers) &#123; if (layer.vote == LayerVoteType::NoVote) &#123; noVoteLayers++; &#125; else if (layer.vote == LayerVoteType::Min) &#123; minVoteLayers++; &#125; else if (layer.vote == LayerVoteType::Max) &#123; maxVoteLayers++; &#125; else if (layer.vote == LayerVoteType::ExplicitDefault) &#123; explicitDefaultVoteLayers++; maxExplicitWeight = std::max(maxExplicitWeight, layer.weight); &#125; else if (layer.vote == LayerVoteType::ExplicitExactOrMultiple) &#123; explicitExactOrMultipleVoteLayers++; maxExplicitWeight = std::max(maxExplicitWeight, layer.weight); &#125; &#125; const bool hasExplicitVoteLayers = explicitDefaultVoteLayers &gt; 0 || explicitExactOrMultipleVoteLayers &gt; 0; // $1. 如果没有显式Layer, 考虑触摸事件, 如果存在触摸事件, 选择最大帧率 if (globalSignals.touch &amp;&amp; !hasExplicitVoteLayers) &#123; ALOGV(&quot;TouchBoost - choose %s&quot;, getMaxRefreshRateByPolicyLocked().getName().c_str()); setTouchConsidered(); return getMaxRefreshRateByPolicyLocked(); &#125; // 如果刷新率范围由单个刷新率组成，那么只有当层显式请求不同的刷新率时，才能选择超出范围 const Policy* policy = getCurrentPolicyLocked(); const bool primaryRangeIsSingleRate = policy-&gt;primaryRange.min == policy-&gt;primaryRange.max; // $2. 没有touch事件，屏幕处于idle状态, 刷新率存在一定范围或者不存在显示请求刷新率的Layer时 // 选择最小帧率 if (!globalSignals.touch &amp;&amp; globalSignals.idle &amp;&amp; !(primaryRangeIsSingleRate &amp;&amp; hasExplicitVoteLayers)) &#123; ALOGV(&quot;Idle - choose %s&quot;, getMinRefreshRateByPolicyLocked().getName().c_str()); setIdleConsidered(); return getMinRefreshRateByPolicyLocked(); &#125; // $3. 没有Layer或者所有Layer都没有投票(NoVote)时, 选择最大帧率？？？ if (layers.empty() || noVoteLayers == layers.size()) &#123; return getMaxRefreshRateByPolicyLocked(); &#125; // $4. 存在Layer且所有Layer要么不投票，要么请求最小帧率时，选择最小帧率 if (noVoteLayers + minVoteLayers == layers.size()) &#123; ALOGV(&quot;all layers Min - choose %s&quot;, getMinRefreshRateByPolicyLocked().getName().c_str()); return getMinRefreshRateByPolicyLocked(); &#125; // $5. 计算找到最佳刷新率 std::vector&lt;std::pair&lt;const RefreshRate*, float&gt;&gt; scores; scores.reserve(mAppRequestRefreshRates.size()); for (const auto refreshRate : mAppRequestRefreshRates) &#123; scores.emplace_back(refreshRate, 0.0f); &#125; // 遍历所有Layer for (const auto&amp; layer : layers) &#123; ALOGV(&quot;Calculating score for %s (%s, weight %.2f)&quot;, layer.name.c_str(), layerVoteTypeString(layer.vote).c_str(), layer.weight); // 忽略不投票或者投票选择最小帧率的Layer if (layer.vote == LayerVoteType::NoVote || layer.vote == LayerVoteType::Min) &#123; continue; &#125; auto weight = layer.weight; // 注意这里还有一层循环，分别计算每个AppRequestRefreshRate的得分 for (auto i = 0u; i &lt; scores.size(); i++) &#123; bool inPrimaryRange = scores[i].first-&gt;inPolicy(policy-&gt;primaryRange.min, policy-&gt;primaryRange.max); if ((primaryRangeIsSingleRate || !inPrimaryRange) &amp;&amp; !(layer.focused &amp;&amp; (layer.vote == LayerVoteType::ExplicitDefault || layer.vote == LayerVoteType::ExplicitExactOrMultiple))) &#123; // $$5.1 只有具有显式帧速率设置的聚焦层才允许对主范围之外的刷新率进行评分 // 换句话说，只有ExplicitDefault或者ExplicitExactOrMultiple类型的Layer，且该Layer是有焦点的 // 才允许投票超出刷新率请求范围的帧率 continue; &#125; // $$5.2 如果图层想要最大值，给更高的刷新率评分 if (layer.vote == LayerVoteType::Max) &#123; // 用当前layer(app)请求的帧率除以最后一个layer(app)请求的帧率 // 注意到mAppRequestRefreshRates中fps是按照升序排序的，最后一个是最大的 // 所以这里就是用 当前请求的帧率除以最大的请求帧率得到一个 (0, 1] 的比值 const auto ratio = scores[i].first-&gt;fps / scores.back().first-&gt;fps; // 使用比值的平方得到一个较低的分数 ==&gt; 为啥？ const auto layerScore = ratio * ratio; ALOGV(&quot;%s (Max, weight %.2f) gives %s score of %.2f&quot;, layer.name.c_str(), weight, scores[i].first-&gt;name.c_str(), layerScore); // 将比值的平方乘上权重系数，作为该layer的分数 scores[i].second += weight * layerScore; continue; &#125; // 屏幕刷新率 const auto displayPeriod = scores[i].first-&gt;hwcConfig-&gt;getVsyncPeriod(); // Layer所需的刷新率 const auto layerPeriod = round&lt;nsecs_t&gt;(1e9f / layer.desiredRefreshRate); // $$5.3 如果是ExplicitDefault类型的Layer if (layer.vote == LayerVoteType::ExplicitDefault) &#123; const auto layerScore = [&amp;]() &#123; // 找到Layer将渲染的实际速率，假设layerPeriod是渲染帧的最短时间 auto actualLayerPeriod = displayPeriod; int multiplier = 1; // 刷新时长依次翻倍，直到满足该Layer刷新的最低时长，也就是fps大小每次折半 // MARGIN_FOR_PERIOD_CALCULATION = 800us while (layerPeriod &gt; actualLayerPeriod + MARGIN_FOR_PERIOD_CALCULATION) &#123; multiplier++; actualLayerPeriod = displayPeriod * multiplier; &#125; // 此时layer分数为 layer所需的时长除以满足刷新要求的最长时长 return std::min(1.0f, static_cast&lt;float&gt;(layerPeriod) / static_cast&lt;float&gt;(actualLayerPeriod)); &#125;(); ALOGV(&quot;%s (ExplicitDefault, weight %.2f) %.2fHz gives %s score of %.2f&quot;, layer.name.c_str(), weight, 1e9f / layerPeriod, scores[i].first-&gt;name.c_str(), layerScore); // layer分数乘上权重作为该layer的最终分数 scores[i].second += weight * layerScore; continue; &#125; // $$5.4 如果是ExplicitExactOrMultiple或者Heuristic类型的Layer if (layer.vote == LayerVoteType::ExplicitExactOrMultiple || layer.vote == LayerVoteType::Heuristic) &#123; const auto layerScore = [&amp;] &#123; // 计算我们需要多少个显示vSync来显示这个层的一个帧 // 其实就是计算 layerPeriod/displayPeriod 得到商和余数 const auto [displayFramesQuot, displayFramesRem] = getDisplayFrames(layerPeriod, displayPeriod); static constexpr size_t MAX_FRAMES_TO_FIT = 10; // Stop calculating when score &lt; 0.1 if (displayFramesRem == 0) &#123; // 整除的时候，直接返回1? // 说明layer请求的fps是比display的fps小，得分直接拉满 return 1.0f; &#125; if (displayFramesQuot == 0) &#123; // 当layer请求的fps比display中的fps要大的时候 // 返回layer period除以display period的商的十一分之一 // 比如 layer = 120Hz， display = 90Hz // 8.33333 1.0 // return = ----------- * ---- // 11.1111 11 // 为啥怎么算呢，这里分数的极限值也就是1/11，最大限度排除这个layer请求的帧率？ return (static_cast&lt;float&gt;(layerPeriod) / static_cast&lt;float&gt;(displayPeriod)) * (1.0f / (MAX_FRAMES_TO_FIT + 1)); &#125; // layer所需的刷新率低于的显示刷新率，但又不是整数倍关系，检查它是否符合节奏 // 计算差值: 用 Pl 表述 layer period，Pd表示display period // diff = | (Pl mod Pd) * 2 - Pd | // 这里的意思是在计算多少帧内，display 刷新可以匹配 layer请求的刷新 auto diff = std::abs(displayFramesRem - (displayPeriod - displayFramesRem)); int iter = 2; while (diff &gt; MARGIN_FOR_PERIOD_CALCULATION &amp;&amp; iter &lt; MAX_FRAMES_TO_FIT) &#123; // 循环计算，总结公式： // 1. diff0 = 2 * (Pl mod Pd) - Pd, Pl &gt; Pd 且 K ∈ &#123;1,2,3,...,9&#125; // 2. 当diff0 &gt; 0 时, diff = (Pl mod Pd) * 2^k - Pd * (2^k-1) // 3. 当diff0 &lt; 0 时, diff = Pd - 2^k * (Pl mode Pd) diff = diff - (displayPeriod - diff); iter++; &#125; // 得分取值范围是[0.1, 0.5] return 1.0f / iter; &#125;(); ALOGV(&quot;%s (%s, weight %.2f) %.2fHz gives %s score of %.2f&quot;, layer.name.c_str(), layerVoteTypeString(layer.vote).c_str(), weight, 1e9f / layerPeriod, scores[i].first-&gt;name.c_str(), layerScore); // 照例，乘上权重作为分数 scores[i].second += weight * layerScore; continue; &#125; &#125; &#125; // $6 如果存在请求最大帧率的layer就反向遍历 // 找到得分最大的帧率 const RefreshRate* bestRefreshRate = maxVoteLayers &gt; 0 ? getBestRefreshRate(scores.rbegin(), scores.rend()) : getBestRefreshRate(scores.begin(), scores.end()); // 显示主刷新率没有范围，只有定值时 if (primaryRangeIsSingleRate) &#123; // 如果没有layer参与评分，从显示主刷新范围选取最大值 // 否则返回计算得出的最佳刷新率 if (std::all_of(scores.begin(), scores.end(), [](std::pair&lt;const RefreshRate*, float&gt; p) &#123; return p.second == 0; &#125;)) &#123; ALOGV(&quot;layers not scored - choose %s&quot;, getMaxRefreshRateByPolicyLocked().getName().c_str()); return getMaxRefreshRateByPolicyLocked(); &#125; else &#123; return *bestRefreshRate; &#125; &#125; // 如果没有explicitDefaultLayers，请考虑touch事件。 // ExplicitDefault主要是交互式的（与ExplicitExactOrMultiple相反），因此如果那些Layer发布了一个显式投票， // 那么存在touch事件，就不应该更改它。只有在触摸增强会增加刷新率超过正常选择时才应用。 const RefreshRate&amp; touchRefreshRate = getMaxRefreshRateByPolicyLocked(); // 存在touch事件，不存在ExplicitDefault的Layer且显示主范围刷新率最大值大于计算的刷新率时 // 采用最大刷新率 if (globalSignals.touch &amp;&amp; explicitDefaultVoteLayers == 0 &amp;&amp; bestRefreshRate-&gt;fps &lt; touchRefreshRate.fps) &#123; setTouchConsidered(); ALOGV(&quot;TouchBoost - choose %s&quot;, touchRefreshRate.getName().c_str()); return touchRefreshRate; &#125; return *bestRefreshRate;&#125; Emmmm…. 这一言难尽的代码。 总结一下，在上层计算传入两个刷新率范围后，这里主要是根据Layer投票以及一系列判断得到最终所需的刷新率。 说明一下几个概念： 显示主范围刷新率: DisplayModeDirector中投票算出的包含所有请求帧率的最小范围 layerPeriod: 根据当前layer.desiredRefreshRate计算出一帧的时长 displayPeriod: 当前AppReqeustRefereshRate中HwcConfig计算的一帧时长 整个投票过程简述: 首先计算所有不同LayerVoteType的数量 如果没有显式Layer,即ExplicitDefault和ExplicitExactOrMultiple类型,且存在触摸事件, 直接选择主范围刷新率最大帧率 没有touch事件且屏幕处于idle状态, 刷新率存在一定范围或者不存在显示请求刷新率的Layer时, 选择主范围刷新率最小帧率 没有Layer或者所有Layer都没有投票(NoVote)时, 选择最大帧率 存在Layer且所有Layer要么不投票，要么请求最小帧率时，选择最小帧率 当上述条件都不满足时，遍历所有Layer计算每个AppRequestRefreshRate的得分，找到最佳刷新率, 注意遍历时, 忽略不投票或者投票选择最小帧率的Layer 遍历所有AppRequestRefreshRate 只有ExplicitDefault或者ExplicitExactOrMultiple类型的Layer，且该Layer是有焦点的才允许投票超出刷新率请求范围的帧率，否则忽略该Layer 如果Layer是Max类型 用当前layer(app)请求的帧率除以最后一个layer(app)请求的帧率,得到的比值的平方乘以权重，计入当前AppRequestRefreshRate的分数 如果是ExplicitDefault类型的Layer 找到Layer将渲染的实际速率，首先假设layer.desiredRefreshRate计算的Period是渲染帧的最短时间 将该AppReqeustRefereshRate中的Display Period刷新时长依次翻倍，直到满足该Layer刷新的最低时长，也就是fps大小每次折半 此时layer分数为 layer所需的时长除以满足刷新要求的最长时长在乘以权重计入当前AppRequestRefreshRate的分数 如果是ExplicitExactOrMultiple或者Heuristic类型的Layer 首先计算需要多少个显示vSync来显示这个层的一个帧，即计算 layerPeriod&#x2F;displayPeriod 得到商 quot 和余数 rem 如果是整数倍关系，当前AppRequestRefreshRate的分数直接加上该Layer的权重 当layer请求的fps比AppReqeustRefereshRate中的实际display的fps要大的时候，得分是layer period除以display period的商的十一分之一乘以layer的权重 layer所需的刷新率低于的显示刷新率，但又不是整数倍关系时，用 Pl 表述 layer period，Pd表示display period diff0 &#x3D; 2 * (Pl mod Pd) - Pd, Pl &gt; Pd 且 K ∈ {1,2,3,…,9} 当diff0 &gt; 0 时, diff &#x3D; (Pl mod Pd) * 2^k - Pd * (2^k-1) 当diff0 &lt; 0 时, diff &#x3D; Pd - 2^k * (Pl mode Pd) 当diff小于800时(差值小于800us), 或者k&gt;9结束, 得分是当前Layer的权重乘以1&#x2F;(2K) 如果存在请求最大帧率的layer就反向遍历,找到得分最大的帧率 bestRefreshRate 如果显示主刷新率没有范围，比如最小值和最大值都是120Hz时 如果没有layer参与评分，从显示主刷新范围选取最大值 否则返回计算得出的最佳刷新率 如果存在touch事件, 不存在ExplicitDefault的Layer且显示主范围刷新率最大值大于计算的刷新率时, 采用最大刷新率 以上条件均不满足时，返回计算的bestRefreshRate 好了，本次分析到此为止，接下来就是继续看SurfaceFlinger如何通知HWC硬件切换帧率了。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Vsync","slug":"Android/Vsync","permalink":"https://swallowjoe.github.io/categories/Android/Vsync/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"}]},{"title":"App申请帧率(2)--Framework选择最近帧率范围","slug":"App申请帧率-2-Framework选择最近帧率范围","date":"2022-02-26T19:53:41.000Z","updated":"2022-02-26T19:58:50.653Z","comments":true,"path":"2022/02/27/App申请帧率-2-Framework选择最近帧率范围/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/","excerpt":"以下分析基于Android Q.","text":"以下分析基于Android Q. 一. preferredDisplayModeId改变上篇文章讲到，只要将window的Param设置就可以更改屏幕分辨率： 1wmParams!!.preferredDisplayModeId = highestMode.modeId 代码是和实现的呢, 在App接受vsync信号后，会回调Choreographer.CALLBACK_TRAVERSAL，也就会调用到ViewRootImpl.doTraversal. 调用栈如下: Choreographer.onVsync() Choreographer.doFrame() &#x2F;&#x2F; doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); ViewRootImpl.doTraversal() ViewRootImpl.performTraversals() ViewRootImpl.relayoutWindow() &#x2F;&#x2F; 这里将当前Window的Attr传入WindowManagerService IWindowSession.relayout() &#x2F;&#x2F; 通过binder调用 Session.relayout WindowManagerService.relayoutWindow() &#x2F;&#x2F; 进入SystenServer进程 WindowSurfacePlacer.performSurfacePlacement() WindowSurfacePlacer.performSurfacePlacementLoop() RootWindowContainer.performSurfacePlacement() RootWindowContainer.performSurfacePlacementNoTrace() RootWindowContainer.applySurfaceChangesTransaction() DisplayContent.applySurfaceChangesTransaction() DisplayContent.mApplySurfaceChangesTransaction &#x2F;&#x2F; 对所有window遍历执行，如果有属性变化响应变化 DisplayManagerService.setDisplayProperties &#x2F;&#x2F; 计算并保存合适的modeId DisplayManagerInternal.performTraversal(mDisplayTransaction) &#x2F;&#x2F; 应用modeId变化 1.1 RootWindowContainer.applySurfaceChangesTransaction1234567891011121314private void applySurfaceChangesTransaction(boolean recoveringMemory) &#123; ...... final int count = mChildren.size(); for (int j = 0; j &lt; count; ++j) &#123; final DisplayContent dc = mChildren.get(j); // 1.2 对每个display都计算变化 dc.applySurfaceChangesTransaction(recoveringMemory); &#125; // 3.1 通知SurfaceFlinger改变ModeId mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction); SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction);&#125; 1.2 DisplayContent.applySurfaceChangesTransaction()1234567891011121314151617181920void applySurfaceChangesTransaction(boolean recoveringMemory) &#123; ...... Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, &quot;applyWindowSurfaceChanges&quot;); try &#123; // 1.3 遍历所有window, 按照Z轴从上到下 forAllWindows(mApplySurfaceChangesTransaction, true /* traverseTopToBottom */); &#125; finally &#123; Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; prepareSurfaces(); mLastHasContent = mTmpApplySurfaceChangesTransactionState.displayHasContent; // 1.4 应用需要Display属性变化 mWmService.mDisplayManagerInternal.setDisplayProperties(mDisplayId, mLastHasContent, mTmpApplySurfaceChangesTransactionState.preferredRefreshRate, mTmpApplySurfaceChangesTransactionState.preferredModeId, true /* inTraversal, must call performTraversalInTrans... below */); ......&#125; 1.3 DisplayContent.mApplySurfaceChangesTransaction12345678910111213141516private final Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123; ...... if (!mTmpApplySurfaceChangesTransactionState.obscured) &#123; ...... // 获取wmParams.preferredDisplayModeId中的modeId final int preferredModeId = getDisplayPolicy().getRefreshRatePolicy() .getPreferredModeId(w); // 注意这里是按照Z轴从上到下遍历Window，所以只会取第一个可见的有Surface的且被设置的window的modeId if (mTmpApplySurfaceChangesTransactionState.preferredModeId == 0 &amp;&amp; preferredModeId != 0) &#123; // 标记preferredModeId mTmpApplySurfaceChangesTransactionState.preferredModeId = preferredModeId; &#125; &#125; ......&#125; 1.4 DisplayManagerService.setDisplayProperties12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void setDisplayProperties(int displayId, boolean hasContent, float requestedRefreshRate, int requestedMode, boolean inTraversal) &#123; setDisplayPropertiesInternal(displayId, hasContent, requestedRefreshRate, requestedMode, inTraversal);&#125;private void setDisplayPropertiesInternal(int displayId, boolean hasContent, float requestedRefreshRate, int requestedModeId, boolean inTraversal) &#123; synchronized (mSyncRoot) &#123; LogicalDisplay display = mLogicalDisplays.get(displayId); if (display == null) &#123; return; &#125; if (display.hasContentLocked() != hasContent) &#123; if (DEBUG) &#123; Slog.d(TAG, &quot;Display &quot; + displayId + &quot; hasContent flag changed: &quot; + &quot;hasContent=&quot; + hasContent + &quot;, inTraversal=&quot; + inTraversal); &#125; display.setHasContentLocked(hasContent); scheduleTraversalLocked(inTraversal); &#125; // 当应用仅仅设置了刷新率，而没有设置modeId时，需要找到一个合适的modeId // 为什么这么做呢，因为modeId不仅仅包含刷新率，还有分辨率。 // 当请求刷新率变化时，是不能或不必要改变分辨率的，所以就需要找到分辨率不变的modeId if (requestedModeId == 0 &amp;&amp; requestedRefreshRate != 0) &#123; // Scan supported modes returned by display.getInfo() to find a mode with the same // size as the default display mode but with the specified refresh rate instead. requestedModeId = display.getDisplayInfoLocked().findDefaultModeByRefreshRate( requestedRefreshRate); &#125; // 2.1 发现有应用请求Display改变modeId mDisplayModeDirector.getAppRequestObserver().setAppRequestedMode( displayId, requestedModeId); &#125;&#125; 二. DisplayModeDirector这个类是用于决策当前设备刷新率的 2.1 DisplayModeDirector.AppRequestObserver.setAppRequestedMode12345678910111213141516171819202122232425262728293031323334public void setAppRequestedMode(int displayId, int modeId) &#123; synchronized (mLock) &#123; setAppRequestedModeLocked(displayId, modeId); &#125;&#125;private void setAppRequestedModeLocked(int displayId, int modeId) &#123; // 做一个参数检查，确保displayId和modeId参数是可接受的 final Display.Mode requestedMode = findModeByIdLocked(displayId, modeId); // 如果当前displayId下的modeId已经是App所需的modeId，就不用继续了 if (Objects.equals(requestedMode, mAppRequestedModeByDisplay.get(displayId))) &#123; return; &#125; final Vote refreshRateVote; final Vote sizeVote; if (requestedMode != null) &#123; // 保存当前App设置的参数 mAppRequestedModeByDisplay.put(displayId, requestedMode); float refreshRate = requestedMode.getRefreshRate(); // 创建刷新率Vote refreshRateVote = Vote.forRefreshRates(refreshRate, refreshRate); sizeVote = Vote.forSize(requestedMode.getPhysicalWidth(), requestedMode.getPhysicalHeight()); &#125; else &#123; mAppRequestedModeByDisplay.remove(displayId); refreshRateVote = null; sizeVote = null; &#125; updateVoteLocked(displayId, Vote.PRIORITY_APP_REQUEST_REFRESH_RATE, refreshRateVote); updateVoteLocked(displayId, Vote.PRIORITY_APP_REQUEST_SIZE, sizeVote); return;&#125; 2.2 DisplayModeDirector.Vote.updateVoteLocked更新Vote策略 1234567891011121314151617181920212223242526272829303132private void updateVoteLocked(int displayId, int priority, Vote vote) &#123; if (DEBUG) &#123; Slog.i(TAG, &quot;updateVoteLocked(displayId=&quot; + displayId + &quot;, priority=&quot; + Vote.priorityToString(priority) + &quot;, vote=&quot; + vote + &quot;)&quot;); &#125; if (priority &lt; Vote.MIN_PRIORITY || priority &gt; Vote.MAX_PRIORITY) &#123; Slog.w(TAG, &quot;Received a vote with an invalid priority, ignoring:&quot; + &quot; priority=&quot; + Vote.priorityToString(priority) + &quot;, vote=&quot; + vote, new Throwable()); return; &#125; // 获取当前display的所有Vote final SparseArray&lt;Vote&gt; votes = getOrCreateVotesByDisplay(displayId); // 获取PRIORITY_APP_REQUEST_REFRESH_RATE优先级的Vote，不过根本没有用？ Vote currentVote = votes.get(priority); // 传入的Vote不为空，说明有符合要求的ModeId,就保存，没有就移除当前优先级的Vote if (vote != null) &#123; votes.put(priority, vote); &#125; else &#123; votes.remove(priority); &#125; if (votes.size() == 0) &#123; if (DEBUG) &#123; Slog.i(TAG, &quot;No votes left for display &quot; + displayId + &quot;, removing.&quot;); &#125; mVotesByDisplay.remove(displayId); &#125; // 通知ModeId改变 notifyAllowedModesChangedLocked();&#125; 2.3 DisplayModeDirector.Vote.notifyAllowedModesChangedLocked123456789101112131415161718192021222324252627private void notifyAllowedModesChangedLocked() &#123; if (mListener != null &amp;&amp; !mHandler.hasMessages(MSG_ALLOWED_MODES_CHANGED)) &#123; // We need to post this to a handler to avoid calling out while holding the lock // since we know there are things that both listen for changes as well as provide // information. If we did call out while holding the lock, then there&#x27;s no guaranteed // lock order and we run the real of risk deadlock. Message msg = mHandler.obtainMessage(MSG_ALLOWED_MODES_CHANGED, mListener); msg.sendToTarget(); &#125;&#125;private final class DisplayModeDirectorHandler extends Handler &#123; DisplayModeDirectorHandler(Looper looper) &#123; super(looper, null, true /*async*/); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_ALLOWED_MODES_CHANGED: Listener listener = (Listener) msg.obj; listener.onAllowedDisplayModesChanged(); break; ...... &#125; &#125;&#125; 转到DisplayThread线程处理，也就是回调onAllowedDisplayModesChanged.这里的mListener是调用DisplayModeDirector.setListener设置的，这个是在DisplayManagerService中: 12345678910111213141516171819/** * Called when the system is ready to go. */public void systemReady(boolean safeMode, boolean onlyCore) &#123; synchronized (mSyncRoot) &#123; mSafeMode = safeMode; mOnlyCore = onlyCore; mSystemReady = true; // Just in case the top inset changed before the system was ready. At this point, any // relevant configuration should be in place. recordTopInsetLocked(mLogicalDisplays.get(Display.DEFAULT_DISPLAY)); &#125; // 这里： mDisplayModeDirector.setListener(new AllowedDisplayModeObserver()); mDisplayModeDirector.start(mSensorManager); mHandler.sendEmptyMessage(MSG_REGISTER_ADDITIONAL_DISPLAY_ADAPTERS);&#125; 2.4 DisplayManagerService.onAllowedDisplayModesChangedInternal1234567891011121314151617181920212223242526private void onAllowedDisplayModesChangedInternal() &#123; boolean changed = false; synchronized (mSyncRoot) &#123; final int count = mLogicalDisplays.size(); // 遍历所有的Display，依次设置 for (int i = 0; i &lt; count; i++) &#123; LogicalDisplay display = mLogicalDisplays.valueAt(i); int displayId = mLogicalDisplays.keyAt(i); // 2.5 获取displayId对应的ModeIds int[] allowedModes = mDisplayModeDirector.getAllowedModes(displayId); // Note that order is important here since not all display devices are capable of // automatically switching, so we do actually want to check for equality and not // just equivalent contents (regardless of order). if (!Arrays.equals(allowedModes, display.getAllowedDisplayModesLocked())) &#123; // 保存modeId集，以便判断是否有modeId变化，这个判断条件内getAllowedDisplayModesLocked // 拿到的modeId数组就是上一次在这里保存的 display.setAllowedDisplayModesLocked(allowedModes); changed = true; &#125; &#125; // 有改变, 请求下一次Vsync, 以确保通知到SurfaceFlinger有modeId更改 if (changed) &#123; scheduleTraversalLocked(false); &#125; &#125;&#125; 2.5 DisplayModeDirector.getAllowedModes12345678910111213141516@NonNullpublic int[] getAllowedModes(int displayId) &#123; synchronized (mLock) &#123; // 取出displayId对应的所有Vote，注意这里包含GLOBAL_ID(-1), 即全局生效的Vote SparseArray&lt;Vote&gt; votes = getVotesLocked(displayId); Display.Mode[] modes = mSupportedModesByDisplay.get(displayId); Display.Mode defaultMode = mDefaultModeByDisplay.get(displayId); if (modes == null || defaultMode == null) &#123; Slog.e(TAG, &quot;Asked about unknown display, returning empty allowed set! (id=&quot; + displayId + &quot;)&quot;); return new int[0]; &#125; // 2.5.1 计算 return getAllowedModesLocked(votes, modes, defaultMode); &#125;&#125; 计算displayId对应允许的可自由切换的modeId列表 2.5.1 DisplayModeDirector.getAllowedModesLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@NonNullprivate int[] getAllowedModesLocked(@NonNull SparseArray&lt;Vote&gt; votes, @NonNull Display.Mode[] modes, @NonNull Display.Mode defaultMode) &#123; // 从最低优先级开始遍历，不过为什么会有两层循环？ int lowestConsideredPriority = Vote.MIN_PRIORITY; while (lowestConsideredPriority &lt;= Vote.MAX_PRIORITY) &#123; float minRefreshRate = 0f; float maxRefreshRate = Float.POSITIVE_INFINITY; int height = Vote.INVALID_SIZE; int width = Vote.INVALID_SIZE; // 从优先级最大的开始遍历 for (int priority = Vote.MAX_PRIORITY; priority &gt;= lowestConsideredPriority; priority--) &#123; Vote vote = votes.get(priority); if (vote == null) &#123; continue; &#125; // 刷新率最小值取两者中的较大值 minRefreshRate = Math.max(minRefreshRate, vote.minRefreshRate); // 刷新率最大值取两者中的较小值 maxRefreshRate = Math.min(maxRefreshRate, vote.maxRefreshRate); // 显示大小只需要取第一个值 if (height == Vote.INVALID_SIZE &amp;&amp; width == Vote.INVALID_SIZE &amp;&amp; vote.height &gt; 0 &amp;&amp; vote.width &gt; 0) &#123; width = vote.width; height = vote.height; &#125; &#125; // If we don&#x27;t have anything specifying the width / height of the display, just use the // default width and height. We don&#x27;t want these switching out from underneath us since // it&#x27;s a pretty disruptive behavior. if (height == Vote.INVALID_SIZE || width == Vote.INVALID_SIZE) &#123; width = defaultMode.getPhysicalWidth(); height = defaultMode.getPhysicalHeight(); &#125; // 2.5.2 获取可取的mode int[] availableModes = filterModes(modes, width, height, minRefreshRate, maxRefreshRate); if (availableModes.length &gt; 0) &#123; return availableModes; &#125; // 当前优先级下没有找到合适的modeId时，提高优先级重新搜索 lowestConsideredPriority++; &#125; // If we still haven&#x27;t found anything that matches our current set of votes, just fall back // to the default mode. return new int[] &#123; defaultMode.getModeId() &#125;;&#125; 这里刷新率的算法是，遍历所有优先级的Vote，最终的minRefreshRate取所有Vote的最小刷新率中的最大值。maxRefreshRate取所有Vote中最大刷新率的最小值。 这里有个地方一开始比较难理解，就是为什么是用双层循环，而且第一层循环是从优先级最低的开始，最内层是优先级最大的开始。不着急我们先看#2.5.2 2.5.2 DisplayModeDirector.filterModes12345678910111213141516171819202122232425262728private int[] filterModes(Display.Mode[] supportedModes, int width, int height, float minRefreshRate, float maxRefreshRate) &#123; ArrayList&lt;Display.Mode&gt; availableModes = new ArrayList&lt;&gt;(); for (Display.Mode mode : supportedModes) &#123; if (mode.getPhysicalWidth() != width || mode.getPhysicalHeight() != height) &#123; continue; &#125; final float refreshRate = mode.getRefreshRate(); // EPSILON = 0.001f // 为啥会有这呢，因为小数计算会有误差 // 比如60Hz的刷新的vsync间隔是16.666666ms // 计算得来的refreshRate就是：1000/16.666666 = 60.0000024 // 不是恰好为60，所以需要去掉这个误差 if (refreshRate &lt; (minRefreshRate - EPSILON) || refreshRate &gt; (maxRefreshRate + EPSILON)) &#123; // 当该mode的刷新率不符合边界条件时，抛弃该mode continue; &#125; availableModes.add(mode); &#125; final int size = availableModes.size(); int[] availableModeIds = new int[size]; for (int i = 0; i &lt; size; i++) &#123; availableModeIds[i] = availableModes.get(i).getModeId(); &#125; // 返回符合要求的modeId集合 return availableModeIds;&#125; 其实实际推演一下就不难理解了, 假设我们有如下Votes: 12345678910111213141516mSupportedModesByDisplay: 0 -&gt; [ &#123;id=1, width=1080, height=2376, fps=60.000004&#125;, &#123;id=2, width=1440, height=3168, fps=120.00001&#125;, &#123;id=3, width=1440, height=3168, fps=60.000004&#125;, &#123;id=4, width=1080, height=2376, fps=120.00001&#125;] mVotesByDisplay: -1: PRIORITY_LOW_POWER_MODE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=60.0&#125; PRIORITY_USER_SETTING_PEAK_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=120.0&#125; PRIORITY_USER_SETTING_MIN_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=Infinity&#125; 0: PRIORITY_APP_REQUEST_SIZE -&gt; Vote&#123;width=1080, height=2376, minRefreshRate=0.0, maxRefreshRate=Infinity&#125; PRIORITY_APP_REQUEST_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=120.00001, maxRefreshRate=120.00001&#125; 注意这里的优先级: name Value PRIORITY_LOW_BRIGHTNESS 0 PRIORITY_USER_SETTING_MIN_REFRESH_RATE 1 PRIORITY_APP_REQUEST_REFRESH_RATE 2 PRIORITY_APP_REQUEST_SIZE 3 PRIORITY_USER_SETTING_PEAK_REFRESH_RATE 4 PRIORITY_LOW_POWER_MODE 5 当外层循环第一次执行时：lowestConsideredPriority &#x3D; PRIORITY_LOW_BRIGHTNESS &#x3D; 0 内层循环会遍历所有Vote(包含-1，和当前displayId,这里是0): 算出的minRefreshRate &#x3D; Infinity, maxRefreshRate &#x3D;0 当然，在filterModes中是找不到合适的mode的，所以优先级+1，继续搜索 外层循环第二次执行时：lowestConsideredPriority &#x3D; PRIORITY_USER_SETTING_MIN_REFRESH_RATE &#x3D; 1 此时排除优先级为0的所有Vote，其实结果还是一样，所以lowestConsideredPriority继续+1 外层循环第三次执行时：lowestConsideredPriority &#x3D; PRIORITY_APP_REQUEST_REFRESH_RATE &#x3D; 2 此时排除优先级小于PRIORITY_APP_REQUEST_REFRESH_RATE的所有Vote，结果还是一样，所以lowestConsideredPriority继续+1 外层循环第四次执行时：lowestConsideredPriority &#x3D; PRIORITY_APP_REQUEST_SIZE &#x3D; 3 此时排除优先级小于PRIORITY_APP_REQUEST_SIZE的所有Vote，结果还是一样，所以lowestConsideredPriority继续+1 外层循环第五次执行时：lowestConsideredPriority &#x3D; PRIORITY_USER_SETTING_PEAK_REFRESH_RATE &#x3D; 4 此时排除优先级小于PRIORITY_USER_SETTING_PEAK_REFRESH_RATE的所有Vote 内层循环其实只有两个选项： PRIORITY_LOW_POWER_MODE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;60.0} PRIORITY_USER_SETTING_PEAK_REFRESH_RATE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;120.0} 此时结果为minRefreshRate &#x3D; 60, maxRefreshRate &#x3D;0，当然还是没有有效的modeId 外层循环第六次执行时：lowestConsideredPriority &#x3D; PRIORITY_LOW_POWER_MODE &#x3D; 5 只有选项：PRIORITY_LOW_POWER_MODE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;60.0} 所以最终的minRefreshRate &#x3D; 0.0, maxRefreshRate &#x3D; 60.0，width&#x3D;1080, height&#x3D;2376 最后满足条件的modeId就只有mSupportedModesByDisplay中的0了. 最终算出来了modeId, 这里面计算复杂，弯弯绕绕，为什么Google如此设计呢，个人猜测是为了尽可能满足低优先级下的刷新率要求，并不是优先级最高就能决定modeId的取值,而是找到尽快满足更多优先级下合适刷新率的modeId集提供给SurfaceFlinger选择. 继续往下看，framework将这个modeId集传给SurfaceFlinger. 三. 通知SurfaceFlinger变化3.1 DisplayManagerInternal.performTraversal1234@Overridepublic void performTraversal(SurfaceControl.Transaction t) &#123; performTraversalInternal(t);&#125; 3.2 DisplayManagerService.performTraversalInternal12345678910111213141516@VisibleForTestingvoid performTraversalInternal(SurfaceControl.Transaction t) &#123; synchronized (mSyncRoot) &#123; if (!mPendingTraversal) &#123; return; &#125; mPendingTraversal = false; // 3.2.1 通知SF有相关状态变化 performTraversalLocked(t); &#125; // List is self-synchronized copy-on-write. for (DisplayTransactionListener listener : mDisplayTransactionListeners) &#123; listener.onDisplayTransaction(t); &#125;&#125; 3.2.1 DisplayManagerService.performTraversalLocked123456789101112131415private void performTraversalLocked(SurfaceControl.Transaction t) &#123; // Clear all viewports before configuring displays so that we can keep // track of which ones we have configured. clearViewportsLocked(); // 3.2.2 对每个Display都做配置 final int count = mDisplayDevices.size(); for (int i = 0; i &lt; count; i++) &#123; DisplayDevice device = mDisplayDevices.get(i); // 与SurfaceFlinger通信，这里的device我们视为默认的LocalDisplayDevice configureDisplayLocked(t, device); device.performTraversalLocked(t); &#125; ......&#125; 3.2.2 DisplayManagerService.configureDisplayLocked123456789private void configureDisplayLocked(SurfaceControl.Transaction t, DisplayDevice device) &#123; ...... // 拿到对应LogicalDisplay LogicalDisplay display = findLogicalDisplayForDeviceLocked(device); ...... // 3.2.3 应用状态变化 display.configureDisplayLocked(t, device, info.state == Display.STATE_OFF); ......&#125; 3.2.3 LogicalDisplay.configureDisplayLocked1234567891011121314151617public void configureDisplayLocked(SurfaceControl.Transaction t, DisplayDevice device, boolean isBlanked) &#123; // Set the layer stack. device.setLayerStackLocked(t, isBlanked ? BLANK_LAYER_STACK : mLayerStack); // 3.3 应用配置变化，注意这里的device是LocalDisplayDevice if (device == mPrimaryDisplayDevice) &#123; device.setAllowedDisplayModesLocked(mAllowedDisplayModes); device.setRequestedColorModeLocked(mRequestedColorMode); &#125; else &#123; // Reset to default for non primary displays device.setAllowedDisplayModesLocked(new int[] &#123;0&#125;); device.setRequestedColorModeLocked(0); &#125; ......&#125; 3.3 LocalDisplayAdapter.LocalDisplayDevice.setAllowedDisplayModesLocked12345678910111213141516171819202122232425262728293031323334353637@Overridepublic void setAllowedDisplayModesLocked(int[] modes) &#123; updateAllowedModesLocked(modes);&#125;public void updateAllowedModesLocked(int[] allowedModes) &#123; if (Arrays.equals(allowedModes, mAllowedModeIds) &amp;&amp; !mAllowedModeIdsInvalid) &#123; return; &#125; if (updateAllowedModesInternalLocked(allowedModes)) &#123; updateDeviceInfoLocked(); &#125;&#125;public boolean updateAllowedModesInternalLocked(int[] allowedModes) &#123; if (DEBUG) &#123; Slog.w(TAG, &quot;updateAllowedModesInternalLocked(allowedModes=&quot; + Arrays.toString(allowedModes) + &quot;)&quot;); &#125; int[] allowedPhysIndexes = new int[allowedModes.length]; int size = 0; // 将modeId转化为物理modeId，简单来说就是 physicalId = modeId - 1 for (int modeId : allowedModes) &#123; int physIndex = findDisplayInfoIndexLocked(modeId); if (physIndex &lt; 0) &#123; Slog.w(TAG, &quot;Requested mode ID &quot; + modeId + &quot; not available,&quot; + &quot; dropping from allowed set.&quot;); &#125; else &#123; allowedPhysIndexes[size++] = physIndex; &#125; &#125; ...... // 3.4 通过SurfaceControl通知SurfaceFlinger有modeId变化，binder通信 SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes); int activePhysIndex = SurfaceControl.getActiveConfig(getDisplayTokenLocked()); return updateActiveModeLocked(activePhysIndex);&#125; 3.4 SurfaceControl.setAllowedDisplayConfigs12345678910111213private static native boolean nativeSetAllowedDisplayConfigs(IBinder displayToken, int[] allowedConfigs);public static boolean setAllowedDisplayConfigs(IBinder displayToken, int[] allowedConfigs) &#123; if (displayToken == null) &#123; throw new IllegalArgumentException(&quot;displayToken must not be null&quot;); &#125; if (allowedConfigs == null) &#123; throw new IllegalArgumentException(&quot;allowedConfigs must not be null&quot;); &#125; // JNI调用 return nativeSetAllowedDisplayConfigs(displayToken, allowedConfigs);&#125; 3.5 android_view_SurfaceControl::nativeSetAllowedDisplayConfigs123456789101112131415161718static jboolean nativeSetAllowedDisplayConfigs(JNIEnv* env, jclass clazz, jobject tokenObj, jintArray configArray) &#123; sp&lt;IBinder&gt; token(ibinderForJavaObject(env, tokenObj)); if (token == nullptr) return JNI_FALSE; std::vector&lt;int32_t&gt; allowedConfigs; jsize configArraySize = env-&gt;GetArrayLength(configArray); allowedConfigs.reserve(configArraySize); jint* configArrayElements = env-&gt;GetIntArrayElements(configArray, 0); for (int i = 0; i &lt; configArraySize; i++) &#123; allowedConfigs.push_back(configArrayElements[i]); &#125; env-&gt;ReleaseIntArrayElements(configArray, configArrayElements, 0); // 3.5.1 通过SurfaceComposerClient size_t result = SurfaceComposerClient::setAllowedDisplayConfigs(token, allowedConfigs); return result == NO_ERROR ? JNI_TRUE : JNI_FALSE;&#125; 3.5.1 SurfaceComposerClient::setAllowedDisplayConfigs123456status_t SurfaceComposerClient::setAllowedDisplayConfigs( const sp&lt;IBinder&gt;&amp; displayToken, const std::vector&lt;int32_t&gt;&amp; allowedConfigs) &#123; // 通过binder调用到SurfaceFlinger return ComposerService::getComposerService()-&gt;setAllowedDisplayConfigs(displayToken, allowedConfigs);&#125; 3.6 SurfaceFlinger::setAllowedDisplayConfigs12345678910111213141516171819202122232425262728status_t SurfaceFlinger::setAllowedDisplayConfigs(const sp&lt;IBinder&gt;&amp; displayToken, const std::vector&lt;int32_t&gt;&amp; allowedConfigs) &#123; ATRACE_CALL(); if (!displayToken || allowedConfigs.empty()) &#123; return BAD_VALUE; &#125; if (mDebugDisplayConfigSetByBackdoor) &#123; // ignore this request as config is overridden by backdoor return NO_ERROR; &#125; postMessageSync(new LambdaMessage([&amp;]() &#123; const auto display = getDisplayDeviceLocked(displayToken); if (!display) &#123; ALOGE(&quot;Attempt to set allowed display configs for invalid display token %p&quot;, displayToken.get()); &#125; else if (display-&gt;isVirtual()) &#123; ALOGW(&quot;Attempt to set allowed display configs for virtual display&quot;); &#125; else &#123; Mutex::Autolock lock(mStateLock); setAllowedDisplayConfigsInternal(display, allowedConfigs); &#125; &#125;)); return NO_ERROR;&#125; 好了，app设置屏幕显示刷新的流程就走完了，接下来就是SurfaceFlinger去和硬件交互，通知切换刷新率了。","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Vsync","slug":"Android/Vsync","permalink":"https://swallowjoe.github.io/categories/Android/Vsync/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"}]},{"title":"App申请帧率(1)--简述","slug":"App申请帧率-1-简述","date":"2022-02-26T19:53:29.000Z","updated":"2022-02-26T19:58:12.384Z","comments":true,"path":"2022/02/27/App申请帧率-1-简述/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/","excerpt":"背景 参考资料 查看设备可支持的刷新率和分辨率 App设置设备帧率 Android Q及以下版本 Android R 背景随着手机屏幕硬件能力的提升，越来越多的厂商提供支持多档次刷新率的Android设备。而在Android Q上也是支持App指定当前屏幕帧率的，也有一套帧率分辨率切换的逻辑。","text":"背景 参考资料 查看设备可支持的刷新率和分辨率 App设置设备帧率 Android Q及以下版本 Android R 背景随着手机屏幕硬件能力的提升，越来越多的厂商提供支持多档次刷新率的Android设备。而在Android Q上也是支持App指定当前屏幕帧率的，也有一套帧率分辨率切换的逻辑。 参考资料 https://zhuanlan.zhihu.com/p/142212769?from_voters_page=true 查看设备可支持的刷新率和分辨率使用命令：adb shell dumpsys display dump |grep -A 10 -iE “mSupportedModes” 这里设备使用的是OnePlus8Pro，结果如下: 12345mSupportedModes= DisplayModeRecord&#123;mMode=&#123;id=1, width=1080, height=2376, fps=60.000004&#125;&#125; DisplayModeRecord&#123;mMode=&#123;id=2, width=1440, height=3168, fps=120.00001&#125;&#125; DisplayModeRecord&#123;mMode=&#123;id=3, width=1440, height=3168, fps=60.000004&#125;&#125; DisplayModeRecord&#123;mMode=&#123;id=4, width=1080, height=2376, fps=120.00001&#125;&#125; 可以看到是有四种模式： 1080 + 60Hz 2K + 120Hz 2K + 60Hz 1080 + 120Hz App设置设备帧率Android Q及以下版本在Android Q或更低版本上，可以通过指定当前Window的帧率来设置屏幕刷新率，如选择设备可支持的最高刷新率： 12345678var highestMode: Display.Mode = mWindowManager!!.defaultDisplay.supportedModes[0]for (mode in mWindowManager!!.defaultDisplay.supportedModes) &#123; if (mode.refreshRate &gt; highestMode.refreshRate) &#123; highestMode = mode &#125;&#125;wmParams!!.preferredDisplayModeId = highestMode.modeId Android R如 Google建议利用可变刷新率 在较旧的 Android 版本 (Android 11 之前) 中并不存在 setFrameRate API，这时应用仍然可以通过直接将WindowManager.LayoutParams.preferredDisplayModeId设置为Display.getSupportedModes中的可用模式之一来影响刷新率。 从 Android 11 开始，我们不建议大家采用这种方法，因为平台会不知道应用的渲染意图。 例如，如果一个设备支持 48Hz、60Hz 和 120Hz，屏幕上有两个应用分别调用 setFrameRate(60, …) 和 setFrameRate(24, …)，那么平台可以选择 120Hz 来同时满足这两个应用。 而如果这些应用使用了preferredDisplayModeId，它们很可能会把模式设置为 60Hz 和 48Hz，那这时平台就无法使用 120Hz 了。这时平台只能从 60Hz 或 48Hz 中选择一个，从而影响到另一个应用的显示效果。 获取刷新率： SDK 通过 DisplayManager.DisplayListener 注册一个显示监听器，并通过 Display.getRefreshRate 查询刷新率。 2. NDK使用 AChoreographer_registerRefreshRateCallback 注册回调 (API 级别30)。 设置刷新率应用可以调用以下方法之一: SDK Surface.setFrameRate SurfaceControl.Transaction.setFrameRate NDK ANativeWindow_setRrameRate ASurfaceTransaction_setFrameRate","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Vsync","slug":"Android/Vsync","permalink":"https://swallowjoe.github.io/categories/Android/Vsync/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"}]},{"title":"Looper-Android中的消息机制","slug":"Looper-Android中的消息机制","date":"2022-02-26T19:48:26.000Z","updated":"2022-02-26T19:57:34.959Z","comments":true,"path":"2022/02/27/Looper-Android中的消息机制/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/","excerpt":"简述本文详细分析android的消息机制Looper的底层原理。","text":"简述本文详细分析android的消息机制Looper的底层原理。 以下分析基于Android S. 初学Android的时候, 比较容易遇到如下错误: 1234567E AndroidRuntime: FATAL EXCEPTION: 非UI线程E AndroidRuntime: Process: com.android.demo, PID: 23939E AndroidRuntime: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.E AndroidRuntime: at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:9587)E AndroidRuntime: at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1894)......E AndroidRuntime: at java.lang.Thread.run(Thread.java:923) 往往是我们在非UI线程更新UI组件导致的。解决的方案也很简单，将更新组件的操作移入UI线程执行即可。此时就需要用到Android中非常基础又非常重要的Handler、Looper、Message这三个类: 12345678910111213141516171819var uiHandler = UiHandler(Looper.getMainLooper())val message = uiHandler.obtainMessage(MSG_UPDATE_UI)message.obj = &quot;我在UI线程中更新UI组件哦!&quot;uiHandler.sendMessage(message)companion object &#123; const val MSG_UPDATE_UI = 0x1&#125;inner class UiHandler(looper: Looper) : Handler(looper) &#123; override fun handleMessage(msg: Message) &#123; super.handleMessage(msg) when (msg.what) &#123; MSG_UPDATE_UI -&gt; &#123; textview.text = msg.obj as String &#125; &#125; &#125;&#125; 如上，设置Handler的Looper为MainLooper，然后通过sendMessage将封装数据的Message发送到MainLooper代表的UI线程中处理，就这样切换了线程。接下来我们研究下其中的原理，为什么Looper有main looper, Handler的sendMessage是怎么找到对应线程，然后调用handleMessage的。 或者通过Looper prepare的方式， 其实也是获取主线程的Looper实现的: 123456789101112131415161718192021class Keep extends Thread &#123; public static final int MSG_A = 0x00; public static final int MSG_B = 0x00; public Handler handler; @Override public void run() &#123; Looper.prepare(); handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_A: &#123; /* .... */ &#125; break; case MSG_B: &#123; /* .... */ &#125; break; &#125; &#125; &#125;; Looper.loop(); &#125;&#125; 这样我们在需要的时候执行: handler.sendMessage(handler.obtain(MSG_A)) 即可以实现线程交换了, 除了sendMessage，还有如下方式: Android系统中大量使用Message来进行跨线程通信，实现交互，设计四个类：Message、Handler、Looper和MessageQueue, 类图如下: Message: 消息，封装待传递的数据 Handler: 消息辅助类，向消息池(MessageQueue)中存入消息和接收消息进行处理 Looper: 如其名，封装一个不断循环的函数体，不停的从消息池(MessageQueue)中取出合适的消息交给Handler处理 MessageQueue: 消息池，维护了一个由消息组成的链表，该链表按照消息执行的时间顺序排列 我们首先看看UI线程的Looper获取：Looper.getMainLooper() 一. Main Looper的创建1.1 Looper.getMainLooper12345public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125;&#125; 返回的就是Looper中静态变量sMainLooper。那么该sMainLooper是何时创建的呢： 1.2 sMainLooper1234567891011public static void prepareMainLooper() &#123; // 1.2.1 Looper准备工作 prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; // 1.2.3 myLooper拿的就是当前线程的Looper. sMainLooper = myLooper(); &#125;&#125; sMainLooper是在Looper.prepareMainLooper被第一次调用时赋值的。而prepareMainLooper是在ActivityThread.main函数中调用的: 123456789// ActivityThread.javapublic static void main(String[] args) &#123; ...... Looper.prepareMainLooper(); ...... // 1.3 执行loop Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 在Zygote启动进程时，进程的入口函数是ActivityThread.main，也就是说三方进程启动后第一时间就会调用Looper.prepareMainLooper()设置sMainLooper。 1.2.1 Looper.prepare123456789101112public static void prepare() &#123; prepare(true);&#125;// quitAllowed 这个参数表明该Looper是否允许退出private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; // 1.2.2 注意这里创建了一个Looper, 并保存在sThreadLocal中 sThreadLocal.set(new Looper(quitAllowed));&#125; quitAllowed 这个参数表明该Looper是否允许退出，自然UI线程(主线程)是不允许退出的，除非被kill或者进程自杀。 这里稍微提一下，sThreadLocal是ThreadLocal类型，实现了线程本地存储区(Thread Local Storage, 简称TLS)。每个线程都有自己私有的存储区域，不同线程之间彼此不能访问对方的TSL区域。简单来说，可以将这里的 sThreadLocal 视为一个Map集合，其中key为Thread, value是Looper, 每次set和get都是获取当前线程对应的Looper 1.2.2 Looper 的创建12345private Looper(boolean quitAllowed) &#123; // 3.1 MessageQueue创建 mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 简单的创建了一个MessageQueue,并保存创建该Looper的线程。 1.2.3 Looper.myLooper123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 通过sThreadLocal获取当前线程对应的Looper. 1.3 Looper.loop1234567891011121314151617181920212223242526public static void loop() &#123; // 获取当前线程的Looper final Looper me = myLooper(); // Looper一定存在某个线程中，线程不一定拥有Looper if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;); &#125; // adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27; // 用于修改记录Looper中的Message是否执行慢或者超时的时长 final int thresholdOverride = SystemProperties.getInt(&quot;log.looper.&quot; + Process.myUid() + &quot;.&quot; + Thread.currentThread().getName() + &quot;.slow&quot;, 0); // 如果有message分发超时，这个变量就会被标记为true me.mSlowDeliveryDetected = false; // 这个就是Loop名称的由来，一直循环 for (;;) &#123; if (!loopOnce(me, ident, thresholdOverride)) &#123; return; &#125; &#125;&#125; loop()函数很简单，就一直循环执行loopOnce就可 1.4 Looper.loopOnce123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) &#123; // 5.1 通过MessageQueue获取下一个Message, 这里稍后分析 Message msg = me.mQueue.next(); if (msg == null) &#123; // 获取的下一个Message为null，说明该Looper将要退出 return false; &#125; // mLogging是Printer的对象，可以通过: looper.setMessageLogging(printer)设置 // 用于打印Looper日志，如下： final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; // Make sure the observer won&#x27;t change while processing a transaction. final Observer observer = sObserver; // traceTag用于抓取systrace，通过looper.setTraceTag设置 final long traceTag = me.mTraceTag; // mSlowDispatchThresholdMs和mSlowDeliveryThresholdMs默认都是0 // 可以通过setSlowLogThresholdMs设置 // 比如SystemServer主线程的looper就被分别设置为100ms，200ms long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; // thresholdOverride可以通过属性修改:setprop log.looper.1000.main.slow 1 slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; // 开始抓取trace if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; // 记录Message分发开始的时间 final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; // 1.4.1 分发message， 这里的target就是Handler msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; // 记录消息分发结束时间 dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; // mSlowDeliveryDetected 表明之前就有消息等待分发超时了 if (me.mSlowDeliveryDetected) &#123; // message分发时间和该message需要执行的时间相差不超过10ms，说明Message分发及时 // 去掉之前标记的消息分发超时 if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, &quot;Drained&quot;); me.mSlowDeliveryDetected = false; &#125; &#125; else &#123; // 这里就是检测Message等待分发是否超过阈值 // 打印的日志如： Looper: Slow delivery took 233ms android.ui h=com.XXX c=null m=31 if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, &quot;delivery&quot;, msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. me.mSlowDeliveryDetected = true; &#125; &#125; &#125; // 消息分发是否超时 // 打印的日志如： Looper: Slow dispatch took 233ms android.ui h=com.XXX c=null m=31 if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, &quot;dispatch&quot;, msg); &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; ...... // 回收该Message msg.recycleUnchecked(); return true;&#125; loopOnce函数看起来也很简单，一直从MessageQueue中获取Message并执行Handler.handleMessage函数。除非拿到的message是null时返回false，否则永远返回true。注意弄清 delivery 和 dispatch 的区别： delivery: 消息被拿出准备分发的时间与消息期望被执行的时间差 dispatch: 消息处理的总时间，即handle.dispatchMessage的执行时长 1.4.1 Handler.dispatchMessage12345678910111213public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 执行我们重载的函数了 handleMessage(msg); &#125;&#125; 我们知道在Handler.handleMessage这里已经转到Handler对应Looper所在的线程了。这样看起来，线程切换的奥秘都被隐藏在MessageQueue中了。 二. Message在分析MessageQueue之前，简单看一下Message的设计。 变量 类型 作用 what int 标明消息类别 arg1 int 参数1 arg2 int 参数2 obj Object 消息内容 when long 消息期望触发时间 data Bundle 消息附带内容 target Handler 消息触发执行的Handler callback Runnable 消息执行的Runnable next Message 下一个消息, 消息链表结构基础 2.1 消息链表结构1234567891011121314151617181920212223@UnsupportedAppUsage/*package*/ Message next;/** @hide */public static final Object sPoolSync = new Object();private static Message sPool;private static int sPoolSize = 0;private static final int MAX_POOL_SIZE = 50;public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message();&#125; 通过维护一个大小为50的Message缓冲池，来缓解Message频繁创建销毁带来的资源损耗，所以在开发过程中尽可能选择使用obtain来创建Message。 三. MessageQueue既然Message自己就维护了一个链表结构，还需要MessageQueue做什么呢？ 3.1 MessageQueue12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; // 3.2 通过JNI进入native实例化 mPtr = nativeInit();&#125; 设置mQuitAllowed, 主线程的Looper不允许退出(调用quit，主动退出)。然后通过JNI进入native层初始化 3.2 android_os_MessageQueue_nativeInit12345678910static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 也就是创建了一个NativeMessageQueue的对象。 3.3 NativeMessageQueue1234567891011NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; // 注意这里是native层的Loop了, 同样的也是通过TLS方式存储的 mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; // 3.4 创建Looper mLooper = new Looper(false); // 保存在当前线程的TLS中 Looper::setForThread(mLooper); &#125;&#125; 3.4 Looper.cpp123456789101112131415161718Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; // eventfd函数会创建一个eventfd, 这里保存在mWakeEventFd中 // EFD_NONBLOCK: 设置FD对象为非阻塞状态 // EFD_CLOEXEC: 调用exec后会自动关闭文件描述符，防止泄漏 mWakeEventFd.reset(eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC)); LOG_ALWAYS_FATAL_IF(mWakeEventFd.get() &lt; 0, &quot;Could not make wake event fd: %s&quot;, strerror(errno)); AutoMutex _l(mLock); // 3.4.1 重建epoll rebuildEpollLocked();&#125; eventfd 是 Linux 的一个系统调用，创建一个文件描述符用于事件通知，自 Linux 2.6.22 以后开始支持。该函数会创建一个 eventfd 对象，用户空间的应用程序可以用这个 eventfd 来实现事件的等待或通知机制，也可以用于内核通知新的事件到用户空间应用程序。 看来初始化该Looper的线程是通过这个eventfd来实现被唤醒的。 3.4.1 Looper.cpp:rebuildEpollLocked123456789101112131415161718192021222324252627282930313233void Looper::rebuildEpollLocked() &#123; // 如果原有fd存在，则关闭 if (mEpollFd &gt;= 0) &#123; mEpollFd.reset(); &#125; // 创建一个新的epoll实例, 并获取该实例的fd标记 mEpollFd.reset(epoll_create1(EPOLL_CLOEXEC)); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, &quot;Could not create epoll instance: %s&quot;, strerror(errno)); struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // EPOLLIN 表明fd文件可读 eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd.get(); // 在epoll实例上注册mWakeEventFd文件描述符，并将EPOLL_CTL_ADD事件关联到mWakeEventFd int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem); LOG_ALWAYS_FATAL_IF(result != 0, &quot;Could not add wake event fd to epoll instance: %s&quot;, strerror(errno)); // 对所有mRequests的fd进行重定向, 均关联到新创建的epoll实例上 for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); int epollResult = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, request.fd, &amp;eventItem); if (epollResult &lt; 0) &#123; ALOGE(&quot;Error adding epoll events for fd %d while rebuilding epoll set: %s&quot;, request.fd, strerror(errno)); &#125; &#125;&#125; 这里主要是创建了一个epoll实例，并将该Looper的mWakeEventFd（即eventfd）关联到该epoll实例上。如果该Looper的mRequests存在Request时，也对所有mRequests的fd进行重定向, 均关联到新创建的epoll实例上。 所以MessageQueue的初始化就是在Native层创建了一个NativeMessageQueue的对象，该对象持有一个Native层的Looper对象。而Native层的Looper里有两个文件描述符: 通过eventfd创建的mWakeEventFd; 通过epoll_create1创建的代表epoll实例的mEpollFd。 四. sendMessageAtTime发送消息现在回到Handler发送消息，假设Handler中的Looper是MainLooper, 现在是在非UI线程，比如bg线程读取网络数据后更新到UI组件上：uiHandler.sendMessageAtTime 123456789101112131415161718192021222324public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; // 将Message的target设置为自己 msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); // mAsynchronous表明是否异步执行 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; // 交给Handler的MessageQueue执行 return queue.enqueueMessage(msg, uptimeMillis);&#125; 4.1 MessageQueue.enqueueMessage12345678910111213141516171819202122232425262728293031323334353637383940414243444546boolean enqueueMessage(Message msg, long when) &#123; ...... synchronized (this) &#123; ...... // 标记该Message正在使用, 避免缓冲池重复使用该Message msg.markInUse(); // 记录该Message期望执行的时间 msg.when = when; // mMessages是一个Message对象，代表该MessageQueue队列的头节点 Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 如果头节点是空的、传入的Message执行时间是0（立刻执行） // 或者执行时间在头节点消息执行之前，将该Message作为链表新的头节点 msg.next = p; mMessages = msg; // mBlocked为false代表Handler所在线程已经拿到合适的Message执行了 needWake = mBlocked; &#125; else &#123; // 将Message插入到链表头节点之后 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; // 找到该Message的位置，即其执行时间在链表中的顺序排列位置 for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // 是否需要唤醒, 唤醒什么，当然是Handler的Looper对应线程了！ if (needWake) &#123; // 进入JNI, 通过epoll唤醒线程 nativeWake(mPtr); &#125; &#125; return true;&#125; 所以Handler.sendMessage仅仅是将Message插入MessageQueue中Message链表的合适位置，即保持mMessages链表中的Message期望执行时间从小到大排列，等待执行。 4.2 android_os_MessageQueue_nativeWake12345678static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125;void NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125; 转到native层的loop执行。 4.3 Looper.cpp:wake1234567891011void Looper::wake() &#123; uint64_t inc = 1; // 通过write向该Looper的mWakeEventFd中写入1 ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; LOG_ALWAYS_FATAL(&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;, mWakeEventFd.get(), nWrite, strerror(errno)); &#125; &#125;&#125; 到这里，bg线程中uiHandler发送Message的流程就结束了。 五. UI线程处理Message那么此时我们UI线程在做什么呢? 对了，就是一直在循环执行 Looper中的 loopOnce 函数！ 123456private static boolean loopOnce(final Looper me, final long ident, final int thresholdOverride) &#123; // 5.1 通过MessageQueue获取下一个Message Message msg = me.mQueue.next(); ......&#125; 5.1 MessageQueue.next1234567891011Message next() &#123; ...... int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; ...... // 5.2 转到Native中执行，获取下一次poll的时间 nativePollOnce(ptr, nextPollTimeoutMillis); ...... &#125;&#125; 直接转到native层执行pollOnce. 5.2 android_os_MessageQueue_nativePollOnce1234567891011121314151617181920static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125;void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; mPollEnv = env; mPollObj = pollObj; // 还是用到Native层的Looper mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125; 5.3 Looper.cpp:pollOnce123456789101112131415161718192021222324252627282930313233inline int pollOnce(int timeoutMillis) &#123; return pollOnce(timeoutMillis, nullptr, nullptr, nullptr);&#125;int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; // 当前mResponses还是空的，mResponseIndex为0 while (mResponseIndex &lt; mResponses.size()) &#123; const Response&amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident &gt;= 0) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; if (outFd != nullptr) *outFd = fd; if (outEvents != nullptr) *outEvents = events; if (outData != nullptr) *outData = data; return ident; &#125; &#125; // result为0, 表明poll超时 if (result != 0) &#123; if (outFd != nullptr) *outFd = 0; if (outEvents != nullptr) *outEvents = 0; if (outData != nullptr) *outData = nullptr; return result; &#125; // 先执行这里 result = pollInner(timeoutMillis); &#125;&#125; 5.4 Looper.cpp:pollInner123456789101112131415161718192021222324252627282930313233343536373839404142int Looper::pollInner(int timeoutMillis) &#123; ...... // Poll. int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; // 标记正在poll mPolling = true; // EPOLL_MAX_EVENTS默认是16 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // 通过epoll_wait监听mEpollFd文件描述符等待被唤醒, 注意这里timeoutMillis是0 // 也就是说当mEpollFd没有事件时，立刻返回超时 0 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); ...... // poll超时，在执行一次Looper.pollOnce的循环 if (eventCount == 0) &#123; result = POLL_TIMEOUT; goto Done; &#125; // epoll中存在事件 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; // 当epoll中事件描述符是当前Looper的mWakeEventFd时, 说明有线程通过write向该fd写入值 if (fd == mWakeEventFd.get()) &#123; if (epollEvents &amp; EPOLLIN) &#123; // 5.5 执行被唤醒后的处理 awoken(); &#125; else &#123; ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;, epollEvents); &#125; &#125; ...... &#125;Done: ; ...... return result;&#125; int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误。 epfd是 epoll的描述符。 events则是分配好的 epoll_event结构体数组，epoll将会把发生的事件复制到 events数组中 maxevents表示本次可以返回的最大事件数目，通常 maxevents参数与预分配的events数组的大小是相等的。 timeout表示在没有检测到事件发生时最多等待的时间（单位为毫秒），如果 timeout为0，则表示 epoll_wait在 rdllist链表中为空，立刻返回，不会等待。 5.5 Looper.cpp:awoken1234void Looper::awoken() &#123; uint64_t counter; TEMP_FAILURE_RETRY(read(mWakeEventFd.get(), &amp;counter, sizeof(uint64_t)));&#125; 读取mWakeEventFd中的值，也就是之前bg线程通过write写入的1. 然后回到Looper.cpp:pollOnce返回1. 这样UI线程就从epoll_wait阻塞状态(或者一直执行Looper.cpp:pollOnce函数的状态)退出，之后回到java层的MessageQueue.next中继续执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Message next() &#123; ...... int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; ...... // 5.2 转到Native中执行，获取下一次poll的时间 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // 记录当前系统时间 final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; ...... // 尝试找到抵达执行时间的Message if (msg != null) &#123; if (now &lt; msg.when) &#123; // 如果头节点Message的执行时间尚未到来，那么下一次epoll_wait的等待时间就是 // 该message执行时间和当前时间的差值 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 找到可执行的Message了 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; // 头节点标记为下一个 mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); // 打破循环，返回该Message，回到Looper.loopOnce中 // 即执行 [1.4.1] Handler.dispatchMessage return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; ...... &#125; &#125;&#125; 自此，Android的线程切换就结束了。 六. 小结通过上述分析，画一张图来展示一次Message的执行: 6.1 Epoll机制关于Eopll推荐大家阅读这篇文: Epoll本质 https://zhuanlan.zhihu.com/p/63179839 cpu running Ui Thread: epoll_wait Bg Thread: write fd Ui Thread: read","categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"Looper","slug":"Android/Looper","permalink":"https://swallowjoe.github.io/categories/Android/Looper/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"Looper","slug":"Looper","permalink":"https://swallowjoe.github.io/tags/Looper/"}]},{"title":"Vulkan入门(15)-图像视图和采样器","slug":"Vulkan入门-15-图像视图和采样器","date":"2022-02-26T19:35:34.000Z","updated":"2022-02-26T19:44:47.967Z","comments":true,"path":"2022/02/27/Vulkan入门-15-图像视图和采样器/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/","excerpt":"简述回顾上一篇章中的读取图像的步骤: 首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存 通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象 用VkBuffer图像文件中的像素填充创建的VkImage图像对象 填充图像对象需要使用VkImageMemoryBarrier 使用vkCmdPipelineBarrier使得图像填充Barrier生效 通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充) 再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样 创建图像视图和图像采样器 添加一个组合的图像采样器描述符来从纹理中采样颜色 在图像采样器创建之前，我们首先看看纹理图像视图，这个是在我们创建交换链的时候见过:","text":"简述回顾上一篇章中的读取图像的步骤: 首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存 通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象 用VkBuffer图像文件中的像素填充创建的VkImage图像对象 填充图像对象需要使用VkImageMemoryBarrier 使用vkCmdPipelineBarrier使得图像填充Barrier生效 通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充) 再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样 创建图像视图和图像采样器 添加一个组合的图像采样器描述符来从纹理中采样颜色 在图像采样器创建之前，我们首先看看纹理图像视图，这个是在我们创建交换链的时候见过: 一. 纹理图像视图 Texture Image View通过VkImageView类来存储纹理图像视图, 它描述了如何访问图像以及要访问的图像部分，创建VkImageView的方式也是通过一个结构体：VkImageViewCreateInfo, 来指明细节. 这部分我们在之前的交换链创建图像视图中有过接触，如果忘记了的话可以回顾一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061VkImageView textureImageView;void initVulkan() &#123; ... createTextureImage(); createTextureImageView(); createVertexBuffer(); ...&#125;VkImageView createImageView(VkImage image, VkFormat format) &#123; VkImageView imageView; VkImageViewCreateInfo viewInfo = &#123;&#125;; viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; viewInfo.image = image; // 绑定 VkImage // viewType和format字段指定应如何解释图像数据 // viewType参数指定图像为一维纹理，二维纹理，三维纹理或立方体贴图 viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; // 图像格式 viewInfo.format = format; // subresourceRange字段描述了图像的目的是什么以及应该访问图像的哪个部分。 // 这里图像将用作颜色目标，没有任何mipmapping级别或多个层。 viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; viewInfo.subresourceRange.baseMipLevel = 0; viewInfo.subresourceRange.levelCount = 1; viewInfo.subresourceRange.baseArrayLayer = 0; viewInfo.subresourceRange.layerCount = 1; // 注意，通过vkCreateXXX创建的对象，不需要时要主动去释放 if (vkCreateImageView(device, &amp;viewInfo, nullptr, &amp;imageView) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create image views!&quot;); &#125; return imageView;&#125;void createImageViews() &#123; // 设置集合大小 swapChainImageViews.resize(swapChainImages.size()); for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) &#123; swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat); &#125;&#125;void createTextureImageView() &#123; textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_UNORM);&#125;// 在 vulkan 中推荐在创建的资源不需要后主动释放void cleanup() &#123; // 清理交换链关联资源 cleanupSwapChain(); // 清理纹理贴图 vkDestroyImageView(device, textureImageView, nullptr); vkDestroyImage(device, textureImage, nullptr); vkFreeMemory(device, textureImageMemory, nullptr); ...&#125; 如上，纹理图像的视图创建成功了，很简单。接下来就是采样器的创建了。 二. 采样器着色器可以直接从图像读取纹理像素，但是当将其用作纹理时，一般不会直接读取。 通常通过采样器访问纹理，采样器将应用过滤和转换以计算最终获取的颜色。 这些过滤器有助于处理过采样等问题。 考虑一个映射到几何图形的纹理，该纹理的碎片多于纹理像素。 如果只是在每个片段中使用最接近的纹理像素作为纹理坐标，那么将获得下图左边图像的结果： 而通过线性插值法将4个最接近的纹理像素组合在一起，那么将获得如上右图所示的更平滑的结果。 当然，您的应用程序可能具有更适合左侧风格的艺术风格要求（比如Minecraft，哈哈），但是在常规图形应用程序中，右侧风格是首选，图像越精细越好。 从纹理读取颜色时，采样器对象会自动为您应用此过滤。 抽样不足(欠采样)则是相反的问题，比如纹理像素多于片段。这将导致在以锐角采样高频图案(如棋盘纹理)时产生伪影: 如左图所示，纹理在远处变得模糊混乱。解决这个问题的方法是各向异性滤波，它也可以由采样器自动应用。 除了这些过滤器，采样器还可以处理转换。它决定当你试图通过它的寻址模式读取图像外的texel时会发生什么。下面的图片显示了一些可能性: 2.1 createTextureSampler现在创建一个函数createTextureSampler来设置这样的采样对象。稍后我们将在着色器中使用采样器从纹理中读取颜色: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061VkImageView textureImageView;VkSampler textureSampler;...void initVulkan() &#123; ... createTextureImage(); createTextureImageView(); createTextureSampler(); ...&#125;void createTextureSampler() &#123; // 采样器通过VkSamplerCreateInfo结构进行配置，该结构指定了应应用的所有过滤器和转换。 VkSamplerCreateInfo samplerInfo = &#123;&#125;; samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO; // magFilter和minFilter字段指定如何对放大或缩小的纹理像素进行插值。 // 放大倍数与上面描述的过采样问题有关，而缩小倍数与欠采样有关。 // 指定要应用于查找的放大滤镜为线性过滤 samplerInfo.magFilter = VK_FILTER_LINEAR; // 指定要应用于查找的缩小过滤器为线性过滤 samplerInfo.minFilter = VK_FILTER_LINEAR; // 指定U、V、W坐标的[0..1]范围之外的寻址模式, 指定当超出图像尺寸时，重复纹理 // 注意，轴称为U，V和W，而不是X，Y和Z。这是纹理空间坐标的约定 samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT; samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT; samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT; // anisotropyEnable为true, 采样器使用使用各向异性过滤 samplerInfo.anisotropyEnable = VK_TRUE; samplerInfo.maxAnisotropy = 16; // borderColor字段指定在使用边界寻址模式对图像进行采样以外时返回的颜色。 // 可以以float或int格式返回黑色，白色或透明。 samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK; // 指定要用于处理图像中纹理像素的坐标系 // 为VK_FALSE，则将使用所有轴上的[0，1）范围对纹理像素进行寻址 samplerInfo.unnormalizedCoordinates = VK_FALSE; // 如果启用了比较功能，则将首先将纹理像素与一个值进行比较，并且该比较的结果将用于过滤操作中。 主要用于阴影贴图上的百分比封闭器过滤。 samplerInfo.compareEnable = VK_FALSE; samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS; // 所有这些字段都适用于mipmapping。以后讨论mipmapping samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR; samplerInfo.mipLodBias = 0.0f; samplerInfo.minLod = 0.0f; samplerInfo.maxLod = 0.0f; // 创建采样器，注意清理 if (vkCreateSampler(device, &amp;samplerInfo, nullptr, &amp;textureSampler) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create texture sampler!&quot;); &#125;&#125;void cleanup() &#123; cleanupSwapChain(); // 清理采样器 vkDestroySampler(device, textureSampler, nullptr); ...&#125; samplerInfo中的anisotropyEnable和maxAnisotropy这两个字段指定是否应该使用各向异性过滤。最大各向异性字段限制了可以用来计算最终颜色的texel样本的数量。数值越低，性能越好，但质量越低。目前没有任何图形硬件可以使用超过16个样本，因为超过这个值的差异就可以忽略不计了。 unnormalizedCoordinates字段指定要用于处理图像中纹理像素的坐标系。 如果此字段为VK_TRUE，则可以简单地使用[0，texWidth）和[0，texHeight）范围内的坐标。 如果为VK_FALSE，则将使用所有轴上的[0，1）范围对纹理像素进行寻址。 实际应用中几乎总是使用归一化的坐标，因为这样一来，便可以使用分辨率完全相同的不同分辨率的纹理。 请注意，采样器未在任何地方引用VkImage。 采样器是一个独特的对象，它提供了一个接口来从纹理中提取颜色。 它可以应用于所需的任何图像，无论是1D，2D还是3D。 这与许多较早的API不同，后者将纹理图像和过滤合并为一个状态。 2.2 VkSamplerCreateInfoVkSamplerCreateInfo结构体指定了采样器对象的状态： 1234567891011121314151617181920typedef struct VkSamplerCreateInfo &#123; VkStructureType sType; const void* pNext; VkSamplerCreateFlags flags; VkFilter magFilter; VkFilter minFilter; VkSamplerMipmapMode mipmapMode; VkSamplerAddressMode addressModeU; VkSamplerAddressMode addressModeV; VkSamplerAddressMode addressModeW; float mipLodBias; VkBool32 anisotropyEnable; float maxAnisotropy; VkBool32 compareEnable; VkCompareOp compareOp; float minLod; float maxLod; VkBorderColor borderColor; VkBool32 unnormalizedCoordinates;&#125; VkSamplerCreateInfo; sType是此结构的类型， VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO pNext是NULL或指向扩展特定结构的指针 flag是VkSamplerCreateFlagBits的位掩码，描述了采样器的其他参数 magFilter是VkFilter值，用于指定要应用于查找的放大滤镜 VK_FILTER_NEAREST 指定最近的过滤 VK_FILTER_LINEAR 指定线性过滤 VK_FILTER_CUBIC_EXT 指定三次过滤 VK_FILTER_CUBIC_IMG 指定三次过滤，同VK_FILTER_CUBIC_EXT minFilter是一个VkFilter值，用于指定要应用于查找的缩小过滤器 mipmapMode是VkSamplerMipmapMode值，指定要应用于查找的mipmap过滤器 addressModeU是VkSamplerAddressMode值，用于为U坐标指定[0..1]范围之外的寻址模式 VK_SAMPLER_ADDRESS_MODE_REPEAT 当超出图像尺寸时，重复纹理 VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT 类似于重复，但是当超出尺寸时会反转坐标以镜像图像 VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 在图像尺寸之外，获取最靠近坐标的边缘的颜色 VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER 当采样超出图像尺寸时，返回纯色 VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE 类似CLAMP_TO_EDGE，但使用与最近边缘相反的边缘,仅在启用samplerMirrorClampToEdge或启用[VK_KHR_sampler_mirror_clamp_to_edge]扩展名后才有效 addressModeV是VkSamplerAddressMode值，用于指定V坐标的[0..1]范围之外的寻址模式 addressModeW是VkSamplerAddressMode值，它为W坐标指定[0..1]范围之外的寻址模式 mipLodBias是要添加到mipmap LOD（详细程度）计算中的偏差，以及由SPIR-V中的图像采样功能提供的偏差 anisotropyEnable为VK_TRUE以启用各向异性过滤，如“ Texel各向异性过滤”部分所述，否则为VK_FALSE maxAnisotropy是anisotropyEnable为VK_TRUE时采样器使用的各向异性值钳位。如果anisotropyEnable为VK_FALSE，则maxAnisotropy被忽略 compareEnable为VK_TRUE，以允许在查找过程中与参考值进行比较，否则为VK_FALSE 注意：如果此成员不匹配，则某些实现将默认为着色器状态 compareOp是一个VkCompareOp值，它指定比较功能，以按“深度比较操作”部分所述在过滤之前将其应用于获取的数据 minLod和maxLod是用于钳位计算的LOD值的值 borderColor是VkBorderColor值，用于指定要使用的预定义边框颜色 unnormalizedCoordinates指定要用于处理图像中纹理像素的坐标系。设置为VK_TRUE时，用于查找纹理像素的图像坐标的范围在0到x，y和z的图像尺寸的范围内。设置为VK_FALSE时，图像坐标范围为零到一。 当unnormalizedCoordinates为VK_TRUE时，在着色器中使用采样器的图像具有以下要求： viewType必须为VK_IMAGE_VIEW_TYPE_1D或VK_IMAGE_VIEW_TYPE_2D 图像视图必须具有单个图层和单个mip级别 当unnormalizedCoordinates为VK_TRUE时，使用采样器的着色器中的图像内置函数具有以下要求： 这些功能不得使用投影 这些函数不得使用偏移量 2.3 vkCreateSamplerVkSampler对象表示图像采样器的状态，实现可使用该对象读取图像数据并为着色器应用过滤和其他转换。 12345VkResult vkCreateSampler( VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler); device是创建采样器的逻辑设备 pCreateInfo是指向VkSamplerCreateInfo结构的指针，该结构指定采样器对象的状态 pAllocator控制主机内存分配 pSampler是指向VkSampler句柄的指针，在该句柄中返回生成的采样器对象 2.4 设备功能之各向异性过滤如果现在运行程序，则会看到如下所示的验证层消息： 这是因为各向异性过滤实际上是一个可选的设备特性。我们需要更新createLogicalDevice函数来请求它: 12VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;;deviceFeatures.samplerAnisotropy = VK_TRUE; 即使现在的显卡不支持它的可能性很小，我们也应该更新isDeviceSuitable来检查它是否可用: 1234567bool isDeviceSuitable(VkPhysicalDevice device) &#123; ... VkPhysicalDeviceFeatures supportedFeatures; vkGetPhysicalDeviceFeatures(device, &amp;supportedFeatures); return indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;&#125; vkGetPhysicalDeviceFeatures重新调整VkPhysicalDeviceFeatures结构的用途，通过设置布尔值来指示支持哪些功能，而不是请求哪些功能。 除了强制各向异性过滤的可用性，也可以通过条件设置不使用它: 12samplerInfo.anisotropyEnable = VK_FALSE;samplerInfo.maxAnisotropy = 1; 2.5 小结现在图像有了，接下来，我们将向着色器公开图像和采样器对象，以便将纹理绘制到正方形上并呈现出来。 三. 组合图像采样器我们在统一缓冲区部分中了解了描述符。 现在我们看一种新型的描述符：组合图像采样器。 该描述符使着色器可以通过采样器对象访问图像资源。 我们将从修改描述符布局，描述符池和描述符集开始，以包括此类组合的图像采样器描述符。 之后，我们将向顶点添加纹理坐标，并修改片段着色器以从纹理读取颜色，而不仅仅是插入顶点颜色。 3.1 更新描述符回到createDescriptorSetLayout函数，为组合的图像采样器描述符添加VkDescriptorSetLayoutBinding。 将其放在统一缓冲区之后的绑定中： 12345678910111213141516171819202122232425262728293031323334void createDescriptorSetLayout() &#123; VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;; // 指定在着色器中使用的绑定 uboLayoutBinding.binding = 0; // 描述符的类型 uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; uboLayoutBinding.descriptorCount = 1; // 指定描述符将在顶点着色器阶段被引用 uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT; // pImmutableSamplers仅与图像采样描述符有关 uboLayoutBinding.pImmutableSamplers = nullptr; // 创建采样器描述符 VkDescriptorSetLayoutBinding samplerLayoutBinding = &#123;&#125;; samplerLayoutBinding.binding = 1; samplerLayoutBinding.descriptorCount = 1; samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; samplerLayoutBinding.pImmutableSamplers = nullptr; // 指明片段着色器阶段可以使用组合的图像采样器描述符, 那就是片段颜色确定的地方。 // 可以在顶点着色器中使用纹理采样，例如通过高度图使顶点网格动态变形。 samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT; std::array&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings = &#123;uboLayoutBinding, samplerLayoutBinding&#125;; VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;; layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO; layoutInfo.bindingCount = static_cast&lt;uint32_t&gt;(bindings.size()); layoutInfo.pBindings = bindings.data(); // 创建描述符集布局 if (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, nullptr, &amp;descriptorSetLayout) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create descriptor set layout!&quot;); &#125;&#125; 如果您现在运行带有验证层的应用程序，那么会发现描述符池无法使用此布局分配描述符集，因为它没有任何组合的图像采样器描述符。 转到createDescriptorPool函数并对其进行修改，以包括此描述符的VkDescriptorPoolSize： 1234567891011121314151617181920212223242526void createDescriptorPool() &#123; VkDescriptorPoolSize poolSize = &#123;&#125;; // 我们创建的是统一缓冲的描述符 poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; poolSize.descriptorCount = static_cast&lt;uint32_t&gt;(swapChainImages.size()); std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes = &#123;&#125;; // 第一个是统一缓冲区描述符 poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; poolSizes[0].descriptorCount = static_cast&lt;uint32_t&gt;(swapChainImages.size()); // 第二个是纹理图像采样器描述符 poolSizes[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; poolSizes[1].descriptorCount = static_cast&lt;uint32_t&gt;(swapChainImages.size()); VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;; poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO; poolInfo.poolSizeCount = static_cast&lt;uint32_t&gt;(poolSizes.size()); poolInfo.pPoolSizes = poolSizes.data(); // 除了可用的单个描述符的最大数量外，还需要指定可以分配的最大描述符集数量：与交换链图像数量一致 poolInfo.maxSets = static_cast&lt;uint32_t&gt;(swapChainImages.size()); // 创建描述符池 if (vkCreateDescriptorPool(device, &amp;poolInfo, nullptr, &amp;descriptorPool) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create descriptor pool!&quot;); &#125;&#125; 最后一步是将实际图像和采样器资源绑定到描述符集中的描述符。 转到createDescriptorSets函数: 123456789101112131415161718192021222324252627282930313233343536373839void createDescriptorSets() &#123; ... // 配置描述符 for (size_t i = 0; i &lt; descriptorSets.size(); i++) &#123; ... // 绑定图像视图和采样器到描述符中 VkDescriptorImageInfo imageInfo = &#123;&#125;; imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; // 必须在VkDescriptorImageInfo结构中指定用于组合图像采样器结构的资源 imageInfo.imageView = textureImageView; imageInfo.sampler = textureSampler; std::array&lt;VkWriteDescriptorSet, 2&gt; descriptorWrites = &#123;&#125;; descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; descriptorWrites[0].dstSet = descriptorSets[i]; descriptorWrites[0].dstBinding = 0; descriptorWrites[0].dstArrayElement = 0; // 绑定统一缓冲区至描述符 descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; descriptorWrites[0].descriptorCount = 1; descriptorWrites[0].pBufferInfo = &amp;bufferInfo; descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; descriptorWrites[1].dstSet = descriptorSets[i]; descriptorWrites[1].dstBinding = 1; descriptorWrites[1].dstArrayElement = 0; // 绑定图像视图和相应的采样器至描述符 descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER; descriptorWrites[1].descriptorCount = 1; descriptorWrites[1].pImageInfo = &amp;imageInfo; // 应用描述符集更新 vkUpdateDescriptorSets(device, static_cast&lt;uint32_t&gt;(descriptorWrites.size()), descriptorWrites.data(), 0, nullptr); &#125;&#125; 必须在VkDescriptorImageInfo结构中指定用于组合图像采样器结构的资源，就像在VkDescriptorBufferInfo结构中指定用于统一缓冲区描述符的缓冲区资源一样。 3.2 纹理坐标纹理映射还有一个重要要素就是每个顶点的实际坐标。 坐标决定了图像如何实际映射到几何体: 123456789101112131415161718192021222324252627282930313233343536struct Vertex &#123; glm::vec2 pos; glm::vec3 color; glm::vec2 texCoord; static VkVertexInputBindingDescription getBindingDescription() &#123; VkVertexInputBindingDescription bindingDescription = &#123;&#125;; bindingDescription.binding = 0; bindingDescription.stride = sizeof(Vertex); bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX; return bindingDescription; &#125; static std::array&lt;VkVertexInputAttributeDescription, 3&gt; getAttributeDescriptions() &#123; std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions = &#123;&#125;; // position 顶点输入位置属性描述符 attributeDescriptions[0].binding = 0; attributeDescriptions[0].location = 0; attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT; attributeDescriptions[0].offset = offsetof(Vertex, pos); // color 顶点输入颜色属性描述符 attributeDescriptions[1].binding = 0; attributeDescriptions[1].location = 1; attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT; attributeDescriptions[1].offset = offsetof(Vertex, color); // coordinates 顶点输入坐标属性描述符 attributeDescriptions[2].binding = 0; attributeDescriptions[2].location = 2; attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT; attributeDescriptions[2].offset = offsetof(Vertex, texCoord); return attributeDescriptions; &#125;&#125;; 修改“顶点”结构，使其包含用于纹理坐标的vec2（texCoord）。 确保还添加了VkVertexInputAttributeDescription，以便我们可以将访问纹理坐标用作顶点着色器中的输入。 要将它们传递到片段着色器以便在正方形表面上进行插值，这是必要的。 123456const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;-0.5f, -0.5f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, -0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;, &#123;1.0f, 1.0f&#125;&#125;&#125;; 先使用从左上角的0、0到右下角的1、1的坐标简单地用纹理填充正方形。 随意尝试使用不同的坐标。 稍后我们看看低于0或高于1的坐标下的实际的寻址模式！ 3.3 着色器最后一步是修改着色器，以从纹理中采样颜色。 我们首先需要修改顶点着色器，以将纹理坐标传递到片段着色器： 123456789101112layout(location = 0) in vec2 inPosition;layout(location = 1) in vec3 inColor;layout(location = 2) in vec2 inTexCoord;layout(location = 0) out vec3 fragColor;layout(location = 1) out vec2 fragTexCoord;void main() &#123; gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0); fragColor = inColor; fragTexCoord = inTexCoord;&#125; 就像每个顶点的颜色一样，栅格化器会将fragTexCoord值平滑地插入到正方形区域中。 我们可以通过使片段着色器将纹理坐标输出为颜色来形象化： 1234567891011#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragColor;layout(location = 1) in vec2 fragTexCoord;layout(location = 0) out vec4 outColor;void main() &#123; outColor = vec4(fragTexCoord, 0.0, 1.0);&#125; 现在我们编译下着色器，然后运行下程序: 3.3.1 片段着色器中的图像采样器描述符组合的图像采样器描述符在GLSL中由采样器统一表示。 在片段着色器中添加对它的引用： 123456# 对于其他类型的图像，存在等效的sampler1D和sampler3D类型。 确保在此处使用正确的绑定。 layout(binding = 1) uniform sampler2D texSampler;void main() &#123; outColor = texture(texSampler, fragTexCoord);&#125; 编译一下shader然后运行程序: 哒哒，一个旋转的贴图出现了！","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(14)-VkImage图像的创建","slug":"Vulkan入门-14-VkImage图像的创建","date":"2022-02-26T19:35:18.000Z","updated":"2022-02-26T19:44:04.385Z","comments":true,"path":"2022/02/27/Vulkan入门-14-VkImage图像的创建/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"简述在之前我们使用顶点着色器以及描述符来实现绘制有颜色的几何体，还实现了旋转动画。接下来我们学习一下纹理贴图，这个将是我们实现加载绘制基本3D模型的基础。","text":"简述在之前我们使用顶点着色器以及描述符来实现绘制有颜色的几何体，还实现了旋转动画。接下来我们学习一下纹理贴图，这个将是我们实现加载绘制基本3D模型的基础。 添加纹理的基本步骤有: 创建由设备内存支持的图像对象 用图像文件中的像素填充创建的图像对象 创建图像采样器 添加一个组合的图像采样器描述符来从纹理中采样颜色 我们以前已经使用过图像对象，但是这些对象是由swap chain扩展自动创建的。这次需要手动创建，创建图像并填充数据类似于创建顶点缓冲区。我们将通过创建一个暂存资源和填充它与像素数据，然后我们复制这到我们将用于渲染的最终图像对象。 可以创建一个暂存图像，不过Vulkan允许将像素从VkBuffer复制到image中，而且这个API在某些硬件上实际上更快。我们将首先创建这个缓冲区并填充像素值，然后我们将创建一个图像复制像素到。创建image与创建缓冲区并没有太大的不同。它包括查询内存需求、分配设备内存并绑定它，就像我们之前看到的那样。 图像可以有不同的布局，影响像素在内存中的存储方式。例如，由于图形硬件的工作方式，简单地逐行存储像素可能不会带来最好的性能。当对图像执行任何操作时，确保它们具有在该操作中使用的最佳布局。比如指定渲染通道时其中一些布局有: VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 适合呈现（present） VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:片段着色器中写入颜色的最佳附件 VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: 作为传输操作的最佳源，如vkCmdCopyImageToBuffer VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 作为传输操作的最佳目的地，如vkCmdCopyBufferToImage VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: 适合着色器采样 转换图像布局的最常见方法之一是管道屏障（pipeline barrier）。管道屏障主要用于同步对资源的访问，例如确保在读取图像之前将其写入。后面我们将了解如何将管道壁垒用于转换布局。 使用VK_SHARING_MODE_EXCLUSIVE时，可以另外使用屏障来转移队列系列的所有权。 一. 纹理贴图1.1 图像库有许多库可用于加载图像，您甚至可以编写自己的代码来加载BMP和PPM等简单格式。 这里我们将使用stb集合中的stb_image库。 这样做的好处是所有代码都在一个文件中，因此不需要任何棘手的构建配置。 下载stb_image.h并将其存储在方便的位置，例如保存GLFW和GLM的目录。 将位置添加到您的包含路径。 stb_image库地址: https://github.com/nothings/stb 下载后解压，放在指定目录，然后修改我们的Makefile文件： 1234VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.2.170.0/x86_64STB_IMAGE_PATH = /home/jh/Program/stb-imageCFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/include -I$(STB_IMAGE_PATH) 1.1 读取图片在shaders目录旁边创建一个新的目录textures来存储纹理图像： 首先添加头文件: 12#define STB_IMAGE_IMPLEMENTATION#include &lt;stb_image.h&gt; 默认情况下，头文件只定义函数的原型。一个代码文件需要包含STB_IMAGE_IMPLEMENTATION定义的头文件来包含函数体，否则会有链接错误。 12345678910111213141516171819void initVulkan() &#123; ... createCommandPool(); // 因为需要使用指令缓冲，所以在创建指令池之后调用 createTextureImage(); createVertexBuffer(); ...&#125;void createTextureImage() &#123; int texWidth, texHeight, texChannels; // 加载texture.jpg图像 stbi_uc* pixels = stbi_load(&quot;textures/texture.jpg&quot;, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha); // 每个像素4个字节 VkDeviceSize imageSize = texWidth * texHeight * 4; if (!pixels) &#123; throw std::runtime_error(&quot;failed to load texture image!&quot;); &#125;&#125; stbi_load函数将文件路径和要加载的通道数量作为参数。STBI_rgb_alpha值会强制为图像加载Alpha通道，即使它没有通道也是如此, 与其他纹理保持一致性。中间的三个参数是输出图像中通道的宽度、高度和实际数量。返回的指针是像素值数组中的第一个元素。在STBI_rgba_alpha中，像素逐行排列，每个像素4个字节，总共texWidth * texHeight * 4个值。 1.2 缓存读取的图片现在，我们将在主机可见内存中创建一个缓冲区，以便我们可以使用vkMapMemory并将像素复制到其中。 将此临时缓冲区的变量添加到createTextureImage函数： 12345678910111213141516171819202122232425void createTextureImage() &#123; int texWidth, texHeight, texChannels; // 加载texture.jpg图像 stbi_uc* pixels = stbi_load(&quot;textures/texture.jpg&quot;, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha); // 每个像素4个字节 VkDeviceSize imageSize = texWidth * texHeight * 4; if (!pixels) &#123; throw std::runtime_error(&quot;failed to load texture image!&quot;); &#125; VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; // 缓冲区应该在主机可见内存中，以便我们可以映射它，并且它应该可用作传输源，以便我们以后可以复制 createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory); // 内存映射 void* data; vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &amp;data); memcpy(data, pixels, static_cast&lt;size_t&gt;(imageSize)); vkUnmapMemory(device, stagingBufferMemory); // 最后释放原始像素数据 stbi_image_free(pixels);&#125; 1.3 纹理图像(Texture Image)尽管我们可以设置着色器来访问缓冲区中的像素值，但为此目的最好使用Vulkan中的图像对象-VkImage。 通过使用2D坐标，图像对象将使检索颜色更加容易和快捷。 图像对象中的像素称为纹理像素： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849VkImage textureImage;VkDeviceMemory textureImageMemory;void createTextureImage() &#123; ... VkImageCreateInfo imageInfo = &#123;&#125;; imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; imageInfo.imageType = VK_IMAGE_TYPE_2D; //二维图像 imageInfo.extent.width = static_cast&lt;uint32_t&gt;(texWidth); imageInfo.extent.height = static_cast&lt;uint32_t&gt;(texHeight); imageInfo.extent.depth = 1; // 图像的最小采样的细节级别 imageInfo.mipLevels = 1; // 图像中的层数 imageInfo.arrayLayers = 1; // 指定图像格式，对于像素像素，使用与缓冲区中像素相同的格式，否则复制操作将失败 imageInfo.format = VK_FORMAT_R8G8B8A8_UNORM; // 图像平铺模式,这里指定图像像素最佳内存拼接布局 // 与图像的布局不同，平铺模式不能在以后更改。如果希望能够直接访问图像内存中的texel，则必须使用VK_IMAGE_TILING_OPTIMAL imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL; // 图像的initialLayout只有两个可能的值：VK_IMAGE_LAYOUT_UNDEFINED || VK_IMAGE_LAYOUT_PREINITIALIZED imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT; // 图像将仅由一个队列族使用, 因此独占模式 imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; // 图像采样 imageInfo.samples = VK_SAMPLE_COUNT_1_BIT; imageInfo.flags = 0; // Optional // 创建图像 if (vkCreateImage(device, &amp;imageInfo, nullptr, &amp;textureImage) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create image!&quot;); &#125; // 同样的，需要给Image分配内存空间 VkMemoryRequirements memRequirements; vkGetImageMemoryRequirements(device, textureImage, &amp;memRequirements); VkMemoryAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; allocInfo.allocationSize = memRequirements.size; allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT); if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;textureImageMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate image memory!&quot;); &#125; // 绑定图像和内存 vkBindImageMemory(device, textureImage, textureImageMemory, 0);&#125; 对于initialLayout，很少有情况需要在第一次过渡期间保留纹理像素，但是如果想将图像与VK_IMAGE_TILING_LINEAR布局结合使用作为缓存图像。 在这种情况下，将纹理像素数据上传到其中，然后将图像转换为传输源而又不丢失数据。但是，我们首先将图像转换为传输目标，然后从缓冲区对象将纹理像素数据复制到该图像，因此使用VK_IMAGE_LAYOUT_UNDEFINED。 对于usage, 与缓冲区创建期间的含义相同。 该图像将用作缓冲区副本的目的地，因此应将其设置为传输目的地。 我们还希望能够从着色器访问图像来为网格着色，因此用法应包括VK_IMAGE_USAGE_SAMPLED_BIT。 采样标志与多重采样有关。 这仅与将用作附件的图像有关，这里使用一个样本。 对于与稀疏图像有关的图像，有一些可选的标志。 稀疏图像是其中实际上仅某些区域由内存支持的图像。 例如，如果将3D纹理用于体素地形，则可以使用它来避免分配内存来存储大量的“空”值，这里我们设置为0。 1.3.1 VkImageCreateInfo创建图像的一系列参数是在VkImageCreateInfo中指明的： 1234567891011121314151617typedef struct VkImageCreateInfo &#123; VkStructureType sType; const void* pNext; VkImageCreateFlags flags; VkImageType imageType; VkFormat format; VkExtent3D extent; uint32_t mipLevels; uint32_t arrayLayers; VkSampleCountFlagBits samples; VkImageTiling tiling; VkImageUsageFlags usage; VkSharingMode sharingMode; uint32_t queueFamilyIndexCount; const uint32_t* pQueueFamilyIndices; VkImageLayout initialLayout;&#125; VkImageCreateInfo; sType是此结构的类型,VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO pNext是NULL或指向扩展特定结构的指针 flag是VkImageCreateFlagBits的位掩码，用于描述图像的其他参数 imageType是VkImageType值，用于指定图像的基本尺寸。就图像类型而言，阵列纹理中的图层不算作尺寸 VK_IMAGE_TYPE_1D指定一维图像 VK_IMAGE_TYPE_2D指定二维图像 VK_IMAGE_TYPE_3D指定三维图像 format是一种VkFormat，它描述了将包含在图像中的texel块的格式和类型 extent是一个VkExtent3D，它描述基本级别的每个维度中的数据元素数量 mipLevels描述可用于图像的最小采样的细节级别的数量 arrayLayers是图像中的层数 samples是VkSampleCountFlagBits，用于指定每个纹理像素的样本数 tiling是一个VkImageTiling值，它指定内存中纹理元素块的平铺模式 VK_IMAGE_TILING_LINEAR: 以主要行顺序排列像素 VK_IMAGE_TILING_OPTIMAL: 指定最佳平铺（纹理像素以实现相关的安排进行布局，以实现更好的内存访问） VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: 表示图片的拼贴是由Linux DRM格式修饰符定义的 usage是VkImageUsageFlagBits的位掩码，用于描述图像的预期用法 SharingMode是VkSharingMode值，用于指定多个队列系列将访问图像时的图像共享模式 queueFamilyIndexCount是pQueueFamilyIndi​​ces数组中的条目数 pQueueFamilyIndi​​ces是将访问此图像的队列系列的列表（如果sharedMode不是VK_SHARING_MODE_CONCURRENT，则将被忽略） initialLayout是一个VkImageLayout值，它指定图像的所有图像子资源的初始VkImageLayout。请参阅图像布局 VK_IMAGE_LAYOUT_UNDEFINED: GPU不可用，第一次转换将丢弃纹理像素 VK_IMAGE_LAYOUT_PREINITIALIZED:GPU无法使用，但第一个过渡将保留纹理像素 1.3.2 vkCreateImage图像表示多维（最多3个）数据数组，可用于各种目的（例如附件、纹理），通过描述符集将其绑定到图形或计算管道，或直接将其指定为特定命令的参数。 12345VkResult vkCreateImage( VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage); device是创建Image的逻辑设备 pCreateInfo是指向VkImageCreateInfo结构的指针，该结构包含用于创建图像的参数 pAllocator如“内存分配”一章中所述控制主机内存分配 pImage是指向VkImage句柄的指针，在该句柄中返回生成的图像对象 1.3.3 createImage现在我们重构下createTextureImage, 将创建VkImage的部分单独做个函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778void createImage(uint32_t width, uint32_t height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory) &#123; VkImageCreateInfo imageInfo = &#123;&#125;; imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; imageInfo.imageType = VK_IMAGE_TYPE_2D; //二维图像 imageInfo.extent.width = static_cast&lt;uint32_t&gt;(width); imageInfo.extent.height = static_cast&lt;uint32_t&gt;(height); imageInfo.extent.depth = 1; // 图像的最小采样的细节级别 imageInfo.mipLevels = 1; // 图像中的层数 imageInfo.arrayLayers = 1; imageInfo.format = format; // 图像平铺模式,这里指定图像像素最佳内存拼接布局 // 与图像的布局不同，平铺模式不能在以后更改。如果希望能够直接访问图像内存中的texel，则必须使用VK_IMAGE_TILING_OPTIMAL imageInfo.tiling = tiling; // 图像的initialLayout只有两个可能的值：VK_IMAGE_LAYOUT_UNDEFINED || VK_IMAGE_LAYOUT_PREINITIALIZED imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; imageInfo.usage = usage; // 图像将仅由一个队列族使用, 因此独占模式 imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; // 图像采样 imageInfo.samples = VK_SAMPLE_COUNT_1_BIT; imageInfo.flags = 0; // Optional // 创建图像 if (vkCreateImage(device, &amp;imageInfo, nullptr, &amp;image) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create image!&quot;); &#125; // 同样的，需要给Image分配内存空间 VkMemoryRequirements memRequirements; vkGetImageMemoryRequirements(device, image, &amp;memRequirements); VkMemoryAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; allocInfo.allocationSize = memRequirements.size; allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT); if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;imageMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate image memory!&quot;); &#125; // 绑定图像和内存 vkBindImageMemory(device, image, imageMemory, 0);&#125;void createTextureImage() &#123; int texWidth, texHeight, texChannels; // 加载texture.jpg图像 stbi_uc* pixels = stbi_load(&quot;textures/texture.jpg&quot;, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha); // 每个像素4个字节 VkDeviceSize imageSize = texWidth * texHeight * 4; if (!pixels) &#123; throw std::runtime_error(&quot;failed to load texture image!&quot;); &#125; VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; // 缓冲区应该在主机可见内存中，以便我们可以映射它，并且它应该可用作传输源，以便我们以后可以复制 createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE); // 内存映射 void* data; vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &amp;data); memcpy(data, pixels, static_cast&lt;size_t&gt;(imageSize)); vkUnmapMemory(device, stagingBufferMemory); // 最后释放原始像素数据 stbi_image_free(pixels); createImage(texWidth, texHeight, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);&#125; 1.4 布局转换我们需要再次记录和执行一个命令缓冲区以完成布局转换功能，所以最好是将执行指令缓冲区的部分逻辑抽离: 123456789101112131415161718192021222324252627282930VkCommandBuffer beginSingleTimeCommands() &#123; VkCommandBufferAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandPool = commandPool; allocInfo.commandBufferCount = 1; VkCommandBuffer commandBuffer; vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer); VkCommandBufferBeginInfo beginInfo = &#123;&#125;; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT; vkBeginCommandBuffer(commandBuffer, &amp;beginInfo); return commandBuffer;&#125;void endSingleTimeCommands(VkCommandBuffer commandBuffer) &#123; vkEndCommandBuffer(commandBuffer); VkSubmitInfo submitInfo = &#123;&#125;; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &amp;commandBuffer; vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE); vkQueueWaitIdle(graphicsQueue); vkFreeCommandBuffers(device, commandPool, 1, &amp;commandBuffer);&#125; 现在有了beginSingleTimeCommands和endSingleTimeCommands函数，可以对执行单条指令缓冲区的函数进行优化： 1234567891011121314void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) &#123; VkCommandBuffer commandBuffer= beginSingleTimeCommands(); // 缓冲拷贝指令 VkBufferCopy copyRegion = &#123;&#125;; copyRegion.srcOffset = 0; // Optional copyRegion.dstOffset = 0; // Optional copyRegion.size = size; // std::cout&lt;&lt;&quot;copyBuffer vkCmdCopyBuffer&quot;&lt;&lt;std::endl; // 缓冲区的内容使用vkCmdCopyBuffer命令传输。 // 源和目标缓冲区以及要复制的区域数组作为参数。copyRegion由源缓冲区偏移量、目标缓冲区偏移量和大小组成 vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &amp;copyRegion); endSingleTimeCommands(commandBuffer);&#125; 如果我们仍然使用缓冲区，那么我们现在可以编写一个函数来记录并执行vkCmdCopyBufferToImage，但是这个命令要求首先将Image置于正确的布局中。 创建一个新函数来处理布局转换： 123456789101112131415161718192021222324252627282930313233343536373839void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout) &#123; VkCommandBuffer commandBuffer = beginSingleTimeCommands(); // 使用图像内存屏障,用于同步资源访问 VkImageMemoryBarrier barrier = &#123;&#125;; barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; // 指定布局转换。如果不关心图像的现有内容，可以将VK_IMAGE_LAYOUT_UNDEFINED用作oldLayout barrier.oldLayout = oldLayout; barrier.newLayout = newLayout; // 如果使用屏障来传递队列族的所有权，那么这两个字段应该是队列族的索引 // 如果不这样做，则必须将它们设置为VK_QUEUE_FAMILY_IGNORED barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; // image和subresourceRange指定受影响的图像以及图像的特定部分 barrier.image = image; barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; // 我们的图像不是数组，也没有mipmapping级别，因此只指定了一个级别和层 barrier.subresourceRange.baseMipLevel = 0; barrier.subresourceRange.levelCount = 1; barrier.subresourceRange.baseArrayLayer = 0; barrier.subresourceRange.layerCount = 1; // 屏障主要用于同步目的，因此必须指定哪些涉及资源的操作类型必须在屏障之前发生，哪些涉及资源的操作必须在屏障上等待 barrier.srcAccessMask = 0; // TODO barrier.dstAccessMask = 0; // TODO // 在管道上执行barrier指令, 所有类型的管道屏障都使用相同的函数提交 vkCmdPipelineBarrier(commandBuffer, 0 /* TODO */, 0 /* TODO */, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier ); endSingleTimeCommands(commandBuffer);&#125; 执行布局转换的最常见方法之一是使用图像内存屏障。像这样的管道屏障通常用于同步对资源的访问，例如确保在从缓冲区读取之前完成对缓冲区的写入，但是当使用VK_SHARING_MODE_EXCLUSIVE时，它也可以用于转换映像布局和传输队列族所有权。对于缓冲区，有一个等效的缓冲存储器屏障来实现这一点。 1.4.1 VkImageMemoryBarrier图像存储器屏障仅适用于涉及特定图像子资源范围的存储器访问。也就是说，从图像存储器屏障形成的存储器依赖被限定为通过指定的图像子资源范围进行访问。图像内存屏障还可用于定义指定图像子资源范围的图像布局转换或队列族所有权转移。 123456789101112typedef struct VkImageMemoryBarrier &#123; VkStructureType sType; const void* pNext; VkAccessFlags srcAccessMask; VkAccessFlags dstAccessMask; VkImageLayout oldLayout; VkImageLayout newLayout; uint32_t srcQueueFamilyIndex; uint32_t dstQueueFamilyIndex; VkImage image; VkImageSubresourceRange subresourceRange;&#125; VkImageMemoryBarrier; sType就是这种结构的类型, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER pNext为NULL或指向特定于扩展的结构的指针 srccessmask是指定源访问掩码的VkAccessFlagBits的位掩码, 指定在哪个管道阶段发生操作，这些操作应该在屏障之前发生 dstAccessMask是指定目标访问掩码的VkAccessFlagBits位掩码, 指定操作将在其中等待屏障的管道阶段 oldLayout是图像布局转换中的旧布局 newLayout是图像布局转换中的新布局 srcQueueFamilyIndex是队列系列所有权转移的源队列系列 dstQueueFamilyIndex是队列系列所有权转移的目标队列系列 image是受此屏障影响的图像 subresourceRange描述图像中受此屏障影响的图像子资源范围 1.4.2 vkCmdPipelineBarriervkCmdPipelineBarrier是一个同步命令，它在提交到同一队列的命令之间或同一子类中的命令之间插入依赖关系。 1234567891011void vkCmdPipelineBarrier( VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers); commandBuffer是将命令记录到的命令缓冲区 srcStageMask是一个指定源级掩码的VkPipelineStageFlagBits的位掩码 dstStageMask是指定目标阶段掩码的VkPipelineStageFlagBits的位掩码 dependencyFlags是VkdePendencyFlags的位掩码，指定如何形成执行和内存依赖关系 memoryBarrierCount是pMemoryBarriers数组的长度 pMemoryBarriers是指向VKMemorySbarrier结构数组的指针 bufferMemoryBarrierCount是pBufferMemoryBarriers数组的长度 pBufferMemoryBarriers是指向VkBufferMemoryBarrier结构数组的指针 imageMemoryBarrierCount是pImageMemoryBarriers数组的长度 pImageMemoryBarriers是指向VkimAgemoryBarrier结构数组的指针 当vkCmdPipelineBarrier提交到队列时，它定义了在它之前提交的命令和在它之后提交的命令之间的内存依赖关系。 如果vkCmdPipelineBarrier是在渲染过程实例外部录制的，则第一个同步作用域将包括按提交顺序较早出现的所有命令。如果vkCmdPipelineBarrier记录在渲染过程实例中，则第一个同步作用域仅包括在同一子过程中以提交顺序较早出现的命令。在这两种情况下，第一个同步作用域仅限于由srcStageMask指定的源阶段掩码确定的管道阶段上的操作。 如果vkCmdPipelineBarrier是在渲染过程实例外部录制的，则第二个同步作用域将包括以后按提交顺序执行的所有命令。如果vkCmdPipelineBarrier记录在渲染过程实例中，则第二个同步作用域仅包括稍后在同一子过程中按提交顺序出现的命令。在任何一种情况下，第二同步作用域都限于由dstStageMask指定的目的级掩码确定的管道级上的操作。 第一个访问范围被限制为在由srcStageMask指定的源阶段掩码确定的管道阶段中进行访问。其中，第一访问作用域仅包括由pMemoryBarriers、pBufferMemoryBarriers和pImageMemoryBarriers数组的元素定义的第一访问作用域，每个元素定义一组内存屏障。如果未指定内存屏障，则第一个访问作用域不包括任何访问。 第二访问范围被限制为在由dstStageMask指定的目标阶段掩码确定的管道阶段中的访问。其中，第二访问作用域仅包括由pMemoryBarriers、pBufferMemoryBarriers和pImageMemoryBarriers数组的元素定义的第二访问作用域，它们各自定义了一组内存屏障。如果未指定内存屏障，则第二访问作用域不包括任何访问。 1.5 拷贝缓存数据至Image就像缓冲区复制一样，需要指定缓冲区的哪个部分将被复制到图像的哪个部分： 12345678910111213141516171819202122232425262728void copyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width, uint32_t height) &#123; VkCommandBuffer commandBuffer = beginSingleTimeCommands(); // 使用VkBufferImageCopy指定缓冲区复制行为 VkBufferImageCopy region = &#123;&#125;; // 指定缓冲区中像素值开始的字节偏移量 region.bufferOffset = 0; // 指定像素在内存中的布局方式, 指定0表示像素紧密打包 region.bufferRowLength = 0; region.bufferImageHeight = 0; // 指示要将像素复制到图像的哪个部分 region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; region.imageSubresource.mipLevel = 0; region.imageSubresource.baseArrayLayer = 0; region.imageSubresource.layerCount = 1; region.imageOffset = &#123;0, 0, 0&#125;; region.imageExtent = &#123;width, height, 1&#125;; // 使用vkCmdCopyBufferToImage函数将缓冲区到图像的复制操作排队 // 第四个参数指示图像当前使用的布局 vkCmdCopyBufferToImage(commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region); endSingleTimeCommands(commandBuffer);&#125; 1.5.1 VkBufferImageCopy12345678typedef struct VkBufferImageCopy &#123; VkDeviceSize bufferOffset; uint32_t bufferRowLength; uint32_t bufferImageHeight; VkImageSubresourceLayers imageSubresource; VkOffset3D imageOffset; VkExtent3D imageExtent;&#125; VkBufferImageCopy; bufferOffset是从复制图像数据的缓冲区对象的起始处开始的以字节为单位的偏移量 bufferRowLength和bufferImageHeight以texel为单位指定缓冲存储器中较大的二维或三维图像的子区域，并控制寻址计算。如果这些值中的任何一个为零，则根据imageExtent，缓冲存储器的这一方面被认为是紧密压缩的 imageSubresource是一个VkImageSubresourceLayers，用于指定用于源或目标图像数据的图像的特定图像子资源 imageOffset选择源或目标图像数据子区域的初始x、y、z偏移（以texel为单位） imageExtent是要在宽度、高度和深度上复制的图像的大小（以texel为单位） 当复制到或从深度或模具方面时，缓冲区内存中的数据使用的布局是深度或模具数据的(大部分)紧密封装的表示形式。具体地说: 复制到或从任何深度&#x2F;模板格式的模板方面的数据都用每个texel的VK_FORMAT_S8_UINT值紧密打包 复制到或从VK_FORMAT_D16_UNORM或VK_FORMAT_D16_UNORM_S8_UINT格式的深度方面的数据使用每个texel的VK_FORMAT_D16_UNORM值紧密打包 复制到或从VK_FORMAT_D32_SFLOAT或VK_FORMAT_D32_SFLOAT_S8_UINT格式的深度方面的数据使用每个texel的一个VK_FORMAT_D32_SFLOAT值紧密打包 复制到或从VK_FORMAT_X8_D24_UNORM_PACK32或VK_FORMAT_D24_UNORM_S8_UINT格式的深度方面的数据被打包为每个texel一个32位单词，每个单词的lsb中有D24值，8个msb中有未定义的值 由于图像副本的深度或模板方面缓冲区在某些实现上可能需要格式转换，因此不支持图形的队列不支持格式转换。当复制到深度方面时，并且没有启用VK_EXT_depth_range_unrestricted扩展名，缓冲区内存中的数据必须在[0,1]范围内，否则结果值是未定义的。复制从imageSubresource的图像图层baseArrayLayer成员开始一层一层地进行。layerCount层从源图像或目标图像复制。 1.5.2 vkCmdCopyBufferToImage在缓冲区和图像之间复制数据, 从buffer对象复制数据到image对象, 调用vkCmdCopyBufferToImage: 1234567void vkCmdCopyBufferToImage( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions); commandBuffer是命令将被记录到的命令缓冲区 srcBuffer是源缓冲区 dstImage是目标图像 dstImageLayout是复制的目标图像子资源的布局 regionCount是要复制的区域数 pRegions是一个指向VkBufferImageCopy结构数组的指针，该结构数组指定要复制的区域 区域中的每个区域从源缓冲区的指定区域复制到目标图像的指定区域。 如果dstImage的格式是一个多平面的图像格式)，必须使用VkBufferImageCopy结构的pRegions成员单独指定作为拷贝目标的每个平面的区域。在本例中，imageSubresource的aspectMask必须为VK_IMAGE_ASPECT_PLANE_0_BIT、VK_IMAGE_ASPECT_PLANE_1_BIT或VK_IMAGE_ASPECT_PLANE_2_BIT。对于vkCmdCopyBufferToImage来说，多平面图像的每个平面都被视为具有由相应子资源的aspectMask标识的平面的多平面格式的兼容平面格式中列出的格式。这既适用于VkFormat，也适用于复制中使用的坐标，它对应于平面中的texel，而不是这些texel如何映射到整个图像中的坐标。 1.6 准备纹理图像回到createTextureImage函数。我们在那里做的最后一件事是创建纹理图像。下一步是将暂存缓冲区复制到纹理图像。这包括两个步骤: 转换纹理图像到VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL 执行缓冲区到图像复制操作 123456789101112131415// 该图像是使用VK_IMAGE_LAYOUT_UNDEFINED布局创建的，因此在转换textureImage时应将oldLayout指定为VK_IMAGE_LAYOUT_UNDEFINED// 在执行复制操作之前，不关心图像内容，所以可以这样做transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);// 拷贝stagingBuffer中缓存的图像数据至Image（GPU可见内存）copyBufferToImage(stagingBuffer, textureImage, static_cast&lt;uint32_t&gt;(texWidth), static_cast&lt;uint32_t&gt;(texHeight));// 为了能够从着色器中的纹理图像开始采样，我们需要最后一个过渡来准备着色器访问(用于同步对资源的访问)：transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); 1.7 转换屏障的含义 VkAccessFlags现在在启用验证层的情况下运行应用程序，那么将看到transitionImageLayout中的访问掩码和管道阶段无效。 我们需要根据过渡中的布局来设置它们，拷贝前后的两种转换都需要设置： VK_IMAGE_LAYOUT_UNDEFINED-&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 不需要等待任何内容的传输写入 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL-&gt; VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: shader reads应该等待Transfer writes，特别是shader在片段着色器中读取，因为这就是我们要使用纹理的地方 12345678910111213141516171819202122232425262728293031VkPipelineStageFlags sourceStage;VkPipelineStageFlags destinationStage;if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123; barrier.srcAccessMask = 0; // Image或缓冲区在清除或复制操作中的写访问 barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; // 指定队列最初接收到任何命令的管道阶段 sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; // 指定所有复制命令和清除命令管道阶段 destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;&#125; else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123; // Image或缓冲区在清除或复制操作中的写访问 barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; // 指定对存储缓冲区、物理存储缓冲区、统一texel缓冲区、存储texel缓冲区、采样图像或存储图像的读访问 barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT; // 指定所有复制命令和清除命令管道阶段 sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT; // 指定片段着色器阶段 destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;&#125; else &#123; throw std::invalid_argument(&quot;unsupported layout transition!&quot;);&#125;vkCmdPipelineBarrier(commandBuffer, sourceStage, destinationStage, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier); 传输写入必须在管道传输阶段进行。因为写操作不需要等待任何东西，所以您可以为预barrier操作指定一个空的访问掩码和尽可能早的管道阶段VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT。需要注意的是，VK_PIPELINE_STAGE_TRANSFER_BIT并不是图形和计算管道中的一个真正的阶段。它更多的是一个发生转移的伪阶段。 图像将在相同的管道阶段被写入，然后被片段着色器读取，这就是为什么我们在片段着色器管道阶段指定着色器读取访问。需要注意的一点是，命令缓冲区提交在开始时会导致隐式的VK_ACCESS_HOST_WRITE_BIT同步。由于transitionImageLayout函数只使用一个命令来执行一个命令缓冲区，所以如果在布局转换中需要VK_ACCESS_HOST_WRITE_BIT依赖项，您可以使用这个隐式同步并将srcAccessMask设置为0。 实际上，有一种特殊的图像布局类型可以支持所有操作–VK_IMAGE_LAYOUT_GENERAL。当然，它的问题在于，它不一定能为任何操作提供最佳性能。在某些特殊情况下，例如使用图像作为输入和输出，或者在离开预初始化的布局后读取图像。到目前为止，所有提交命令的帮助程序功能都已设置为通过等待队列变为空闲状态而同步执行。对于实际应用，建议将这些操作组合在单个命令缓冲区中，并异步执行它们以提高吞吐量，尤其是createTextureImage函数中的过渡和复制。通过创建一个helper函数将命令记录到其中的setupCommandBuffer并尝试添加一个flushSetupCommands来执行到目前为止已记录的命令，来尝试进行此操作。最好在纹理贴图工作后执行此操作，以检查纹理资源是否仍正确设置。 1.7.1 VkAccessFlagBitsVulkan中的内存可以通过shader调用和管道中的一些固定函数来访问。访问类型是所使用的描述符类型的函数，或者固定函数阶段如何访问内存。每个访问类型对应于VkAccessFlagBits中的一个位标志。 一些同步命令以访问类型集作为参数来定义内存依赖项的访问范围。如果同步命令包含源访问掩码，则其第一个访问作用域仅包括通过该掩码中指定的访问类型进行的访问。类似地，如果同步命令包含目标访问掩码，则其第二个访问作用域仅包括通过该掩码中指定的访问类型进行的访问。 12345678910111213141516171819202122232425262728293031typedef enum VkAccessFlagBits &#123; VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0x00000001, VK_ACCESS_INDEX_READ_BIT = 0x00000002, VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0x00000004, VK_ACCESS_UNIFORM_READ_BIT = 0x00000008, VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0x00000010, VK_ACCESS_SHADER_READ_BIT = 0x00000020, VK_ACCESS_SHADER_WRITE_BIT = 0x00000040, VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0x00000080, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0x00000100, VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0x00000200, VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0x00000400, VK_ACCESS_TRANSFER_READ_BIT = 0x00000800, VK_ACCESS_TRANSFER_WRITE_BIT = 0x00001000, VK_ACCESS_HOST_READ_BIT = 0x00002000, VK_ACCESS_HOST_WRITE_BIT = 0x00004000, VK_ACCESS_MEMORY_READ_BIT = 0x00008000, VK_ACCESS_MEMORY_WRITE_BIT = 0x00010000, VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 0x02000000, VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 0x04000000, VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 0x08000000, VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 0x00100000, VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 0x00020000, VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 0x00040000, VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 0x00080000, VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 0x00800000, VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 0x00200000, VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 0x00400000, VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 0x01000000, VK_ACCESS_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkAccessFlagBits; VK_ACCESS_INDIRECT_COMMAND_READ_BIT指定对作为间接绘图或调度命令一部分的间接命令数据的读访问 VK_ACCESS_INDEX_READ_BIT指定对索引缓冲区的读访问，作为索引绘图命令的一部分，由vkCmdBindIndexBuffer绑定 VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT指定对顶点缓冲区的读访问，作为绘图命令的一部分，由vkCmdBindVertexBuffers绑定 VK_ACCESS_UNIFORM_READ_BIT统一缓冲区读访问权限 VK_ACCESS_INPUT_ATTACHMENT_READ_BIT指定在片段着色期间渲染通道内对输入附件的读访问 VK_ACCESS_SHADER_READ_BIT指定对存储缓冲区、物理存储缓冲区、统一texel缓冲区、存储texel缓冲区、采样图像或存储图像的读访问 VK_ACCESS_SHADER_WRITE_BIT存储缓冲区、物理存储缓冲区、存储texel缓冲区或存储映像的写访问 VK_ACCESS_COLOR_ATTACHMENT_READ_BIT指定对颜色附件的读访问，例如通过混合、逻辑操作或通过某些subpass加载操作。它不包括高级混合操作 VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT指定在渲染通道期间或通过某些子通道加载和存储操作对颜色、解析或深度&#x2F;模板解析附件的写访问 VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT指定对深度&#x2F;模板附件的读访问，通过深度或模板操作，或通过某些子传递加载操作 VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT指定对深度&#x2F;模板附件的写访问，通过深度或模板操作，或者通过某些子传递加载和存储操作 VK_ACCESS_TRANSFER_READ_BIT拷贝操作中对镜像或缓冲区的读访问 VK_ACCESS_TRANSFER_WRITE_BIT映像或缓冲区在清除或复制操作中的写访问 VK_ACCESS_HOST_READ_BIT主机操作读访问。这种类型的访问不是通过资源执行的，而是直接在内存上执行的 VK_ACCESS_HOST_WRITE_BIT主机操作写访问。这种类型的访问不是通过资源执行的，而是直接在内存上执行的 VK_ACCESS_MEMORY_READ_BIT所有读访问。它在任何访问掩码中都是有效的，并被视为等同于设置所有在使用它时有效的读访问标志 VK_ACCESS_MEMORY_WRITE_BIT所有写访问。它在任何访问掩码中都是有效的，并被视为等同于设置所有在使用它时有效的写访问标志 VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT指定对谓词的读访问，作为条件呈现的一部分 VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT指定在转换反馈激活时对转换反馈缓冲区的写访问 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT指定对转换反馈计数器缓冲区的读访问，当vkCmdBeginTransformFeedbackEXT执行时读取该缓冲区 VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT指定对转换反馈计数器缓冲区的写访问，该缓冲区在vkCmdEndTransformFeedbackEXT执行时写入 VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX指定从VkBuffer输入读取vkCmdProcessCommandsNVX VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX指定写到vkCmdProcessCommandsNVX的目标命令缓冲区 VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT类似于VK_ACCESS_COLOR_ATTACHMENT_READ_BIT，但是也包括高级的混合操作 VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV指定对着色率图像的读取访问，作为绘图命令的一部分，由vkcmdbindshadingraemimagenv绑定 VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV指定对加速结构的读访问，作为跟踪或构建命令的一部分 VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV指定对加速结构的写访问，作为构建命令的一部分 VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT动态碎片密度图操作时对碎片密度图附件的读访问 1.7.2 VkPipelineStageFlags 管道阶段操作或同步命令执行的工作由多个操作组成，这些操作作为逻辑上独立的步骤序列执行，称为管道阶段。执行的确切管道阶段取决于所使用的特定命令，以及记录命令时的当前命令缓冲区状态。绘制命令、分派命令、复制命令、清除命令和同步命令都在管道阶段的不同集合中执行。同步命令不会在已定义的管道中执行，但会执行VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT和VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT。 注意同步命令执行的操作(例如可用性和可见性操作)不是由定义的管道阶段执行的。但是，其他命令仍然可以通过VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT和VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT管道阶段与它们同步。 跨管道阶段执行操作必须遵循隐式排序保证，特别是包括管道阶段顺序。否则，与其他阶段相比，跨管道阶段的执行可能会重叠或无序执行，除非执行依赖项强制执行。 一些同步命令包括管道阶段参数，将该命令的同步范围限制在这些阶段。这允许对精确的执行依赖关系和操作命令执行的访问进行细粒度的控制。实现应该使用这些管道阶段来避免不必要的停顿或缓存刷新。 可以设置指定管道阶段通过VkPipelineStageFlags: 1234567891011121314151617181920212223242526272829typedef enum VkPipelineStageFlagBits &#123; VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0x00000001, VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0x00000002, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0x00000004, VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0x00000008, VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0x00000010, VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0x00000020, VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0x00000040, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0x00000080, VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0x00000100, VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0x00000200, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0x00000400, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0x00000800, VK_PIPELINE_STAGE_TRANSFER_BIT = 0x00001000, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0x00002000, VK_PIPELINE_STAGE_HOST_BIT = 0x00004000, VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0x00008000, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0x00010000, VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = 0x01000000, VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00040000, VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 0x00020000, VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = 0x00400000, VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = 0x00200000, VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = 0x02000000, VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = 0x00080000, VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = 0x00100000, VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = 0x00800000, VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkPipelineStageFlagBits; VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT指定队列最初接收到任何命令的管道阶段 VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT指定使用Draw&#x2F;DispatchIndirect数据结构的管道阶段。这个阶段还包括读取vkCmdProcessCommandsNVX写的命令 VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV指定任务着色器阶段 VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV指定网格着色器阶段 VK_PIPELINE_STAGE_VERTEX_INPUT_BIT指定消耗顶点和索引缓冲区的流水线阶段 VK_PIPELINE_STAGE_VERTEX_SHADER_BIT指定顶点着色器阶段 VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT指定镶嵌控制着色器阶段 VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT指定镶嵌评估着色器阶段 VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT指定几何着色器阶段 VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT指定片段着色器阶段 VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT指定执行早期片段测试（片段着色之前的深度和模板测试）的管道阶段。此阶段还包括针对具有深度&#x2F;模板格式的帧缓冲区附件的子传递加载操作 VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT指定执行后期片段测试（片段着色后的深度和模板测试）的管道阶段。此阶段还包括用于具有深度&#x2F;模板格式的帧缓冲区附件的子传递存储操作 VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT指定混合后管道的阶段，从管道输出最终颜色值。此阶段还包括子通道加载和存储操作以及具有颜色或深度&#x2F;模板格式的帧缓冲区附件的多样本解析操作 VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT指定执行计算着色器 VK_PIPELINE_STAGE_TRANSFER_BIT指定以下命令： 所有复制命令，包括vkCmdCopyQueryPoolResults，vkCmdBlitImage，vkCmdResolveImage 所有清除命令，但vkCmdClearAttachments除外 VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT指定管道中由所有命令生成的操作完成执行的最后阶段 VK_PIPELINE_STAGE_HOST_BIT指定一个伪阶段，指示在主机上执行设备存储器的读&#x2F;写操作。记录在命令缓冲区中的任何命令都不会调用此阶段 VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV指定光线跟踪着色器阶段的执行 VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV指定vkCmdBuildAccelerationStructureNV，vkCmdCopyAccelerationStructureNV和vkCmdWriteAccelerationStructuresPropertiesNV的执行 VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT指定所有图形管线阶段的执行，并且等效于： VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV VK_PIPELINE_STAGE_VERTEX_INPUT_BIT VK_PIPELINE_STAGE_VERTEX_SHADER_BIT VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT VK_PIPELINE_STAGE_ALL_COMMANDS_BIT等效于与其一起使用的队列上支持的所有其他管道阶段标志的逻辑或 VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT指定使用条件渲染谓词的管道阶段 VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT指定将顶点属性输出值写入转换反馈缓冲区的管线阶段 VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX指定了处理通过vkCmdProcessCommandsNVX在设备端生成命令的管道阶段 VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV指定管道的阶段，在该阶段中读取阴影率图像，以确定栅格化图元各部分的阴影率 VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT指定读取片段密度图以生成片段区域的管线阶段 1.8 清理创建纹理贴图后，不能忘记在必要的时候将内存释放出来： 123456789101112131415161718void createTextureImage() &#123; ... // 通过清除过渡缓冲区及其末尾的内存来完成createTextureImage函数： transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr);&#125;void cleanup() &#123; cleanupSwapChain(); vkDestroyImage(device, textureImage, nullptr); vkFreeMemory(device, textureImageMemory, nullptr); ...&#125; 1.9 总结到目前为止，我们从设备物理存储上读取了图片内容，将其转成临时缓存后又将其存储在对应GPU可见的内存中以及生成对应VkImage纹理贴图对象，接下来需要将其显示在屏幕上还需要把这个对象放入图形管道中。 在回顾下本章中的读取图像的步骤: 首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存 通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象 用VkBuffer图像文件中的像素填充创建的VkImage图像对象 填充图像对象需要使用VkImageMemoryBarrier 使用vkCmdPipelineBarrier使得图像填充Barrier生效 通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充) 再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样 创建图像视图和图像采样器(后续下一章开始处理) 添加一个组合的图像采样器描述符来从纹理中采样颜色 上面步骤中，4和5是下一章的内容。 1.10 Windows上的CMakefileLists.txt写法windows平台上编译当前项目，可以使用cmake, CMakefileLists.txt文件如下(注意先安装Vulkan sdk)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556cmake_minimum_required (VERSION 3.7) #最低要求的CMake版本project(MyVulkan) # 项目名称set(VERSION 0.0.1)set(CMAKE_BUILD_TYPE &quot;Debug&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -g -Wall -Wno-unused-variable -pthread&quot;)message(STATUS &quot;This is &quot; $&#123;PROJECT_NAME&#125; &quot; version &quot; $&#123;VERSION&#125;)message(STATUS &quot;This is for windows platform&quot;)message(&quot;Build Type:&quot; $&#123;CMAKE_BUILD_TYPE&#125; $&#123;CMAKE_CXX_FLAGS&#125;)# Use FindVulkan module added with CMAKE 3.7if (NOT CMAKE_VERSION VERSION_LESS 3.7.0) message(STATUS &quot;Using module to find Vulkan&quot;) find_package(Vulkan)endif()find_library(Vulkan_LIBRARY NAMES vulkan-1 vulkan PATHS $&#123;CMAKE_SOURCE_DIR&#125;/libs/vulkan)IF (Vulkan_LIBRARY) set(Vulkan_FOUND ON) MESSAGE(&quot;Using bundled Vulkan library version&quot;)ENDIF()message(STATUS &quot;Using Vulkan lib: &quot; $&#123;Vulkan_LIBRARY&#125;)# CMAKE_SOURCE_DIR 代表工程根目录CMakeLists.txt文件所在目录set(ROOT_DIR $&#123;CMAKE_SOURCE_DIR&#125;)### GLFW3set(GLFW_LIB_DIR $&#123;ROOT_DIR&#125;/lib/glfw3)set(GLFW_LIBS $&#123;GLFW_LIB_DIR&#125;/glfw3dll.lib)### GLMset(GLM_INCLUDE_DIRS $&#123;ROOT_DIR&#125;/include/glm)### stb-imageset(STB_IMAGE_DIRS $&#123;ROOT_DIR&#125;/include/stb-image)message(STATUS &quot;Lib path: &quot;)message(STATUS &quot; GLFW3: &quot; $&#123;GLFW_LIBS&#125;)message(STATUS &quot; GLM : &quot; $&#123;GLM_INCLUDE_DIRS&#125;)message(STATUS &quot; STB_IMAGE: &quot; $&#123;STB_IMAGE_DIRS&#125;)# 定义头文件搜索路径include_directories($&#123;ROOT_DIR&#125;/inlcude $&#123;GLM_INCLUDE_DIRS&#125;)#aux_source_directory(./ SOURCE_DIR)aux_source_directory($&#123;ROOT_DIR&#125;/inlcude SOURCE_DIR)aux_source_directory($&#123;ROOT_DIR&#125;/src SOURCE_DIR)# Targetadd_executable(MyVulkan $&#123;SOURCE_DIR&#125;)####Vulkanfind_package(Vulkan REQUIRED)# GLFW3 is dynamic linktarget_link_libraries($&#123;PROJECT_NAME&#125; Vulkan::Vulkan $&#123;GLFW_LIBS&#125;) 项目文件目录:","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(13)-描述符布局及缓存","slug":"Vulkan入门-13-描述符布局及缓存","date":"2022-02-26T19:34:54.000Z","updated":"2022-02-26T19:43:22.440Z","comments":true,"path":"2022/02/27/Vulkan入门-13-描述符布局及缓存/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/","excerpt":"简述我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。","text":"简述我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。 在Vulkan中解决这个问题的正确方法是使用资源描述符（resource descriptor）。描述符是着色器自由访问缓冲区和图像等资源的一种方式。我们将设置一个包含变换矩阵的缓冲区，并让顶点着色器通过描述符访问它们。描述符的使用包括三个部分： 在管道创建期间指定描述符布局 从描述符池分配描述符集 渲染期间绑定描述符集 描述符是表示着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。描述符被组织成描述符集，这些描述符集在命令记录期间被绑定，以便在后续的绘制命令中使用。每个描述符集中内容的安排由描述符集布局决定，该布局决定了可以在其中存储哪些描述符。管道可使用的描述符集布局序列在管道布局中指定。每个管道对象最多可以使用maxBoundDescriptorSets(参见限制)描述符集。 描述符布局指定管道要访问的资源类型，就像渲染过程指定要访问的附件类型一样。描述符集指定将绑定到描述符的实际缓冲区或图像资源，就像帧缓冲区指定要绑定到渲染过程附件的实际图像视图一样。然后为绘图命令绑定描述符集，就像顶点缓冲区和帧缓冲区一样。 着色器通过装饰有描述符集和绑定数的变量访问资源，这些变量将它们连接到描述符集中的描述符。着色器接口到绑定描述符集的映射在着色器资源接口部分描述。着色器也可以通过64位地址使用物理存储缓冲区访问，而不需要通过描述符来访问缓冲区。 描述符有很多种类型，这里使用统一缓冲区对象(UBO)。如下所示: 12345struct UniformBufferObject &#123; glm::mat4 model; glm::mat4 view; glm::mat4 proj;&#125;; 我们可以使用GLM中的数据类型精确匹配着色器中的定义。矩阵中的数据与着色器期望的方式是二进制兼容的，因此我们可以稍后将UniformBufferObject的memcpy转换为VkBuffer。 需要更改顶点着色器: 123456789101112131415161718#version 450#extension GL_ARB_separate_shader_objects : enablelayout(binding = 0) uniform UniformBufferObject &#123; mat4 model; mat4 view; mat4 proj;&#125; ubo;layout(location = 0) in vec2 inPosition;layout(location = 1) in vec3 inColor;layout(location = 0) out vec3 fragColor;void main() &#123; gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0); fragColor = inColor;&#125; 绑定指令类似于属性的位置指令。 我们将在描述符布局中引用此绑定。 更改了带有gl_Position的行，以使用转换来计算剪辑坐标中的最终位置。 与2D三角形不同，剪辑坐标的最后一个分量可能不是1，这在转换为屏幕上的最终归一化设备坐标时将导致除法。 这在透视投影中用作透视划分，对于使较近的对象看起来比较远的对象看起来更大，这是必不可少的。 一. 描述符集布局我们需要提供着色器中用于管道创建的每个描述符绑定的详细信息，就像我们必须为每个顶点属性及其位置索引所做的那样。我们将设置一个新函数来定义所有这些信息，称为createDescriptorSetLayout。在创建管道之前应该调用: 12345678910111213141516171819void initVulkan() &#123; ... createDescriptorSetLayout(); createGraphicsPipeline(); ...&#125;void createDescriptorSetLayout() &#123; VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;; // 指定在着色器中使用的绑定 uboLayoutBinding.binding = 0; // 描述符的类型 uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; uboLayoutBinding.descriptorCount = 1; // 指定描述符将在顶点着色器阶段被引用 uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT; // pImmutableSamplers仅与图像采样描述符有关 uboLayoutBinding.pImmutableSamplers = nullptr;&#125; 每个绑定都需要通过VkDescriptorSetLayoutBinding结构来描述。前两个字段指定在着色器中使用的绑定和描述符的类型，该描述符是一个统一的缓冲区对象。着色器变量可能表示一个统一缓冲区对象的数组，而描述符计数指定该数组中值的数量。 例如，这可用于为骨骼动画指定骨骼中每个骨骼的变换。 我们的MVP转换位于单个统一缓冲区对象中，因此我们使用的描述符数为1。 1.1 VkDescriptorSetLayoutBinding1234567typedef struct VkDescriptorSetLayoutBinding &#123; uint32_t binding; VkDescriptorType descriptorType; uint32_t descriptorCount; VkShaderStageFlags stageFlags; const VkSampler* pImmutableSamplers;&#125; VkDescriptorSetLayoutBinding; binding是此条目的绑定号，并且与着色器阶段中具有相同绑定号的资源相对应。 descriptorType是VkDescriptorType，它指定用于此绑定的资源描述符的类型。 descriptorCount是绑定中包含的描述符数量，在着色器中以数组形式访问，除非描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，在这种情况下，描述符计数是嵌入式统一块的字节大小。如果描述符计数为零，则此绑定条目被保留，并且不得使用设置的布局在任何管道内通过任何绑定从任何阶段访问资源。 stageFlags成员是VkShaderStageFlagBits的位掩码，用于指定哪些管道着色器阶段可以访问此绑定的资源。 VK_SHADER_STAGE_ALL是一种简写形式，用于指定所有定义的着色器阶段，包括扩展定义的任何其他阶段，都可以访问该资源。如果stageFlags中未包含着色器阶段，则不得使用设置的布局在任何管道中通过此绑定从该阶段访问资源。除了限于片段着色器的输入附件之外，对于阶段的哪些组合可以使用描述符绑定没有任何限制，特别是图形阶段和计算阶段都可以使用绑定。 pImmutableSamplers影响采样器的初始化。如果描述符类型指定VK_DESCRIPTOR_TYPE_SAMPLER或VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型描述符，则可以使用pImmutableSamplers初始化一组不可变的采样器。不可变的采样器永久绑定到设置的布局中，不得更改。不允许使用不可变采样器更新VK_DESCRIPTOR_TYPE_SAMPLER描述符，并且使用不可变采样器更新VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER描述符不会修改采样器（将更新图像视图，但会忽略采样器更新）。如果pImmutableSamplers不为NULL，则它指向一个采样器句柄数组，该数组将被复制到set布局中并用于相应的绑定。仅采样器句柄被复制；在最终使用集合布局以及使用它创建的任何描述符池和集合之前，不得破坏采样器对象。如果pImmutableSamplers为NULL，则采样器插槽是动态的，必须使用此布局将采样器句柄绑定到描述符集中。如果描述符类型不是这些描述符类型之一，则将忽略pImmutableSamplers。 1.1.1 VkDescriptorType其中描述符的类型VkDescriptorType有如下取值: 12345678910111213141516typedef enum VkDescriptorType &#123; VK_DESCRIPTOR_TYPE_SAMPLER = 0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3, VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4, VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9, VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10, VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = 1000138000, VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = 1000165000, VK_DESCRIPTOR_TYPE_MAX_ENUM = 0x7FFFFFFF&#125; VkDescriptorType; VK_DESCRIPTOR_TYPE_SAMPLER: 指定采样器描述符 VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: 指定组合图像采样器描述符 VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: 指定采样图像描述符 VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: 指定存储映像描述符 VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: 指定统一纹理像素缓冲区描述符 VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: 指定存储纹理元素缓冲区描述符 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: 统一缓冲区描述符 VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: 指定存储缓冲区描述符 VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: 指定动态统一缓冲区描述符 VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: 指定动态存储缓冲区描述符 VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: 指定输入附件描述符 VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: 指定内联统一块 1.1.2 VkShaderStageFlags需要指定一个或多个着色器阶段的命令和结构使用位对应于阶段的位掩码来指定。可以设置为指定着色器阶段的位有： 12345678910111213141516171819typedef enum VkShaderStageFlagBits &#123; VK_SHADER_STAGE_VERTEX_BIT = 0x00000001, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004, VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008, VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010, VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020, VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F, VK_SHADER_STAGE_ALL = 0x7FFFFFFF, VK_SHADER_STAGE_RAYGEN_BIT_NV = 0x00000100, VK_SHADER_STAGE_ANY_HIT_BIT_NV = 0x00000200, VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 0x00000400, VK_SHADER_STAGE_MISS_BIT_NV = 0x00000800, VK_SHADER_STAGE_INTERSECTION_BIT_NV = 0x00001000, VK_SHADER_STAGE_CALLABLE_BIT_NV = 0x00002000, VK_SHADER_STAGE_TASK_BIT_NV = 0x00000040, VK_SHADER_STAGE_MESH_BIT_NV = 0x00000080, VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkShaderStageFlagBits; VK_SHADER_STAGE_VERTEX_BIT: 顶点阶段 VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: 细分控制阶段 VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: 细分评估阶段 VK_SHADER_STAGE_GEOMETRY_BIT: 几何图形阶段 VK_SHADER_STAGE_FRAGMENT_BIT: 片段阶段 VK_SHADER_STAGE_COMPUTE_BIT: 计算阶段 VK_SHADER_STAGE_ALL_GRAPHICS: 用作速记的位的组合，用于指定上面定义的所有图形阶段（计算阶段除外） VK_SHADER_STAGE_ALL: 用作简写的位的组合，用于指定设备支持的所有着色器阶段，包括扩展引入的所有其他阶段 VK_SHADER_STAGE_TASK_BIT_NV: 任务阶段 VK_SHADER_STAGE_MESH_BIT_NV: 网格阶段 VK_SHADER_STAGE_RAYGEN_BIT_NV: 射线生成阶段 VK_SHADER_STAGE_ANY_HIT_BIT_NV: 任何命中阶段 VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: 最接近的命中阶段 VK_SHADER_STAGE_MISS_BIT_NV: 未命中阶段 VK_SHADER_STAGE_INTERSECTION_BIT_NV: 相交阶段 VK_SHADER_STAGE_CALLABLE_BIT_NV: 可调用阶段 1.2 创建VkDescriptorSetLayout所有描述符绑定都合并到一个vkDescriptorSetLayout对象中： 123456789101112131415161718192021222324VkDescriptorSetLayout descriptorSetLayout;void createDescriptorSetLayout() &#123; VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;; // 指定在着色器中使用的绑定 uboLayoutBinding.binding = 0; // 描述符的类型 uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; uboLayoutBinding.descriptorCount = 1; // 指定描述符将在顶点着色器阶段被引用 uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT; // pImmutableSamplers仅与图像采样描述符有关 uboLayoutBinding.pImmutableSamplers = nullptr; VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;; layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO; layoutInfo.bindingCount = 1; layoutInfo.pBindings = &amp;uboLayoutBinding; // 创建描述符集布局 if (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, nullptr, &amp;descriptorSetLayout) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create descriptor set layout!&quot;); &#125;&#125; 1.2.1 VkDescriptorSetLayoutCreateInfo1234567typedef struct VkDescriptorSetLayoutCreateInfo &#123; VkStructureType sType; const void* pNext; VkDescriptorSetLayoutCreateFlags flags; uint32_t bindingCount; const VkDescriptorSetLayoutBinding* pBindings;&#125; VkDescriptorSetLayoutCreateInfo; sType就是这种结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO pNext为NULL或指向特定于扩展的结构的指针 flags是VkDescriptorSetLayoutCreateFlagBits的位掩码，用于指定描述符集布局创建的选项 bindingCount是pBindings中的元素数 pBindings是指向VkDescriptorSetLayoutBinding结构数组的指针 123456typedef enum VkDescriptorSetLayoutCreateFlagBits &#123; VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 0x00000002, VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 0x00000001, VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT, VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkDescriptorSetLayoutCreateFlagBits; VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: 指定不得使用此布局分配描述符集，而是由vkCmdPushDescriptorSetKHR推送描述符 VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: 指定描述符集使用此布局必须从创建一个描述符池分配VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT位集。描述符集布局创建这部分设置有备用限制描述符的最大数量每级和per-pipeline布局。non-UpdateAfterBind限制仅计数在没有此标志的情况下创建的集合中的描述符。UpdateAfterBind限制计算所有描述符，但是限制可能高于非UpdateAfterBind限制。 1.2.2 vkCreateDescriptorSetLayout描述符集布局对象由零个或多个描述符绑定的数组定义。每个单独的描述符绑定由描述符类型、绑定中描述符数量的计数（数组大小）、可以访问绑定的一组着色器阶段以及（如果使用不可变采样器）采样器描述符数组指定。 创建描述符集布局可以使用函数: vkCreateDescriptorSetLayout 12345VkResult vkCreateDescriptorSetLayout( VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout); device: 创建描述符集布局的逻辑设备 pCreateInfo: 指向VkDescriptorSetLayoutCreateInfo结构的指针，它指定了描述符集布局对象的状态 pAllocator: 控制主机内存分配 pSetLayout: 指向VkDescriptorSetLayout句柄的指针，在这个句柄中返回结果描述符集布局对象 当然通过vkCreate*创建的对象或资源，一般需要显示销毁: 12345void cleanup() &#123; cleanupSwapChain(); vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr); ...&#125; 1.3 管道指定描述符集布局我们需要在管道创建期间指定描述符集布局，以告诉Vulkan着色器将使用哪些描述符。描述符集布局在管道布局对象中指定。修改VkPipelineLayoutCreateInfo以引用布局对象： 1234VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;;pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;pipelineLayoutInfo.setLayoutCount = 1;pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout; 这里留个悬念，为什么可以指定多个描述符集布局。 1.4 统一缓存我们将指定包含着色器的UBO数据的缓冲区，但是我们需要首先创建这个缓冲区。我们将在每一帧将新数据复制到统一缓冲区，因此使用暂存缓冲区实际上没有任何意义。在这种情况下，它只会增加额外的开销，而且可能会降低性能。 我们应该有多个缓冲区，因为多个帧可能在同一时间绘制，我们不想更新缓冲区，准备下一帧，而前一帧仍在读取它！我们可以为每个帧或每个交换链图像提供统一的缓冲区。然而，由于我们需要从每个交换链映像所拥有的命令缓冲区引用统一缓冲区，因此最好也为每个交换链映像创建一个统一缓冲区。 123456789101112131415161718192021222324252627VkBuffer indexBuffer;VkDeviceMemory indexBufferMemory;std::vector&lt;VkBuffer&gt; uniformBuffers;std::vector&lt;VkDeviceMemory&gt; uniformBuffersMemory;void initVulkan() &#123; ... createVertexBuffer(); createIndexBuffer(); createUniformBuffers(); ...&#125;void createUniformBuffers() &#123; VkDeviceSize bufferSize = sizeof(UniformBufferObject); uniformBuffers.resize(swapChainImages.size()); uniformBuffersMemory.resize(swapChainImages.size()); for (size_t i = 0; i &lt; swapChainImages.size(); i++) &#123; createBuffer(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, uniformBuffers[i], uniformBuffersMemory[i], VK_SHARING_MODE_EXCLUSIVE); &#125;&#125; 我们将编写一个单独的函数，在每一帧用一个新的转换来更新统一缓冲区，所以这里没有vkMapMemory。 统一数据将被用于所有的draw调用，所以包含它的缓冲区只有在我们停止渲染时才会被销毁。因为它也取决于交换链图像的数量，这可能会在重新创建后改变，所以在cleanupSwapChain中清理它: 1234567891011121314void cleanupSwapChain() &#123; ... for (size_t i = 0; i &lt; uniformBuffers.size(); i++) &#123; vkDestroyBuffer(device, uniformBuffers[i], nullptr); vkFreeMemory(device, uniformBuffersMemory[i], nullptr); &#125;&#125;void recreateSwapChain() &#123; ... createFramebuffers(); createUniformBuffers(); createCommandBuffers();&#125; 1.5 更新统一缓存数据在绘制更新交换链帧的时候更新统一缓存数据： 123456789101112void drawFrame() &#123; ... updateUniformBuffer(imageIndex); VkSubmitInfo submitInfo = &#123;&#125;; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; ...&#125;void updateUniformBuffer(uint32_t currentImage) &#123;&#125; updateUniformBuffer函数将在每帧生成一个新的变换，以使几何体旋转。 1234567891011121314151617181920212223242526272829303132333435// 确保glm::rotate之类的函数使用弧度作为参数是必要的，以避免任何可能的混淆#define GLM_FORCE_RADIANS#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;// chrono标准库标头公开了执行精确计时的功能#include &lt;chrono&gt;void updateUniformBuffer(uint32_t currentImage) &#123; static auto startTime = std::chrono::high_resolution_clock::now(); auto currentTime = std::chrono::high_resolution_clock::now(); // 计算时长 float time = std::chrono::duration&lt;float, std::chrono::seconds::period&gt;(currentTime - startTime).count(); UniformBufferObject ubo = &#123;&#125;; // 在统一缓冲区对象中定义模型，视图和投影转换。 使用时间变量，模型旋转将是围绕Z轴的简单旋转 // 意思是每秒旋转90度 ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // 设置视图角度，从上方以45度角查看几何图形。 glm :: lookAt函数将眼睛位置，中心位置和上轴作为参数。 ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f)); // 使用具有45度垂直视场的透视投影。 // 其他参数是长宽比，近视平面和远视平面。 重要的是使用当前交换链范围来计算纵横比，以考虑调整大小后窗口的新宽度和高度。 ubo.proj = glm::perspective(glm::radians(45.0f), swapChainExtent.width / (float) swapChainExtent.height, 0.1f, 10.0f); // GLM最初是为OpenGL(左手坐标系)设计的，将其中坐标的Y坐标反转。 最简单的补偿方法是在投影矩阵中翻转Y轴缩放比例上的符号。 // 如果不这样做，那么图像将被倒置呈现。 ubo.proj[1][1] *= -1; // 将统一缓冲区对象中的数据复制到当前的统一缓冲区中。 与使用顶点缓冲区的方式完全相同，只是不需要暂存缓冲区（因为每帧都要更新）： void* data; vkMapMemory(device, uniformBuffersMemory[currentImage], 0, sizeof(ubo), 0, &amp;data); memcpy(data, &amp;ubo, sizeof(ubo)); vkUnmapMemory(device, uniformBuffersMemory[currentImage]);&#125; 当然此时编译运行程序是不成功的，因为我们仅仅是更新数据，但是没有将描述符集绑定到图形管道中。 二. 描述符前面我们创建了描述符集布局，描述了可以绑定的描述符的类型，现在我们给统一缓冲区的每个缓冲创建一个描述符集，然后将其绑定到统一缓冲区描述符中。 2.1 描述符池描述符集无法直接创建，它们必须从命令缓冲区之类的池中分配。描述符集又称为描述符池。 我们将编写一个新函数createDescriptorPool进行设置 12345678910111213141516171819202122232425void initVulkan() &#123; ... createUniformBuffers(); createDescriptorPool(); ...&#125;void createDescriptorPool() &#123; VkDescriptorPoolSize poolSize = &#123;&#125;; // 我们创建的是统一缓冲的描述符 poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; poolSize.descriptorCount = static_cast&lt;uint32_t&gt;(swapChainImages.size()); VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;; poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO; poolInfo.poolSizeCount = 1; poolInfo.pPoolSizes = &amp;poolSize; // 除了可用的单个描述符的最大数量外，还需要指定可以分配的最大描述符集数量：与交换链图像数量一致 poolInfo.maxSets = static_cast&lt;uint32_t&gt;(swapChainImages.size()); // 创建描述符池 if (vkCreateDescriptorPool(device, &amp;poolInfo, nullptr, &amp;descriptorPool) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create descriptor pool!&quot;); &#125;&#125; 首先需要使用VkDescriptorPoolSize结构来描述我们的描述符集将包含哪些描述符类型以及其中有多少个描述符类型。 2.1.1 VkDescriptorPoolSize1234typedef struct VkDescriptorPoolSize &#123; VkDescriptorType type; uint32_t descriptorCount;&#125; VkDescriptorPoolSize; type是描述符的类型 descriptorCount是要分配的该类型的描述符数。如果类型是VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则descriptorCount是要为此类型的描述符分配的字节数 2.1.2 VkDescriptorPoolCreateInfo12345678typedef struct VkDescriptorPoolCreateInfo &#123; VkStructureType sType; const void* pNext; VkDescriptorPoolCreateFlags flags; uint32_t maxSets; uint32_t poolSizeCount; const VkDescriptorPoolSize* pPoolSizes;&#125; VkDescriptorPoolCreateInfo; sType是此结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO pNext是NULL或指向扩展特定结构的指针 flags是VkDescriptorPoolCreateFlagBits的位掩码，用于指定池中某些受支持的操作 maxSets是可以从池中分配的描述符集的最大数量 poolSizeCount是pPoolSizes中的元素数 pPoolSizes是一个指向VkDescriptorPoolSize结构数组的指针，每个结构都包含一个描述符类型和要在池中分配的该类型的描述符数量 2.1.3 vkCreateDescriptorPool描述符池维护着一个描述符池，从中分配描述符集。 描述符池是外部同步的，这意味着应用程序不得同时从多个线程中的同一池中分配和&#x2F;或释放描述符集。 12345VkResult vkCreateDescriptorPool( VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool); device: 创建描述符池的逻辑设备 pCreateInfo: 指向VkDescriptorPoolCreateInfo结构的指针，该结构指定描述符池对象的状态 pAllocator: 内存分配 pDescriptorPool: 指向VkDescriptorPool句柄的指针，在该句柄中返回生成的描述符池对象 别忘了手动清理描述符池： 1234567891011void cleanupSwapChain() &#123; ... vkDestroyDescriptorPool(device, descriptorPool, nullptr);&#125;void recreateSwapChain() &#123; ... createUniformBuffers(); createDescriptorPool(); createCommandBuffers();&#125; 2.2 描述符集有了描述符池就可以分配描述符集了。为此添加createDescriptorSets函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859VkDescriptorPool descriptorPool;std::vector&lt;VkDescriptorSet&gt; descriptorSets;void initVulkan() &#123; ... createDescriptorPool(); createDescriptorSets(); ...&#125;void recreateSwapChain() &#123; ... createDescriptorPool(); createDescriptorSets(); ...&#125;void createDescriptorSets() &#123; std::vector&lt;VkDescriptorSetLayout&gt; layouts(swapChainImages.size(), descriptorSetLayout); VkDescriptorSetAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO; allocInfo.descriptorPool = descriptorPool; allocInfo.descriptorSetCount = static_cast&lt;uint32_t&gt;(swapChainImages.size()); allocInfo.pSetLayouts = layouts.data(); // 重置大小 descriptorSets.resize(swapChainImages.size()); // 内存分配描述符集 if (vkAllocateDescriptorSets(device, &amp;allocInfo, descriptorSets.data()) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate descriptor sets!&quot;); &#125; // 配置描述符 for (size_t i = 0; i &lt; descriptorSets.size(); i++) &#123; // 引用缓冲区的描述符（例如我们的统一缓冲区描述符）使用VkDescriptorBufferInfo结构进行配置 // 指定缓冲区以及其中包含描述符数据的区域。 VkDescriptorBufferInfo bufferInfo = &#123;&#125;; // 绑定缓冲区 bufferInfo.buffer = uniformBuffers[i]; bufferInfo.offset = 0; bufferInfo.range = sizeof(UniformBufferObject); VkWriteDescriptorSet descriptorWrite = &#123;&#125;; descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; descriptorWrite.dstSet = descriptorSets[i]; descriptorWrite.dstBinding = 0; descriptorWrite.dstArrayElement = 0; descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; descriptorWrite.descriptorCount = 1; descriptorWrite.pBufferInfo = &amp;bufferInfo; descriptorWrite.pImageInfo = nullptr; // Optional descriptorWrite.pTexelBufferView = nullptr; // Optional // 应用描述符集更新 vkUpdateDescriptorSets(device, 1, &amp;descriptorWrite, 0, nullptr); &#125;&#125; 描述符集分配用VkDescriptorSetAllocateInfo结构描述。需要指定要从中分配的描述符池、要分配的描述符集的数量以及基于它们的描述符布局。 2.2.1 VkDescriptorSetAllocateInfo1234567typedef struct VkDescriptorSetAllocateInfo &#123; VkStructureType sType; const void* pNext; VkDescriptorPool descriptorPool; uint32_t descriptorSetCount; const VkDescriptorSetLayout* pSetLayouts;&#125; VkDescriptorSetAllocateInfo; sType是此结构的类型 pNext是NULL或指向扩展特定结构的指针 descriptorPool是从中分配集合的池 descriptorSetCount确定要从池中分配的描述符集的数量 pSetLayouts是一个指向描述符集布局数组的指针，每个成员指定如何分配相应的描述符集 2.2.2 vkAllocateDescriptorSets1234VkResult vkAllocateDescriptorSets( VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets); device: 拥有描述符池的逻辑设备 pAllocateInfo: 指向VkDescriptorSetAllocateInfo结构的指针，该结构描述分配参数 pDescriptorSets: 指向VkDescriptorSet句柄数组的指针，在该数组中返回生成的描述符集对象 无需手动清理描述符集，因为在销毁描述符池时，会自动释放描述符集。 对vkAllocateDescriptorSets的调用将分配描述符集，每个描述符集具有一个统一的缓冲区描述符。 2.2.3 VkDescriptorBufferInfo12345typedef struct VkDescriptorBufferInfo &#123; VkBuffer buffer; VkDeviceSize offset; VkDeviceSize range;&#125; VkDescriptorBufferInfo; buffer是缓冲区资源 offset是从缓冲区开始的偏移量（以字节为单位）。 通过此描述符访问缓冲存储器将使用相对于此起始偏移量的寻址 range是用于此描述符更新的大小（以字节为单位），或者是VK_WHOLE_SIZE以使用从偏移量到缓冲区末尾的范围 2.2.4 VkWriteDescriptorSet123456789101112typedef struct VkWriteDescriptorSet &#123; VkStructureType sType; const void* pNext; VkDescriptorSet dstSet; uint32_t dstBinding; uint32_t dstArrayElement; uint32_t descriptorCount; VkDescriptorType descriptorType; const VkDescriptorImageInfo* pImageInfo; const VkDescriptorBufferInfo* pBufferInfo; const VkBufferView* pTexelBufferView;&#125; VkWriteDescriptorSet; sType是此结构的类型, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET pNext是NULL或指向扩展特定结构的指针 dstSet是要更新的目标描述符集 dstBinding是该集合内的描述符绑定 dstArrayElement是该数组中的起始元素。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则dstArrayElement指定绑定内的起始字节偏移量 descriptorCount是要更新的描述符的数量（pImageInfo，pBufferInfo或pTexelBufferView中的元素数量，或者与pNext链中的VkWriteDescriptorSetInlineUniformBlockEXT结构的dataSize成员匹配的值，或者与pNext中的VkWriteDescriptorSetAccelerationStructureNV结构的AccelerationStructureCount匹配的值。链 ）。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则描述符计数指定要更新的字节数 descriptorType是VkDescriptorType，用于指定pImageInfo，pBufferInfo或pTexelBufferView中每个描述符的类型，如下所述。它必须与在dstBinding中为dstSet的VkDescriptorSetLayoutBinding中指定的类型相同。描述符的类型还控制描述符从哪个数组获取 pImageInfo是指向VkDescriptorImageInfo结构数组的指针 pBufferInfo是指向VkDescriptorBufferInfo结构数组的指针 pTexelBufferView是指向VkBufferView句柄数组的指针 2.2.5 vkUpdateDescriptorSets内存分配后，描述符集可以使用写和复制操作的组合进行更新。 要更新描述符集，调用：vkUpdateDescriptorSets 123456void vkUpdateDescriptorSets( VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies); device是更新描述符集的逻辑设备 descriptorWriteCount是pDescriptorWrites数组中元素的数量 pDescriptorWrites是指向VkWriteDescriptorSet结构数组的指针，该结构描述了要写入的描述符集 descriptorCopyCount是pDescriptorCopies数组中元素的数量 pDescriptorCopies是指向VkCopyDescriptorSet结构数组的指针，该结构描述了要在其间复制的描述符集 2.3 使用描述符集现在，我们需要更新createCommandBuffers函数，以将每个交换链图像的正确描述符集实际绑定到具有cmdBindDescriptorSets的着色器中的描述符。 需要在vkCmdDrawIndexed调用之前完成： 12vkCmdBindDescriptorSets(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &amp;descriptorSets[i], 0, nullptr);vkCmdDrawIndexed(commandBuffers[i], static_cast&lt;uint32_t&gt;(indices.size()), 1, 0, 0, 0); 与顶点和索引缓冲区不同，描述符集不是图形管线所独有的。因此，我们需要指定是否要将描述符集绑定到图形或计算管道–vkCmdBindDescriptorSets。 现在运行程序，是看不到任何内容的。问题在于，由于我们在投影矩阵中进行了Y翻转，因此现在以顺时针顺序而不是逆时针顺序绘制了顶点。这将导致背面剔除，并阻止绘制任何几何图形。 在createGraphicsPipeline函数中VkPipelineRasterizationStateCreateInfo中修改frontFace来更正此问题： 12rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; frontFace是VkFrontFace结构体内的类型: 12345typedef enum VkFrontFace &#123; VK_FRONT_FACE_COUNTER_CLOCKWISE = 0, VK_FRONT_FACE_CLOCKWISE = 1, VK_FRONT_FACE_MAX_ENUM = 0x7FFFFFFF&#125; VkFrontFace; VK_FRONT_FACE_COUNTER_CLOCKWISE 指定具有正面积的三角形被认为是朝前的 VK_FRONT_FACE_CLOCKWISE 指定具有负面积的三角形被认为是朝前的 如何计算面积的正负，后续研究。现在运行程序可以看到我们的图像在沿着逆时针旋转~ 2.3.1 vkCmdBindDescriptorSets绑定描述符集调用 vkCmdBindDescriptorSets:一个参数是描述符所基于的布局。接下来的三个参数指定第一个描述符集的索引，要绑定的集的数量以及要绑定的集的数组。我们待会儿再讲这个。最后两个参数指定用于动态描述符的偏移量数组。 123456789void vkCmdBindDescriptorSets( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets); commandBuffer是描述符集将绑定到的命令缓冲区 pipelineBindPoint是一个VkPipelineBindPoint，它指示描述符是由图形管线还是由计算管线使用。 每个图形和计算都有一组单独的绑定点，因此绑定一个不会干扰另一个 layout是一个VkPipelineLayout对象，用于对绑定进行编程 firstSet是要绑定的第一个描述符集的集号 descriptorSetCount是pDescriptorSets数组中元素的数量 pDescriptorSets是指向VkDescriptorSet对象的句柄数组的指针，该对象描述了要写入的描述符集 dynamicOffsetCount是pDynamicOffsets数组中的动态偏移量 pDynamicOffsets是指向指定动态偏移量的uint32_t值数组的指针 vkCmdBindDescriptorSets导致编号为[firstSet..firstSet + descriptorSetCount-1]的集合使用存储在pDescriptorSets [0..descriptorSetCount-1]中的绑定用于后续渲染命令（根据pipelineBindPoint计算或图形）。以前通过这些集合应用的任何绑定都不再有效。 绑定后，描述符集会影响命令缓冲区中后续图形或计算命令的渲染，直到将不同的集绑定到相同的集编号，或者直到该集受到干扰（如管线布局兼容性中所述）为止。 在记录绘制或分派命令以使用该管道执行时，必须为管道中任何着色器访问的所有设定编号绑定一个兼容的描述符集。但是，如果管道中的所有着色器都不静态使用具有特定集合号的任何绑定，则即使该管道编号包括该集合号的非平凡描述符集合布局，也不需要为该集合号绑定任何描述符集。 如果要绑定的任何集合包括动态统一缓冲区或存储缓冲区，则pDynamicOffsets会为每个集合中每个动态描述符类型绑定中的每个数组元素包含一个元素。从pDynamicOffsets中获取值的顺序是：集合N的所有条目都在集合N + 1之前；在一个集合中，条目按描述符集合布局中的绑定号排序；在绑定数组中，元素是有序的。 dynamicOffsetCount必须等于要绑定的集合中动态描述符的总数。 用于动态统一和存储缓冲区绑定的有效偏移量是从pDynamicOffsets获取的相对偏移量与缓冲区的基地址加描述符集中的基本偏移量之和。动态统一和存储缓冲区绑定的范围是描述符集中指定的缓冲区范围。 每个pDescriptorSet都必须与layout指定的管道布局兼容。用于编程绑定的布局还必须与后续图形或计算命令中使用的管线兼容，如“管线布局兼容性”部分中所定义。 调用vkCmdBindDescriptorSets绑定的描述符集内容可能在以下时间使用： 对于使用VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT位置1创建的描述符绑定，在将命令缓冲区提交到队列时，在着色器执行结果绘制和调度时或在两者之间的任何时间，内容都可能被消耗。 在命令的主机执行期间，或在着色器执行结果绘制和派发期间，或之间的任何时间。 因此，在描述符集合绑定的内容可能被消耗的第一个时间点和该命令在队列上完成执行之间，不得更改（由更新命令覆盖或释放）描述符集绑定的内容。 在执行vkCmdBindDescriptorSets时，pDynamicOffsets的内容将立即消耗。一旦所有待定用途都已完成，就可以更新和重用描述符集。 三. 总结描述符的使用包括三个部分： 在管道创建期间指定描述符布局 从描述符池分配描述符集 渲染期间绑定描述符集 所谓描述符，就是用来描述着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。 接下来，我们尝试一些更让人激动的东西–贴图。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(12)-暂存缓冲和索引缓冲","slug":"Vulkan入门-12-暂存缓冲和索引缓冲","date":"2022-02-26T19:34:41.000Z","updated":"2022-02-26T19:42:33.608Z","comments":true,"path":"2022/02/27/Vulkan入门-12-暂存缓冲和索引缓冲/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/","excerpt":"简述虽然现在我们创建的顶点缓冲区工作正常，但是从CPU访问它的内存类型可能不是图形显卡本身读取的最佳内存类型，最理想的内存具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT位标志，并且通常不可由专用图形显卡上的CPU访问。而且我们上一篇最后实现的随鼠标移动的功能也没有考虑同步，简单一点，考虑读写分离。 现在创建两个顶点缓冲区：CPU可访问内存中的一个暂存缓冲区用于从顶点数组上传数据，最终顶点缓冲区位于设备本地内存中。然后我们将使用一个缓冲区复制命令将数据从暂存缓冲区移动到实际的顶点缓冲区。简单来说就是暂存缓冲区用于cpu写入，顶点缓冲区用于GPU读取数据。","text":"简述虽然现在我们创建的顶点缓冲区工作正常，但是从CPU访问它的内存类型可能不是图形显卡本身读取的最佳内存类型，最理想的内存具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT位标志，并且通常不可由专用图形显卡上的CPU访问。而且我们上一篇最后实现的随鼠标移动的功能也没有考虑同步，简单一点，考虑读写分离。 现在创建两个顶点缓冲区：CPU可访问内存中的一个暂存缓冲区用于从顶点数组上传数据，最终顶点缓冲区位于设备本地内存中。然后我们将使用一个缓冲区复制命令将数据从暂存缓冲区移动到实际的顶点缓冲区。简单来说就是暂存缓冲区用于cpu写入，顶点缓冲区用于GPU读取数据。 参考资料 Vulkan coordinate system http://vulkano.rs/guide/vertex-input 一. 传输队列buffer copy命令需要支持传输操作的队列族，使用VK_QUEUE_TRANSFER_BIT表示。不过任何具有VK_QUEUE_GRAPHICS_BIT或VK_QUEUE_COMPUTE_BIT功能的队列家族都已经隐式支持VK_QUEUE_TRANSFER_BIT操作。在这些情况下，不需要实现在queueFlags中显式地列出它。 但可以尝试使用专门用于传输操作的不同队列族， 可以如下操作: 修改QueueFamilyIndices和findQueueFamilies来显式地查找具有VK_QUEUE_TRANSFER位的队列族，而不是VK_QUEUE_GRAPHICS_BIT位 修改createLogicalDevice以请求传输队列的句柄 为传输队列系列上提交的命令缓冲区创建第二个命令池 修改资源的共享模式为VK_SHARING_MODE_CONCURRENT，并指定图形和传输队列族 提交传输命令，如vkCmdCopyBuffer到传输队列，而不是图形队列 二. 暂存缓冲区因为我们要创建多个VkBuffer，所以最好把共有的部分抽出，以避免代码累赘: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 传入必要参数void createBuffer(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer&amp; buffer, VkDeviceMemory&amp; bufferMemory, VkSharingMode mode) &#123; VkBufferCreateInfo bufferInfo = &#123;&#125;; bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; bufferInfo.size = size; bufferInfo.usage = usage; bufferInfo.sharingMode = mode; if (vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;buffer) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create vertex buffer!&quot;); &#125; VkMemoryRequirements memRequirements; vkGetBufferMemoryRequirements(device, buffer, &amp;memRequirements); VkMemoryAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; allocInfo.allocationSize = memRequirements.size; allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties); if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;bufferMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate vertex buffer memory!&quot;); &#125; vkBindBufferMemory(device, buffer, bufferMemory, 0);&#125;void createVertexBuffer() &#123; VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size(); VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, // 资源只能由单个队列族独占 stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE); void* data; vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data); memcpy(data, vertices.data(), (size_t) bufferSize); vkUnmapMemory(device, stagingBufferMemory); // 注意这里的MEMORY_PROPERTY是VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT！ createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, // 资源只能由单个队列族独占 vertexBufferMemory, VK_SHARING_MODE_EXCLUSIVE);&#125; 因为我们需要使用传输队列，所以注意stagingBuffer的usage是用的VK_BUFFER_USAGE_TRANSFER_SRC_BIT，而vertexBuffer现在用的是VK_BUFFER_USAGE_TRANSFER_DST_BIT！ vertexBuffer现在从设备本地的内存类型分配，这意味着我们不能使用vkMapMemory。但是，我们可以将数据从stagingBuffer复制到vertexBuffer。我们必须通过指定stagingBuffer的传输源标志和vertexBuffer的传输目标标志以及顶点缓冲区使用标志来表明我们打算这样做。 2.1 VkBufferUsageFlagBits12345678910111213141516171819typedef enum VkBufferUsageFlagBits &#123; VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0x00000001, VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0x00000002, VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0x00000004, VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0x00000008, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0x00000010, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0x00000020, VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0x00000040, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0x00000080, VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0x00000100, VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 0x00020000, VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 0x00000800, VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 0x00001000, VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 0x00000200, VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = 0x00000400, VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkBufferUsageFlagBits; VkBufferUsageFlagBits设置的位可以指定缓冲区的使用行为： VK_BUFFER_USAGE_TRANSFER_SRC_BIT指定缓冲区可以用作传输命令的源(请参阅VK_PIPELINE_STAGE_TRANSFER_BIT的定义)。 VK_BUFFER_USAGE_TRANSFER_DST_BIT指定缓冲区可以用作传输命令的目的地。 VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT缓冲区可用于创建一个VkBufferView，该视图适合占用VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER类型的VkDescriptorSet槽位。 VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT指定该缓冲区可以用来创建一个VkBufferView，该视图适合于占用VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的VkDescriptorSet槽位。 VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT缓冲区可以用于VkDescriptorBufferInfo中，该缓冲区适合于占用VkDescriptorSet类型的VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC槽位。 VK_BUFFER_USAGE_STORAGE_BUFFER_BIT指定该缓冲区可用于VkDescriptorBufferInfo中，该缓冲区适合于占用VkDescriptorSet类型的VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC槽位。 VK_BUFFER_USAGE_INDEX_BUFFER_BIT指定该缓冲区适合作为buffer参数传递给vkCmdBindIndexBuffer。 VK_BUFFER_USAGE_VERTEX_BUFFER_BIT指定缓冲区适合作为pBuffers数组的元素传递给vkCmdBindVertexBuffers。 VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT缓冲区适合作为buffer参数传递给vkCmdDrawIndirect、vkCmdDrawIndexedIndirect、vkCmdDrawMeshTasksIndirectNV、vkCmdDrawMeshTasksIndirectCountNV或vkCmdDispatchIndirect。它也适合作为VkIndirectCommandsTokenNVX的缓冲区成员，或VkCmdProcessCommandsInfoNVX的sequencesCountBuffer或sequencesIndexBuffer成员传递 VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT指定缓冲区适合作为buffer参数传递给vkCmdBeginConditionalRenderingEXT。 VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT指定该缓冲区适合使用for binding作为vkCmdBindTransformFeedbackBuffersEXT的转换反馈缓冲区。 VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT指定该缓冲区适合与vkCmdBeginTransformFeedbackEXT和vkCmdEndTransformFeedbackEXT一起用作计数器缓冲区。 VK_BUFFER_USAGE_RAY_TRACING_BIT_NV指定缓冲区适用于vkCmdTraceRaysNV和vkCmdBuildAccelerationStructureNV。 VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT指定缓冲区可以通过vkGetBufferDeviceAddress来检索缓冲区设备地址，并使用该地址从着色器访问缓冲区的内存。 2.2 VkMemoryPropertyFlags1234567891011typedef enum VkMemoryPropertyFlagBits &#123; VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002, VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004, VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008, VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010, VK_MEMORY_PROPERTY_PROTECTED_BIT = 0x00000020, VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = 0x00000040, VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = 0x00000080, VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkMemoryPropertyFlagBits; VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: 指定使用这种类型分配的内存对于设备访问是最有效的。当且仅当内存类型属于设置了VK_MEMORY_HEAP_DEVICE_LOCAL_BIT的堆时，才会设置此属性。 VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: 指定使用这种类型分配的内存可以通过vkMapMemory映射给主机访问。 VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: 指定主机缓存管理命令vkFlushMappedMemoryRanges和vkInvalidateMappedMemoryRanges分别用于刷新主机对设备的写操作，或者使设备的写操作对主机可见。 VK_MEMORY_PROPERTY_HOST_CACHED_BIT: 指定用这种类型分配的内存缓存在主机上。主机内存对非缓存内存的访问比对缓存内存的访问慢，但是非缓存内存总是与主机一致的。 VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: 指定内存类型仅允许设备访问内存。内存类型不能同时设置VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT。另外，对象的后备内存可以由在惰性分配内存中指定的lazy实现提供。 VK_MEMORY_PROPERTY_PROTECTED_BIT: 指定内存类型仅允许设备访问内存，并允许受保护的队列操作访问内存。内存类型不能设置VK_MEMORY_PROPERTY_PROTECTED_BIT和任何VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT、VK_MEMORY_PROPERTY_HOST_COHERENT_BIT或VK_MEMORY_PROPERTY_HOST_CACHED_BIT。 VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: 指定对这种内存类型分配的设备访问将自动变为可用和可见的。 VK_MEMORY_PROPERTY_DEVICE_UNCACHHED_BIT_AMD: 指定用这种类型分配的内存不会缓存到设备上。非缓存设备内存总是设备一致的。 2.3 缓冲区拷贝函数内存传输操作使用命令缓冲区执行，就像绘制命令一样。因此，首先分配一个临时的命令缓冲区。您可能希望为这些短期缓冲区创建一个单独的命令池，因为实现可能能够应用内存分配优化。在这种情况下，您应该在生成命令池期间使用VK_COMMAND_POOL_CREATE_TRANSIENT_BIT标志。 123456789101112131415161718192021222324252627282930313233343536void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) &#123; VkCommandBufferAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandPool = commandPool; allocInfo.commandBufferCount = 1; VkCommandBuffer commandBuffer; vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer); // 开始记录指令 VkCommandBufferBeginInfo beginInfo = &#123;&#125;; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; // 只使用一次命令缓冲区，并等待函数返回，直到复制操作完成执行 // 所以使用VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT标志 beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT; vkBeginCommandBuffer(commandBuffer, &amp;beginInfo); // 缓冲拷贝指令 VkBufferCopy copyRegion = &#123;&#125;; copyRegion.srcOffset = 0; // Optional copyRegion.dstOffset = 0; // Optional copyRegion.size = size; // 缓冲区的内容使用vkCmdCopyBuffer命令传输。 // 源和目标缓冲区以及要复制的区域数组作为参数。copyRegion由源缓冲区偏移量、目标缓冲区偏移量和大小组成 vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &amp;copyRegion); vkEndCommandBuffer(commandBuffer); VkSubmitInfo submitInfo = &#123;&#125;; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &amp;commandBuffer; vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE); vkQueueWaitIdle(graphicsQueue); vkFreeCommandBuffers(device, commandPool, 1, &amp;commandBuffer);&#125; 拷贝缓冲指令的一般流程是: vkAllocateCommandBuffers 创建指令缓冲，分配内存 vkBeginCommandBuffer 开始指令记录 vkCmdCopyBuffer 执行具体指令 vkEndCommandBuffer 结束指令记录 vkQueueSubmit 将指令提交到管道 vkQueueWaitIdle 等待管道执行指令,也可以通过fence机制 vkFreeCommandBuffers 释放指令缓冲区 2.2.1 vkCmdCopyBuffer 拷贝缓冲区在缓冲区对象之间复制数据，调用:vkCmdCopyBuffer 123456void vkCmdCopyBuffer( VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions); commandBuffer是命令将被记录到的命令缓冲区。 srcBuffer是源缓冲区。 dstBuffer是目标缓冲区。 regionCount是要复制的区域数。 pRegions是一个指向VkBufferCopy结构体数组的指针，该数组指定了要复制的区域。 2.3 缓冲区拷贝12345678910111213141516171819202122232425262728void createVertexBuffer() &#123; VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size(); VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, // 资源只能由单个队列族独占 stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE); void* data; vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data); memcpy(data, vertices.data(), (size_t) bufferSize); vkUnmapMemory(device, stagingBufferMemory); // 注意这里的MEMORY_PROPERTY是VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT！ createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, // 资源只能由单个队列族独占 vertexBufferMemory, VK_SHARING_MODE_EXCLUSIVE); // 将暂存缓冲区的数据内容拷贝到顶点缓冲区 copyBuffer(stagingBuffer, vertexBuffer, bufferSize); // 销毁暂存缓冲区，释放内存 vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr);&#125; 在这里思考一下，为什么要使用一个暂存缓冲区替换原来的直接使用memcpy呢，而且使用暂存缓冲还额外多了一个创建缓冲区的操作？ 因为图形管道使用顶点数据缓冲区时，如果需要更改顶点数据内容，还需要等待memcpy,如果使用暂存缓冲区，可以将更改顶点数据内容的操作放在另一个线程执行，等到写完之后，再使用vkCmdCopyBuffer指令拷贝内存数据，这样图形管道最多等待这个指令拷贝的时间。当然这一点现在看不出来优势，等我们的顶点数据多而且绘制内容复杂的时候就可以体现出来了。 让我们更近一步，考虑到每次拷贝都需要执行vkAllocateCommandBuffers分配内存，不如一开始就请求一块合适的内存区域，毕竟这个函数开销还是很大的。通过使用我们在许多函数中看到的偏移参数，在许多不同的对象之间分割单个分配或回收。可以自己实现也可以使用GPUOpen倡议提供的VulkanMemoryAllocator库。 三. 索引缓冲区在真实世界的应用程序中渲染的3D网格经常会在多个三角形之间共享顶点。比如画一个矩形: 绘制一个矩形需要两个三角形(基本绘制单元只有点、线和三角形，所以矩形是两个三角形之和)，这意味着需要有6个顶点的顶点缓冲区。问题是两个顶点的部分数据重复，会产生50%的冗余。在更复杂的网格中，只会变得更糟，因为顶点会在平均3个三角形中重复使用。解决这个问题的方法是使用索引缓冲区。 索引缓冲区本质上是一个指向顶点缓冲区的指针数组。它允许重新排序顶点数据，并为多个顶点重用现有数据。上面的插图演示了一个顶点缓冲区包含四个不同的顶点，其索引缓冲区会是什么样子的。前三个索引定义了右上角的三角形，后三个索引定义了左下角三角形的顶点(顺时钟)。 3.1 创建索引缓冲区接下来将修改顶点数据并添加索引数据来绘制一个矩形，像上图中一样。修改顶点数据以表示四个角: 123456const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;-0.5f, -0.5f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, -0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;&#125;&#125;; 左上角是红色的，右上方是绿色的，右下角是蓝色的，左下角是白色的。现在添加一个新的数组索引来表示索引缓冲区的内容，匹配图中的索引来绘制右上三角形和左下三角形。 123const std::vector&lt;uint16_t&gt; indices = &#123; 0, 1, 2, 2, 3, 0&#125;; 可以使用uint16_t或uint32_t作为索引缓冲区，这取决于顶点中条目的数量。我们可以坚持uint16_t现在，因为我们使用少于65535唯一顶点。 就像顶点数据一样，索引需要上传到VkBuffer中，GPU才能访问它们。定义两个新的类成员来保存索引缓冲区的资源: 123456789101112131415161718192021222324252627282930313233343536VkBuffer indexBuffer;VkDeviceMemory indexBufferMemory;void initVulkan() &#123; ... createVertexBuffer(); createIndexBuffer(); ...&#125;void createIndexBuffer() &#123; VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size(); VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, // 资源只能由单个队列族独占 stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE); void* data; vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data); memcpy(data, indices.data(), (size_t) bufferSize); vkUnmapMemory(device, stagingBufferMemory); createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, // 资源只能由单个队列族独占 indexBufferMemory, VK_SHARING_MODE_EXCLUSIVE); // 将暂存缓冲区的数据内容拷贝到顶点缓冲区 copyBuffer(stagingBuffer, indexBuffer, bufferSize); // 销毁暂存缓冲区，释放内存 vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr);&#125; 可以看到 createIndexBuffer 几乎和 createVertexBuffer 一样，只有bufferSize和VkBufferUsageFlags不同而已，毕竟都是只是缓冲区。 索引缓冲同样也需要显示销毁： 12345678void cleanup() &#123; cleanupSwapChain(); vkDestroyBuffer(device, indexBuffer, nullptr); vkFreeMemory(device, indexBufferMemory, nullptr); vkDestroyBuffer(device, vertexBuffer, nullptr); vkFreeMemory(device, vertexBufferMemory, nullptr); ...&#125; 3.2 使用顶点缓冲使用索引缓冲区绘制涉及createCommandBuffers的两个更改。我们首先需要绑定索引缓冲区，就像我们对顶点缓冲区所做的那样。但是索引缓冲区只能有一个。而且，不可能对每个顶点属性使用不同的索引，所以即使只有一个属性发生变化，仍然需要完全复制顶点数据。 索引缓冲区与vkCmdBindIndexBuffer绑定，vkCmdBindIndexBuffer包含索引缓冲区、其中的字节偏移量和索引数据类型作为参数。如前所述，可能的类型是VK_INDEX_TYPE_UINT16和VK_INDEX_TYPE_UINT32。 仅仅绑定索引缓冲区还不能改变任何东西，我们还需要更改绘图命令来告诉Vulkan使用索引缓冲区。移除vkCmdDraw，并用vkCmdDrawIndexed替换: 123456789VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;VkDeviceSize offsets[] = &#123;0&#125;;vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);// VK_INDEX_TYPE_UINT16 是因为我们索引用的就是uint16_tvkCmdBindIndexBuffer(commandBuffers[i], indexBuffer, 0, VK_INDEX_TYPE_UINT16);// 使用vkCmdDrawIndexed替换vkCmdDraw// vkCmdDraw(commandBuffers[i], static_cast&lt;uint32_t&gt;(vertices.size()), 1, 0, 0);vkCmdDrawIndexed(commandBuffers[i], static_cast&lt;uint32_t&gt;(indices.size()), 1, 0, 0, 0);vkCmdEndRenderPass(commandBuffers[i]); 对vkCmdDrawIndexed函数的调用非常类似于vkCmdDraw。前两个参数指定索引的数量和实例的数量。我们没有使用实例，所以只指定一个实例。索引的数量表示将被传递到顶点缓冲区的顶点的数量。下一个参数指定到索引缓冲区的偏移量，使用值1将导致显卡从第二个索引开始读取。倒数第二个参数指定要添加到索引缓冲区中的索引的偏移量。最后一个参数指定了实例化的偏移量。 四. 绘制命令概述绘制命令大致分为两类:非索引绘图命令和索引绘图命令。 4.1 非索引绘图命令非索引绘图命令为顶点着色器提供一个连续的vertexIndex。顺序索引是由设备自动生成的，这些命令有: vkCmdDraw vkCmdDrawIndirect vkCmdDrawIndirectCount vkCmdDrawIndirectCountKHR vkCmdDrawIndirectCountAMD 4.1.1 vkCmdDrawvkCmdDraw可以记录一个非索引的绘制，其原型如下: 123456void vkCmdDraw( VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance); commandBuffer是命令记录到的命令缓冲区 vertexCount是要绘制的顶点数 instanceCount是要绘制的实例数量 firstVertex是绘制的第一个顶点的索引 firstInstance是绘制的第一个实例的实例ID 执行该命令时，将使用当前基本体拓扑和顶点计数连续顶点索引（第一个顶点索引值等于第一个顶点）组装基本体。原语绘制实例数量为instanceCount，instanceIndex从firstInstance开始，每个实例依次递增。组装原语的执行要绑定到图形管道。 4.1.2 vkCmdDrawIndirectvkCmdDrawIndirect用于记录非索引的间接绘制，其原型如下: 123456void vkCmdDrawIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride); commandBuffer是记录命令的命令缓冲区 buffer是包含绘图参数的缓冲区 offset是参数开始的缓冲区中的字节偏移量 drawCount是要执行的绘制数，可以为零 stride是连续绘图参数集之间的字节步幅 vkCmdDrawIndirect的行为与vkCmdDraw类似，不同的是参数是在执行过程中由设备从缓冲区读取的。drawCount绘制由命令执行，参数从缓冲区的偏移量开始，每次绘制时按步长字节递增。每次绘制的参数都编码在一个VkDrawIndirectCommand结构数组中。如果drawCount小于或等于1，则忽略stride。 4.1.3 vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD记录来自缓冲区的draw调用计数的非索引绘制调用,可以使用vkCmdDrawIndirectCount，vkCmdDrawIndirectCountKHR或者vkCmdDrawIndirectCountAMD, 这三个指令几乎等效： 1234567891011121314151617181920212223242526void vkCmdDrawIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);void vkCmdDrawIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);void vkCmdDrawIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride); commandBuffer是记录命令的命令缓冲区 buffer是包含绘图参数的缓冲区 offset是参数开始的缓冲区中的字节偏移量 countBuffer是包含绘图计数的缓冲区 countBufferOffset是开始绘制计数的字节偏移到countBuffer中 maxDrawCount指定将执行的最大绘制数。实际执行的绘制调用数是countBuffer和maxDrawCount中指定的最小计数 stride是连续绘图参数集之间的字节步幅 vkCmdDrawIndirectCount的行为与vkCmdDrawIndirectCount类似，只是在执行期间设备从缓冲区读取绘制计数。该命令将从位于countBufferOffset的countBuffer中读取一个无符号32位整数，并将其用作绘图计数。 4.2 索引绘图命令索引图形命令从索引缓冲区读取索引值，并使用此命令计算顶点着色器的vertexIndex值。这些命令有： vkCmdDrawIndexed vkCmdDrawIndexedIndirect vkCmdDrawIndexedIndirectCount vkCmdDrawIndexedIndirectCountKHR vkCmdDrawIndexedIndirectCountAMD 4.2.1 vkCmdDrawIndexedvkCmdDrawIndexed可以记录一个索引的绘制，其原型如下: 1234567void vkCmdDrawIndexed( VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance); commandBuffer是命令记录到的命令缓冲区 indexCount是要绘制的顶点数 instanceCount是要绘制的实例数 firstIndex是索引缓冲区中的基索引 vertexOffset是在索引到顶点缓冲区之前添加到顶点索引的值 firstInstance是要绘制的第一个实例的实例ID 在执行该命令时，使用当前基元拓扑和indexCount顶点组装基元，这些顶点的索引是从索引缓冲区检索的。索引缓冲区被视为一个紧凑封装的大小无符号整数数组，该整数由vkCmdBindIndexBuffer::indexType形参定义，该形参与该缓冲区绑定。 第一个顶点索引位于绑定索引缓冲区中的firstIndex * indexSize + offset的偏移量，其中offset是由vkCmdBindIndexBuffer指定的偏移量，indexSize是由indexType指定的类型的字节大小。从索引缓冲区中连续的位置检索后续的索引值。索引首先与原始的重启值比较，然后0扩展到32位(如果indexType是VK_INDEX_TYPE_UINT8_EXT或VK_INDEX_TYPE_UINT16)，并添加vertexOffset，然后再作为vertexIndex值提供。 这些原语是用从firstInstance开始的instanceIndex绘制instanceCount次数，并按顺序增加每个实例。组装的原语执行应绑定图形管道。 4.2.2 vkCmdDrawIndexedIndirectvkCmdDrawIndexedIndirect用于记录索引的间接绘制，其原型如下: 123456void vkCmdDrawIndexedIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride); commandBuffer是记录命令的命令缓冲区 buffer是包含绘图参数的缓冲区 offset是参数开始的缓冲区中的字节偏移量 drawCount是要执行的绘制数，可以为零 stride是连续绘图参数集之间的字节步幅 vkCmdDrawIndexedIndirect的行为与vkcmddrawindex类似，不同的是参数是在执行过程中由设备从缓冲区中读取的。drawCount绘制由命令执行，参数从缓冲区的偏移量开始，每次绘制时按步长字节递增。每次绘制的参数都编码在vkdrawindexdindirectcommand结构的数组中。如果drawCount小于或等于1，则忽略stride。 4.2.3 vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD同样的，记录来自缓冲区的draw调用计数的索引绘制调用,可以使用, 这三个指令几乎等效： 1234567891011121314151617181920212223242526void vkCmdDrawIndexedIndirectCount( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);void vkCmdDrawIndexedIndirectCountKHR( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride);void vkCmdDrawIndexedIndirectCountAMD( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride); commandBuffer是记录命令的命令缓冲区 buffer是包含绘图参数的缓冲区 offset是参数开始的缓冲区中的字节偏移量 countBuffer是包含绘制计数的缓冲区 countBufferOffset是进入countBuffer的字节偏移量，在这里开始绘制计数 maxDrawCount指定将执行的最大绘制数。实际执行的draw调用数是countBuffer和maxDrawCount中指定的最小计数 stride是连续绘图参数集之间的字节步幅 vkCmdDrawIndexedIndirectCount的行为与vkCmdDrawIndexedIndirect类似，只是在执行期间设备从缓冲区读取绘制计数。该命令将从位于countBufferOffset的countBuffer中读取一个无符号32位整数，并将其用作绘图计数。 五. 小结在上一篇文章中，我们使用顶点描述符VkVertexInputBindingDescription和VkVertexInputAttributeDescription替换了硬编码顶点，并且使用VkBuffer存储了顶点数据，好处是可随时更改顶点信息。在本文中，我们又使用了暂存缓冲优化了顶点缓冲每次都需要memcpy的弊端，还介绍了顶点索引，使得我们的程序可以画出更多的图形。 使用暂存缓冲是因为图形管道使用顶点数据缓冲区时，如果需要更改顶点数据内容，还需要等待memcpy,如果使用暂存缓冲区，可以将更改顶点数据内容的操作放在另一个线程执行，等到写完之后，再使用vkCmdCopyBuffer指令拷贝内存数据，这样图形管道最多等待这个指令拷贝的时间。当顶点数据多而且绘制内容复杂的时候就可以体现出来了。 而使用顶点索引缓冲是和顶点缓冲几乎一样的流程，只是VkBuffer创建时的VkBufferUsageFlags和size(对应的数据不同嘛)不同。 不过这里还是很好奇，顶点索引和顶点的关系，比如如果我们顶点坐标不变，顶点索引改成： 1234// 顶点索引std::vector&lt;uint16_t&gt; indices = &#123; 0, 1, 2, 2, 3, 1&#125;; 对应的图形就变成了: 但是当顶点索引改成: 1234// 顶点索引std::vector&lt;uint16_t&gt; indices = &#123; 0, 1, 2, 2, 3, 4&#125;; 对应的图形就变成了: 这个顶点索引和最终图像的生成到底是什么个关系呢，参考:https://zhuanlan.zhihu.com/p/97496535 Vulkan中的坐标系使用的右手坐标系，相比OpenGL是用的左手坐标系： 其中原点(0,0,0)在屏幕中央, 所以当我们想画一个三棱锥可以使用如下顶点及索引: 1234567891011// 顶点数据std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;-0.25f, -0.01f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;&#125;, &#123;&#123;0.01f, -0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;&#125;, &#123;&#123;0.25f, 0.01f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125;, &#123;&#123;-0.01f, 0.15f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;&#125;&#125;;// 顶点索引std::vector&lt;uint16_t&gt; indices = &#123; 0,1,2,2,3,0,0,1,3,1,2,3&#125;; 接下来，让我们再接再厉，学习使用资源描述符来加载3D图形。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(11)-顶点输入描述及顶点缓冲的创建","slug":"Vulkan入门-11-顶点输入描述及顶点缓冲的创建","date":"2022-02-26T19:34:26.000Z","updated":"2022-02-26T19:41:34.967Z","comments":true,"path":"2022/02/27/Vulkan入门-11-顶点输入描述及顶点缓冲的创建/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/","excerpt":"简述接下来，我们将用内存中的顶点缓冲区替换顶点着色器中的硬编码顶点数据。我们将从创建CPU可见缓冲区的最简单方法开始，并使用memcpy将顶点数据直接复制到其中，然后我们将看到如何使用分段缓冲区将顶点数据复制到高性能内存。","text":"简述接下来，我们将用内存中的顶点缓冲区替换顶点着色器中的硬编码顶点数据。我们将从创建CPU可见缓冲区的最简单方法开始，并使用memcpy将顶点数据直接复制到其中，然后我们将看到如何使用分段缓冲区将顶点数据复制到高性能内存。 首先修改顶点着色器不再包含顶点数据在着色器代码本身， 顶点着色器使用in关键字从顶点缓冲区获取输入。 12345678910111213#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec2 inPosition;layout(location = 1) in vec3 inColor;// 输出为fragColorlayout(location = 0) out vec3 fragColor;void main() &#123; gl_Position = vec4(inPosition, 0.0, 1.0); fragColor = inColor;&#125; inPosition和inColor变量是顶点属性。 它们是在顶点缓冲区中为每个顶点指定的属性，就像我们使用两个数组为每个顶点手动指定位置和颜色一样。 更改后记得重新编译顶点着色器！ 像fragColor一样，layout（location &#x3D; x）批注为输入分配索引，我们之后可以使用索引来引用它们。 重要的是要知道某些类型（例如dvec3 64位向量）使用多个插槽。 这意味着之后的索引必须至少高2倍（这里没搞懂, 需要学习一下GLSL的语法:https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)）： 12layout(location = 0) in dvec3 inPosition;layout(location = 2) in vec3 inColor; 一. 顶点数据将顶点数据从着色器代码移动到程序代码中的数组中。需要引入GLM库，它为我们提供了与线性代数相关的类型，如向量和矩阵, 有与着色器语言中使用的向量类型完全匹配的c++类型。我们将使用这些类型来指定位置和颜色向量。 123456789101112#include &lt;glm/glm.hpp&gt;struct Vertex &#123; glm::vec2 pos; glm::vec3 color;&#125;;const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;0.0f, -0.5f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125;&#125;; 创建一个名为Vertex的新结构，内有两个属性，我们将在其内部的顶点着色器中使用. 使用顶点结构来指定顶点数据的数组。我们使用和之前完全相同的位置和颜色值，但现在它们被组合到一个顶点数组中, 这就是所谓的交错顶点(interleaving vertex)属性。 接下来是告诉Vulkan，一旦数据格式被上传到GPU内存，如何将其传递到顶点着色器。而传达这个信息需要有两种类型的结构: VkVertexInputBindingDescription和VkVertexInputAttributeDescription. 1.1 绑定描述第一个结构是VkVertexInputBindingDescription，我们将向顶点结构添加一个成员函数，用正确的数据填充它。 123456789struct Vertex &#123; glm::vec2 pos; glm::vec3 color; static VkVertexInputBindingDescription getBindingDescription() &#123; VkVertexInputBindingDescription bindingDescription = &#123;&#125;; return bindingDescription; &#125;&#125;; 1.1.1 VkVertexInputBindingDescription12345typedef struct VkVertexInputBindingDescription &#123; uint32_t binding; uint32_t stride; VkVertexInputRate inputRate;&#125; VkVertexInputBindingDescription; binding: 该结构描述的绑定号 stride : 是缓冲区中两个连续元素之间的距离(以字节为单位) inputRate: 是一个VkVertexInputRate值，指定顶点属性寻址是顶点索引还是实例索引的函数 VK_VERTEX_INPUT_RATE_VERTEX: 指定顶点属性寻址是顶点索引的函数，即移动到每个顶点后的下一个数据项 VK_VERTEX_INPUT_RATE_INSTANCE: 指定顶点属性寻址是实例索引的函数，即移到每个实例之后的下一个数据项 顶点绑定描述在所有顶点中从内存加载数据的速率。它指定数据条目之间的字节数，以及是在每个顶点之后还是在每个实例之后移动到下一个数据条目。 1.1.2 绑定所有的顶点数据都打包在一个数组中，所以我们只需要一个绑定: 12345678910static VkVertexInputBindingDescription getBindingDescription() &#123; VkVertexInputBindingDescription bindingDescription = &#123;&#125;; VkVertexInputBindingDescription bindingDescription = &#123;&#125;; bindingDescription.binding = 0; bindingDescription.stride = sizeof(Vertex); bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX; return bindingDescription;&#125; 1.2 属性描述第二个描述如何处理顶点输入的结构是VkVertexInputAttributeDescription。我们将添加另一个辅助函数到顶点来填充这些结构体。 1234567891011121314151617#include &lt;array&gt;struct Vertex &#123; glm::vec2 pos; glm::vec3 color; static VkVertexInputBindingDescription getBindingDescription() &#123; VkVertexInputBindingDescription bindingDescription = &#123;&#125;; return bindingDescription; &#125; static std::array&lt;VkVertexInputAttributeDescription, 2&gt; getAttributeDescriptions() &#123; std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions = &#123;&#125;; return attributeDescriptions; &#125;&#125;; 正如函数原型所表明的，有两个VkVertexInputAttributeDescription,分别代表位置和颜色。 属性描述结构描述如何从源自绑定描述的顶点数据块中提取顶点属性。 1.2.1 VkVertexInputAttributeDescription123456typedef struct VkVertexInputAttributeDescription &#123; uint32_t location; uint32_t binding; VkFormat format; uint32_t offset;&#125; VkVertexInputAttributeDescription; location: 属性的着色器绑定位置号 binding: 该属性获取其数据的绑定号 format: 指顶点属性数据的大小和类型, 应使用颜色通道数量与着色器数据类型中的组件数量相匹配的格式 float: VK_FORMAT_R32_SFLOAT vec2: VK_FORMAT_R32G32_SFLOAT vec3: VK_FORMAT_R32G32B32_SFLOAT vec4: VK_FORMAT_R32G32B32A32_SFLOAT offset: 该属性相对于顶点输入绑定中元素开始的字节偏移量 1.2.2 绑定12345678910111213141516static std::array&lt;VkVertexInputAttributeDescription, 2&gt; getAttributeDescriptions() &#123; std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions = &#123;&#125;; // position attributeDescriptions[0].binding = 0; attributeDescriptions[0].location = 0; attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT; attributeDescriptions[0].offset = offsetof(Vertex, pos); // color attributeDescriptions[1].binding = 0; attributeDescriptions[1].location = 1; attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT; attributeDescriptions[1].offset = offsetof(Vertex, color); return attributeDescriptions;&#125; 这里offsetof函数是用来获取偏移量的。 1.3 管道输入顶点现在需要通过引用createGraphicsPipeline中的结构来设置图形管道以接受这种格式的顶点数据。找到vertexInputInfo结构体并修改它以引用以下两种描述: 1234567auto bindingDescription = Vertex::getBindingDescription();auto attributeDescriptions = Vertex::getAttributeDescriptions();vertexInputInfo.vertexBindingDescriptionCount = 1;vertexInputInfo.vertexAttributeDescriptionCount = static_cast&lt;uint32_t&gt;(attributeDescriptions.size());vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data(); 管道现在已经准备好接受顶点容器格式的顶点数据，并将其传递给顶点着色器。 如果在启用验证层的情况下运行程序，将报出没有顶点缓冲区绑定到绑定。下一步是创建一个顶点缓冲区，并将顶点数据移动到其中，以便GPU能够访问它。 二. 顶点缓冲区Vulkan中的缓冲区是用于存储任意数据的内存区域，这些数据可以被显卡读取，通过描述符集或特定命令将它们绑定到图形或计算管道，或者直接将它们指定为特定命令的参数。它们可以用来存储顶点数据，但也可以用于许多其他目的，以后中探讨。 与我们目前处理的Vulkan对象不同，缓冲区不会自动为自己分配内存， Vulkan API让程序员控制了几乎所有的事情，内存管理就是其中之一。 2.1 创建缓冲区创建一个新的函数createVertexBuffer，并在createCommandBuffers之前从initVulkan调用它： 123456789101112void initVulkan() &#123; ... createCommandPool(); // 有可能使用指令，所以需要在指令池创建之后创建 createVertexBuffer(); createCommandBuffers(); createSyncObjects();&#125;void createVertexBuffer() &#123;&#125; 创建顶点缓冲区需要填充VkBufferCreateInfo结构。 2.1.1 VkBufferCreateInfo12345678910typedef struct VkBufferCreateInfo &#123; VkStructureType sType; const void* pNext; VkBufferCreateFlags flags; VkDeviceSize size; VkBufferUsageFlags usage; VkSharingMode sharingMode; uint32_t queueFamilyIndexCount; const uint32_t* pQueueFamilyIndices;&#125; VkBufferCreateInfo; sType: 结构体类型, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO pNext: 为空或指向特定于扩展的结构的指针 flags: VkBufferCreateFlagBits的位掩码，指定缓冲区的附加参数, 用于配置稀疏缓冲区内存 size: 是要创建的缓冲区的大小(以字节为单位) usage: VkBufferUsageFlagBits的位掩码，指定缓冲区允许的用法 sharingMode: VkSharingMode值，指定当多个队列族访问缓冲区时，缓冲区的共享模式 VK_SHARING_MODE_EXCLUSIVE: 指定对对象的任何范围或图像子资源的访问一次只能由单个队列族独占 VK_SHARING_MODE_CONCURRENT: 指定支持对来自多个队列族的对象的任何范围或映像子资源的并发访问 queueFamilyIndexCount: 是pQueueFamilyIndices数组中的数量 pQueueFamilyIndices: 将访问这个缓冲区的队列族列表(如果shareingmode不是VK_SHARING_MODE_CONCURRENT则忽略) 2.1.2 vkCreateBuffer12345VkResult vkCreateBuffer( VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer); device: 创建缓冲区对象的逻辑设备 pCreateInfo: 指向VkBufferCreateInfo结构的指针，该结构包含影响缓冲区创建的参数 pAllocator: 控制主机内存分配 pBuffer: 指向VkBuffer句柄的指针，在该句柄中返回结果缓冲区对象 VkBuffer缓冲区表示用于各种目的的数据的线性数组，通过描述符集或特定命令将它们绑定到图形或计算管道，或者直接将它们指定为特定命令的参数。 缓冲区由VkBuffer句柄表示： 2.1.3 createVertexBuffer12345678910111213VkBuffer vertexBuffer;void createVertexBuffer() &#123; VkBufferCreateInfo bufferInfo = &#123;&#125;; bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; bufferInfo.size = sizeof(vertices[0]) * vertices.size(); bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT; bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; if (vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;vertexBuffer) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create vertex buffer!&quot;); &#125;&#125; 创建后不需要时应该手动销毁: 123456void cleanup() &#123; cleanupSwapChain(); vkDestroyBuffer(device, vertexBuffer, nullptr); ...&#125; 2.2 给顶点缓冲区分配内存缓冲区已创建，但实际上尚未分配任何内存。为缓冲区分配内存的第一步是使用vkGetBufferMemoryRequirements函数查询其内存需求. 12VkMemoryRequirements memRequirements;vkGetBufferMemoryRequirements(device, vertexBuffer, &amp;memRequirements); 2.2.1 vkGetBufferMemoryRequirements1234void vkGetBufferMemoryRequirements( VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements); device: 创建缓冲区对象的逻辑设备 buffer: 待请求所需内存大小的缓冲区 pMemoryRequirements: 指向VkMemoryRequirements结构的指针，在该结构中返回缓冲区对象的内存需求 2.2.2 VkMemoryRequirements12345typedef struct VkMemoryRequirements &#123; VkDeviceSize size; VkDeviceSize alignment; uint32_t memoryTypeBits;&#125; VkMemoryRequirements; size: 资源所需的内存分配的大小（以字节为单位） alignment: 资源所需的分配内偏移量的对齐（以字节为单位）,即缓冲区在分配的内存区域中开始的偏移量 memoryTypeBits: 适合缓冲区的内存类型的位字段 2.2.3 findMemoryType图形显卡可以提供不同类型的内存进行分配。每种类型的内存在允许的操作和性能特性方面都有所不同。 我们需要结合缓冲区的需求和我们自己的应用程序需求来找到合适的内存类型。为此，我们创建一个新函数findMemoryType: 1234567891011121314uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) &#123; // 首先获取物理显卡支持的内存类型 VkPhysicalDeviceMemoryProperties memProperties; vkGetPhysicalDeviceMemoryProperties(physicalDevice, &amp;memProperties); for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) &#123; if (typeFilter &amp; (1 &lt;&lt; i) &amp;&amp; // 可能有多个属性 (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) &#123; return i; &#125; &#125; throw std::runtime_error(&quot;failed to find suitable memory type!&quot;);&#125; typeFilter参数用于指定适合的内存类型的位字段。 2.2.3.1 VkPhysicalDeviceMemoryProperties123456typedef struct VkPhysicalDeviceMemoryProperties &#123; uint32_t memoryTypeCount; VkMemoryType memoryTypes[VK_MAX_MEMORY_TYPES]; uint32_t memoryHeapCount; VkMemoryHeap memoryHeaps[VK_MAX_MEMORY_HEAPS];&#125; VkPhysicalDeviceMemoryProperties; memoryTypeCount: memoryTypes数组中的有效元素数。 memoryTypes: VK_MAX_MEMORY_TYPES_Vk MemoryType结构数组，描述可用于访问从memoryHeaps指定的堆中分配的内存的内存类型。 memoryHeapCount: memoryHeaps数组中的有效元素数。 memoryHeaps: VK_MAX_MEMORY_HEAPS VkMemoryHeap结构的数组，描述可以从中分配内存的内存堆。 VkPhysicalDeviceMemoryProperties结构描述了许多内存堆以及一些内存类型，这些内存类型可用于访问这些堆中分配的内存。每个堆描述特定大小的内存资源，每个内存类型描述一组内存属性（例如，主机缓存与未缓存），这些属性可以与给定内存堆一起使用。使用特定内存类型的分配将消耗该内存类型的堆索引指示的堆中的资源。多个内存类型可以共享每个堆，堆和内存类型提供了一种机制，以宣告物理内存资源的精确大小，同时允许将内存与各种不同的属性一起使用。 2.2.4 分配内存通过findMemoryType, 现在可以获取正确的内存类型，接下来就是给VkBuffer分配内存了。 不同类型的内存具有不同的属性。一些类型的内存可以被CPU访问，一些不可以。一些类型可以在GPU和CPU间保持数据一致性、一些类型可以被CPU缓存使用等等。可以通过查询物理设备获取这些信息。我们可以根据需要使用不同的内存类型，比如对于暂存资源，我们需要使用可以被CPU访问的内存类型。对于用于渲染的图像、顶点数据，我们通常为其分配GPU内存。 内存分配现在只需指定大小和类型就可以了，这两种类型都来自于顶点缓冲区的内存需求和所需的属性。创建一个类成员来将句柄存储到内存中，并用vkallocatemory分配它。 2.2.4.1 VkMemoryAllocateInfo123456typedef struct VkMemoryAllocateInfo &#123; VkStructureType sType; const void* pNext; VkDeviceSize allocationSize; uint32_t memoryTypeIndex;&#125; VkMemoryAllocateInfo; sType: 结构体类型, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO pNext: 为空或指向特定于扩展的结构的指针 allocationSize: 内存分配大小，以字节为单位 memoryTypeIndex: 内存类型的索引，VkPhysicalDeviceMemoryProperties结构的memoryTypes数组中的数据 2.2.4.2 内存分配123456789101112void createVertexBuffer() &#123; ... VkMemoryAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; allocInfo.allocationSize = memRequirements.size; allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT); if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;vertexBufferMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate vertex buffer memory!&quot;); &#125;&#125; 内存对象对设备内存中的数据进行操作可以使用vkAllocateMemory函数: 12345VkResult vkAllocateMemory( VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory); device: 是拥有内存的逻辑设备 pAllocateInfo: 指向描述分配参数的VkMemoryAllocateInfo结构的指针。成功返回的分配必须使用请求的参数 - 实现不允许替换。 pAllocator: 控制内存分配 pMemory: 指向VkDeviceMemory句柄的指针，在该句柄中返回有关已分配内存的信息 vkallocatemory返回的分配保证满足实现的任何对齐要求。例如，如果一个实现需要128字节的图像对齐和64字节的缓冲区对齐，那么通过这个机制返回的设备内存将是128字节对齐的。这确保了应用程序可以在同一内存对象中正确地子分配不同类型的对象（具有可能不同的对齐要求）。 2.2.4.3 内存与缓冲区关联如果内存分配成功，那么可以使用vkBindBufferMemory将此内存与缓冲区关联： 1vkBindBufferMemory(device, vertexBuffer, vertexBufferMemory, 0); 要将内存附加到缓冲区对象可以调用vkBindBufferMemory函数： 12345VkResult vkBindBufferMemory( VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset); device: 是拥有内存的逻辑设备 buffer: 要附加到内存的缓冲区 memory: 描述要附加的设备内存的VkDeviceMemory对象 memoryOffset: 要绑定到缓冲区的内存区域的起始偏移量。因为这个内存被专门分配给这个顶点缓冲区，所以偏移量是0。如果偏移量不为零，则要求它可以被整除内存memRequirements.alignment. 一旦缓冲区不再使用，绑定到缓冲区对象的内存可能会被释放，因此让我们在缓冲区被销毁后释放它： 123456789// 在 vulkan 中推荐在创建的资源不需要后主动释放void cleanup() &#123; // 清理交换链关联资源 cleanupSwapChain(); // 清理顶点缓冲区 vkDestroyBuffer(device, vertexBuffer, nullptr); vkFreeMemory(device, vertexBufferMemory, nullptr); ...&#125; 2.3 填充顶点缓冲区现在是时候将顶点数据复制到缓冲区了。可以通过使用vkMapMemory将缓冲内存映射到CPU可访问内存来实现: 1234567VkResult vkMapMemory( VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData); device: 拥有内存的逻辑设备 memory: 要映射的VkDeviceMemory对象 offset: 从内存对象开始的以零为基础的字节偏移量 size: 映射的内存范围的大小，或者是要从偏移量映射到分配末尾的VK_WHOLE_SIZE大小 flags: 保留供将来使用 ppData: 指向void*变量的指针，指向映射内存的指针的输出。在该变量中返回指向映射范围开头的主机可访问指针。此指针减去偏移量必须至少与VkPhysicalDeviceLimits:：minMemoryMapAlignment对齐 此函数允许我们访问由偏移量和大小定义的指定内存资源区域: 1234567void* data;// 将缓冲内存映射到CPU可访问内存vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &amp;data);// 将顶点数据拷贝到映射内存中memcpy(data, vertices.data(), (size_t) bufferInfo.size);// 使用vkUnmapMemory再次取消映射vkUnmapMemory(device, vertexBufferMemory); 填充顶点数据到缓冲区内存的方式就是先映射然后拷贝，最后解映射。 但是驱动程序可能不会立即将数据复制到缓冲区内存中，例如因为缓存(Cache)机制。有两种方法可以解决这个问题： 缓存的内存类型使用主机相关的内存堆，用VK_MEMORY_PROPERTY_HOST_COHERENT_BIT表示 在写入映射内存后调用vkFlushMappedMemoryRanges以及在从映射内存读取之前调用vkInvalidateMappedMemoryRanges 对于CPU可以访问的内存类型，可以使用vkMapMemory&#x2F;vkUnmapMemory函数对其进行映射。这一映射是持久化的，只要进行了正确的同步，可以在GPU使用这一内存区域时访问它。 vkMapMemory函数返回的指针可以被保存使用，只要进行了正确的同步，甚至可以在GPU使用这一内存区域时对其进行写入操作，同步规则可以保证CPU不会写入数据到GPU正在使用的那部分内存。 这里我们采用第一个方式实现，确保映射内存始终与分配内存的内容匹配。 刷新内存范围或使用一致的内存堆意味着驱动程序将知道我们对缓冲区的写入，但这并不意味着它们在GPU上实际上是可见的。将数据传输到GPU是一个在后台发生的操作，规范简单地告诉我们，它保证在下一次调用vkQueueSubmit时完成。 2.4 绑定顶点缓冲区现在我们有了顶点缓冲区，也分配了内存并填充了顶点数据，就剩下在渲染操作期间绑定顶点缓冲区。 通过扩展createCommandBuffers函数来实现: 12345678vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;VkDeviceSize offsets[] = &#123;0&#125;;vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);vkCmdDraw(commandBuffers[i], static_cast&lt;uint32_t&gt;(vertices.size()), 1, 0, 0);vkCmdEndRenderPass(commandBuffers[i]); 将顶点缓冲区绑定到命令缓冲区，以便在后续绘制命令中使用，需要使用vkCmdBindVertexBuffers: 123456void vkCmdBindVertexBuffers( VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets); commandBuffer: 记录命令的命令缓冲区。 firstBinding: 第一个顶点输入绑定的索引，其状态由命令更新。 bindingCount: 状态由命令更新的顶点输入绑定数 pBuffers: 指向缓冲区句柄数组的指针。 pOffsets: 指向缓冲区偏移量数组的指针。 从pBuffers和poffset的元素i获取的值替换了顶点输入绑定firstBinding+i的当前状态，即[0，bindingCount]中的i。顶点输入绑定将更新为从缓冲区pBuffers[i]开始的由pOffsets[i]指示的偏移处开始。所有使用这些绑定的顶点输入属性都将在后续绘制命令的地址计算中使用这些更新的地址。 三. 根据鼠标移动变化颜色现在我们完成了从硬编码的顶点输入转为程序内的顶点数据输入， 更改vertices就可以看到颜色有变化，比如: 123456// 顶点数据const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;0.0f, -0.5f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;1.0f, 1.0f, 0.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125;&#125;; 对应的图形就是: 现在我们动手做根据鼠标移动动态变化颜色: 1234567891011121314151617181920212223242526272829303132333435void initWindow() &#123; ... // 处理事件 initGlfwInput();&#125;void initGlfwInput() &#123; // 注册鼠标位置监听 glfwSetCursorPosCallback(window, cursor_position_callback);&#125;static void cursor_position_callback(GLFWwindow* window, double xpos, double ypos) &#123; auto app = reinterpret_cast&lt;HelloTriangleApplication*&gt;(glfwGetWindowUserPointer(window)); if (app-&gt;widthOfWindow != 0 &amp;&amp; app-&gt;heightOfWindow != 0) &#123; float xP = xpos/app-&gt;widthOfWindow; float yP = ypos/app-&gt;heightOfWindow; float x = xP * 2 - 1; float y = yP * 2 - 1; app-&gt;vertices = &#123; &#123;&#123;x, y&#125;, &#123;xP, xP, xP&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;yP, yP, yP&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125; &#125;; // 顶点数据变化后，重新拷贝至内存中 app-&gt;reMemcpyVertexBuffer(sizeof(app-&gt;vertices[0]) * app-&gt;vertices.size()); &#125;&#125;void reMemcpyVertexBuffer(VkDeviceSize size) &#123; void* data; vkMapMemory(device, vertexBufferMemory, 0, size, 0, &amp;data); memcpy(data, vertices.data(), (size_t) size); vkUnmapMemory(device, vertexBufferMemory);&#125; 最后的结果: 哈哈，有那么回事了，第一个顶点会跟随鼠标移动而移动，并且三角形也会变幻颜色, 不过这里只是简单的处理，甚至没有考虑同步问题。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(10)-重建交换链","slug":"Vulkan入门-10-重建交换链","date":"2022-02-26T19:34:10.000Z","updated":"2022-02-26T19:40:23.936Z","comments":true,"path":"2022/02/27/Vulkan入门-10-重建交换链/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/","excerpt":"简述在上一篇里，我们已经成功绘制了一个颜色渐变的三角形，并将其显示在窗口上了。但是窗口Surface可能会发生变化，从而使交换链不再与之兼容，比如是窗口大小的变化。所以我们必须捕获这些事件并重新创建交换链。","text":"简述在上一篇里，我们已经成功绘制了一个颜色渐变的三角形，并将其显示在窗口上了。但是窗口Surface可能会发生变化，从而使交换链不再与之兼容，比如是窗口大小的变化。所以我们必须捕获这些事件并重新创建交换链。 一. 重建交换链创建一个新的recreateSwapChain函数，该函数调用createSwapChain和所有依赖于交换链或窗口大小的对象的创建函数: 1234567891011121314151617void cleanupSwapChain() &#123;&#125;void recreateSwapChain() &#123; // 等待队列中所有操作完成 vkDeviceWaitIdle(device); // 先清理后创建 cleanupSwapChain(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers();&#125; 首先调用vkDeviceWaitIdle，确保不触及可能仍在使用的资源。显然，我们必须做的第一件事是重新创建交换链本身。 需要重新创建图像视图，因为它们直接基于交换链图像。渲染通道需要重新创建，因为它取决于交换链图像的格式。交换链的图像格式很少在窗口调整等操作期间发生改变，但它仍然应该被处理。视口和剪刀矩形大小是在图形管道创建时指定的，因此管道也需要重新构建。可以通过使用动态状态的视图和剪刀矩形来避免这种情况。最后，帧缓冲区和命令缓冲区也直接依赖于交换链图像。 为了确保这些对象的旧版本在重新创建它们之前得到清理，我们应该将一些清理代码移到一个单独的函数中，我们可以从recreateSwapChain函数调用这个函数cleanupSwapChain。 1.1 cleanupSwapChain将所有和交换链相关的资源从cleanup函数中移到此函数内： 12345678910111213141516171819202122232425262728void cleanupSwapChain() &#123; // 释放所有的帧缓冲区 for (auto framebuffer : swapChainFramebuffers) &#123; vkDestroyFramebuffer(device, framebuffer, nullptr); &#125; // 释放指令缓冲区 // 可以从头重新创建命令池，但相当浪费。所以选择使用vkFreeCommandBuffers函数清理现有的命令缓冲区。 // 这样可以重用现有的池来分配新的命令缓冲区。 vkFreeCommandBuffers(device, commandPool, static_cast&lt;uint32_t&gt;(commandBuffers.size()), commandBuffers.data()); // 销毁图形管道 vkDestroyPipeline(device, graphicsPipeline, nullptr); // 释放管道布局 vkDestroyPipelineLayout(device, pipelineLayout, nullptr); // 释放渲染通道 vkDestroyRenderPass(device, renderPass, nullptr); // 释放交换链对应的图像视图 for (auto imageView : swapChainImageViews) &#123; vkDestroyImageView(device, imageView, nullptr); &#125; // 释放交换链 vkDestroySwapchainKHR(device, swapChain, nullptr);&#125;void cleanup() &#123; cleanupSwapChain(); ...&#125; 可以从头重新创建命令池，但相当浪费。所以选择使用vkFreeCommandBuffers函数清理现有的命令缓冲区, 这样可以重用现有的池来分配新的命令缓冲区。 1.2 获取窗口最新大小为了正确地处理窗口的大小，我们还需要查询framebuffer的当前大小，以确保交换链图像具有(新的)正确的大小。为了做到这一点，改变chooseSwapExtent函数来考虑实际的大小: 12345678910111213141516// 选择交换链分辨率VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities) &#123; if (capabilities.currentExtent.width != std::numeric_limits&lt;uint32_t&gt;::max()) &#123; return capabilities.currentExtent; &#125; else &#123; int width, height; glfwGetFramebufferSize(window, &amp;width, &amp;height); VkExtent2D actualExtent = &#123; static_cast&lt;uint32_t&gt;(width), static_cast&lt;uint32_t&gt;(height)&#125;; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; &#125;&#125; 通过glfwGetFramebufferSize函数来获取当前窗口大小。 这就是重建交换链所需要的全部!然而，这种方法的缺点是:需要在创建新的交换链之前停止所有的呈现。当从旧的交换链在图像上绘制命令时，可以创建一个新的交换链。需要将之前的交换链传递给VkSwapchainCreateInfoKHR结构中的oldswarechain字段，并在使用完旧的交换链后立即销毁它。 1.3 次优或过时的交换链现在，我们只需要确定何时需要重新创建交换链，并调用新的recreateSwapChain函数。幸运的是，Vulkan通常会告诉我们交换链在显示过程中不再足够。vkAcquireNextImageKHR和vkQueuePresentKHR函数可以返回以下特殊值来表示这一点: VK_ERROR_OUT_OF_DATE_KHR: 交换链已经变得与表面不兼容，不能再用于渲染。通常发生在窗口大小调整之后。 VK_SUBOPTIMAL_KHR:交换链仍然可以成功地呈现到表面，但是表面的属性不再完全匹配。 12345678910VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits&lt;uint64_t&gt;::max(), imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);if (result == VK_ERROR_OUT_OF_DATE_KHR) &#123; recreateSwapChain(); // 已经获得了一个映像。VK_SUCCESS和VK_SUBOPTIMAL_KHR都被认为是“成功”返回码, 也可以去掉return return;&#125; else if (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123; throw std::runtime_error(&quot;failed to acquire swap chain image!&quot;);&#125; 如果交换链在试图获取映像时已经过期，那么就不可能再向其呈现。因此，应该立即重新创建交换链，并在下一个drawFrame调用中再次尝试。然而，如果在这中止绘图，那么栅栏将永远不会通过vkqueuessubmit提交，当我们稍后尝试等待它时，它将处于一个意想不到的状态。我们可以重建fence作为交换链重建的一部分，但是移动vkResetFences调用更容易: 12345vkResetFences(device, 1, &amp;inFlightFences[currentFrame]);// VkQueue是Vulkan中应用程序向GPU提交命令的唯一途径if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#125; 把fence放在vkQueueSubmit之前，而不是在vkWaitForFences后立刻调用。这是什么原理呢？ 1.3.1 fencefence是一种同步原语，可用于将依赖项从队列插入到主机。fence有两种状态——有信号的和没有信号的, fence可以作为队列提交命令执行的一部分发出信号。 使用vkResetFences可以将fence置为unsignal状态。主机可以通过vkWaitForFences命令来等待fence，并且可以通过vkGetFenceStatus来查询当前的状态。 如果vkWaitForFences被调用时条件被满足，那么vkWaitForFences会立即返回。如果在vkWaitForFences被调用的时候条件没有被满足，那么vkWaitForFences将会阻塞并等待到超时纳秒，直到条件被满足。这里的条件就是fence状态是不是signal状态。vkQueueSubmit会将fence置为signal状态，那么vkWaitForFences就会通过。 所以，当vkWaitForFences之后立刻调用vkResetFences，那么当vkAcquireNextImageKHR发生异常导致返回时，下次在进入drawFrame调用vkWaitForFences就永远处于等待状态了。 1.3.2 vkQueuePresentKHR如果交换链不是最优的，也可以继续呈现，因为我们已经获得了一个映像。VK_SUCCESS和VK_SUBOPTIMAL_KHR都被认为是“成功”返回码。 123456result = vkQueuePresentKHR(presentQueue, &amp;presentInfo);if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) &#123; recreateSwapChain();&#125; else if (result != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to present swap chain image!&quot;);&#125; vkQueuePresentKHR函数返回具有相同含义的相同值。 在这种情况下，如果交换链不是次优的，为获得最好的结果，最好重新创建交换链。 1.4 主动处理窗口变化尽管许多驱动程序和平台在调整窗口大小后会自动触发VK_ERROR_OUT_OF_DATE_KHR，但不能保证一定会发生这种情况。所以最好通过监听窗口变化来主动重建交换链。 添加一个新的成员变量，该变量指示已调整大小： 12345678910bool framebufferResized = false;void drawFrame() &#123; ... result = vkQueuePresentKHR(presentQueue, &amp;presentInfo); if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) &#123; framebufferResized = false; recreateSwapChain(); ...&#125; 1.4.1 监听窗口变化要实际检测窗口大小调整，可以使用GLFW框架中的glfwSetFramebufferSizeCallback函数来设置回调： 123456789101112131415void initWindow() &#123; glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Vulkan&quot;, nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);&#125;static void framebufferResizeCallback(GLFWwindow* window, int width, int height) &#123; auto app = reinterpret_cast&lt;HelloTriangleApplication*&gt;(glfwGetWindowUserPointer(window)); app-&gt;framebufferResized = true;&#125; 因为glfw回调只能通过静态函数实现，所以通过glfwSetWindowUserPointer保存当前实例指针。 1.5 窗口最小化还有一种特殊状态是，当最小化窗口时，拿到的窗口大小是0, 这样创建出来的帧缓冲区大小也应该是0，根本不需要渲染。所以这里做一个简单的等待处理: 12345678910void recreateSwapChain() &#123; int width = 0, height = 0; while (width == 0 || height == 0) &#123; glfwGetFramebufferSize(window, &amp;width, &amp;height); glfwWaitEvents(); &#125; vkDeviceWaitIdle(device); ...&#125; 突然有点好奇这个绘制的刷新率，通过在drawFrame里嵌入函数computeRefreshRate来计算刷新率: 123456789101112131415161718void computeRefreshRate() &#123; static float fps = 0; static int64_t count = 0; static int64_t lastCount = 0; static auto lastTimestamp = std::chrono::high_resolution_clock::now(); static auto now = std::chrono::high_resolution_clock::now(); count++; now = std::chrono::high_resolution_clock::now(); float duration = std::chrono::duration_cast&lt;std::chrono::duration&lt;float&gt;&gt;(now-lastTimestamp).count(); if (duration &gt;= 1) &#123; lastTimestamp = now; fps = (count - lastCount)/duration; lastCount = count; std::cout&lt;&lt;&quot;computeRefreshRate: fps=&quot;&lt;&lt;fps&lt;&lt;&quot;, count=&quot;&lt;&lt;count&lt;&lt;std::endl; &#125;&#125; 算出来高达4k，看起来这个fence也并没有同步gpu显示，只是不停的提交。 那么如果我们想吧这个实时刷新率显示在我们程序的左上角，该怎么做呢?","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(9)-渲染和显示","slug":"Vulkan入门-9-渲染和显示","date":"2022-02-26T19:33:58.000Z","updated":"2022-02-26T19:39:31.582Z","comments":true,"path":"2022/02/27/Vulkan入门-9-渲染和显示/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/","excerpt":"简述在这一章里，所有的事情都要集中起来。我们将编写drawFrame函数，该函数将在主循环中被调用，以将三角形置于屏幕上。创建函数并从mainLoop调用它. 123456789void mainLoop() &#123; while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); drawFrame(); &#125;&#125;...void drawFrame() &#123;&#125;","text":"简述在这一章里，所有的事情都要集中起来。我们将编写drawFrame函数，该函数将在主循环中被调用，以将三角形置于屏幕上。创建函数并从mainLoop调用它. 123456789void mainLoop() &#123; while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); drawFrame(); &#125;&#125;...void drawFrame() &#123;&#125; 一. 同步drawFrame函数将执行以下操作: 从交换链获取一个映像 在framebuffer中以该图像作为附件执行命令缓冲 将图像返回到交换链以便显示 这些事件都是使用单个函数调用设置的，但它们是异步执行的。函数调用将在操作实际完成之前返回，并且执行的顺序也未定义。因为每个操作都依赖于前一个完成，所以需要同步机制。 有两种同步交换链事件的方法:栅栏和信号量。 它们都是可以用于协调操作的对象，方法是让一个操作信号和另一个操作等待栅栏或信号量从无信号状态变为有信号状态。 不同的是，你可以通过vkWaitForFences来访问fences的状态，而信号量却不能。 fence主要用于通过呈现操作同步应用程序本身，而信号量用于在命令队列内或跨命令队列同步操作。我们想要同步draw命令和表示的队列操作，这使得信号量最适合。 1.1 信号量同步信号量是一种同步原语，可以用来在提交给队列的批之间插入依赖关系。信号量有两种状态——有信号的和无信号的。一个信号量的状态可以在一批命令执行完成后发出信号。批处理可以在开始执行前等待信号量变成有信号的，也可以在批处理开始执行前等待信号量变成无信号的。 与Vulkan中的大多数对象一样，信号量是内部数据的接口，通常对应用程序是不透明的。这个内部数据被称为信号量的有效负载。但是，为了能够与当前设备之外的代理进行通信，必须能够将有效负载导出为一种普遍理解的格式，然后再从该格式导入。信号量的内部数据可以包括对任何资源的引用，以及与在该信号量对象上执行的信号或非信号操作相关的待定工作。 下面提供了向信号量导入和导出内部数据的机制。这些机制间接地使应用程序能够跨进程和API边界在两个或多个信号量和其他同步原语之间共享信号量状态。 信号量由VkSemaphore句柄表示:VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore) 12345VkResult vkCreateSemaphore( VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore); device: 创建信号量的逻辑设备 pCreateInfo: 指向VkSemaphoreCreateInfo结构体实例的指针，该结构体包含了如何创建信号量的信息 pAllocator: 控制内存分配 pSemaphore: 指向返回结果信号量对象的句柄。 创建时，信号量处于无信号状态。 12345typedef struct VkSemaphoreCreateInfo &#123; VkStructureType sType; const void* pNext; VkSemaphoreCreateFlags flags;&#125; VkSemaphoreCreateInfo; sType: 此结构的类型，VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO pNext: 为空或指向特定于扩展的结构的指针 flags: 当前API下无可用flag, 未来版本的Vulkan API或扩展可能会像对其他结构一样为flag和pNext参数添加功能 1.2 创建信号量 vkCreateSemaphore需要一个信号量来表示图像已经获得并准备好呈现，还需要另一个信号量来表示渲染已经完成并可以进行呈现。创建两个类成员来存储这些信号量对象: 12VkSemaphore imageAvailableSemaphore;VkSemaphore renderFinishedSemaphore; 创建信号量需要填写VkSemaphoreCreateInfo，但是在当前版本的API中，除了sType之外实际上没有任何必需的字段: 1234567891011121314void initVulkan() &#123; ... createSemaphores();&#125;void createSemaphores() &#123; VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphore) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create semaphores!&quot;); &#125;&#125; 同理，信号量应该在程序结束时清除，当所有的命令都已经完成，不再需要更多的同步: 12345void cleanup() &#123; vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); ...&#125; 二. 从交换链获取图像如前所述，在drawFrame函数中需要做的第一件事是从交换链中获取图像。回想一下，交换链是一个扩展特性，所以我们必须使用一个具有vk*KHR命名约定的函数: 123456void drawFrame() &#123; uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits&lt;uint64_t&gt;::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);&#125; 获取一个可用的可呈现图像使用，并检索该图像的索引，调用: vkAcquireNextImageKHR: 1234567VkResult vkAcquireNextImageKHR( VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex); device: 提供逻辑设备句柄 swapChain: 交换链对象的句柄, 从这个交换链中获取图像 timeout: 指定如果没有可用的映像，函数将等待多长时间(以纳秒为单位)。 semaphore: 是VK_NULL_HANDLE或者一个信号量 fence: VK_NULL_HANDLE或fence to signal。 pImageIndex: 一个指向uint32_t的指针, 用于输出可用的交换链映像的索引, 索引指的是swapChainImages数组中的VkImage。我们将使用这个索引来选择正确的命令缓冲区。 当成功时，vkAcquireNextImageKHR从swapchain获得一个应用程序可以使用的图像，并将pImageIndex设置为该图像在swapchain中的索引。表示引擎在获取图像时可能还没有完成对图像的读取，因此应用程序必须使用信号量和&#x2F;或栅栏来确保图像布局和内容在表示引擎读取完成之前不会被修改。如果semaphore不是VK_NULL_HANDLE，应用程序可能会认为，一旦vkAcquireNextImageKHR返回，semaphore引用的信号量信号操作已经提交执行。图像获取的顺序取决于实现，并且可能与图像呈现的顺序不同。 如果timeout为0，则vkAcquireNextImageKHR不会等待，并且会成功获取镜像，或者失败并返回VK_NOT_READY，如果没有可用的镜像。如果指定的超时时间在获取镜像之前过期，vkAcquireNextImageKHR将返回VK_TIMEOUT。如果timeout是UINT64_MAX，超时时间被认为是无限的，vkAcquireNextImageKHR将阻塞直到一个图像被获取或一个错误发生。 如果应用程序当前获取的(但尚未呈现的)图像数量小于或等于swapchain中的图像数量与vksurfacecabiltieskhr::minImageCount值之间的差值，则最终会获得一个图像。如果当前获取的图像数量大于此值，则不应该调用vkAcquireNextImageKHR;如果是，timeout不能是UINT64_MAX。 如果一个图像成功获得，vkAcquireNextImageKHR必须要么返回VK_SUCCESS，要么返回VK_SUBOPTIMAL_KHR，如果交换链不再完全匹配表面属性，但仍然可以用于表示。 三. 提交指令缓冲区队列提交和同步是通过VkSubmitInfo结构中的参数配置的。 1234567891011typedef struct VkSubmitInfo &#123; VkStructureType sType; const void* pNext; uint32_t waitSemaphoreCount; const VkSemaphore* pWaitSemaphores; const VkPipelineStageFlags* pWaitDstStageMask; uint32_t commandBufferCount; const VkCommandBuffer* pCommandBuffers; uint32_t signalSemaphoreCount; const VkSemaphore* pSignalSemaphores;&#125; VkSubmitInfo; sType: 此结构的类型，VK_STRUCTURE_TYPE_SUBMIT_INFO pNext: 为空或指向特定于扩展的结构的指针 waitSemaphoreCount: 执行批处理的命令缓冲区之前需要等待的信号量的数量 pWaitSemaphores: 指向VkSemaphore句柄数组的指针，在这个批处理的命令缓冲区开始执行之前，要等待该句柄。如果提供了等待的信号量，则定义一个信号量等待操作。 pWaitDstStageMask: 指向每个对应的信号量等待将发生的管道阶段数组的指针 commandBufferCount: 批处理中要执行的命令缓冲区的数量 pCommandBuffers: 指向要在批处理中执行的VkCommandBuffer句柄数组的指针 signalSemaphoreCount: 在pCommandBuffers中指定的命令完成执行后要发出信号的信号量的数量 pSignalSemaphores: 指向VkSemaphore句柄数组的指针，当这个批处理的命令缓冲区完成执行时，VkSemaphore句柄数组将发出信号。如果提供了要发送信号的信号量，它们定义了一个信号量信号操作。 命令缓冲区在pCommandBuffers中出现的顺序用于确定提交顺序，因此所有的隐式排序都保证遵守它。除了这些隐式排序保证和任何显式同步原语之外，这些命令缓冲区可能会重叠或以其他方式乱序执行。 12345678910111213141516171819202122232425// 前三个参数指定在执行开始之前等待哪些信号量，以及在管道的哪个阶段等待。VkSubmitInfo submitInfo = &#123;&#125;;submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;// 我们希望等待向图像写入颜色，直到它可用为止，因此我们指定了向颜色附件写入的图形管道阶段。VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;submitInfo.waitSemaphoreCount = 1;submitInfo.pWaitSemaphores = waitSemaphores;// 理论上已经可以开始执行顶点着色器，而还没有可用图像。// waitStages数组中的每一项都对应于在pwaitsemaphres中具有相同索引的信号量。submitInfo.pWaitDstStageMask = waitStages;// 指定实际提交哪些命令缓冲区以执行submitInfo.commandBufferCount = 1;submitInfo.pCommandBuffers = &amp;commandBuffers[imageIndex];// 指定在命令缓冲区完成执行后要发送哪些信号量VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;submitInfo.signalSemaphoreCount = 1;submitInfo.pSignalSemaphores = signalSemaphores;// 使用vkqueuessubmit将命令缓冲区提交到图形队列if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#125; 使用vkqueuessubmit将命令缓冲区提交到图形队列。当工作负载更大时，该函数接受一个VkSubmitInfo结构数组作为效率参数。最后一个参数引用一个可选的fence，该fence将在命令缓冲区完成执行时发出信号。我们使用信号量进行同步，所以我们将传递一个VK_NULL_HANDLE。 12345VkResult vkQueueSubmit( VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence); queue: 命令缓冲将被提交到的队列 submitCount: 提交数组pSubmits中的元素数量 pSubmits: 指向VkSubmitInfo结构数组的指针，每个结构都指定了一个命令缓冲区提交批处理 fence: 可选的fence句柄，一旦所有提交的命令缓冲区完成执行，就会发出信号。如果fence不是VK_NULL_HANDLE，则定义一个fence信号操作 提交可能是一个高开销的操作，应用程序应该尽可能少的调用vkqueuessubmit来批量处理。 四. Subpass依赖渲染通道中的子通道会自动处理图像布局的转换。这些转换由子传递依赖项控制，子传递依赖项指定子传递之间的内存和执行依赖项。 我们现在只有一个Subpass，但是在这个Subpass之前和之后的操作也被算作隐式的“Subpasses”。 有两个内置的依赖关系负责渲染通道开始和结束的转换，但前者没有在正确的时间发生。它假设转换发生在管道的开始，但是我们在那一点还没有获得图像! 有两种方法来处理这个问题： 将imageAvailableSemaphore的等待阶段更改为VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT，以确保渲染通道直到图像可用时才开始 让渲染通道等待VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT阶段。 在这里使用第二种方法，因为这是一个很好的方式来了解子传递依赖项及其工作方式。Subpass依赖在VkSubpassDependency结构中指定。 在createRenderPass函数中添加一个: 123456789101112131415VkSubpassDependency dependency = &#123;&#125;;// 指定依赖项dependency.srcSubpass = VK_SUBPASS_EXTERNAL;// 从属子传递的索引dependency.dstSubpass = 0;// 指定要等待的操作以及这些操作发生的阶段// 需要等待交换链完成对图像的读取后才能访问它。这可以通过等待颜色附件输出阶段本身来完成。dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;// 在这一阶段应该等待的操作是在颜色连接阶段，包括阅读和书写颜色连接。// 这些设置将防止转换发生，直到它是真正必要的(和允许的):当我们想要开始写入颜色。renderPassInfo.dependencyCount = 1;renderPassInfo.pDependencies = &amp;dependency; 特殊值VK_SUBPASS_EXTERNAL指的是在渲染传递之前或之后的隐式子传递，这取决于它是在srcSubpass还是dstSubpass中指定的。索引0指向我们的子通道，它是第一个也是唯一一个。dstSubpass必须始终高于srcSubpass，以防止依赖关系图中的循环。 五. 显示绘制框架的最后一步是将结果提交回交换链，使其最终显示在屏幕上。 在应用程序可以呈现一个图像之前，图像的布局必须转换为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR布局，或者对于一个共享的可呈现图像，必须转换为VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR布局。 5.1 VkPresentInfoKHR12345678910typedef struct VkPresentInfoKHR &#123; VkStructureType sType; const void* pNext; uint32_t waitSemaphoreCount; const VkSemaphore* pWaitSemaphores; uint32_t swapchainCount; const VkSwapchainKHR* pSwapchains; const uint32_t* pImageIndices; VkResult* pResults;&#125; VkPresentInfoKHR; sType: 此结构的类型，VK_STRUCTURE_TYPE_PRESENT_INFO_KHR pNext: 为空或指向特定于扩展的结构的指针 waitsemaphore: 在发出当前请求之前等待的信号量的数量, 可能是零。 pwaitsemaphres: 空的或指向带有waitsemaphore条目的VkSemaphore对象数组的指针，它指定了在发出当前请求之前需要等待的信号量。 swapchainCount: 指令提供给交换链的数量 pSwapchains: 指向带有swapchainCount条目的VkSwapchainKHR对象数组的指针。给定的交换链不能在此列表中出现多次。 pImageIndices: 指向每个swapchain的可呈现图像数组的索引数组的指针，其中包含swapchainCount条目。这个数组中的每个条目都标识要在pSwapchains数组中的相应条目上显示的图像。 results: 指向带有swapchainCount条目的VkResult类型元素数组的指针。不需要每个swapchain结果的应用程序可以对结果使用NULL。如果非null，则results中的每个条目都将被设置为VkResult，以表示与pSwapchains中的相同索引相对应的交换链。 5.2 显示设置通过drawFrame函数末尾的VkPresentInfoKHR结构来配置显示相关设置: 123456789101112131415161718VkPresentInfoKHR presentInfo = &#123;&#125;;presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;// 指定在表示发生之前等待哪些信号量，就像VkSubmitInfo一样presentInfo.waitSemaphoreCount = 1;presentInfo.pWaitSemaphores = signalSemaphores;// 指定要向其显示图像的交换链，以及每个交换链的图像索引。VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;presentInfo.swapchainCount = 1;presentInfo.pSwapchains = swapChains;presentInfo.pImageIndices = &amp;imageIndex;// 指定一个VkResult值数组，以便在表示成功时检查每个交换链。// 只使用单个交换链，就不需要，因为可以简单地使用当前函数的返回值。presentInfo.pResults = nullptr; // Optional// vkQueuePresentKHR函数提交请求，以向交换链请求一个图像vkQueuePresentKHR(presentQueue, &amp;presentInfo); 现在编译运行一下我们的程序: ohhhh!!!!整整一千多行的代码，终于不是黑糊糊的窗口了。 当启用验证层时，程序在关闭时就会崩溃。从debugCallback打印到终端的消息告诉我们为什么: 记住，drawFrame中的所有操作都是异步的。这意味着当我们退出mainLoop中的循环时，绘图和表示操作可能仍然在进行。当这种情况发生时，清理资源就可能带来异常。 要解决这个问题，我们应该等待逻辑设备完成操作，然后退出mainLoop并销毁窗口: 1234567void mainLoop() &#123; while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); drawFrame(); &#125;&#125;vkDeviceWaitIdle(device); 5.2.1 vkQueuePresentKHR在将所有渲染命令排队并将图像转换到正确的布局后，要将图像排队显示，调用: 123VkResult vkQueuePresentKHR( VkQueue queue, const VkPresentInfoKHR* pPresentInfo); queue是一个能够在与图像交换链相同的设备上显示到目标表面平台的队列。 pPresentInfo是一个指向VkPresentInfoKHR结构体的指针，该结构体指定了表示的参数。 应用程序不需要按照获取图像的顺序来呈现图像——应用程序可以任意地呈现当前获取的任何图像。 六. Frames in flight如果在启用了验证层的情况下运行应用程序，并且监视应用程序的内存使用情况，则可能会注意到它正在缓慢增长。 原因是应用程序正在使用drawFrame函数快速提交工作，但实际上并没有检查是否有任何工作完成。如果CPU提交工作的速度快于GPU不能跟上的工作，那么队列将缓慢地填满工作。 更糟糕的是，我们同时对多个帧重用了imageAvailableSemaphore和renderFinishedSemaphore。 解决此问题的简单方法是提交后等待工作完成，例如使用vkQueueWaitIdle： 12345void drawFrame() &#123; ... vkQueuePresentKHR(presentQueue, &amp;presentInfo); vkQueueWaitIdle(presentQueue);&#125; 但是，我们可能无法以这种方式最佳地使用GPU，因为整个图形流水线现在一次只能使用一帧。 当前帧已经经过的阶段是空闲的，可能已经用于下一帧。 现在，我们将扩展我们的应用程序，以允许在运行多个frame的同时仍限制堆积的工作量。 首先在程序顶部添加一个常量，该常量定义应同时处理多少帧, 以及每个frame应具有自己的一组信号： 123456789101112131415161718192021222324252627const int MAX_FRAMES_IN_FLIGHT = 2;std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;void createSemaphores() &#123; imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT); renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT); VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS || vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create semaphores for a frame!&quot;); &#125; &#125;&#125;void cleanup() &#123; for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr); vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr); &#125; ...&#125; 同理，drawFrame也需要修改: 123456789void drawFrame() &#123; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits&lt;uint64_t&gt;::max(), imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex); ... VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;; ... VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;; ...&#125; 这里的currentFrame可以通过取模来获取: currentFrame &#x3D; (currentFrame + 1)%MAX_FRAMES_IN_FLIGHT 通过使用模（％）运算符，我们确保帧索引在每个MAX_FRAMES_IN_FLIGHT排队的帧之后循环。 6.1 fence机制尽管我们现在已经设置了必需的对象以方便同时处理多个帧，但实际上并没有阻止提交超过MAX_FRAMES_IN_FLIGHT个对象。 现在只有GPU-GPU同步，没有CPU-GPU同步来跟踪工作的进行情况。 我们可能正在使用第0帧对象，而第0帧仍在显示中！ 为了执行CPU-GPU同步，Vulkan提供了第二种类型的同步原语，称为fences。 在可以发信号并等待信号的意义上，fence与信号相似，但是这次我们实际上在自己的代码中等待信号。 我们首先为每个框架创建一个fence： 1234std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;std::vector&lt;VkFence&gt; inFlightFences;size_t currentFrame = 0; 因为fence也是同步机制，所以最好把同步对象的创建放在一起，吧createSemaphores改名成createSyncObjects: 123456789101112131415161718void createSyncObjects() &#123; imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT); renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT); inFlightFences.resize(MAX_FRAMES_IN_FLIGHT); VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; VkFenceCreateInfo fenceInfo = &#123;&#125;; fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS || vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS || vkCreateFence(device, &amp;fenceInfo, nullptr, &amp;inFlightFences[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create synchronization objects for a frame!&quot;); &#125; &#125;&#125; 也要记得销毁fence. 123456789void cleanup() &#123; // 释放信号量和fence for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i ++) &#123; vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr); vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr); vkDestroyFence(device, inFlightFences[i], nullptr); &#125;&#125; 现在使用fence进行同步。vkqueuessubmit调用包含一个可选参数，用于传递一个fence，当命令缓冲区执行完毕时，该fence应该被通知。我们可以用它来表示一个帧已经完成。 1234567891011void drawFrame() &#123; // 等待当前帧fence完成 vkWaitForFences(device, 1, &amp;inFlightFences[currentFrame], VK_TRUE, std::numeric_limits&lt;uint64_t&gt;::max()); vkResetFences(device, 1, &amp;inFlightFences[currentFrame]); ... // VkQueue是Vulkan中应用程序向GPU提交命令的唯一途径 if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;); &#125; ...&#125; vkWaitForFences函数接受一个fences数组，在返回之前等待其中任何一个或者所有的栅栏被通知。我们在这里传递的VK_TRUE表示我们希望等待所有的fence，但在单个fence的情况下，这显然无关紧要。就像vkAcquireNextImageKHR一样，这个函数也是需要一个超时。 与信号量不同，我们需要通过vkResetFences调用来手动将栅栏恢复到无信号状态。如果你现在运行这个程序，你会注意到一些奇怪的东西。应用程序似乎不再呈现任何东西。这是因为在等一个还没被提交的fence! 这里的问题是，在默认情况下，fence是在无信号状态下创建的。这意味着如果我们以前没有用过fence，vkWaitForFences将会永远等下去。为了解决这个问题，我们可以改变fence的创建，在有信号的状态下初始化它，就像我们已经完成了初始帧的渲染一样: 123VkFenceCreateInfo fenceInfo = &#123;&#125;;fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT; // 初始化fence 程序现在应该可以正常工作了，内存泄漏也消失了! 我们已经实现了所有需要的同步，以确保排队的工作不超过两个帧。请注意，代码的其他部分，如最终的清理，可以依赖于更粗糙的同步，如vkDeviceWaitIdle，应该根据性能需求决定使用哪种方法。 Vulkan管道的框图 七. 总结现在我们已经写了一千多行的代码，总算把Vulkan的这一套简单的过了一遍。在继续后续学习之前，有必要先总结一下，巩固基础。 首先Vulkan是什么：Vulkan是一个低开销、跨平台的二维、三维图形与计算的应用程序接口（API）。本身是一个与平台无关的API，所以不包括用于创建显示渲染结果的窗口的工具。所以借助 GLFW （当然也可以是其他库如SDL）创建窗口。 下面是一个Vuklan应用一般流程的简述: 借助GLFW库，创建显示窗口。 创建Vulkan实例VkInstance 使用VkApplicationInfo和VkInstanceCreateInfo声明相关配置 调用 vkCreateInstance, 创建 vulkan 实例 如果是开发调试，可以启用验证层 实现调试回调函数 通过VkDebugUtilsMessengerCreateInfoEXT.pfnUserCallback绑定消息回调函数 通过CreateDebugUtilsMessengerEXT函数实例化DebugUtilsMessengerEXT 注意在不需要的时候显示销毁回调实例 PFN_vkDestroyDebugUtilsMessengerEXT 检索合适的物理设备 通过vkEnumeratePhysicalDevices获取本机物理显卡，并根据需要选择合适GPU 通过vkGetPhysicalDeviceProperties检查显卡的基本功能 查询vkGetPhysicalDeviceFeatures中可以被支持的feature 挑选需要的队列族 通过vkGetPhysicalDeviceQueueFamilyProperties获取物理显卡支持的队列，并挑选需要的队列 创建逻辑设备 VkDevice 首先将4.2.1中挑选的队列记录在VkDeviceQueueCreateInfo中，指定要创建的队列VkDeviceCreateInfo.pQueueCreateInfos 指定使用的设备功能(feature)，比如几何着色器等 通过vkCreateDevice函数创建逻辑设备，注意在不需要的时候显示销毁逻辑设备(vkDestroyDevice) 队列是与逻辑设备一起自动创建的，直接通过vkGetDeviceQueue获取该逻辑设备上指定的队列即可（当逻辑设备被销毁时，会隐式清除设备队列） 创建Surface 启用VK_KHR_surface扩展，通过glfw的glfwCreateWindowSurface创建VkSurfaceKHR 创建交换链，即渲染缓冲区, 本质上是一个等待呈现给屏幕的图像队列 检查GPU是否支持交换链，VK_KHR_SWAPCHAIN_EXTENSION_NAME 使能设备VK_KHR_swapchain扩展 获取关于swap chain更多支持细节 基本Surface功能（交换链中的最小&#x2F;最大图像数，图像的最小&#x2F;最大宽度和高度） Surface的格式（像素格式，色彩空间） 可用的呈现模式 为交换链选择合适的设置，如Surface格式（颜色深度）、呈现模式（将图像“交换”到屏幕的条件）、交换范围（交换链中图像的分辨率）等 创建swap chain对象 VkSwapchainKHR 绑定窗口Surface 设置最小图像数量 minImageCount 选择合适的图像格式 imageFormat 选择合适的图像颜色空间 imageColorSpace 选择合适的图像分辨率 imageExtent 设置图像图层 imageArrayLayers 设置图像操作方式 imageUsage 选择图像呈现模式 presentMode 是否需要裁剪功能 clipped(VK_TRUE, VK_FALSE) 设置旧交换链的引用 oldSwapchain 获取交换链图像(VkImage)对象集合 创建渲染过程，Render Passes 通过vkCreateRenderPass创建，在不需要时通过vkDestroyRenderPass销毁 创建图形管道, 在Vulkan中，必须明确所有内容，从视口大小到颜色混合功能。有如下几个固定操作： 输入汇编程序(input assembler): 从指定的缓冲区收集原始顶点数据，也可以使用索引缓冲区重复某些元素，而不必复制顶点数据本身。 顶点着色器(vertex shader): 针对每个顶点运行，并且通常应用变换以将顶点位置从模型空间转换到屏幕空间。它还沿着管道传递每顶点数据。 曲面细分着色器(tessellation shaders): 根据特定规则细分几何体以提高网格质量。通常用于使砖墙和楼梯等表面在附近时看起来不那么平坦。 几何着色器(geometry shader): 在每个基元(三角形，直线，点)上运行，并且可以丢弃它或输出比原来更多的基元。类似于曲面细分着色器，但更灵活。但没有得到太多应用，因为大多数显卡的性能都不是很好。 光栅化阶段(rasterization stage): 将基元离散化为片段。这些是它们填充在帧缓冲区上的像素元素。在屏幕之外的片段都将被丢弃，顶点着色器输出的属性将在片段之间进行插值。由于深度测试，通常在这里也丢弃其他原始片段后面的片段。 片段着色器(fragment shader): 为存活的每个片段调用片段着色器，并确定片段写入哪些帧缓冲区以及使用哪些颜色和深度值。它可以使用来自顶点着色器的插值数据来完成此操作，其中可以包括纹理坐标和法线照明等内容。 颜色混合阶段(color blending stage): 应用操作来混合映射到帧缓冲区中的相同像素的不同片段。 fragment可以简单地相互覆盖，加起来或根据透明度进行混合。 输入汇编程序、光栅化和颜色混合阶段阶段被称为固定功能阶段。这些阶段允许使用参数调整其操作，但它们的工作方式是预定义的。 顶点着色器、曲面细分着色器、几何着色器和片段着色器阶段是可编程的，这意味着可以将代码上传到图形卡，以完全应用想要的操作。 例如，实现从纹理和光照到光线跟踪器的任何内容。这些程序同时在许多GPU内核上运行，以并行处理许多对象，如顶点和片段。，可以使用片段着色器 通过vkCreateGraphicsPipelines创建图形管道，指明渲染过程 创建帧缓冲区 调整帧缓冲区容器的大小以容纳所有交换链图像视图 指定帧缓冲区需要与哪个renderPass兼容。只能对与之兼容的渲染过程使用帧缓冲区，这意味着它们使用相同数量和类型的附件。 attachmentCount和pAttachments参数指定应绑定到渲染过程pAttachment数组中相应附件描述的VkImageView对象。 帧缓冲区宽度和高度参数是交换链中获取的宽高 帧缓冲区的layers是指图像数组中的层数 在不需要时，通过vkDestroyFramebuffer销毁帧缓冲区 创建指令缓冲区，Vulkan必须在指令缓冲区对象中记录想要执行的所有操作 先创建创建指令缓冲池，Command pool 创建指令缓冲区，大小和帧缓冲一致 渲染和显示 从交换链获取一个映像 在framebuffer中以该图像作为附件执行命令缓冲，提交指令缓冲区 将图像返回到交换链以便显示 渲染显示的过程需要同步 好的，现在我们又加深了一遍印象，这其中诸多细节我们后续挖掘。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(8)-帧缓冲区和指令缓冲区","slug":"Vulkan入门-8-帧缓冲区和指令缓冲区","date":"2022-02-26T19:33:45.000Z","updated":"2022-02-26T19:39:14.149Z","comments":true,"path":"2022/02/27/Vulkan入门-8-帧缓冲区和指令缓冲区/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/","excerpt":"简述Framebuffers, 帧缓冲区。之前我们在学习’Swap Chain-交换链’时提到Vulkan没有“默认帧缓冲区”的概念，取而代之的是名为 “swap chain” 即交换链，也就是渲染的缓冲区，必须在Vulkan中明确创建。 现在我们已经设置了渲染过程，以期望使用与交换链图像相同格式的单个帧缓冲区，但实际上我们还没有创建任何帧缓冲区。 通过将渲染过程创建期间指定的附件包装到VkFramebuffer对象中来绑定附件。 帧缓冲区对象引用表示附件的所有VkImageView对象。在我们的情况下，这将只是一个单一的：颜色附件。但是，我们必须用于附件的图像取决于在检索用于表示的图像时交换链返回的图像。这意味着我们必须为交换链中的所有图像创建一个帧缓冲区，并使用与绘制时检索到的图像相对应的帧缓冲区。","text":"简述Framebuffers, 帧缓冲区。之前我们在学习’Swap Chain-交换链’时提到Vulkan没有“默认帧缓冲区”的概念，取而代之的是名为 “swap chain” 即交换链，也就是渲染的缓冲区，必须在Vulkan中明确创建。 现在我们已经设置了渲染过程，以期望使用与交换链图像相同格式的单个帧缓冲区，但实际上我们还没有创建任何帧缓冲区。 通过将渲染过程创建期间指定的附件包装到VkFramebuffer对象中来绑定附件。 帧缓冲区对象引用表示附件的所有VkImageView对象。在我们的情况下，这将只是一个单一的：颜色附件。但是，我们必须用于附件的图像取决于在检索用于表示的图像时交换链返回的图像。这意味着我们必须为交换链中的所有图像创建一个帧缓冲区，并使用与绘制时检索到的图像相对应的帧缓冲区。 一. VkFramebuffer 创建帧缓冲区帧缓冲区由VkFramebuffer句柄表示： VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer) 通过调用vkCreateFramebuffer来创建： 12345VkResult vkCreateFramebuffer( VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer); device: 创建帧缓冲区的逻辑设备 pCreateInfo: 指向VkFramebufferCreateInfo结构，该结构描述有关帧缓冲区创建的附加信息。 pAllocator: 控制主机内存分配 pFramebuffer: 指向返回结果帧缓冲区对象的VkFramebuffer句柄。 我们创建一个VkFramebuffer的集合来保存所有帧缓冲: 1std::vector&lt;VkFramebuffer&gt; swapChainFramebuffers; 在一个新函数createFramebuffers中为该数组创建对象，该函数在创建图形管道之后立即从initVulkan调用： 123456789101112void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers();&#125; 在createFramebuffers最开始，调整帧缓冲区容器的大小以容纳所有交换链图像视图, 然后遍历图像视图并从它们创建帧缓冲区： 123456789101112131415161718192021void createFramebuffers() &#123; swapChainFramebuffers.resize(swapChainImageViews.size()); for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) &#123; VkImageView attachments[] = &#123; swapChainImageViews[i] &#125;; VkFramebufferCreateInfo framebufferInfo = &#123;&#125;; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &amp;framebufferInfo, nullptr, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create framebuffer!&quot;); &#125;&#125; 如上，帧缓冲区的创建非常简单: 首先需要指定帧缓冲区需要与哪个renderPass兼容。只能对与之兼容的渲染过程使用帧缓冲区，这意味着它们使用相同数量和类型的附件。 attachmentCount和pAttachments参数指定应绑定到渲染过程pAttachment数组中相应附件描述的VkImageView对象。 宽度和高度参数是交换链中获取的宽高 layers是指图像数组中的层数。我们的交换链图像是单个图像，因此层的数量是1。 我们应该先删除帧缓冲区，然后再删除它们所基于的图像视图和渲染过程，但必须在完成渲染之后： 123456void cleanup() &#123; for (auto framebuffer : swapChainFramebuffers) &#123; vkDestroyFramebuffer(device, framebuffer, nullptr); &#125; ...&#125; 现在我们已经到达了一个里程碑–拥有了渲染所需的所有对象。接下来，我们将编写第一个实际的绘图指令。 二. Command buffers 指令缓冲区Vulkan中的指令，比如绘图操作和内存传输，不是直接使用函数调用来执行的。必须在指令缓冲区对象中记录想要执行的所有操作。这样做的好处是，所有设置绘图指令的工作都可以提前在多个线程中完成。之后，只需告诉Vulkan在主循环中执行指令。 指令缓冲区是用来记录指令的对象，这些指令可以随后提交到设备队列中执行。指令缓冲区有两级:一级指令缓冲区，它可以执行二级指令缓冲区，并提交给队列;二级指令缓冲区，它可以由一级指令缓冲区执行，但不直接提交给队列。 2.1 Command pools 指令池在创建指令缓冲区之前必须先创建指令池。指令池管理用于存储缓冲区的内存，并从它们中分配指令缓冲区。 指令池通过允许不同的线程使用不同的分配器来提高多线程性能，而不需要每次使用都进行内部同步。 由VkCommandPool对象表示： VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool) 1VkCommandPool commandPool; 创建指令池函数: 12345VkResult vkCreateCommandPool( VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool); device: 创建指令池的逻辑设备 pCreateInfo: 一个指向VkCommandPoolCreateInfo结构实例的指针，该结构指定指令池对象的状态。 pAllocator: 控制内存分配 pCommandPool: 指向一个VkCommandPool句柄，创建的池返回该句柄。 2.1.1 创建指令池我们创建一个新的函数：createCommandPool, 来执行创建指令池： 123456789101112131415161718192021222324252627282930313233343536void initVulkan() &#123; // checkAvailableExtensions(); createInstance(); // 创建DEBUG消息回调 setupDebugMessenger(); // 创建surface createSurface(); // 选择物理设备 pickPhysicalDevice(); // 创建逻辑设备 createLogicalDevice(); // 创建交换链 createSwapChain(); // 创建交换链图像的VkImageView createImageViews(); // 创建渲染通道 createRenderPass(); // 创建管道 createGraphicsPipeline(); // 创建帧缓冲区 createFramebuffers(); // 创建指令缓冲池 createCommandPool();&#125;void createCommandPool() &#123; QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice); VkCommandPoolCreateInfo poolInfo = &#123;&#125;; poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value(); poolInfo.flags = 0; // Optional if (vkCreateCommandPool(device, &amp;poolInfo, nullptr, &amp;commandPool) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create command pool!&quot;); &#125;&#125; 指令缓冲区是通过将它们提交到设备队列(比如我们检索到的图形和展示队列)上来执行的。 每个指令池只能分配提交到单一类型队列上的指令缓冲区。我们将记录绘图的指令，这就是我们选择图形队列家族的原因。 2.1.2 VkCommandPoolCreateInfo123456typedef struct VkCommandPoolCreateInfo &#123; VkStructureType sType; const void* pNext; VkCommandPoolCreateFlags flags; uint32_t queueFamilyIndex;&#125; VkCommandPoolCreateInfo; sType: 此结构的类型，VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO pNext: 为空或指向特定于扩展的结构的指针。 flags: 是VkCommandPoolCreateFlagBits的位掩码, 指示指令池和从中分配的指令缓冲区的使用行为。 queueFamilyIndex: 指定队列族。从这个指令池分配的所有指令缓冲区必须在来自相同队列族的队列上提交。 2.1.3 VkCommandPoolCreateFlags123456typedef enum VkCommandPoolCreateFlagBits &#123; VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0x00000001, VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0x00000002, VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 0x00000004, VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkCommandPoolCreateFlagBits; VK_COMMAND_POOL_CREATE_TRANSIENT_BIT:指定从池中分配的指令缓冲区将是短暂的，这意味着它们将在相对较短的时间内被重置或释放。这个标志可以被实现用来控制池内的内存分配行为。 VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT:允许从池中分配的任何指令缓冲区被单独重置到初始状态;或者通过调用vkResetCommandBuffer，或者在调用vkBeginCommandBuffer时通过隐式重置。如果在池中没有设置这个标志，那么vkResetCommandBuffer绝对不能被从池中分配的任何指令缓冲区调用。 VK_COMMAND_POOL_CREATE_PROTECTED_BIT:指定从池中分配的指令缓冲区为受保护的指令缓冲区。如果未启用受保护的内存特性，则不能设置VK_COMMAND_POOL_CREATE_PROTECTED_BIT标志位。 鉴于我们将只在程序开始时记录指令缓冲区，然后在主循环中多次执行它们，因此我们不会使用这这些标志。 2.1.4 vkDestroyCommandPool使用vkCreateCommandPool功能完成指令池的创建，指令将在整个程序中使用来绘制屏幕上的东西，所以池应该只在结束时销毁: 12345void cleanup() &#123; // 释放指令池 vkDestroyCommandPool(device, commandPool, nullptr); ...&#125; 2.2 Command buffer allocation 指令缓冲区分配现在我们可以开始分配指令缓冲区并在其中记录绘图指令。因为其中一个绘图指令涉及到绑定正确的VkFramebuffer，所以我们实际上必须再次为交换链中的每个图像记录一个指令缓冲区。 为此，创建一个VkCommandBuffer对象列表作为类成员。当它们的指令池被销毁时，指令缓冲区将被自动释放，所以我们不需要显式的清理。 1std::vector&lt;VkCommandBuffer&gt; commandBuffers; 现在开始使用createCommandBuffers函数，为每个交换链图像(VkImageView)分配和记录指令。 12345678void initVulkan() &#123; ... createCommandBuffers();&#125;void createCommandBuffers() &#123; commandBuffers.resize(swapChainFramebuffers.size());&#125; 2.2.1 vkAllocateCommandBuffers指令缓冲区是通过vkAllocateCommandBuffers函数分配的，该函数以VkCommandBufferAllocateInfo结构体作为参数，指定指令池和要分配的缓冲区数量: 1234VkResult vkAllocateCommandBuffers( VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers); device: 指令池所属的逻辑设备。 pAllocateInfo: 指向VkCommandBufferAllocateInfo结构实例的指针，该结构描述了分配的参数。 pCommandBuffers: 指向VkCommandBuffer句柄数组的指针，在该数组中返回生成的指令缓冲区对象。数组必须至少为pAllocateInfo的commandBufferCount成员指定的长度commandBufferCount。每个分配的指令缓冲区都从初始状态开始。(就是commandBuffers集的首个元素的地址) 2.2.2 VkCommandBufferAllocateInfo1234567typedef struct VkCommandBufferAllocateInfo &#123; VkStructureType sType; const void* pNext; VkCommandPool commandPool; VkCommandBufferLevel level; uint32_t commandBufferCount;&#125; VkCommandBufferAllocateInfo; sType: 结构体类型 pNext: 为空或指向特定于扩展的结构的指针 commandPool: 分配此指令缓冲区的指令池 level: VkCommandBufferLevel值，指定指令缓冲区级别 commandBufferCount: 从池中分配的指令缓冲区的数量 VkCommandBufferLevel, 指定指令缓冲区级别: 12345typedef enum VkCommandBufferLevel &#123; VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0, VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1, VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 0x7FFFFFFF&#125; VkCommandBufferLevel; VK_COMMAND_BUFFER_LEVEL_PRIMARY:指定主指令缓冲区，可以提交到队列执行，但不能从其他指令缓冲区调用。 VK_COMMAND_BUFFER_LEVEL_SECONDARY:指定次要指令缓冲区，不能直接提交，但可以从主指令缓冲区调用。 2.2.3 createCommandBuffers接下来就是完成指令缓冲区集的创建： 123456789101112void createCommandBuffers() &#123; commandBuffers.resize(swapChainFramebuffers.size()); VkCommandBufferAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.commandPool = commandPool; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandBufferCount = (uint32_t) commandBuffers.size(); if (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate command buffers!&quot;); &#125;&#125; 在这里不使用辅助指令缓冲区功能，但是可以想象，重用来自主要指令缓冲区的常用操作是很有帮助的 2.3 启动指令缓冲区记录记录的指令包括将管道和描述符集绑定到指令缓冲区的指令、修改动态状态的指令、绘制指令(用于图形渲染)、调度指令(用于计算)、执行次要指令缓冲区的指令(仅用于主要指令缓冲区)、复制缓冲区和图像的指令，以及其他指令。 为什么需要记录指令？ 先看一下指令缓冲区的生命周期。 2.3.1 指令缓冲区的生命周期每个指令缓冲区总是处于以下状态之一: Initial(初始状态): 当一个指令缓冲区被分配时，它处于初始状态。一些指令能够将一个指令缓冲区或一组指令缓冲区从任何可执行状态、记录状态或无效状态重置回该状态。处于初始状态的指令缓冲区只能移动到记录状态或释放。 Recording(记录状态): vkBeginCommandBuffer改变指令缓冲区的状态从初始状态到记录状态。一旦指令缓冲区处于记录状态，可以使用vkCmd*指令记录到指令缓冲区。 Executable(可执行状态): vkEndCommandBuffer结束指令缓冲区的记录，并将其从记录状态移动到可执行状态。可执行指令缓冲区可以提交、重置或记录到另一个指令缓冲区。 Pending(挂起状态): 指令缓冲区的队列提交将指令缓冲区的状态从可执行状态更改为挂起状态。在挂起状态下，应用程序不能试图以任何方式修改指令缓冲区-因为设备可能正在处理记录到它的指令。一旦指令缓冲区的执行完成，指令缓冲区将返回到可执行状态，或者返回无效状态(如果它是通过VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT记录的)。应该使用一个同步指令来检测何时发生这种情况。 Invalid(无效状态):某些操作，如修改或删除记录到指令缓冲区的指令中使用的资源，将把该指令缓冲区的状态转换为无效状态。处于无效状态的指令缓冲区只能被重置或释放。 所以记录状态可以理解为记录绘制操作，然后记录完毕就转为可执行状态，等待被执行。 2.3.2 记录指令缓冲区通过调用vkBeginCommandBuffer开始记录指令缓冲区，并使用一个小的VkCommandBufferBeginInfo结构作为参数，指定关于这个特定指令缓冲区使用的一些细节。 123VkResult vkBeginCommandBuffer( VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo); commandBuffer: 待放入记录状态的指令缓冲区的句柄。 pBeginInfo: VkCommandBufferBeginInfo结构的一个实例，它定义了关于指令缓冲区如何开始记录的附加信息。 123456typedef struct VkCommandBufferBeginInfo &#123; VkStructureType sType; const void* pNext; VkCommandBufferUsageFlags flags; const VkCommandBufferInheritanceInfo* pInheritanceInfo;&#125; VkCommandBufferBeginInfo; sType: 结构体类型 pNext: 为空或指向特定于扩展的结构的指针 flags: 是VkCommandBufferUsageFlagBits的位掩码，指定命令缓冲区的使用行为。 pInheritanceInfo: 是一个指向VkCommandBufferInheritanceInfo结构的指针，如果commandBuffer是一个次要命令缓冲区，就会使用这个结构。如果这是一个主命令缓冲区，那么这个值将被忽略。 在VkCommandBufferBeginInfo::flags中设置位来指定命令缓冲区的使用行为: 123456typedef enum VkCommandBufferUsageFlagBits &#123; VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0x00000001, VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0x00000002, VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0x00000004, VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkCommandBufferUsageFlagBits; VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:指定命令缓冲区的每个记录将只提交一次，命令缓冲区将被重置并在每次提交之间再次记录。 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT:指定次要命令缓冲区被认为完全位于渲染通道内。如果这是一个主命令缓冲区，那么这个位会被忽略。 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:指定当命令缓冲区处于挂起状态时，可以重新提交给队列，并记录到多个主要命令缓冲区中。 开始指令缓冲区记录: 12345678910for (size_t i = 0; i &lt; commandBuffers.size(); i++) &#123; VkCommandBufferBeginInfo beginInfo = &#123;&#125;; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; // 标记该指令缓冲区可重复追加指令 beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional if (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to begin recording command buffer!&quot;); &#125;&#125; 我们使用VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT标志是因为我们可能已经在为下一帧调度绘图命令，而最后一帧还没有完成。pInheritanceInfo参数仅与辅助命令缓冲区相关。它指定从调用的主命令缓冲区继承哪个状态。 如果命令缓冲区已经被记录过一次，那么调用vkBeginCommandBuffer将隐式重置它。以后不可能向缓冲区追加命令。 2.4 启动渲染通道通过vkCmdBeginRenderPass开始绘制。渲染通道是使用VkRenderPassBeginInfo结构中的一些参数来配置的。 1234void vkCmdBeginRenderPass( VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents); commandBuffer: 指令缓冲区 VkRenderPassBeginInfo: 是一个指向VkRenderPassBeginInfo结构的指针，提供的渲染通道的详细信息 contents: 是一个VkSubpassContents值，控制渲染通道内的绘图命令将如何提供,可以有两个值: VK_SUBPASS_CONTENTS_INLINE:render pass命令将被嵌入到主命令缓冲区中，而不会执行次要命令缓冲区。 VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS:render pass命令将从次要命令缓冲区执行。 在开始渲染通道实例之后，命令缓冲区准备好记录该渲染通道的第一个子通道的命令。 2.4.1 VkRenderPassBeginInfo123456789typedef struct VkRenderPassBeginInfo &#123; VkStructureType sType; const void* pNext; VkRenderPass renderPass; VkFramebuffer framebuffer; VkRect2D renderArea; uint32_t clearValueCount; const VkClearValue* pClearValues;&#125; VkRenderPassBeginInfo; sType: 结构体类型 pNext: 为空或指向特定于扩展的结构的指针 renderPass: 渲染通道 framebuffer: 指令缓冲区 renderArea: 渲染通道实例影响的渲染区域 clearValueCount: pClearValues中的元素数量 pClearValues: 是一个VkClearValue结构的数组，它包含每个附件的清除值，如果附件使用的loadOp值是VK_ATTACHMENT_LOAD_OP_CLEAR，或者附件具有深度&#x2F;模板格式并使用的stencilLoadOp值是VK_ATTACHMENT_LOAD_OP_CLEAR。数组按附件号索引。只使用与已清除附件对应的元素。pClearValues的其他元素将被忽略。 renderArea渲染区域是受渲染通道实例影响的渲染区域。附件加载、存储和多样本解析操作的影响仅限于x和y坐标落在所有附件渲染区域内的像素。渲染区域扩展到framebuffer的所有层。应用程序必须确保(必要时使用scissor)所有的渲染都包含在渲染区域内。渲染区域必须包含在framebuffer尺寸内。 2.4.2 start a Render Pass应用程序一次记录一个render pass实例的命令，方法是开始一个render pass实例，遍历子通道(subpass)来记录该子通道的命令，然后结束render pass实例。 123456789101112131415VkRenderPassBeginInfo renderPassInfo = &#123;&#125;;renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;// 渲染通道本身和要绑定的附件renderPassInfo.renderPass = renderPass;// 每个交换链图像创建了一个framebuffer，将其指定为颜色附件。renderPassInfo.framebuffer = swapChainFramebuffers[i];// 渲染区域定义着色器加载和存储的位置。该区域之外的像素将具有未定义的值。它应该与附件的大小相匹配，以获得最佳性能。renderPassInfo.renderArea.offset = &#123;0, 0&#125;;renderPassInfo.renderArea.extent = swapChainExtent;// 定义用于VK_ATTACHMENT_LOAD_OP_CLEAR的清除值，我们将其用作颜色附件的加载操作。将透明颜色定义为100%不透明度的黑色。VkClearValue clearColor = &#123;0.0f, 0.0f, 0.0f, 1.0f&#125;;renderPassInfo.clearValueCount = 1;renderPassInfo.pClearValues = &amp;clearColor; 2.4.3 基本绘制指令123456789// 渲染通道现在可以开始了。所有记录命令的函数都可以通过它们的vkCmd前缀来识别。它们都返回void，所以在完成记录之前不会有错误处理。vkCmdBeginRenderPass(commandBuffers[i], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);vkCmdDraw(commandBuffers[i], 3, 1, 0, 0);vkCmdEndRenderPass(commandBuffers[i]);if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to record command buffer!&quot;);&#125; 2.4.3.1 vkCmdBindPipeline管道被创建后，可以使用以下命令将其绑定到指令缓冲区: 1234void vkCmdBindPipeline( VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline); commandBuffer: 是即将绑定到管道的命令缓冲区 pipelineBindPoint:是一个VkPipelineBindPoint值，指定管道对象是图形管道还是计算管道。 VK_PIPELINE_BIND_POINT_COMPUTE: 管道控制vkCmdDispatch和vkCmdDispatchIndirect的行为。 VK_PIPELINE_BIND_POINT_GRAPHICS: 管道控制所有绘制命令的行为。其他命令不受管道状态的影响。 pipeline: 即将绑定的管道 一旦绑定，管道绑定将影响命令缓冲区中的后续图形或计算命令，直到另一个管道绑定到绑定点。 2.4.3.2 vkCmdDraw123456void vkCmdDraw( VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance); commandBuffer: 绘制指令记录到的指令缓冲区 vertexCount: 要绘制的顶点数 instanceCount: 要绘制的实例数 firstVertex: 要绘制的第一个顶点的索引 firstInstance: 要绘制的第一个实例的索引 当执行该命令时，将使用当前基元拓扑和vertexCount连续顶点索引(第一个vertexIndex值等于firstVertex)组装基元。这些原语是用从firstInstance开始的instanceIndex绘制的instanceCount时间，并按顺序增加每个实例。组装的原语执行绑定的图形管道。 2.4.3.3 vkCmdEndRenderPass在记录了最后一个子过程的指令之后，结束渲染通道实例调用: 12void vkCmdEndRenderPass( VkCommandBuffer commandBuffer); 结束渲染通道实例在最终子通道上执行一切多样本解析操作。 2.4.3.4 vkEndCommandBuffer一旦开始记录，应用程序将记录指令序列(vkCmd*)，以在指令缓冲区、绘制、调度和其他指令中设置状态。调用完成vkEndCommandBuffer命令缓冲区的记录: 12VkResult vkEndCommandBuffer( VkCommandBuffer commandBuffer); 如果在记录过程中发生了错误，vkEndCommandBuffer将返回一个不成功的返回码来通知应用程序。 如果应用程序希望进一步使用指令缓冲区，则必须重置指令缓冲区。指令缓冲区必须处于记录状态，并被移动到可执行状态。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(7)-渲染过程及创建图形管道","slug":"Vulkan入门-7-渲染过程及创建图形管道","date":"2022-02-26T19:22:14.000Z","updated":"2022-02-26T19:29:57.058Z","comments":true,"path":"2022/02/27/Vulkan入门-7-渲染过程及创建图形管道/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/","excerpt":"简述Render passes, 即渲染过程。在完成创建管道之前，我们需要告诉Vulkan渲染时将使用的帧缓冲区附件。 我们需要指定将有多少颜色和深度缓冲区，为每个缓冲区使用多少个样本，以及在整个渲染操作中应如何处理它们的内容。 所有这些信息都包装在一个render pass对象中，为其创建一个新的createRenderPass函数。在createGraphicsPipeline之前从initVulkan调用此函数。","text":"简述Render passes, 即渲染过程。在完成创建管道之前，我们需要告诉Vulkan渲染时将使用的帧缓冲区附件。 我们需要指定将有多少颜色和深度缓冲区，为每个缓冲区使用多少个样本，以及在整个渲染操作中应如何处理它们的内容。 所有这些信息都包装在一个render pass对象中，为其创建一个新的createRenderPass函数。在createGraphicsPipeline之前从initVulkan调用此函数。 123456789101112131415void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline();&#125;void createRenderPass() &#123;&#125; Vulkan图形管线和计算管线的区别之一是，你使用图形管线来渲染出像素，组成图像以供处理或显示给用户。在复杂的图形应用程序中，图片经过很多遍构建，每一遍都生成场景的一部分，应用全帧效果如后期处理、合成、渲染用户界面元素等等。这样的一遍可以使用Vulkan 中 renderpass 对象表示。 一个单一的的renderpass对象封装了多个pass或者一系列最终图像的几个渲染阶段，renderpass对象包含输出图像所需的信息。 所有的绘制必须被包含在一个renderpass中。甚至，图形管线需要知道他们把渲染结果发往哪儿，因此，有必要在创建图形管线之前创建一个renderpass对象，告知正在生成图像的管线有关图像的信息。 参考资料一. Attachment description 附件说明在这里，我们仅有一个颜色缓冲区附件，由交换链中的一个图像表示。 12345void createRenderPass() &#123; VkAttachmentDescription colorAttachment = &#123;&#125;; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;&#125; 颜色附件的格式应该与交换链图像的格式匹配，而且我们还没有对多重采样做任何事情，所以只要使用1个样本。 12345colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; loadOp和storeOp决定在呈现之前和呈现之后如何处理附件中的数据。loadOp和storeOp应用于颜色和深度数据，以及stencilLoadOp&#x2F;stencilStoreOp应用于模具数据。这里不会对模板缓冲区执行任何操作，因此加载和存储的结果是无关的。 1.1 loadOp VK_ATTACHMENT_LOAD_OP_LOAD: 指定将保留渲染区域中图像的先前内容。对于深度&#x2F;模具格式的附件，这将使用访问类型VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ位。对于颜色格式的附件，这将使用访问类型VK_ACCESS_COLOR_ATTACHMENT_READ位。 VK_ATTACHMENT_LOAD_OP_CLEAR: 指定将渲染区域中的内容清除为统一值，该值在渲染过程实例开始时指定。对于深度&#x2F;模板格式的附件，这将使用访问类型VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE位。对于颜色格式的附件，这将使用访问类型VK_ACCESS_COLOR_ATTACHMENT_WRITE位。 VK_ATTACHMENT_LOAD_OP_DONT_CARE: 指定不需要保留区域中的前一个内容；附件的内容将在渲染区域内未定义。对于深度&#x2F;模板格式的附件，这将使用访问类型VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE位。对于颜色格式的附件，这将使用访问类型VK_ACCESS_COLOR_ATTACHMENT_WRITE位。 1.2 storeOp VK_ATTACHMENT_STORE_OP_STORE: 指定在渲染过程中和渲染区域内生成的内容写入内存，以后可以读取 VK_ATTACHMENT_STORE_OP_DONT_CARE: 指定渲染后不需要渲染区域内的内容，这些内容可能会被丢弃；附件的内容将在渲染区域内未定义。 1.3 内存中像素的布局12colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; Vulkan中的纹理和帧缓冲区由具有特定像素格式的VkImage对象表示，但是，内存中像素的布局可能会根据您尝试对图像执行的操作而改变。 initialLayout指定在渲染过程开始之前图像将具有的布局。finalLayout最终布局指定渲染过程完成时自动转换到的布局。 对initialLayout使用VK_IMAGE_LAYOUT_UNDEFINED意味着我们不关心图像在以前的布局中是什么。这个特殊值的警告是图像的内容不能保证被保存，但这并不重要，因为我们无论如何都要清除它。我们希望图像在渲染后可以使用交换链进行显示，这就是为什么我们使用VK_IMAGE_LAYOUT_PRESENT_SRC_KHR作为finalLayout。 一些最常见的布局有： VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: 用作颜色附件的图像 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 交换链中要显示的图像 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 要用作内存复制操作目标的图像 我们将在“纹理”一章中更深入地讨论这个主题，但现在需要知道的是，图像需要转换到适合其下一步将要涉及的操作的特定布局。 二. Subpasses and attachment references 子过程和附件引用单个渲染过程可以由多个子过程组成。子过程是依赖于先前过程中帧缓冲区的内容的后续呈现操作。 例如一系列相继应用的后处理效果。如果将这些渲染操作分组到一个渲染过程中，则Vulkan能够对操作重新排序，并节省内存带宽以获得可能更好的性能。 这里对于一个三角形，使用一个子过程。 每个子过程引用一个或多个附件，这些附件是我们使用前面部分中的结构描述的。这些引用本身就是VKatAttchmentReference结构，如下： 123VkAttachmentReference colorAttachmentRef = &#123;&#125;;colorAttachmentRef.attachment = 0;colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; attachment参数通过附件描述数组中的索引指定要引用的附件。我们的数组由一个VkAttachmentDescription组成，所以它的索引是0。 layout指定在使用此引用的子过程期间希望附件具有的布局。当子进程启动时，Vulkan将自动将附件转换到此布局。使用附件作为一个颜色缓冲区，VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL LAYOUT会给我们带来最好的性能，顾名思义。 子过程使用VkSubpassDescription结构进行描述： 1234VkSubpassDescription subpass = &#123;&#125;;subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;subpass.colorAttachmentCount = 1;subpass.pColorAttachments = &amp;colorAttachmentRef; // 指定对颜色附件的引用 Vulkan将来也可能支持计算子过程，所以我们必须明确表示这是一个图形子过程。此数组中附件的索引直接从具有layout（location&#x3D;0）out vec4 outColor指令的片段着色器引用！ 子过程可以引用以下类型的附件： pColorAttachments: 颜色附件 pInputAttachments: 从着色器读取的附件 pResolveAttachments: 用于多重采样颜色附件的附件 pDepthStencilAttachment: 深度和模板数据附件 pPreserveAttachments: 此子过程未使用但必须保留数据的附件 三. Render pass 渲染过程上面已经描述了附件和引用它的基本子过程，我们就可以创建渲染过程本身了。 渲染过程表示附件、子过程和子过程之间的依赖关系的集合，并描述如何在子过程中使用附件。 创建一个新的类成员变量，将VkRenderPass对象保持在pipelineLayout变量的正上方： 12VkRenderPass renderPass;VkPipelineLayout pipelineLayout; 可以通过使用附件和子过程数组填充VkRenderPassCreateInfo结构来创建渲染过程对象。VkAttachmentReference对象使用此数组的索引引用附件。 12345678910// 创建渲染过程VkRenderPassCreateInfo renderPassInfo = &#123;&#125;;renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;renderPassInfo.attachmentCount = 1;renderPassInfo.pAttachments = &amp;colorAttachment;renderPassInfo.subpassCount = 1;renderPassInfo.pSubpasses = &amp;subpass;if (vkCreateRenderPass(device, &amp;renderPassInfo, nullptr, &amp;renderPass) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create render pass!&quot;);&#125; 与管道布局一样，渲染过程将在整个程序中被引用，因此只应在结束时进行清理： 12345void cleanup() &#123; vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ...&#125; 目前我们以及做了很多工作了，下一步就是创建图形管道对象了！ 四. 创建 pipeline快速回顾现在拥有的对象类型： shader stages: 定义图形管道可编程阶段功能的着色器模块 Fixed-function state: 定义管道固定函数阶段的所有结构，如输入程序集、光栅化器、视口和颜色混合 Pipeline layout: 可在绘制时更新的着色器引用的统一值和推送值 Render pass: 管道阶段引用的附件及其用法 所有这些组合都充分定义了图形管道的功能，因此现在可以开始在createGraphicsPipeline函数末尾填充VkGraphicsPipelineCreateInfo结构。但是是在调用vkDestroyShaderModule之前，因为在创建过程中使用仍然需要使用这些着色器！ VkGraphicsPipelineCreateInfo结构包括一个shader-reate-info结构数组，其中包含所有所需的活动着色器阶段、定义所有相关固定函数阶段的创建信息以及管道布局。 123456789101112131415161718VkGraphicsPipelineCreateInfo pipelineInfo = &#123;&#125;;pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;pipelineInfo.stageCount = 2;pipelineInfo.pStages = shaderStages;// 首先引用VkPipelineShaderStageCreateInfo结构的数组。pipelineInfo.pVertexInputState = &amp;vertexInputInfo;pipelineInfo.pInputAssemblyState = &amp;inputAssembly;pipelineInfo.pViewportState = &amp;viewportState;pipelineInfo.pRasterizationState = &amp;rasterizer;pipelineInfo.pMultisampleState = &amp;multisampling;pipelineInfo.pDepthStencilState = nullptr; // OptionalpipelineInfo.pColorBlendState = &amp;colorBlending;pipelineInfo.pDynamicState = nullptr; // Optional// 然后引用所有描述固定函数阶段的结构。pipelineInfo.layout = pipelineLayout;// 之后是管道布局，它是一个Vulkan句柄而不是结构指针。pipelineInfo.renderPass = renderPass;pipelineInfo.subpass = 0; 最后，我们有了渲染过程的引用以及使用这个图形管道的子过程的索引。也可以将其他渲染过程用于此管道而不是此特定实例，但它们必须与renderPass兼容。下面描述了兼容性的要求，但这里不使用该特性。 实际上还有两个参数：basePipelineHandle和basePipelineIndex。 Vulkan允许通过从现有管道派生来创建新的图形管道。管道衍生品的想法是，当管道具有与现有管道具有许多相同功能时，设置管道成本更低，并且可以更快地在同一父管道之间切换。可以指定现有管道的句柄（带有basePipelineHandle），也可以引用另一个将由basePipelineIndex的索引创建的管道。 现在只有一个管道，所以只需要指定一个null句柄和一个无效的索引。只有在VkGraphicsPipelineCreateInfo的flags字段中指定VK_PIPELINE_CREATE_UBIT标志时，才使用这些值。 12pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // OptionalpipelineInfo.basePipelineIndex = -1; // Optional 通过创建一个类成员来保存VkPipeline对象： 1234567VkPipeline graphicsPipeline;// 创建图形管道if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;graphicsPipeline) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create graphics pipeline!&quot;);&#125; vkCreateGraphicsPipelines实际上比Vulkan中常用的对象创建函数有更多的参数。它的设计是支持在一次调用中获取多个VkGraphicsPipelineCreateInfo对象并创建多个VkPipeline对象。 第二个参数（我们为其传递了VK_NULL_HANDLE参数）引用了一个可选的VkPipelineCache对象。管道缓存可用于在对vkCreateGraphicsPipelines的多个调用中存储和重用与管道创建相关的数据，如果缓存存储到文件中，甚至可以跨程序执行。这使得以后可以大大加快管道的创建速度。我们将在管道缓存中讨论这个问题。 所有常见的绘图操作都需要图形管道，因此也只能在程序结束时销毁： 12345void cleanup() &#123; vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ...&#125; 现在运行程序来确认所有这些艰苦的工作已经成功地创建了管道！我们已经非常接近看到屏幕上弹出一些东西(实际现在还没有看到任何东西，黑乎乎一片)。 接下来将从交换链图像设置实际的帧缓冲区，并准备绘图命令。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(6)-创建管道的几个固定操作","slug":"Vulkan入门-6-创建管道的几个固定操作","date":"2022-02-26T19:22:00.000Z","updated":"2022-02-26T19:29:09.449Z","comments":true,"path":"2022/02/27/Vulkan入门-6-创建管道的几个固定操作/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/","excerpt":"简述其他图形API为图形管道的大多数阶段提供了默认状态。但在Vulkan中，必须明确所有内容，从视口大小到颜色混合功能。接下来我们试着填写配置这些固定功能操作的所有结构。","text":"简述其他图形API为图形管道的大多数阶段提供了默认状态。但在Vulkan中，必须明确所有内容，从视口大小到颜色混合功能。接下来我们试着填写配置这些固定功能操作的所有结构。 参考资料一. Vertex inputVkPipelineVertexInputStateCreateInfo结构描述将传递给顶点着色器的顶点数据的格式。它以两种方式描述了这一点： 绑定( Bindings )：数据之间的间距以及数据是按顶点还是按实例（请参阅实例化） 属性描述( Attribute descriptions )：传递给顶点着色器的属性的类型，从哪个绑定加载它们 因为我们直接在顶点着色器中对顶点数据进行硬编码，所以我们将填充此结构以指定现在没有要加载的顶点数据。 12345678910111213141516void createGraphicsPipeline() &#123; ...... // 这里为管道指定着色器 VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfo, fragShaderStageInfo&#125;; // 创建顶点着色器的数据输入 VkPipelineVertexInputStateCreateInfo vertexInputInfo = &#123;&#125;; vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; vertexInputInfo.vertexBindingDescriptionCount = 0; vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional vertexInputInfo.vertexAttributeDescriptionCount = 0; vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional ......&#125; pVertexBindingDescriptions和pVertexAttributeDescriptions 成员指向一个结构数组，描述前面提到的加载顶点数据的细节。后续在学习顶点缓冲的时候详细分析。 二. Input assemblyVkPipelineInputAssemblyStateCreateInfo结构描述了两件事： 将从顶点绘制什么类型的几何, 由成员变量topology 指定。可以使用如下值： VK_PRIMITIVE_TOPOLOGY_POINT_LIST：来自顶点的点 VK_PRIMITIVE_TOPOLOGY_LINE_LIST：来自每2个顶点的行而不重用 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP：每行的结束顶点用作下一行的起始顶点 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST：每3个顶点的三角形，无需重复使用 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP：每个三角形的第二个和第三个顶点用作下一个三角形的前两个顶点 是否应启用基元重启。 通常，顶点缓冲区按顺序从顶点缓冲区加载，但是使用元素缓冲区可以指定要自己使用的索引，这允许您执行重用顶点等优化。如果将primitiveRestartEnable成员设置为VK_TRUE，则可以通过使用特殊索引0xFFFF或0xFFFFFFFF来分解_STRIP拓扑模式中的行和三角形。 如果是绘制三角形，创建如下的 VkPipelineInputAssemblyStateCreateInfo： 12345VkPipelineInputAssemblyStateCreateInfo inputAssembly = &#123;&#125;;inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;inputAssembly.primitiveRestartEnable = VK_FALSE; 三. Viewports and scissors3.1 Viewports视窗描述了输出将被渲染到的帧缓冲区域。 基本总是（0,0）到（宽度，高度），也就是窗口大小。 1234567VkViewport viewport = &#123;&#125;;viewport.x = 0.0f;viewport.y = 0.0f;viewport.width = (float) swapChainExtent.width; // 交换链，即帧缓冲区viewport.height = (float) swapChainExtent.height;viewport.minDepth = 0.0f;viewport.maxDepth = 1.0f; 交换链及其图像的大小可能与窗口的宽度和高度不同。 交换链图像将在以后用作帧缓冲区，因此我们不能轻易改变它们的大小。minDepth和maxDepth值指定用于帧缓冲区的深度值范围。 这些值必须在[0.0f，1.0f]范围内，但minDepth可能高于maxDepth。虽然视窗定义了从图像到帧缓冲的转换，但剪刀矩形定义了实际存储像素的区域。剪刀矩形外的任何像素都将被光栅化器丢弃。 它们的功能类似于过滤器而不是转换。差异如下所示。 请注意，左边的剪刀矩形只是导致该图像的众多可能性之一，只要它比视口大： 也就是说Viewport会缩放以显示完整的图片，而scissors会裁剪(或者说遮挡)图片内容。 3.2 Scissors简单定义一个可以绘制整个帧缓冲的Scissor: 123VkRect2D scissor = &#123;&#125;;scissor.offset = &#123;0, 0&#125;;scissor.extent = swapChainExtent; 3.3 使用方式现在使用VkPipelineViewportStateCreateInfo结构将此视口和剪刀矩形组合成视口状态。可以在某些图形卡上使用多个视口和剪刀矩形，因此其成员需要引用它们的数组。使用多个需要启用GPU功能。 1234567VkPipelineViewportStateCreateInfo viewportState = &#123;&#125;;viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;viewportState.viewportCount = 1;viewportState.pViewports = &amp;viewport;viewportState.scissorCount = 1;viewportState.pScissors = &amp;scissor; 四. Rasterizer (光栅化)光栅化器采用由顶点着色器的顶点整形的几何体，并将其转换为片段着色器着色的片段。它还可以执行深度测试，面部剔除和剪刀测试，并且可以配置为输出填充整个多边形或仅填充边缘的片段（线框渲染）。所有这些都是使用VkPipelineRasterizationStateCreateInfo结构配置的。 12345678910111213VkPipelineRasterizationStateCreateInfo rasterizer = &#123;&#125;;rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;rasterizer.depthClampEnable = VK_FALSE;rasterizer.rasterizerDiscardEnable = VK_FALSE;rasterizer.polygonMode = VK_POLYGON_MODE_FILL;rasterizer.lineWidth = 1.0f;rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;rasterizer.depthBiasEnable = VK_FALSE;rasterizer.depthBiasConstantFactor = 0.0f; // Optionalrasterizer.depthBiasClamp = 0.0f; // Optionalrasterizer.depthBiasSlopeFactor = 0.0f; // Optional depthClampEnable: 设置为VK_TRUE，那么超出近平面和远平面的fragment将被夹住，而不是丢弃它们。这在某些特殊情况下很有用，比如阴影贴图。使用此功能需要启用GPU功能。 rasterizerDiscardEnable: 设置为VK_TRUE，那么几何图形永远不会通过光栅化阶段。这基本上禁止任何输出到帧缓冲区。 polygonMode: 多边形模态决定了如何为几何图形生成fragment。有以下几种模式:(使用FILL以外的任何模式都需要启用GPU功能) VK_POLYGON_MODE_FILL: 用fragment填充多边形的区域 VK_POLYGON_MODE_LINE: 多边形边缘以直线的形式绘制 VK_POLYGON_MODE_POINT: 用点绘制多边形顶点 lineWidth: 用来描述线条的粗细。支持的最大线宽取决于硬件，任何超过1.0f的线路都需要启用宽带GPU功能。 cullMode: 确定要使用的面消隐的类型。可以禁用消隐、消隐正面、消隐背面或两者兼有。 frontFace: 指定要视为正面的面的顶点顺序，可以是顺时针或逆时针。 光栅化器可以通过添加一个常量值或根据fragment的坡度对深度值进行偏移来改变深度值。这有时用于阴影映射，一般不使用时只需将depthBiasEnable设置为VK_FALSE。 五. Multisampling 多重采样VkPipelineMultisampleStateCreateInfo结构体用于配置vulkan中的多重采样。 是通过将光栅化为同一像素的多个多边形的片段着色器结果组合在一起实现的，这也是抗锯齿的方式之一。主要是在图形边缘地区做多重采样，这是最明显的锯齿伪影发生的地方。 如果只有一个多边形映射到一个像素，它不需要多次运行片段着色器，因此它比简单地渲染到更高的分辨率然后缩小比例的开销小得多。 启用多重采样需要启用GPU功能。 12345678VkPipelineMultisampleStateCreateInfo multisampling = &#123;&#125;;multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;multisampling.sampleShadingEnable = VK_FALSE;multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;multisampling.minSampleShading = 1.0f; // Optionalmultisampling.pSampleMask = nullptr; // Optionalmultisampling.alphaToCoverageEnable = VK_FALSE; // Optionalmultisampling.alphaToOneEnable = VK_FALSE; sampleShadingEnable: 可用于启用采样着色。 rasterizationSamples: 指定用于光栅化的样本数, 一共有7个可选 VK_SAMPLE_COUNT_1_BIT: 指定每像素1个采样的图像。 VK_SAMPLE_COUNT_2_BIT: 指定每像素2个采样的图像。 VK_SAMPLE_COUNT_4_BIT: 指定每像素4个采样的图像。 VK_SAMPLE_COUNT_8_BIT: 指定每像素8个采样的图像。 VK_SAMPLE_COUNT_16_BIT: 指定每像素16个采样的图像。 VK_SAMPLE_COUNT_32_BIT: 指定每像素32个采样的图像。 VK_SAMPLE_COUNT_64_BIT: 指定每像素64个采样的图像。 minSampleShading: 若sampleShadingEnable设置为VK_TRUE，则指定采样着色的最小部分。 后续详细研究，当前先暂时关闭该功能。 六. Color blending 颜色混合片段着色器返回颜色后，需要将其与帧缓冲区中已有的颜色组合。这种转换称为颜色混合，有两种方法： 将新旧值混合生成最终颜色 使用位运算组合新旧值 有两种类型的结构可以配置颜色混合。 VkPipelineColorBlendAttachmentState: 包含每个附加帧缓冲区的配置， VkPipelineColorBlendStateCreateInfo: 包含全局颜色混合设置。 6.1 VkPipelineColorBlendAttachmentState 结构1234567891011121314VkPipelineColorBlendAttachmentState colorBlendAttachment = &#123;&#125;;colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;colorBlendAttachment.blendEnable = VK_FALSE;colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;// OptionalcolorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;// OptionalcolorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // OptionalcolorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;// OptionalcolorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;// OptionalcolorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional 此每帧缓冲区结构允许您配置颜色混合的第一种方式。将要执行的操作使用以下伪代码演示原理： 123456789if (blendEnable) &#123; finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);&#125; else &#123; finalColor = newColor;&#125;finalColor = finalColor &amp; colorWriteMask; 如果blendEnable设置为VK_FALSE，则片段着色器中的新颜色将不经修改地通过。否则，执行这两个混合操作来计算新颜色。生成的颜色与colorWriteMask进行AND运算，以确定实际通过哪些通道。 使用颜色混合最常用的方法是实现alpha混合，我们希望新颜色与基于不透明度的旧颜色混合。最终颜色的计算如下： 12finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor;finalColor.a = newAlpha.a; 这可以通过以下参数实现： 12345678// 实现alpha混合colorBlendAttachment.blendEnable = VK_TRUE;colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; 可以在VkBlendFactor和VkBlendOp中找到所有可用的操作： VkBlendFactor RGB Blend Factors (Sr,Sg,Sb) or (Dr,Dg,Db) Alpha Blend Factor (Sa or Da) VK_BLEND_FACTOR_ZERO (0,0,0) 0 VK_BLEND_FACTOR_ONE (1,1,1) 1 VK_BLEND_FACTOR_SRC_COLOR (Rs0,Gs0,Bs0) As0 VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR (1-Rs0,1-Gs0,1-Bs0) 1-As0 VK_BLEND_FACTOR_DST_COLOR (Rd,Gd,Bd) Ad VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR (1-Rd,1-Gd,1-Bd) 1-Ad VK_BLEND_FACTOR_SRC_ALPHA (As0,As0,As0) As0 VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA (1-As0,1-As0,1-As0) 1-As0 VK_BLEND_FACTOR_DST_ALPHA (Ad,Ad,Ad) Ad VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA (1-Ad,1-Ad,1-Ad) 1-Ad VK_BLEND_FACTOR_CONSTANT_COLOR (Rc,Gc,Bc) Ac VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR (1-Rc,1-Gc,1-Bc) 1-Ac VK_BLEND_FACTOR_CONSTANT_ALPHA (Ac,Ac,Ac) Ac VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA (1-Ac,1-Ac,1-Ac) 1-Ac VK_BLEND_FACTOR_SRC_ALPHA_SATURATE (f,f,f); f &#x3D; min(As0,1-Ad) 1 VK_BLEND_FACTOR_SRC1_COLOR (Rs1,Gs1,Bs1) As1 VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR (1-Rs1,1-Gs1,1-Bs1) 1-As1 VK_BLEND_FACTOR_SRC1_ALPHA (As1,As1,As1) As1 VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA (1-As1,1-As1,1-As1) 1-As1 备注: Rs0、Gs0、Bs0和As0分别表示与正在混合的颜色附件相对应的片段输出位置的第一源颜色R、G、B和A分量。 Rs1、Gs1、Bs1和As1分别表示第二源颜色R、G、B和A分量，用于对应于被混合的颜色附件的片段输出位置，这些分量在双源混合模式中使用。 Rd、Gd、Bd和Ad表示目的颜色的R、G、B和A分量。也就是说，此片段&#x2F;样本的相应颜色附件中当前的颜色。 Rc、Gc、Bc和Ac分别表示混合常数R、G、B和A组分。 选择源和目标混合因子后，它们连同源和目标组件一起传递给混合操作。RGB和alpha组件可以使用不同的操作。指定操作的VkBlendOp的可能值为： VkBlendOp RGB Components Alpha Component VK_BLEND_OP_ADD R &#x3D; Rs0 × Sr + Rd × DrG &#x3D; Gs0 × Sg + Gd × DgB &#x3D; Bs0 × Sb + Bd × Db A &#x3D; As0 × Sa + Ad × Da VK_BLEND_OP_SUBTRACT R &#x3D; Rs0 × Sr - Rd × DrG &#x3D; Gs0 × Sg - Gd × DgB &#x3D; Bs0 × Sb - Bd × Db A &#x3D; As0 × Sa - Ad × Da VK_BLEND_OP_REVERSE_SUBTRACT R &#x3D; Rd × Dr - Rs0 × SrG &#x3D; Gd × Dg - Gs0 × SgB &#x3D; Bd × Db - Bs0 × Sb A &#x3D; Ad × Da - As0 × Sa VK_BLEND_OP_MIN R &#x3D; min(Rs0,Rd)G &#x3D; min(Gs0,Gd)B &#x3D; min(Bs0,Bd) A &#x3D; min(As0,Ad) VK_BLEND_OP_MAX R &#x3D; max(Rs0,Rd)G &#x3D; max(Gs0,Gd)B &#x3D; max(Bs0,Bd) A &#x3D; max(As0,Ad) 备注: Rs0、Gs0、Bs0和As0分别表示第一源颜色R、G、B和A分量。 Rd、Gd、Bd和Ad表示目的颜色的R、G、B和A分量。也就是说，此片段&#x2F;样本的相应颜色附件中当前的颜色。 Sr、Sg、Sb和Sa分别表示源混合因子R、G、B和A组分。 Dr、Dg、Db和Da分别表示目标混合因子R、G、B和A分量。 6.2 VkPipelineColorBlendStateCreateInfo 全局颜色混合设置VkPipelineColorBlendStateCreateInfo结构引用所有帧缓冲区的结构数组，并允许您设置可以在上述计算中用作混合因子的混合常数。 12345678910VkPipelineColorBlendStateCreateInfo colorBlending = &#123;&#125;;colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;colorBlending.logicOpEnable = VK_FALSE;colorBlending.logicOp = VK_LOGIC_OP_COPY; // OptionalcolorBlending.attachmentCount = 1;colorBlending.pAttachments = &amp;colorBlendAttachment;colorBlending.blendConstants[0] = 0.0f; // OptionalcolorBlending.blendConstants[1] = 0.0f; // OptionalcolorBlending.blendConstants[2] = 0.0f; // OptionalcolorBlending.blendConstants[3] = 0.0f; // Optional 如果要使用第二种混合方法（按位组合），则应将logicOpEnable设置为VK_TRUE。然后可以在logicOp字段中指定位操作。请注意，这将自动禁用第一个方法，就像为每个附加的帧缓冲区将blendEnable设置为VK_FALSE一样！colorWriteMask也将用于此模式，以确定帧缓冲区中的哪些通道将实际受到影响。也可以禁用这两种模式，这种情况下，片段颜色将被不修改地写入帧缓冲区。 七. Dynamic state 可动态修改状态一小部分状态是可以不需要重新创建管道，直接修改的；比如viewport的大小，线宽和颜色混合常数等。 可以使用 VkPipelineDynamicStateCreateInfo 来更改这些动态参数： 12345678VkDynamicState dynamicStates[] = &#123; VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH&#125;;VkPipelineDynamicStateCreateInfo dynamicState = &#123;&#125;;dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;dynamicState.dynamicStateCount = 2;dynamicState.pDynamicStates = dynamicStates; 这将导致忽略这些值的配置，并要求在绘图时指定相应配置。 八. Pipeline layout 管道布置图可以在着色器中使用统一的值，类似于可以在绘制时更改的动态状态变量，以更改着色器的行为，而无需重新创建它们。 通常用于将变换矩阵传递给顶点着色器，或在片段着色器中创建纹理采样器。 在创建管道期间，需要通过创建VkPipelineLayout对象来指定这些统一值。创建一个类成员来保存这个对象，稍后会从其他函数中引用它： 12345678910111213141516VkPipelineLayout pipelineLayout;void createGraphicsPipeline() &#123; // ...... VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;; pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; pipelineLayoutInfo.setLayoutCount = 0; // Optional pipelineLayoutInfo.pSetLayouts = nullptr; // Optional pipelineLayoutInfo.pushConstantRangeCount = 0; // Optional pipelineLayoutInfo.pPushConstantRanges = nullptr; // Optional if (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, nullptr, &amp;pipelineLayout) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create pipeline layout!&quot;); &#125; // ......&#125; 该结构还指定了push常量，这是将动态值传递给着色器的另一种方式，我们将在以后的章节中讨论。 管道布局将在整个程序的整个生命周期内被引用，因此在结束时应销毁： 1234void cleanup() &#123; vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ...&#125; 九. 小结所有的固定函数状态都是这样！这是一个很大的工作，以设置所有这些从头开始，但好处是，我们现在几乎完全了解一切正在进行的图形管道！这减少了运行到意外行为的机会，因为某些组件的默认状态不是您所期望的。不过，在我们最终创建图形管道之前，还有一个对象需要创建，那就是渲染过程。 总结一下到目前位为止，创建图形管道应该做的操作: Vertex Input 描述将传递给顶点着色器的顶点数据的格式 Input assembly 描述顶点绘制几何类型 Viewports and scissors 描述将被渲染到的帧缓冲区域 Rasterizer 光栅化配置 Multisampling 配置多重采样 Color blending 配置颜色混合 Pipeline layout 创建管道布置图","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(5)-图像视图及Pipeline简述","slug":"Vulkan入门-5-图像视图及Pipeline简述","date":"2022-02-26T19:21:47.000Z","updated":"2022-02-26T19:29:03.055Z","comments":true,"path":"2022/02/27/Vulkan入门-5-图像视图及Pipeline简述/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-5-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%8F%8APipeline%E7%AE%80%E8%BF%B0/","excerpt":"简述本文主要介绍VkImageView以及着色器的创建，并且我们将学习到如何编写一个渐变颜色的三角形着色器。","text":"简述本文主要介绍VkImageView以及着色器的创建，并且我们将学习到如何编写一个渐变颜色的三角形着色器。 参考资料 [SPIR-V] https://www.khronos.org/spir/ [SPIR-V doc] https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html [GLSL开发手册] https://github.com/wshxbqq/GLSL-Card 一. Image views在Render pipeline中使用VkImage, 包括在交换链中，需要创建一个VkImageView的对象。VkImageView实际上就是图像的视图。它描述了如何访问图像以及要访问的图像部分，例如，如果它应被视为2D纹理深度纹理而没有任何mipmapping级别。接下来我们试试为交换链中的每个图像创建一个基本VkImageView。创建VkImageView的方式也是通过一个结构体：VkImageViewCreateInfo, 来指明细节. 12345678910typedef struct VkImageViewCreateInfo &#123; VkStructureType sType; const void* pNext; VkImageViewCreateFlags flags; VkImage image; VkImageViewType viewType; VkFormat format; VkComponentMapping components; VkImageSubresourceRange subresourceRange;&#125; VkImageViewCreateInfo; 参数说明： VkImage: 绑定对应图像 VkImageViewType: 图像视图类型 一维纹理: VK_IMAGE_VIEW_TYPE_1D、VK_IMAGE_VIEW_TYPE_1D_ARRAY 二维纹理: VK_IMAGE_VIEW_TYPE_2D、VK_IMAGE_VIEW_TYPE_2D_ARRAY 三维纹理: VK_IMAGE_VIEW_TYPE_3D 立方体贴图: VK_IMAGE_VIEW_TYPE_CUBE、VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VkFormat: 图像格式 VkComponentMapping: 图像颜色通道，即RGB和Alpha通道 VkImageSubresourceRange:描述了图像的目的以及应该访问图像的哪个部分 特别的，如果是3D应用程序, 那应该创建一个带有多个layer的交换链。这样可以通过访问不同的图层为每个图像创建多个图像视图，以表示左右视图。 123456789101112131415161718192021222324252627282930313233343536373839404142void createImageViews() &#123; // 设置集合大小 swapChainImageViews.resize(swapChainImages.size()); for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) &#123; VkImageViewCreateInfo createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; createInfo.image = swapChainImages[i]; // 绑定 VkImage // viewType和format字段指定应如何解释图像数据 // viewType参数指定图像为一维纹理，二维纹理，三维纹理或立方体贴图 createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; // 图像格式 createInfo.format = swapChainImageFormat; // 图像颜色通道，即RGB和Alpha通道。比如将所有通道映射到红色通道以获得单色纹理，或者将常量值0和1映射到通道。这里选择默认映射: createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY; createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; // subresourceRange字段描述了图像的目的是什么以及应该访问图像的哪个部分。 // 这里图像将用作颜色目标，没有任何mipmapping级别或多个层。 createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; createInfo.subresourceRange.baseMipLevel = 0; createInfo.subresourceRange.levelCount = 1; createInfo.subresourceRange.baseArrayLayer = 0; createInfo.subresourceRange.layerCount = 1; // 注意，通过vkCreateXXX创建的对象，都需要我们主动去释放 if (vkCreateImageView(device, &amp;createInfo, nullptr, &amp;swapChainImageViews[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create image views!&quot;); &#125; &#125;&#125;void cleanup() &#123; // 释放交换链对应的图像视图 for (auto imageView : swapChainImageViews) &#123; vkDestroyImageView(device, imageView, nullptr); &#125; .....&#125; 有了图像视图足以开始将图像用作纹理，但还不能直接用作渲染目标。需要一个间接步骤，称为帧缓冲，但首先我们必须设置图形管道。 二. 图形管道 Pipeline 简介所谓图形管道就是一系列操作，它们将网格的顶点和纹理一直带到渲染目标中的像素。简化概述如下所示： 输入汇编程序(input assembler): 从指定的缓冲区收集原始顶点数据，也可以使用索引缓冲区重复某些元素，而不必复制顶点数据本身。 顶点着色器(vertex shader): 针对每个顶点运行，并且通常应用变换以将顶点位置从模型空间转换到屏幕空间。它还沿着管道传递每顶点数据。 曲面细分着色器(tessellation shaders): 根据特定规则细分几何体以提高网格质量。通常用于使砖墙和楼梯等表面在附近时看起来不那么平坦。 几何着色器(geometry shader): 在每个基元(三角形，直线，点)上运行，并且可以丢弃它或输出比原来更多的基元。类似于曲面细分着色器，但更灵活。但没有得到太多应用，因为大多数显卡的性能都不是很好。 光栅化阶段(rasterization stage): 将基元离散化为片段。这些是它们填充在帧缓冲区上的像素元素。在屏幕之外的片段都将被丢弃，顶点着色器输出的属性将在片段之间进行插值。由于深度测试，通常在这里也丢弃其他原始片段后面的片段。 片段着色器(fragment shader): 为存活的每个片段调用片段着色器，并确定片段写入哪些帧缓冲区以及使用哪些颜色和深度值。它可以使用来自顶点着色器的插值数据来完成此操作，其中可以包括纹理坐标和法线照明等内容。 颜色混合阶段(color blending stage): 应用操作来混合映射到帧缓冲区中的相同像素的不同片段。 碎片可以简单地相互覆盖，加起来或根据透明度进行混合。 绿色的阶段被称为固定功能阶段。这些阶段允许使用参数调整其操作，但它们的工作方式是预定义的。 橙色的阶段是可编程的，这意味着可以将代码上传到图形卡，以完全应用想要的操作。 例如，实现从纹理和光照到光线跟踪器的任何内容。这些程序同时在许多GPU内核上运行，以并行处理许多对象，如顶点和片段。，可以使用片段着色器 在OpenGL和Direct3D中，可以使用glBlendFunc和OMSetBlendState等调用随意更改任何管道设置。但Vulkan中的图形管道几乎完全不可变，因此如果要更改着色器，绑定不同的帧缓冲区或更改混合函数，则必须从头开始重新创建管道。缺点是您必须创建许多管道，这些管道代表您要在渲染操作中使用的所有状态组合。但是，因为您将在管道中执行的所有操作都是事先知道的，所以驱动程序可以更好地优化它。 根据您的目的，某些可编程阶段是可选的。例如，如果您只是绘制简单几何体，则可以禁用曲面细分和几何体阶段。如果您只对深度值感兴趣，则可以禁用片段着色器阶段，这对阴影贴图生成很有用。 记住创建管道需要在创建VkImageView之后。 具体的创建需要依赖上述各个着色器，我们先熟悉一下这些着色器。 三. 着色器(Shader modules)Vulkan中的着色器代码必须以字节码格式指定，而不是像GLSL和HLSL这样的人类可读语法。 GLSL是一种具有C风格语法的着色语言。写在其中的程序具有为每个对象调用的主函数。 GLSL使用全局变量来处理输入和输出，而不是使用输入参数和返回值作为输出。该语言包括许多有助于图形编程的功能，如内置向量和矩阵基元。包括交叉积，矩阵向量积和向量周围反射等操作的函数。 而Vulkan中的这种字节码格式称为SPIR-V，旨在与Vulkan和OpenCL（两种Khronos API）一起使用。SPIR-V是一种用于图形着色器和计算内核的简单二进制中间语言。 更多信息可以参考 https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html 使用字节码格式的优点是比GPU供应商编写的将着色器代码转换为本机代码的编译器要简单的得多。过去已经表明，使用像GLSL这样的人类可读语法，一些GPU供应商对标准的解释相当灵活。如果碰巧使用其中一个供应商编写的不标准GPU着色器，那么由于语法错误，可能其他供应商的驱动程序会拒绝我们的代码，或者更糟糕的，由于编译器错误，着色器运行方式不同。而使用简单的字节码格式，如SPIR-V，则可以避免此类问题。 但是，这并不意味着我们需要手动编写这个字节码。 Khronos发布了自己独立于供应商的编译器，将GLSL编译为SPIR-V。此编译器旨在验证着色器代码是否完全符合标准，并生成一个可与程序一起提供的SPIR-V二进制文件。我们还可以将此编译器作为库包含在运行时生成SPIR-V。这个编译器已经包含在LunarG SDK中作为glslangValidator.exe，无需额外下载。 接下来我们使用GLSL语言(详细参考: https://github.com/wshxbqq/GLSL-Card)编写着色器。 3.1 顶点着色器 Vertex Shader矢量类型称为vec，其数字表示元素的数量。 例如，3D位置将存储在vec3中。可以通过.x等成员访问单个组件，但也可以同时从多个组件创建新的向量。 例如，表达式vec3（1.0,2.0,3.0）.xy将导致vec2。向量的构造函数也可以采用向量对象和标量值的组合。 例如，vec3可以用vec3（vec2（1.0,2.0），3.0）构建。 顶点着色器处理每个传入的顶点。 它将其属性（如世界位置，颜色，法线和纹理坐标）作为输入。输出是剪辑坐标中的最终位置以及需要传递到片段着色器的属性，如颜色和纹理坐标。然后，光栅化器将这些值插入片段上以产生平滑的梯度。剪辑坐标是来自顶点着色器的四维矢量，其随后通过将整个矢量除以其最后一个分量而变为标准化设备坐标。 这些标准化的设备坐标是齐次坐标，它将帧缓冲区映射到[-1,1]乘[-1,1]坐标系，如下所示： 注意xy轴的方向，类似Android中的坐标轴，而不是OpenGL中的坐标轴方向。接下来我们通过顶点着色器和片段着色器以在屏幕上呈现一个三角形,如下图： 我们可以直接输出归一化设备坐标，方法是将它们作为顶点着色器的剪辑坐标输出，最后一个组件设置为1.这样，将剪辑坐标转换为规范化设备坐标的划分不会改变任何东西。通常这些坐标将存储在顶点缓冲区中，但在Vulkan中创建顶点缓冲区并用数据填充它并不简单。如果我们直接在顶点着色器中包含坐标，那么可以这样写： 1234567891011#version 450vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5));void main() &#123; gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);&#125; 每个顶点的生成都需要调用main函数。内置的gl_VertexIndex变量包含当前顶点的索引，一般是顶点缓冲区的索引。在这里，它是顶点数据的硬编码数组的索引。从着色器中的常量数组访问每个顶点的位置，并与虚拟z和w组件组合以在剪辑坐标中生成位置，内置变量gl_Position用作输出。 3.2 片段着色器 Fragment Shader由顶点着色器的位置形成的三角形用片段填充屏幕上的区域。在这些片段上调用片段着色器以生成帧缓冲区（或帧缓冲区）的颜色和深度。为整个三角形输出红色的简单片段着色器如下所示： 123456789#version 450#extension GL_ARB_separate_shader_objects : enable// 帧缓冲区的索引为0layout(location = 0) out vec4 outColor;void main() &#123; outColor = vec4(1.0, 0.0, 0.0, 1.0);&#125; GLSL中的颜色是4分量矢量，其中R，G，B和α通道在[0,1]范围内。与顶点着色器中的gl_Position不同，没有内置变量来输出当前片段的颜色。 所以必须为每个帧缓冲区指定自己的输出变量，其中layout（location &#x3D; 0）修饰符指定帧缓冲区的索引。红色将写入此outColor变量，该变量链接到索引0处的第一个（也是唯一的）帧缓冲区。 3.3 为每个顶点着色如果我们想要实现渐变颜色的三角形，如下： 这就需要我们为三个顶点中的每一个指定不同的颜色。 顶点着色器现在应该包含一个颜色的数组，就像它对位置一样. 123456vec3 colors[3] = vec3[]( // vec3(r,g,b) vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0)); 每一个vec3对应一个顶点。现在我们只需要将这些顶点颜色传递给片段着色器，这样就可以将它们的插值输出到帧缓冲区。将颜色输出添加到顶点着色器并在main函数中写入： 1234567891011121314#version 450vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5));layout(location = 0) out vec3 fragColor;void main() &#123; gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex];&#125; 接下来，我们需要在片段着色器中添加匹配的输入： 123456789#version 450#extension GL_ARB_separate_shader_objects : enable// 帧缓冲区的索引为0layout(location = 0) in vec3 fragColor;void main() &#123; outColor = vec4(fragColor, 1.0);&#125; 输入变量不一定必须使用相同的名称，因为我们使用location指令指定的索引讲它们链接在一起。如上图所示，fragColor的值将自动插入三个顶点之间的片段，从而产生平滑的渐变。 3.4 编译着色器首先在我们的工程目录下创建一个 shaders 的目录，用于保存我们的着色器。首先是 shader.vert 文件： 123456789101112131415161718192021222324#version 450#extension GL_ARB_separate_shader_objects : enable// 输出为fragColorlayout(location = 0) out vec3 fragColor;// 三角形顶点坐标vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5));// 渐变颜色vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));void main() &#123; gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex];&#125; 还有 shader.frag 文件: 12345678910#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragColor;layout(location = 0) out vec4 outColor;void main() &#123; outColor = vec4(fragColor, 1.0);&#125; 3.4.1 Linux平台下编译方式使用 vulkan SDK中的glslangValidator来编译shader文件: 1234#/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslangValidator -V shader.vert#/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslangValidator -V shader.frag/home/jh/Program/vulkan/1.1.106.0/x86_64/bin/glslangValidator -V shader.vert/home/jh/Program/vulkan/1.1.106.0/x86_64/bin/glslangValidator -V shader.frag 执行上面的脚本后，会在当前目录生成对应的: frag.spv和vert.spv文件 3.4.2 Windows平台编译方式类似，不赘述 另外Vulkan SDK包含libshaderc库，用于从程序中将GLSL代码编译为SPIR-V。 3.5 加载着色器加载着色器就是读取我们编译好的shader文件:frag.spv和vert.spv.c++中读取文件如下： 1234567891011121314151617181920#include &lt;fstream&gt;static std::vector&lt;char&gt; readFile(const std::string&amp; filename) &#123; // ate: 从文件末尾开始阅读 // binary: 二进制流形式 std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) &#123; throw std::runtime_error(&quot;failed to open file!&quot;); &#125; size_t fileSize = (size_t) file.tellg(); std::vector&lt;char&gt; buffer(fileSize); file.seekg(0); file.read(buffer.data(), fileSize); file.close(); return buffer;&#125; 比如读取 vert.spv: 1auto vertShaderCode = readFile(&quot;shaders/vert.spv&quot;); 读取成功后，记得check一下文件大小是否匹配。 3.6 创建着色器模块(shader modules - VkShaderModule)在Vulkan中使用VkShaderModule存储着色器. 使用结构体： 1234567typedef struct VkShaderModuleCreateInfo &#123; VkStructureType sType; const void* pNext; VkShaderModuleCreateFlags flags; size_t codeSize; const uint32_t* pCode;&#125; VkShaderModuleCreateInfo; 封装成createShaderModule方法,方便后续调用.其实VkShaderModule只是一个对着色器文件的封装而已。使用方法：vkCreateShaderModule 123456789101112131415VkShaderModule createShaderModule(const std::vector&lt;char&gt;&amp; code) &#123; VkShaderModuleCreateInfo createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; createInfo.codeSize = code.size(); createInfo.pCode = reinterpret_cast&lt;const uint32_t*&gt;(code.data()); VkShaderModule shaderModule; // vkResult device, const *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) if (vkCreateShaderModule(device, &amp;createInfo, nullptr, &amp;shaderModule) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create shader module!&quot;); &#125; return shaderModule;&#125; 3.7 着色器阶段创建(shader stage)只是有 VkShaderModule，还不够。要使用着色器，还需要在创建管道(Pipeline)时，使用VkPipelineShaderStageCreateInfo结构讲其分配到特定的管道阶段。比如在管道中填充顶点着色器: vert.spv 123456789VkPipelineShaderStageCreateInfo vertShaderStageInfo = &#123;&#125;;vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; // 指明当前是顶点阶段 (3.7.1)// 指定包含代码的着色器模块vertShaderStageInfo.module = vertShaderModule;// 指定要调用的着色器模块函数（称为入口点）vertShaderStageInfo.pName = &quot;main&quot;; 还有一个（可选的）成员pSpecializationInfo，这里不会在这里使用。它允许您指定着色器常量的值。当使用单个着色器模块，通过为其中使用的常量指定不同的值，就可以在创建管道时配置其行为。这比在渲染时使用变量配置着色器更有效，因为编译器可以执行优化，例如消除依赖于这些值的if语句。默认为nullptr，struct初始化会自动执行。 3.7.1 Shader Stage1234567891011typedef enum VkShaderStageFlagBits &#123; VK_SHADER_STAGE_VERTEX_BIT = 0x00000001, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0x00000002, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0x00000004, VK_SHADER_STAGE_GEOMETRY_BIT = 0x00000008, VK_SHADER_STAGE_FRAGMENT_BIT = 0x00000010, VK_SHADER_STAGE_COMPUTE_BIT = 0x00000020, VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F, VK_SHADER_STAGE_ALL = 0x7FFFFFFF, VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkShaderStageFlagBits; VK_SHADER_STAGE_VERTEX_BIT: 顶点阶段 VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: 曲面细分控制阶段 VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: 曲面细分评估阶段 VK_SHADER_STAGE_GEOMETRY_BIT: 几何阶段 VK_SHADER_STAGE_FRAGMENT_BIT: 片段阶段 VK_SHADER_STAGE_COMPUTE_BIT: 计算阶段 VK_SHADER_STAGE_ALL_GRAPHICS: 用作速记的位组合，用于指定上面定义的所有图形阶段（不包括计算阶段）。 VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: 用作速记的位组合，用于指定设备支持的所有着色器阶段，包括扩展引入的所有其他阶段。 3.7.2 为着色器指定管道1234567891011121314void createGraphicsPipeline() &#123; auto vertShaderCode = readFile(&quot;shaders/vert.spv&quot;); auto fragShaderCode = readFile(&quot;shaders/frag.spv&quot;); VkShaderModule vertShaderModule = createShaderModule(vertShaderCode); VkShaderModule fragShaderModule = createShaderModule(fragShaderCode); // 这里为管道指定着色器 VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfo, fragShaderStageInfo&#125;; // 记得销毁shader vkDestroyShaderModule(device, vertShaderModule, nullptr); vkDestroyShaderModule(device, fragShaderModule, nullptr);&#125; 图形管道 其他部分设置在下个文章中讨论。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(4)-Surface和交换链","slug":"Vulkan入门-4-Surface和交换链","date":"2022-02-26T19:21:25.000Z","updated":"2022-02-26T19:25:56.402Z","comments":true,"path":"2022/02/27/Vulkan入门-4-Surface和交换链/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-4-Surface%E5%92%8C%E4%BA%A4%E6%8D%A2%E9%93%BE/","excerpt":"简述本文主要是学习Vulkan Tutorial.pdf文档中的Window Surface和Swap Chain的部分。","text":"简述本文主要是学习Vulkan Tutorial.pdf文档中的Window Surface和Swap Chain的部分。 参考资料 [Vulkan-文档]https://github.com/KhronosGroup/Vulkan-Docs 一. Window Surface由于Vulkan是一个与平台无关的API，因此无法直接与窗口系统进行交互。要在Vulkan和窗口系统之间建立连接以向屏幕显示结果，我们需要使用WSI（窗口系统集成）扩展。这就需要使用到VK_KHR_surface，它公开了一个VkSurfaceKHR对象，表示一个抽象类型的Surface，以呈现渲染图像。我们程序中的Surface将由我们已经使用GLFW打开的窗口支持。VK_KHR_surface扩展是一个实例级扩展，我们实际上已经启用它，因为它包含在glfwGetRequiredInstanceExtensions返回的列表中。 一般需要在创建实例后立即创建窗口Surface，因为它实际上可以影响物理设备选择。但如果你只需要离屏渲染，窗口Surface是Vulkan中完全可选的组件。 Vulkan允许这样做，而不是像OpenGL一样必须创建一个不可见的窗口。 1.1 创建窗口Surface在Vulkan中使用VkSurfaceKHR表示窗口Surface： 1VkSurfaceKHR surface; 虽然VkSurfaceKHR对象及其用法与平台无关，但它的创建并不是因为它取决于窗口系统的细节。例如，它需要Windows上的HWND和HMODULE句柄。因此，扩展中有一个特定于平台的添加，在Windows上称为VK_KHR_win32_surface，并且还自动包含在glfwGetRequiredInstanceExtensions的列表中。但使用像GLFW这样的库然后继续使用特定于平台的代码没有任何意义。GLFW实际上有glfwCreateWindowSurface来帮我们处理平台的差异。 12345678910111213 // 使用glfw创建WindowSurface void createWindowSurface() &#123; if (glfwCreateWindowSurface(instance, window, nullptr, &amp;surface) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create window surface!&quot;); &#125; &#125; // 记得释放 void cleanup() &#123; // 释放WindowSurface vkDestroySurfaceKHR(instance, surface, nullptr); ...... &#125; 二. Swap Chain-交换链Vulkan没有“默认帧缓冲区”的概念，取而代之的是名为 “swap chain” 即交换链，也就是渲染的缓冲区，必须在Vulkan中明确创建。交换链本质上是一个等待呈现给屏幕的图像队列。应用程序将获取这样的图像以绘制它，然后将其返回到队列中。队列的工作原理以及从队列中显示图像的条件取决于交换链的设置方式，但交换链的一般用途是将图像的显示与屏幕的刷新率同步。 2.1 检查GPU是否支持交换链并不是所有的GPU都支持图像显示(比如专为服务器设计的)，其次，由于图像显示严重依赖于窗口系统和与窗口相关的Surface，因此它实际上不是Vulkan核心的一部分。所以必须在查询其支持后才能启用K_KHR_swapchain设备扩展。 可以扩展isDeviceSuitable函数以检查是否支持此扩展。之前已经实现过如何列出VkPhysicalDevice支持的扩展，这样做法其实一样。值得注意的是，Vulkan头文件提供了一个很好的宏VK_KHR_SWAPCHAIN_EXTENSION_NAME，定义为VK_KHR_swapchain。使用此宏的优点是编译器将捕获拼写错误。首先声明所需设备扩展的列表，类似于要启用的验证层列表。 12345678910111213141516171819202122232425262728const std::vector&lt;const char*&gt; deviceExtensions = &#123; VK_KHR_SWAPCHAIN_EXTENSION_NAME&#125;;bool isDeviceSuitable(VkPhysicalDevice device) &#123; QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() &amp;&amp; extensionsSupported; &#125;bool checkDeviceExtensionSupport(VkPhysicalDevice device) &#123; uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, nullptr); std::vector&lt;VkExtensionProperties&gt; availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, availableExtensions.data()); std::set&lt;std::string&gt; requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); // 遍历当前所有可支持的扩展，并逐步移除也存在于deviceExtensions中的 for (const auto&amp; extension : availableExtensions) &#123; requiredExtensions.erase(extension.extensionName); &#125; // 为empty时，表示所有deviceExtensions中的扩展均支持 return requiredExtensions.empty();&#125; 2.2 使能设备扩展使用交换链需要首先使能VK_KHR_swapchain扩展。方法也很简单，只需要在创建逻辑设备的时候声明一下即可： 12createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(deviceExtensions.size());createInfo.ppEnabledExtensionNames = deviceExtensions.data(); 2.3 获取关于swap chain更多支持细节只检查交换链是否可用是不够的，因为它实际上可能与我们创建的窗口Surface不兼容（有点坑）。创建交换链还涉及比vulkan实例和设备创建时更多的设置，因此我们需要在能够继续之前查明更多的细节。需要检查的基本上有以下三种属性： 基本Surface功能（交换链中的最小&#x2F;最大图像数，图像的最小&#x2F;最大宽度和高度） Surface的格式（像素格式，色彩空间） 可用的呈现模式 与创建队列类似，同样可以使用一个结构体来存储传递这些细节部分： 12345struct SwapChainSupportDetails &#123; VkSurfaceCapabilitiesKHR capabilities; // 基本Surface功能 std::vector&lt;VkSurfaceFormatKHR&gt; formats; // Surface格式 std::vector&lt;VkPresentModeKHR&gt; presentModes; // 可用的呈现模式(presentation modes)&#125;; 接来下是查询细节部分： 123456789101112131415161718192021222324252627SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) &#123; SwapChainSupportDetails details; // 1. 查询基本Surface功能 // 需要使用到本机物理设备(GPU), 以及创建的逻辑设备对应的Surface，结果保存在VkSurfaceCapabilitiesKHR结构体中 // VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &amp;details.capabilities); // 2. 查询可支持的Surface格式 // 类似扩展，按例先查询一下数量，然后更新细节到VkSurfaceFormatKHR的队列中 uint32_t formatCount; vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, nullptr); if (formatCount != 0) &#123; details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, details.formats.data()); &#125; // 3. 查询可用的呈现模式(presentation modes) uint32_t presentModeCount; vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, nullptr); if (presentModeCount != 0) &#123; details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, details.presentModes.data()); &#125; return details;&#125; 2.4 为swap chain-交换链选择合适的设置满足了swapChainAnequate条件，那么物理设备肯定是支持我们的应用程序的，但还可以有许多不同的最优性模式。有三种类型的设置可以选择： Surface格式（颜色深度） 呈现模式（将图像“交换”到屏幕的条件） 交换范围（交换链中图像的分辨率） 2.4.1 Surface格式在Vulkan中，Surface格式使用结构体 VkSurfaceFormatKHR 来表示: 1234typedef struct VkSurfaceFormatKHR &#123; VkFormat format; // 格式 VkColorSpaceKHR colorSpace; // 色彩空间&#125; VkSurfaceFormatKHR; 如上每个VkSurfaceFormatKHR条目都包含一个格式和一个colorSpace成员。 格式成员指定颜色通道和类型。例如，VK_FORMAT_B8G8R8A8_UNORM意味着我们以8位无符号整数的顺序存储B，G，R和alpha通道，每个像素总共32位。 colorSpace成员使用VK_COLOR_SPACE_SRGB_NONLINEAR_KHR标志指示是否支持SRGB色彩空间。请注意，在旧版本的规范中，此标志曾被称为VK_COLORSPACE_SRGB_NONLINEAR_KHR。对于色彩空间，我们将使用SRGB（如果可用），因为它会产生更准确的感知色彩。直接使用SRGB颜色有点挑战，因此我们将使用标准RGB作为颜色格式，其中最常见的一种是VK_FORMAT_B8G8R8A8_UNORM。 最好的情况是 Surface 没有首选格式，Vulkan只通过返回一个格式成员设置为VK_FORMAT_UNDEFINED的VkSurfaceFormatKHR条目来指示。 1234567891011121314151617// 选择合适交换链和Surface的格式VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats) &#123; if (availableFormats.size() == 1 &amp;&amp; availableFormats[0].format == VK_FORMAT_UNDEFINED) &#123; return &#123;VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR&#125;; &#125; for (const auto&amp; availableFormat : availableFormats) &#123; if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123; return availableFormat; &#125; &#125; // 如果没有找到合适的，保险起见，直接使用第一个就好了 return availableFormats[0];&#125; 2.4.2 呈现模式(Presentation Mode)呈现模式可以说是交换链中最重要的设置，因为它代表了向屏幕显示图像的实际条件。Vulkan有四种可用的模式： VK_PRESENT_MODE_IMMEDIATE_KHR：应用程序提交的图像会立即传输到屏幕上，这可能会导致撕裂现象(上下或者左右图像不匹配，前后两帧合成)。 VK_PRESENT_MODE_FIFO_KHR：交换链是一个队列，当刷新显示并且程序在队列的后面插入渲染图像时，显示从队列前面获取图像。如果队列已满，则程序必须等待。这与现代游戏中的垂直同步最相似。刷新显示的那一刻被称为“垂直空白”。 VK_PRESENT_MODE_FIFO_RELAXED_KHR：如果应用程序延迟且队列在最后一个垂直空白处为空，则此模式仅与前一个模式不同。而不是等待下一个垂直空白，图像最终到达时立即传输。这可能会导致明显的撕裂。 VK_PRESENT_MODE_MAILBOX_KHR：这是第二种模式的另一种变体。当队列已满时，已排队的图像将被替换为较新的图像，而不是阻塞应用程序。此模式可用于实现三重缓冲，与使用双缓冲的标准垂直同步相比，可以避免使用明显更少的延迟问题进行撕裂。 比如我们试试机器是否支持三重缓冲, 即允许我们通过渲染尽可能最新的新图像直到垂直空白来避免撕裂，同时仍保持相当低的延迟: 123456789101112VkPresentModeKHR chooseSwapPresentMode(const std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes) &#123; VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto&amp; availablePresentMode : availablePresentModes) &#123; if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123; return availablePresentMode; &#125; else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) &#123; bestMode = availablePresentMode; &#125; &#125; return bestMode;&#125; 2.4.3 交换范围(Swap extent)交换范围是交换链图像的分辨率，它几乎总是完全等于绘制的窗口的分辨率。可能的分辨率范围在 VkSurfaceCapabilitiesKHR 结构中定义。 Vulkan通过在currentExtent成员中设置宽度和高度来匹配窗口的分辨率。但是，一些窗口管理器允许在这里有所不同, 通过将currentExtent中的宽度和高度设置为特殊值来表示：uint32_t的最大值。在这种情况下，要选择与minImageExtent和maxImageExtent范围内的窗口最匹配的分辨率。 1234567891011// 选择交换链分辨率VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities) &#123; if (capabilities.currentExtent.width != std::numeric_limits&lt;uint32_t&gt;::max()) &#123; return capabilities.currentExtent; &#125; else &#123; VkExtent2D actualExtent = &#123;WIDTH, HEIGHT&#125;; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; &#125;&#125; 2.5 创建交换链上述步骤已经把创建交换链的三个主要属性设置了，接下来就是创建交换链对象：VkSwapchainKHR swapChain;除了上述的三个主要属性，其实还需要做的是： 绑定窗口Surface 设置交换链图像细节，包括最小图像数量、图像图层数量 处理将在多个队列系列中使用的交换链图像。如果图形队列系列与呈现队列不同，需要从图形队列中绘制交换链中的图像，然后在呈现队列中提交它们。 有两种方法可以处理从多个队列访问的图像： VK_SHARING_MODE_EXCLUSIVE：映像一次由一个队列系列拥有，并且必须在将其用于另一个队列系列之前显式转移所有权。 此选项提供最佳性能。 VK_SHARING_MODE_CONCURRENT：可以跨多个队列系列使用映像，而无需显式所有权传输。 类似创建其他对象，交换链的创建依赖结构体：VkSwapchainCreateInfoKHR 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void createSwapChain() &#123; // 获取物理设备可支持的交换链细节部分 SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); // 选择合适的Surface格式 VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); // 选择合适的呈现模式 VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); // 选择合适的分辨率 VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities); // 必须设置交换链运行所需的最小图像数量： // 有时可能必须等待驱动程序完成内部操作才能获取另一个要渲染的图像。 因此，建议最小值加1： uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1; // 边界检查，防止越界，超出交换链可支持的最大图像数量 if (swapChainSupport.capabilities.maxImageCount &gt; 0 &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123; imageCount = swapChainSupport.capabilities.maxImageCount; &#125; // 创建交换链对象 VkSwapchainCreateInfoKHR createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; createInfo.surface = surface; // 绑定窗口Surface createInfo.minImageCount = imageCount; // 设置最小图像数量 createInfo.imageFormat = surfaceFormat.format; // 设置图像格式 createInfo.imageColorSpace = surfaceFormat.colorSpace; // 设置图像颜色空间 createInfo.imageExtent = extent; // 设置分辨率 createInfo.imageArrayLayers = 1; // 指定每个图像所包含的图层数量, 除非是立体3D应用程序，否则始终为1。 // imageUsage 是 VkImageUsageFlags 类型, 指定将使用交换链中的图像进行哪种操作 createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; // 指定该图像可用于创建适合用作颜色的VkImageView或解析VkFramebuffer中的附件。 QueueFamilyIndices indices = findQueueFamilies(physicalDevice); uint32_t queueFamilyIndices[] = &#123;indices.graphicsFamily.value(), indices.presentFamily.value()&#125;; if (indices.graphicsFamily != indices.presentFamily) &#123; createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices; &#125; else &#123; createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional &#125; // 可以指定某个变换应该应用于交换链中的图像（支持变换功能），如顺时针旋转90度或水平翻转。 要指定您不需要任何转换，只需指定当前转换。 createInfo.preTransform = swapChainSupport.capabilities.currentTransform; // compositeAlpha字段指定是否应该使用alpha通道与窗口系统中的其他窗口进行混合。 一般都是忽略alpha通道，因此设置为VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR。 createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; // 设置呈现模式 createInfo.presentMode = presentMode; // 如果剪裁的成员设置为VK_TRUE，那么这意味着我们不关心被遮挡的像素的颜色 // 例如因为另一个窗口位于它们前面。 除非真的需要能够读回这些像素并获得可预测的结果，否则可以通过启用剪辑获得最佳性能。 createInfo.clipped = VK_TRUE; // 使用Vulkan时，交换链可能会在应用程序运行时变为无效或未优化，例如因为窗口已调整大小。 // 在这种情况下，交换链实际上需要从头开始重新创建，并且必须在此字段中指定对旧交换链的引用, 后续在研究。 // 假设我们只会创建一个交换链 createInfo.oldSwapchain = VK_NULL_HANDLE; if (vkCreateSwapchainKHR(device, &amp;createInfo, nullptr, &amp;swapChain) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create swap chain!&quot;); &#125;&#125; 2.5.1 VkImageUsageFlagsVkImageUsageFlags是一个位掩码类型，用于设置零或更多VkImageUsageFlagBits的掩码。用于指定图像进行的操作类型, 有如下 1234567891011typedef enum VkImageUsageFlagBits &#123; VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0x00000001, VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0x00000002, VK_IMAGE_USAGE_SAMPLED_BIT = 0x00000004, VK_IMAGE_USAGE_STORAGE_BIT = 0x00000008, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0x00000010, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000020, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0x00000040, VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0x00000080, VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF&#125; VkImageUsageFlagBits; VK_IMAGE_USAGE_TRANSFER_SRC_BIT: 指定图像可用作传输命令的源。 VK_IMAGE_USAGE_TRANSFER_DST_BIT: 指定图像可用作传输命令的目标。 VK_IMAGE_USAGE_SAMPLED_BIT: 指定该图像可用于创建适合占用VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE或VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型的VkDescriptorSet槽的VkImageView，并由着色器进行采样。 VK_IMAGE_USAGE_STORAGE_BIT: 指定该图像可用于创建适合占用VK_DESCRIPTOR_TYPE_STORAGE_IMAGE类型的VkDescriptorSet插槽的VkImageView。 VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: 指定该图像可用于创建适合用作颜色的VkImageView或解析VkFramebuffer中的附件。 VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: 指定该图像可用于创建适合用作VkFramebuffer中的深度&#x2F;模板附件的VkImageView。 VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: 指定绑定到此映像的内存将使用VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT进行分配。可以为任何可用于创建适合用作颜色，分辨率，深度&#x2F;模板或输入附件的VkImageView的图像设置此位。 VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: 指定该图像可用于创建适合占用VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT类型的VkDescriptorSet槽的VkImageView; 从着色器读取作为输入附件; 并用作帧缓冲区中的输入附件。 2.5.2 处理将在多个队列系列中使用的交换链图像如果队列系列不同，那么需要使用并发模式来避免必须执行所有权。并发模式要求使用queueFamilyIndexCount和pQueueFamilyIndices参数预先指定将共享哪些队列系列所有权。如果图形队列系列和表示队列系列是相同的（大多数硬件都是这种情况），那么我们应该坚持独占模式，因为并发模式要求指定至少两个不同的队列系列。 2.6 检索交换链图像创建了交换链对象后，就可以检索其中的VkImages的句柄，这些VkImages是用于后续渲染操作的。我们可以使用一个Set集合存储这些VkImages: 1std::vector&lt;VkImage&gt; swapChainImages; 类似于Surface, 这些VkImage是不需要我们主动销毁的。在交换链被销毁时，Vulkan自动就会销毁这些VkImage了。 一般在vkCreateSwapchainKHR调用之后立即检索createSwapChain函数末尾的句柄。在交换链中只是指定了最少数量的图像，Vulkan允许实现创建更多的图像。创建后记得调整容器大小，最后再次调用它来检索VkImage。 123456// 先获取交换链中图像数量vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, nullptr);// 调整set集合大小swapChainImages.resize(imageCount);// 获取VkImage对象vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, swapChainImages.data()); 2.7 小结这部分内容比较多，小结一下： 2.7.1 什么是交换链？交换链本质上是一个等待呈现给屏幕的图像队列。应用程序将获取这样的图像以绘制它，然后将其返回到队列中。 2.7.2 创建交换链的一般步骤 确认当前物理设备(GPU)是否支持交换链 创建逻辑设备时，使能交换链扩展(ppEnabledExtensionNames) 获取当前设备支持swap chain的更多细节 创建swap chain对象 绑定窗口Surface 设置最小图像数量 minImageCount 选择合适的图像格式 imageFormat 选择合适的图像颜色空间 imageColorSpace 选择合适的图像分辨率 imageExtent 设置图像图层 imageArrayLayers 设置图像操作方式 imageUsage 选择图像呈现模式 presentMode 是否需要裁剪功能 clipped(VK_TRUE, VK_FALSE) 设置旧交换链的引用 oldSwapchain 获取交换链图像(VkImage)对象集合 虽然到目前为止，我们编出来的程序还只是一个800*600的黑窗口。但是已经万事具备了，下一步就可以把图像内容呈现到窗口里了。","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(3)-设置物理设备和逻辑设备","slug":"Vulkan入门-3-设置物理设备和逻辑设备","date":"2022-02-26T19:16:37.000Z","updated":"2022-02-26T19:20:43.723Z","comments":true,"path":"2022/02/27/Vulkan入门-3-设置物理设备和逻辑设备/","link":"","permalink":"https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-3-%E8%AE%BE%E7%BD%AE%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87/","excerpt":"简述本文主要是学习Vulkan Tutorial.pdf文档中的Physical devices and queue families(物理设备和队列系列)部分以及Logical device and queues(逻辑设备与队列)部分。","text":"简述本文主要是学习Vulkan Tutorial.pdf文档中的Physical devices and queue families(物理设备和队列系列)部分以及Logical device and queues(逻辑设备与队列)部分。 参考资料 [Vulkan-文档]https://github.com/KhronosGroup/Vulkan-Docs [Vulkan-feature查询]https://vulkan.lunarg.com/doc/view/1.0.26.0/linux/vkspec.chunked/ch31s01.html 一. Physical devices and queue families(物理设备和队列系列)1.1 选择物理显卡GPU在通过VkInstance初始化Vulkan库之后，需要在系统中查找并选择支持我们所需功能的图形显卡。事实上，我们可以选择任意数量的显卡并同时使用。但在这里，只使用第一个适合我们需求的显卡。我们将添加一个函数pickPhysicalDevice并在initVulkan函数中添加对它的调用。 12345678910111213void initVulkan() &#123; checkAvailableExtensions(); createInstance(); // 创建DEBUG消息回调 setupDebugMessenger(); // 选择物理设备 pickPhysicalDevice();&#125;void pickPhysicalDevice() &#123; &#125; 最终选择的图形卡将存储在VkPhysicalDevice句柄中，该句柄作为新的类成员添加。当VkInstance被销毁时，该对象将被隐式销毁，因此我们不需要在清理函数中做任何新的操作。 VkPhysicalDevice对象不能被显式销毁。相反，当检索到它们的VkInstance对象被撤销时，它们将隐式撤销。 一旦所有由VkPhysicalDevice对象创建的VkDevice对象都被销毁，VkInstance对象就可以被销毁。 1VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; 列出物理显卡的过程和列出vulkan扩展的过程类似，首先是获取本机物理显卡的数量： 123456789101112131415161718192021222324252627void pickPhysicalDevice() &#123; uint32_t deviceCount = 0; // 首先获取本机物理显卡数量 vkEnumeratePhysicalDevices(instance, &amp;deviceCount, nullptr); // 当然没有GPU时，抛出异常 if (deviceCount == 0) &#123; throw std::runtime_error(&quot;failed to find GPUs with Vulkan support!&quot;); &#125; std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount); vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data()); // 遍历所有GPU, 选择合适的使用 for (const auto&amp; device : devices) &#123; if (isDeviceSuitable(device)) &#123; physicalDevice = device; break; &#125; &#125;&#125;bool isDeviceSuitable(VkPhysicalDevice device) &#123; // 暂时没什么可以挑剔的，都可以吧 // 其实大部分的机器只会有一个显卡 return true;&#125; 1.2 基础设备适配性检查通过查询细节来评估设备的适用性。可以使用vkGetPhysicalDeviceProperties查询基本设备属性，如名称，类型和支持的Vulkan版本。 12VkPhysicalDeviceProperties deviceProperties;vkGetPhysicalDeviceProperties(device, &amp;deviceProperties); 使用vkGetPhysicalDeviceFeatures查询对纹理压缩，64位浮点和多视口渲染（对VR有用）等可选功能的支持： 12VkPhysicalDeviceFeatures deviceFeatures;vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures); 基本操作就是： 通过vkGetPhysicalDeviceProperties获取本机设备的属性 查询vkGetPhysicalDeviceFeatures中可以被支持的feature 举个例子，假设我们的应用程序仅适用于支持几何着色器的专用显卡。 那么isDeviceSuitable函数将如下所示： 12345678910bool isDeviceSuitable(VkPhysicalDevice device) &#123; VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &amp;deviceProperties); vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures); return ((deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) &amp;&amp; deviceFeatures.geometryShader);&#125; 所有可支持的feature见附录。根据Vulkan Tutorial文档，有推荐使用评分机制来选择最合适的GPU，这个就见仁见智，看个人喜好，这里就不赘述了。 1.3 Queue families几乎所有Vulkan中的操作，从绘图到上传纹理，都需要将命令提交到队列中(这一点研究过hwui的童鞋肯定深有体会)。存在来自不同队列系列的不同类型的队列，并且每个队列族仅允许命令的子集。例如，可能存在仅允许处理计算命令的队列系列或仅允许与存储器传输相关的命令的队列系列。 所有我们需要检查本机设备支持哪些队列系列，以及哪一个支持我们要使用的命令。添加一个新函数findQueueFamilies，用于查找我们需要的所有队列系列。比如查找支持图形命令的队列： 123456789101112131415161718192021222324252627282930313233343536373839404142struct QueueFamilyIndices &#123; // 别忘了添加头文件：including &lt;optional&gt; // optional用途如其名，它可以容纳一个对象值或是为空。 // 典型的应用情景是函数调用时，如需根据条件返回一个对象（有效）或默认对象（无效） // 若该对象构造成本很高（资源分配等），可用optional返回一个空对象，提高效率。 std::optional&lt;uint32_t&gt; graphicsFamily; bool isComplete() &#123; return graphicsFamily.has_value(); &#125;&#125;;QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) &#123; QueueFamilyIndices indices; // 先检查数量 uint32_t queueFamilyCount = 0; // 使用 vkGetPhysicalDeviceQueueFamilyProperties 检索队列系列是否正是我们需要的： vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr); // VkQueueFamilyProperties结构包含有关队列系列的一些详细信息 // 包括支持的操作类型以及可基于该系列创建的队列数 std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount); vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data()); // 比如我们找到一个支持VK_QUEUE_GRAPHICS_BIT的队列系列 int i = 0; for (const auto&amp; queueFamily : queueFamilies) &#123; if (queueFamily.queueCount &gt; 0 &amp;&amp; queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123; indices.graphicsFamily = i; &#125; if (indices.isComplete()) &#123; break; &#125; i++; &#125; return indices;&#125; 把这个检查加入isDeviceSuitable函数。现在已经找到合适的物理设备了， 下一步是创建一个与之适配的逻辑设备。 二. Logical device and queues选择要使用的物理设备后，就可以创建一个与之适配的逻辑设备。逻辑设备创建过程类似于实例创建过程，还需要指定现在要创建的队列（已经查询了哪些队列系列可用）。并且从同一物理设备可以创建多个逻辑设备。 存储逻辑设备类似物理设备，也是使用句柄： 1VkDevice device; 2.1 指定要创建的队列创建逻辑设备也是在结构体中指定一堆细节，其中第一个是VkDeviceQueueCreateInfo。此结构描述了我们为单个队列系列所需的队列数。比如创建具有图形功能的队列： 1234567QueueFamilyIndices indices = findQueueFamilies(physicalDevice);VkDeviceQueueCreateInfo queueCreateInfo = &#123;&#125;;queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();queueCreateInfo.queueCount = 1; 当前可用的驱动程序只允许为每个队列系列创建少量队列，实际上也不需要多个队列。因为可以在多个线程上创建所有命令缓冲区，然后使用一个低开销调用在主线程上一次性提交。 Vulkan允许为队列分配优先级，以使用介于0.0和1.0之间的浮点数来影响命令缓冲区执行的调度。即使只有一个队列，也是必需的： 12float queuePriority = 1.0f;queueCreateInfo.pQueuePriorities = &amp;queuePriority; 2.2 指定使用的设备功能(feature)要指定的下一个信息是我们将要使用的一组设备feature。这些是在[1.2]中使用vkGetPhysicalDeviceFeatures查询支持的功能，例如几何着色器。如果不需要任何特殊的东西，可以简单地定义它并默认为VK_FALSE。但一旦即将开始用Vulkan做更多有趣的事情，就需要设定这个结构了。 1VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;; 2.3 创建逻辑设备在VkDeviceQueueCreateInfo和VkPhysicalDeviceFeatures创建完毕后，就可以根据这个创建逻辑设备实例了。 12345678VkDeviceCreateInfo createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;// 首先指定VkDeviceQueueCreateInfocreateInfo.pQueueCreateInfos = &amp;queueCreateInfo;createInfo.queueCreateInfoCount = 1;// 指定VkPhysicalDeviceFeaturescreateInfo.pEnabledFeatures = &amp;deviceFeatures; 其余信息与VkInstanceCreateInfo结构相似，并要求指定扩展(Extensions)和验证层(Validation Layers)。不同之处在于这次是逻辑设备的。设备特定扩展的其中之一是VK_KHR_swapchain，它允许您将该设备的渲染图像呈现给窗口。系统中可能存在缺乏此功能的Vulkan设备，比如因为它们仅支持计算操作。 Vulkan的先前实现区分了实例和设备特定的验证层，但现在不做区分了。也就是说VkDeviceCreateInfo的enabledLayerCount和ppEnabledLayerNames字段在最新实现中可以忽略。 12345678createInfo.enabledExtensionCount = 0;if (enableValidationLayers) &#123; createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data();&#125; else &#123; createInfo.enabledLayerCount = 0;&#125; 类似创建vulkan实例，这里使用 vkCreateDevice 函数创建逻辑设备： 1234// 调用 vkCreateDevice 创建逻辑设备，别忘了在cleanup函数中销毁if (vkCreateDevice(physicalDevice, &amp;createInfo, nullptr, &amp;device) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create logical device!&quot;);&#125; 2.4 检索队列句柄队列是与逻辑设备一起自动创建的，现在创建与它们接口的句柄。使用 VkQueue 来存储队列的句柄，如存储图形队列的句柄： 1VkQueue graphicsQueue; 当设备被销毁时，会隐式清除设备队列，因此我们不需要在清理中执行任何操作(vkCreateXXX才需要主动释放哦)。 我们可以使用vkGetDeviceQueue函数来检索每个队列系列的队列句柄。参数是逻辑设备，队列系列，队列索引和指向存储队列句柄的变量的指针。因为我们只是从这个系列创建一个队列，所以我们只使用索引0。 1vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &amp;graphicsQueue); 有了逻辑设备和队列句柄，我们现在可以开始使用显卡来做事了！准备工作基本完成，后续我们可以设置资源并用窗口显示结果！这次就不贴代码了。 附录vulkan feature vulkan feature 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 定义在 vulkan_core.h 文件中typedef struct VkPhysicalDeviceFeatures &#123; VkBool32 robustBufferAccess; VkBool32 fullDrawIndexUint32; VkBool32 imageCubeArray; VkBool32 independentBlend; VkBool32 geometryShader; VkBool32 tessellationShader; VkBool32 sampleRateShading; VkBool32 dualSrcBlend; VkBool32 logicOp; VkBool32 multiDrawIndirect; VkBool32 drawIndirectFirstInstance; VkBool32 depthClamp; VkBool32 depthBiasClamp; VkBool32 fillModeNonSolid; VkBool32 depthBounds; VkBool32 wideLines; VkBool32 largePoints; VkBool32 alphaToOne; VkBool32 multiViewport; VkBool32 samplerAnisotropy; VkBool32 textureCompressionETC2; VkBool32 textureCompressionASTC_LDR; VkBool32 textureCompressionBC; VkBool32 occlusionQueryPrecise; VkBool32 pipelineStatisticsQuery; VkBool32 vertexPipelineStoresAndAtomics; VkBool32 fragmentStoresAndAtomics; VkBool32 shaderTessellationAndGeometryPointSize; VkBool32 shaderImageGatherExtended; VkBool32 shaderStorageImageExtendedFormats; VkBool32 shaderStorageImageMultisample; VkBool32 shaderStorageImageReadWithoutFormat; VkBool32 shaderStorageImageWriteWithoutFormat; VkBool32 shaderUniformBufferArrayDynamicIndexing; VkBool32 shaderSampledImageArrayDynamicIndexing; VkBool32 shaderStorageBufferArrayDynamicIndexing; VkBool32 shaderStorageImageArrayDynamicIndexing; VkBool32 shaderClipDistance; VkBool32 shaderCullDistance; VkBool32 shaderFloat64; VkBool32 shaderInt64; VkBool32 shaderInt16; VkBool32 shaderResourceResidency; VkBool32 shaderResourceMinLod; VkBool32 sparseBinding; VkBool32 sparseResidencyBuffer; VkBool32 sparseResidencyImage2D; VkBool32 sparseResidencyImage3D; VkBool32 sparseResidency2Samples; VkBool32 sparseResidency4Samples; VkBool32 sparseResidency8Samples; VkBool32 sparseResidency16Samples; VkBool32 sparseResidencyAliased; VkBool32 variableMultisampleRate; VkBool32 inheritedQueries;&#125; VkPhysicalDeviceFeatures; 1. robustBufferAccess指定对缓冲区的访问是根据缓冲区描述符的范围进行边界检查的(由VkDescriptorBufferInfo::range，VkBufferViewCreateInfo::range或缓冲区的大小确定）。超出范围访问不得导致应用程序终止，并且着色器加载，存储和原子的效果必须符合与如下相关的行为： 如果满足以下任何条件，则认为缓冲区访问超出范围： 指针由OpImageTexelPointer形成，坐标小于零或大于或等于绑定范围内的整个元素的数量。 指针不是由OpImageTexelPointer形成的，并且指向的对象并不完全包含在绑定范围内。这包括通过变量指针执行的访问，其中不能静态地确定被访问的缓冲区描述符。未初始化的指针和指向OpConstantNull的指针被视为指向零大小的对象，因此通过这些指针的所有访问都被视为超出范围。 注意：如果SPIR-V OpLoad指令加载结构并且结构的尾端超出边界，则结构的所有成员都被视为超出边界，即使最终的成员未被静态使用。 如果确定给定SPIR-V块中的任何缓冲区访问超出范围，则在同一SPIR-V块中访问小于16字节的地址的任何其他相同类型（加载，存储或原子）访问 远离界外地址也可能被认为是超出界限。 超出范围的缓冲区加载将返回以下任何值： 从绑定到缓冲区的内存范围内的任何位置开始的值（可能包括超出缓冲区末尾的内存字节，直到绑定范围的末尾）。 向量读取的零值或（0,0,0，x）向量，其中x是向量组件类型中表示的有效值，可以是以下任意一种： 有符号或无符号整数分量的0,1或最大可表示正整数值 0.0或1.0，用于浮点组件 越界写入可以修改绑定到缓冲区的内存范围内的值，但不能修改任何其他内存。 越界原子可以修改绑定到缓冲区的内存范围内的值，但不能修改任何其他内存，并返回未定义的值。 如果绑定顶点缓冲区范围中属性的偏移量加上属性的大小大于以下值，则顶点输入属性被视为超出边界。 vertexBufferRangeSize, if bindingStride &#x3D;&#x3D; 0; 或者 (vertexBufferRangeSize - (vertexBufferRangeSize % bindingStride)) 其中vertexBufferRangeSize是绑定到顶点缓冲区绑定的内存范围的字节大小，bindingStride是相应顶点输入绑定的字节跨度。此外，如果使用特定顶点输入绑定的任何顶点输入属性超出边界，则使用该顶点着色器调用的顶点输入绑定的所有顶点输入属性被视为超出边界。 一旦顶点输入属性超出范围，将为其分配以下值之一： 来自绑定到缓冲区的内存范围内任何位置的值，根据属性的格式进行转换。 零值，或（0,0,0，x）向量，格式根据属性的格式转换。 如果未启用robustBufferAccess，则应用程序不得执行越界访问。而一般来讲，robustBufferAccess都是需要开启的。 2. fullDrawIndexUint32指定当使用VKIndexType为VK_INDEX_TYPE_UINT32时，索引绘制调用支持完整的32位索引范围。maxDrawIndexedIndexValue是可以使用的最大索引值（除了原始重启索引，当VkIndexType是VK_INDEX_TYPE_UINT32时，它总是2^32-1）。如果支持此功能，则maxDrawIndexedIndexValue必须为2^32-1; 否则它必须不小于2^24-1。 3. imageCubeArray指定是否可以创建VkImageViewType为VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的图像视图，以及是否可以在着色器代码中使用相应的SampledCubeArray和ImageCubeArray SPIR-V功能。 4. independentBlend指定是否每个附件独立控制VkPipelineColorBlendAttachmentState设置。如果未启用此功能，则所有颜色附件的VkPipelineColorBlendAttachmentState设置必须相同。如果启用，可以为每个绑定的颜色附件提供不同的VkPipelineColorBlendAttachmentState。 5. geometryShader指定是否支持几何着色器。如果未启用此功能，则不得使用VK_SHADER_STAGE_GEOMETRY_BIT和VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT枚举值。这还指定着色器模块是否可以声明几何功能。 6. tessellationShader指定是否支持曲面细分控制和评估着色器。如果未启用此功能，则不得使用： VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT：指定曲面细分控制阶段 VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT：指定曲面细分评估阶段 VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT：指定曲面细分控制着色器阶段 VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT：指定曲面细分评估着色器阶段 VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO 这还指定着色器模块是否可以声明Tessellation功能。 7. sampleRateShading指定是否支持样本着色和多重采样插值。如果未启用此功能，则必须将VkPipelineMultisampleStateCreateInfo结构的sampleShadingEnable成员设置为VK_FALSE，并忽略minSampleShading成员。这还指定着色器模块是否可以声明SampleRateShading功能。 8. dualSrcBlend指定是否支持采用两个源的混合操作。如果未启用此功能，则不得将： VK_BLEND_FACTOR_SRC1_COLOR： VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR VK_BLEND_FACTOR_SRC1_ALPHA VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA 以上枚举值用作源或目标混合因子。详细信息参阅 vkspec.html: 26.1.2. Dual-Source Blending 9. logicOp指定是否支持逻辑运算。 如果未启用此功能，则必须将VkPipelineColorBlendStateCreateInfo结构的logicOpEnable成员设置为VK_FALSE，并忽略logicOp成员。 10. multiDrawIndirect指定是否支持多个draw间接。如果未启用此功能，则vkCmdDrawIndirect和vkCmdDrawIndexedIndirect命令的drawCount参数必须为0或1.如果不支持此功能，则VkPhysicalDeviceLimits结构的maxDrawIndirectCount(间接绘制调用支持的最大绘制计数)成员也必须为1。 11. drawIndirectFirstInstance指定间接绘制调用是否支持firstInstance参数。如果未启用此功能，则提供给vkCmdDrawIndirect和vkCmdDrawIndexedIndirect命令的所有VkDrawIndirectCommand和VkDrawIndexedIndirectCommand结构的firstInstance成员必须为0。 12. depthClamp指定是否支持深度Clamp。如果未启用此功能，则必须将VkPipelineRasterizationStateCreateInfo结构的depthClampEnable成员设置为VK_FALSE。如果启用，将depthClampEnable设置为VK_TRUE将启用深度Clamp。 13. depthBiasClamp指定是否支持深度偏置Clamp。如果未启用此功能，则必须将VkPipelineRasterizationStateCreateInfo结构的depthBiasClamp成员设置为0.0，除非启用VK_DYNAMIC_STATE_DEPTH_BIAS动态状态，并且必须将vkCmdSetDepthBias的depthBiasClamp参数设置为0.0。 14. fillModeNonSolid指定是否支持点和线框填充模式。如果未启用此功能，则VkPipelineRasterizationStateCreateInfo::polygonMode不得使用: VK_POLYGON_MODE_POINT:指定将多边形顶点绘制为点 VK_POLYGON_MODE_LINE:指定将多边形的边绘制为点 15. depthBounds指定是否支持深度边界测试。如果未启用此功能，则必须将VkPipelineDepthStencilStateCreateInfo结构的depthBoundsTestEnable成员设置为VK_FALSE。 当depthBoundsTestEnable设置为VK_FALSE时，将忽略VkPipelineDepthStencilStateCreateInfo结构的minDepthBounds和maxDepthBounds成员。 16. wideLines指定是否支持宽度不是1.0的行。如果未启用此功能，则必须将VkPipelineRasterizationStateCreateInfo结构的lineWidth成员设置为1.0，除非启用VK_DYNAMIC_STATE_LINE_WIDTH动态状态，并且必须将vWCmdSetLineWidth的lineWidth参数设置为1.0。支持此功能时，支持的线宽的范围和粒度分别由VkPhysicalDeviceLimits结构的lineWidthRange和lineWidthGranularity成员指示。 17. largePoints指定是否支持大小大于1.0的点。如果未启用此功能，则仅支持着色器写入的点大小1.0。 支持的点大小的范围和粒度分别由VkPhysicalDeviceLimits结构的pointSizeRange和pointSizeGranularity成员指示。 18. alphaToOne指定实现是否能够使用定点颜色的最大可表示alpha值或浮点颜色的1.0替换片段着色器中输出的颜色片段的alpha值。如果未启用此功能，则必须将VkPipelineMultisampleStateCreateInfo结构的alphaToOneEnable成员设置为VK_FALSE。否则，将alphaToOneEnable设置为VK_TRUE将启用alpha-to-one行为。 19. multiViewport指定是否支持多个Viewport。 如果未启用此功能： 必须将VkPipelineViewportStateCreateInfo结构的viewportCount和scissorCount成员设置为1。 vkCmdSetViewport命令的firstViewport和viewportCount参数必须分别设置为0和1。 vkCmdSetScissor命令的firstScissor和scissorCount参数必须分别设置为0和1。 20. samplerAnisotropy指定是否支持各向异性过滤。如果未启用此功能，则VkSamplerCreateInfo结构的anisotropyEnable成员必须为VK_FALSE。 21. textureCompressionETC2指定是否支持所有ETC2和EAC压缩纹理格式。如果启用此功能，则OptimalTilingFeatures中必须支持: VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:指定可以从中采样图像视图 VK_FORMAT_FEATURE_BLIT_SRC_BIT:指定图像可用作vkCmdBlitImage命令的srcImage VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT：图像视图可以与采样器一起使用(详细信息 vkspec.html:VkFormatFeatureFlagBits) 以上格式的功能： VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK VK_FORMAT_EAC_R11_UNORM_BLOCK VK_FORMAT_EAC_R11_SNORM_BLOCK VK_FORMAT_EAC_R11G11_UNORM_BLOCK VK_FORMAT_EAC_R11G11_SNORM_BLOCK 要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。 22. textureCompressionASTC_LDR指定是否支持所有ASTC LDR压缩纹理格式。如果启用此功能，则OptimalTilingFeatures中必须支持: VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT VK_FORMAT_FEATURE_BLIT_SRC_BIT和VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT 以上格式的功能： VK_FORMAT_ASTC_4x4_UNORM_BLOCK VK_FORMAT_ASTC_4x4_SRGB_BLOCK VK_FORMAT_ASTC_5x4_UNORM_BLOCK VK_FORMAT_ASTC_5x4_SRGB_BLOCK VK_FORMAT_ASTC_5x5_UNORM_BLOCK VK_FORMAT_ASTC_5x5_SRGB_BLOCK VK_FORMAT_ASTC_6x5_UNORM_BLOCK VK_FORMAT_ASTC_6x5_SRGB_BLOCK VK_FORMAT_ASTC_6x6_UNORM_BLOCK VK_FORMAT_ASTC_6x6_SRGB_BLOCK VK_FORMAT_ASTC_8x5_UNORM_BLOCK VK_FORMAT_ASTC_8x5_SRGB_BLOCK VK_FORMAT_ASTC_8x6_UNORM_BLOCK VK_FORMAT_ASTC_8x6_SRGB_BLOCK VK_FORMAT_ASTC_8x8_UNORM_BLOCK VK_FORMAT_ASTC_8x8_SRGB_BLOCK VK_FORMAT_ASTC_10x5_UNORM_BLOCK VK_FORMAT_ASTC_10x5_SRGB_BLOCK VK_FORMAT_ASTC_10x6_UNORM_BLOCK VK_FORMAT_ASTC_10x6_SRGB_BLOCK VK_FORMAT_ASTC_10x8_UNORM_BLOCK VK_FORMAT_ASTC_10x8_SRGB_BLOCK VK_FORMAT_ASTC_10x10_UNORM_BLOCK VK_FORMAT_ASTC_10x10_SRGB_BLOCK VK_FORMAT_ASTC_12x10_UNORM_BLOCK VK_FORMAT_ASTC_12x10_SRGB_BLOCK VK_FORMAT_ASTC_12x12_UNORM_BLOCK VK_FORMAT_ASTC_12x12_SRGB_BLOCK 要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。 23. textureCompressionBC指定是否支持所有BC压缩纹理格式。如果启用此功能，则OptimalTilingFeatures中必须支持： VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT VK_FORMAT_FEATURE_BLIT_SRC_BIT VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT 以上格式的功能： VK_FORMAT_BC1_RGB_UNORM_BLOCK VK_FORMAT_BC1_RGB_SRGB_BLOCK VK_FORMAT_BC1_RGBA_UNORM_BLOCK VK_FORMAT_BC1_RGBA_SRGB_BLOCK VK_FORMAT_BC2_UNORM_BLOCK VK_FORMAT_BC2_SRGB_BLOCK VK_FORMAT_BC3_UNORM_BLOCK VK_FORMAT_BC3_SRGB_BLOCK VK_FORMAT_BC4_UNORM_BLOCK VK_FORMAT_BC4_SNORM_BLOCK VK_FORMAT_BC5_UNORM_BLOCK VK_FORMAT_BC5_SNORM_BLOCK VK_FORMAT_BC6H_UFLOAT_BLOCK VK_FORMAT_BC6H_SFLOAT_BLOCK VK_FORMAT_BC7_UNORM_BLOCK VK_FORMAT_BC7_SRGB_BLOCK 要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。 24. occlusionQueryPrecise指定是否支持返回实际样本计数的遮挡查询。通过在VkQueryPoolCreateInfo结构中指定VK_QUERY_TYPE_OCCLUSION的queryType并将其传递给vkCreateQueryPool，可以在VkQueryPool中创建遮挡查询。如果启用此功能，则此类查询可以将flags参数中的VK_QUERY_CONTROL_PRECISE_BIT启用为vkCmdBeginQuery。如果不支持此功能，则实现仅支持布尔遮挡查询。传递任何样本时，布尔查询将返回非零结果值，否则返回结果值为零。启用此功能并设置VK_QUERY_CONTROL_PRECISE_BIT后，遮挡查询将报告传递的实际样本数。 25. pipelineStatisticsQuery指定是否支持管道统计信息查询。如果未启用此功能，则无法创建类型为VK_QUERY_TYPE_PIPELINE_STATISTICS的查询，并且无法在VkQueryPoolCreateInfo结构的pipelineStatistics成员中设置任何VkQueryPipelineStatisticFlagBits位。 26. vertexPipelineStoresAndAtomics指定存储缓冲区和图像是否支持顶点，曲面细分和几何着色器阶段中的存储和原子操作。如果未启用此功能，则着色器模块中这些阶段使用的所有存储器映像，存储纹理缓冲区缓冲区和存储缓冲区变量必须使用NonWritable修饰（或GLSL中的只读内存限定符）进行修饰。 27. fragmentStoresAndAtomics指定存储缓冲区和图像是否支持片段着色器阶段中的存储和原子操作。如果未启用此功能，则着色器模块中片段阶段使用的所有存储器映像，存储纹理缓冲区缓冲区和存储缓冲区变量必须使用NonWritable修饰（或GLSL中的只读内存限定符）进行修饰。 28. shaderTessellationAndGeometryPointSize指定曲面细分控件，曲面细分评估和几何着色器阶段中是否提供PointSize内置修饰。如果未启用此功能，则不得读取或写入使用PointSize内置修饰的成员，并且从曲面细分或几何着色器写入的所有点的大小均为1.0。这还指定着色器模块是否可以为曲面细分控制和评估着色器声明TessellationPointSize功能，或者着色器模块是否可以为几何着色器声明GeometryPointSize功能。支持此功能的实现还必须支持tessellationShader或geometryShader功能中的一个或两个。 29. shaderImageGatherExtended指定着色器代码中是否可以使用扩展的图像收集指令集。如果未启用此功能，则OpImage * Gather指令不支持Offset和ConstOffsets操作数。 这还指定着色器模块是否可以声明ImageGatherExtended功能。 30. shaderStorageImageExtendedFormats指定着色器代码中是否所有扩展存储器图像格式都可用。如果启用此功能，则必须在所有扩展格式的optimalTilingFeatures中支持VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT功能。要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。 31. shaderStorageImageMultisample指定是否支持多重采样存储映像。如果未启用此功能，则必须使用等于VK_SAMPLE_COUNT_1_BIT的样本创建使用包含VK_IMAGE_USAGE_STORAGE_BIT的用法创建的图像。这还指定着色器模块是否可以声明StorageImageMultisample功能。 32. shaderStorageImageReadWithoutFormat指定存储图像是否需要在从存储器映像读取时指定格式限定符。如果未启用此功能，则OpImageRead指令的OpTypeImage不得为Unknown。这还指定着色器模块是否可以声明StorageImageReadWithoutFormat功能。 33. shaderStorageImageWriteWithoutFormat指定存储图像是否需要在写入存储图像时指定格式限定符。如果未启用此功能，则OpImageWrite指令的OpTypeImage不得为Unknown。这还指定着色器模块是否可以声明StorageImageWriteWithoutFormat功能。 34. shaderUniformBufferArrayDynamicIndexing指定是否可以通过着色器代码中的动态统一整数表达式对统一缓冲区的数组建立索引。如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER或VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC的资源必须仅由常量整数表达式编制索引。这还指定着色器模块是否可以声明UniformBufferArrayDynamicIndexing功能。 35. shaderSampledImageArrayDynamicIndexing指定采样器阵列或采样图像是否可以通过着色器代码中的动态统一整数表达式进行索引。如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_SAMPLER，VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER或VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE的资源必须仅由常量整数表达式编制索引。这还指定着色器模块是否可以声明SampledImageArrayDynamicIndexing功能。 36. shaderStorageBufferArrayDynamicIndexing指定是否可以通过着色器代码中的动态统一整数表达式索引存储缓冲区的数组。如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_STORAGE_BUFFER或VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC的资源必须仅由常量整数表达式编制索引。这还指定着色器模块是否可以声明StorageBufferArrayDynamicIndexing功能。 37. shaderStorageImageArrayDynamicIndexing指定是否可以通过着色器代码中的动态统一整数表达式索引存储器图像数组。如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_STORAGE_IMAGE的资源必须仅通过常量整数表达式编制索引。这还指定着色器模块是否可以声明StorageImageArrayDynamicIndexing功能。 38. shaderClipDistance指定着色器代码中是否支持ClipDistance。如果未启用此功能，则不得在着色器模块中读取或写入使用ClipDistance内置装饰的任何成员。这还指定着色器模块是否可以声明ClipDistance功能。 39. shaderCullDistance指定着色器代码中是否支持CullDistance。如果未启用此功能，则不得在着色器模块中读取或写入使用CullDistance内置装饰的任何成员。这还指定着色器模块是否可以声明CullDistance功能。 40. shaderFloat64指定着色器代码中是否支持64位浮点（双精度）。如果未启用此功能，则不得在着色器代码中使用64位浮点类型。这还指定着色器模块是否可以声明Float64功能。 41. shaderInt64指定着色器代码中是否支持64位整数（有符号和无符号）。如果未启用此功能，则不得在着色器代码中使用64位整数类型。这还指定着色器模块是否可以声明Int64功能。 42. shaderInt16指定着色器代码中是否支持16位整数（有符号和无符号）。如果未启用此功能，则不得在着色器代码中使用16位整数类型。这还指定着色器模块是否可以声明Int16功能。 43. shaderResourceResidency指定着色器代码是否支持返回资源驻留信息的图像操作。如果未启用此功能，则不得在着色器代码中使用OpImageSparse *指令。这还指定着色器模块是否可以声明SparseResidency功能。该功能至少需要支持一个sparseResidency *功能。 44. shaderResourceMinLod指定着色器代码中是否支持指定最小资源LOD的图像操作。如果未启用此功能，则不得在着色器代码中使用MinLod图像操作数。这还指定着色器模块是否可以声明MinLod功能。 45. sparseBinding指定是否可以在不透明的稀疏块级别而不是在对象级别管理资源内存。如果未启用此功能，则必须使用vkBindBufferMemory和vkBindImageMemory命令仅基于每个对象绑定资源内存。 在这种情况下，不能分别使用VkBufferCreateInfo和VkImageCreateInfo结构的flags成员中设置的VK_BUFFER_CREATE_SPARSE_BINDING_BIT和VK_IMAGE_CREATE_SPARSE_BINDING_BIT创建缓冲区和映像。 否则，可以按稀疏资源特征中的描述管理资源存储器。 46. sparseResidencyBuffer指定设备是否可以访问部分驻留缓冲区。如果未启用此功能，则不能使用VkBufferCreateInfo结构的flags成员中设置的VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建缓冲区。 47. sparseResidencyImage2D指定设备是否可以访问每个像素1个样本的部分驻留的2D图像。如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_1_BIT的图像。 48. sparseResidencyImage3D指定设备是否可以访问部分驻留的3D图像。如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_3D的映像。 49. sparseResidency2Samples指定物理设备是否可以访问具有每像素2个样本的部分驻留的2D图像。如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_2_BIT的图像。 50. sparseResidency4Samples指定物理设备是否可以访问每个像素有4个样本的部分驻留的2D图像。如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_4_BIT的图像。 51. sparseResidency8Samples指定物理设备是否可以访问具有每像素8个样本的部分驻留的2D图像。如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_8_BIT的图像。 52. sparseResidency16Samples指定物理设备是否可以访问每个像素16个样本的部分驻留的2D图像。如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_16_BIT的图像。 53. sparseResidencyAliased指定物理设备是否可以正确访问别名到多个位置的数据。如果未启用此功能，则不得分别在VkBufferCreateInfo和VkImageCreateInfo结构的flags成员中使用VK_BUFFER_CREATE_SPARSE_ALIASED_BIT和VK_IMAGE_CREATE_SPARSE_ALIASED_BIT枚举值。 54. variableMultisampleRate指定在没有附件的子通行期间将绑定到命令缓冲区的所有管道是否必须具有VkPipelineMultisampleStateCreateInfo::rasterizationSamples的相同值。如果设置为VK_TRUE，则实现支持不带附件的子通道中的可变多重采样率。如果设置为VK_FALSE，则绑定在此子通道中的所有管道必须具有相同的多采样率。 但这在子通道使用任何附件的情况下无效。 55. inheritedQueries指定在查询处于活动状态时是否可以执行辅助命令缓冲区。 说明：vkspec.html（2019&#x2F;05&#x2F;03）是从官方文档 https://github.com/KhronosGroup/Vulkan-Docs/ 中制作生成的。可以自行下载最新代码制作，也可以直接下载： csdn（需要5积分，不知道怎么去掉这个）：https://download.csdn.net/download/u014535072/11158246 百度网盘：链接: https://pan.baidu.com/s/1IyPnb-2ti1SjU0puFKwYUQ 提取码: f2c2","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(2)-创建Vulkan示例及验证层","slug":"Vulkan入门-2-创建Vulkan示例及验证层","date":"2022-02-26T14:24:59.000Z","updated":"2022-02-26T19:17:36.499Z","comments":true,"path":"2022/02/26/Vulkan入门-2-创建Vulkan示例及验证层/","link":"","permalink":"https://swallowjoe.github.io/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-2-%E5%88%9B%E5%BB%BAVulkan%E7%A4%BA%E4%BE%8B%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%B1%82/","excerpt":"简述本文主要是实现Vulkan Tutorial.pdf文档中的Base Code, Instance和Validation Layers部分。","text":"简述本文主要是实现Vulkan Tutorial.pdf文档中的Base Code, Instance和Validation Layers部分。 参考资料 https://github.com/KhronosGroup/Vulkan-Docs https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateInstance https://github.com/SaschaWillems/Vulkan/blob/master/base/vulkanexamplebase.h 一. 创建 vulkan 实例1.1 创建 Window 实例先创建个 window 窗口 12345678910111213141516void initWindow() &#123; // 第一步一定是先初始化GLFW库. glfwInit(); // 因为GLFW最初是为创建OpenGL上下文而设计的， // 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); // 创建窗口 // GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share) window = glfwCreateWindow(WIDTH, HEIGHT, WINDOW_TITLE, nullptr, nullptr);&#125; 1.2 创建 Vulkan 实例 创建 VkApplicationInfo 结构体变量，参数可选 创建 VkInstanceCreateInfo 结构体变量，必须指明 使用 GLFW (glfwGetRequiredInstanceExtensions) 创建 glfwExtensions, 以便为GLFW窗口创建Vulkan surface 调用 vkCreateInstance, 创建 vulkan 实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void createInstance() &#123; // 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo // 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化 VkApplicationInfo appInfo = &#123;&#125;; // Vulkan中的许多结构要求在sType成员中明确指定类型。 // 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。 appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; appInfo.pApplicationName = &quot;Hello Triangle&quot;; appInfo.applicationVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.pEngineName = &quot;No Engine&quot;; appInfo.engineVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.apiVersion = VK_API_VERSION_1_1; // Vulkan中的很多信息都是通过结构而不是函数参数传递的， // 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。 // VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 VkInstanceCreateInfo createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pNext = nullptr; createInfo.pApplicationInfo = &amp;appInfo; // 前两个参数很简单。 // Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。 // GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo uint32_t glfwExtensionCount = 0; const char** glfwExtensions; // 返回GLFW所需的Vulkan实例扩展。 // 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 // 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。 // 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。 glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); createInfo.enabledExtensionCount = glfwExtensionCount; // createInfo.ppEnabledLayerNames = glfwExtensions; // 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped) // 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。 createInfo.ppEnabledExtensionNames = glfwExtensions; // 结构体的最后两个成员确定要启用的全局验证层。 createInfo.enabledLayerCount = 0; // VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) VkResult res = vkCreateInstance(&amp;createInfo, nullptr, &amp;instance); if (res != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create instance!&quot;); &#125;&#125; 二. 验证层(Validation layers)2.1 什么是 Validation layers？Vulkan API围绕最小驱动程序开销的想法而设计，该目标的一个表现形式是默认情况下API中的错误检查非常有限。即使是将枚举设置为不正确的值或将空指针传递给所需参数这样简单的错误通常也不会被显式处理，只会导致崩溃或未定义的行为。这一点，笔者已经深刻体会到了，(╯﹏╰)因为Vulkan要求你对你所做的一切都非常明确，所以很容易犯很多小错误，例如使用新的GPU功能而忘记在逻辑设备创建时请求它。 但是，这并不意味着无法将这些检查添加到API中。Vulkan为这种称为验证层的系统引入了一个优雅的系统: Validation layers.验证层是可选组件，它挂接到Vulkan函数调用以应用其他操作。 验证层中的常见操作是： 根据规范检查参数值以检测误用 跟踪对象的创建和销毁以查找资源泄漏 通过跟踪调用的线程来检查线程安全性 将每个调用及其参数记录到标准输出方便调试 跟踪Vulkan要求进行性能分析和重放 2.2 Validation layers示例123456789101112VkResult vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* instance) &#123; if (pCreateInfo == nullptr || instance == nullptr) &#123; log(&quot;Null pointer passed to required parameter!&quot;); return VK_ERROR_INITIALIZATION_FAILED; &#125; return real_vkCreateInstance(pCreateInfo, pAllocator, instance);&#125; 比如上面的vkCreateInstance中的if语句。官方文档上如此说： 1234567891011这些验证层可以自由堆叠，以包含您感兴趣的所有调试功能。您可以简单地为调试版本启用验证层，并为发布版本完全禁用它们，这将为您提供两全其美的优势！Vulkan没有内置任何验证层，但LunarG Vulkan SDK提供了一组很好的层来检查常见错误。它们也是完全开源的，因此您可以检查它们检查和贡献的错误类型。使用验证层是避免应用程序因意外依赖未定义行为而破坏不同驱动程序的最佳方法。验证层只有在已安装到系统上时才能使用。例如，LunarG验证层仅适用于安装了Vulkan SDK的PC。Vulkan中以前有两种不同类型的验证层：实例和设备特定。我们的想法是，实例层只会检查与全局Vulkan对象（如实例）相关的调用，而设备特定层只会检查与特定GPU相关的调用。现在已弃用特定于设备的层，这意味着实例验证层适用于所有Vulkan调用。规范文档仍建议您在设备级别启用验证层以及兼容性，这是某些实现所需的。 2.3 启用验证层如何启用Vulkan SDK提供的标准诊断层? 就像扩展一样，需要通过指定其名称来启用验证层。所有有用的标准验证都捆绑在SDK中包含的层中，称为VK_LAYER_KHRONOS_validation。让我们首先向程序添加两个配置变量，以指定要启用的层以及是否启用它们。 我已经选择将该值作为程序是否在调试模式下编译。NDEBUG宏是C ++标准的一部分，意味着“不调试”。 123456789const std::vector&lt;const char*&gt; validationLayers = &#123; &quot;VK_LAYER_KHRONOS_validation&quot;&#125;;#ifdef NDEBUG const bool enableValidationLayers = false;#else const bool enableValidationLayers = true;#endif 2.4 消息回调仅启用这些层并没有多大帮助，因为它们目前无法将调试消息中继回我们的程序。要接收这些消息，我们必须设置一个带回调的调试信使，这需要VK_EXT_debug_utils扩展。我们将首先创建一个getRequiredExtensions函数，根据是否启用验证层返回所需的扩展名列表： 12345678910111213std::vector&lt;const char*&gt; getRequiredExtensions() &#123; uint32_t glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount); if (enableValidationLayers) &#123; extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); &#125; return extensions;&#125; GLFW指定的扩展始终是必需的，但有条件地添加了调试信使扩展(VK_EXT_debug_utils)。请注意，在这里使用了VK_EXT_DEBUG_UTILS_EXTENSION_NAME宏，它等于文字字符串“VK_EXT_debug_utils”。 使用此宏可以避免拼写错误。我们现在可以在createInstance中使用此函数： 123auto extensions = getRequiredExtensions();createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());createInfo.ppEnabledExtensionNames = extensions.data(); 2.4.1 调试回调函数 debugCallback现在让我们看一下调试回调函数的样子。使用PFN_vkDebugUtilsMessengerCallbackEXT原型添加一个名为debugCallback的新静态成员函数。VKAPI_ATTR和VKAPI_CALL确保该函数具有Vulkan调用它的正确签名。 12345678910static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) &#123; std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl; return VK_FALSE;&#125; 第一个参数: VkDebugUtilsMessageSeverityFlagBitsEXT 指明了消息的严重程度•VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT：诊断消息•VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT：信息性消息，如创建资源•VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT：有关行为的消息不一定是错误，但很可能是应用程序中的错误•VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT：有关无效行为的消息，可能导致崩溃可以根据这个参数过滤所需的信息。 第二个参数: VkDebugUtilsMessageTypeFlagsEXT 指明了消息的类型•VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT：发生了与规范或性能无关的某些事件•VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT：发生了违反规范或表明可能存在错误的事情•VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT：潜在的非最佳使用Vulkan 第三个参数: VkDebugUtilsMessengerCallbackDataEXT 这个结构体包含了消息更多的细节内容•pMessage：调试消息为以空字符结尾的字符串•pObjects：与消息相关的Vulkan对象句柄数组•object Count：数组中的对象数 第四个参数: pUserData 包含在回调设置期间指定的指针，并允许您将自己的数据传递给它。 回调返回一个布尔值，指示是否应该中止触发验证层消息的Vulkan调用。如果回调返回true，则调用将因VK_ERROR_VALIDATION_FAILED_EXT错误而中止。这通常仅用于测试验证层本身，因此应始终返回VK_FALSE。 2.4.2 注册调试回调在Vulkan中, 调试回调也是通过需要显式创建和销毁的句柄来管理的。 这样的回调是debug message的一部分，可以根据需要设置尽可能多的回调。 12345678910111213141516171819202122232425// 在成员变量中添加：VkDebugUtilsMessengerEXTVkDebugUtilsMessengerEXT debugMessenger;void initVulkan() &#123; createInstance(); setupDebugMessenger();&#125;void setupDebugMessenger() &#123; if (!enableValidationLayers) return; VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT; // 指定消息回调函数 createInfo.pfnUserCallback = debugCallback; createInfo.pUserData = nullptr; // 可选&#125; messageSeverity字段允许指定要为其调用回调的所有类型的严重性。在这里指定了除VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT之外的所有类型，以接收有关可能问题的通知，同时省略详细的一般调试信息。类似地，messageType字段可以过滤通知回调的消息类型。 在这里启用了所有类型。最后，pfnUserCallback字段指定回调函数的指针。可以选择将指针传递给pUserData字段，该字段将通过pUserData参数传递给回调函数。例如，可以使用它来传递指向HelloTriangleApplication类的指针。 应该将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。然而因为这个function是一个扩展函数，它不会自动加载。必须使用vkGetInstanceProcAddr查找其地址。 创建代理函数，然后在处理它，如下: 12345678910111213VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) &#123; auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance,&quot;vkCreateDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; return func(instance, pCreateInfo, pAllocator, pDebugMessenger); &#125; else &#123; return VK_ERROR_EXTENSION_NOT_PRESENT; &#125;&#125; 现在我们可以在 setupDebugMessenger 中调用此函数： 12345678910void setupDebugMessenger() &#123; if (!enableValidationLayers) return; ...... // 实例化DebugUtilsMessengerEXT if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to set up debug messenger!&quot;); &#125;&#125; 最后注意，既然有 vkCreateXXX, 就需要显示调用 vkDestroyXXX 哦！ 12345678910void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) &#123; auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; func(instance, debugMessenger, pAllocator); &#125;&#125; 如果你忘了调用DestroyDebugUtilsMessengerEXT去销毁debugMessenger，在关闭窗口的时候就会打印如下信息: 三. 代码3.1 Makefile12345678910111213141516VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/includeLDFLAGS = -L$(VULKAN_SDK_PATH)/lib -lvulkan `pkg-config --static --libs glfw3`LDFLAGS += -ldlHelloTriangleApplication: main.cpp g++ $(CFLAGS) -o HelloTriangleApplication main.cpp $(LDFLAGS).PHONY: test cleantest: HelloTriangleApplication LD_LIBRARY_PATH=$(VULKAN_SDK_PATH)/lib VK_LAYER_PATH=$(VULKAN_SDK_PATH)/etc/explicit_layer.d ./HelloTriangleApplicationclean:rm -f HelloTriangleApplication 3.2 main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294/** * #include &lt;vulkan/vulkan.h&gt; // vulkan 头文件 * 使用下面两行替换 vulkan头文件 * #define GLFW_INCLUDE_VULKAN * #include &lt;GLFW/glfw3.h&gt; * * GLFW 会自动加载 vulkan 头文件的。 * GLFW是一个开源，多平台的库，用于桌面上的OpenGL，OpenGL ES和Vulkan开发。 * 它提供了一个简单的API，用于创建窗口，上下文和曲面，接收输入和事件。 * GLFW是用C语言编写的，并且使用X Window系统（例如Linux和FreeBSD）对Windows，macOS和许多类Unix系统提供原生支持。 */#define GLFW_INCLUDE_VULKAN#include &lt;GLFW/glfw3.h&gt;#include &lt;iostream&gt;#include &lt;stdexcept&gt; // 包含用于报告错误的头文件#include &lt;functional&gt; // 用于资源管理部分中的lambda函数#include &lt;cstdlib&gt; // cstdlib: EXIT_FAILURE, EXIT_SUCCESS#include &lt;vector&gt;#include &lt;string.h&gt; #ifdef NDEBUG const bool enableValidationLayers = false;#else const bool enableValidationLayers = true;#endifclass HelloTriangleApplication &#123;public: void run() &#123; initWindow(); initVulkan(); mainLoop(); cleanup(); &#125; const int WIDTH = 800; const int HEIGHT = 600; const char * WINDOW_TITLE = &quot;Vulkan&quot;;private: void initWindow() &#123; // 第一步一定是先初始化GLFW库. glfwInit(); // 因为GLFW最初是为创建OpenGL上下文而设计的， // 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变 glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); // 创建窗口 // GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share) window = glfwCreateWindow(WIDTH, HEIGHT, WINDOW_TITLE, nullptr, nullptr); &#125; void initVulkan() &#123; checkAvailableExtensions(); createInstance(); // 创建DEBUG消息回调 setupDebugMessenger(); &#125; void setupDebugMessenger() &#123; if (!enableValidationLayers) return; VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT; createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT; // 指定消息回调函数 createInfo.pfnUserCallback = debugCallback; createInfo.pUserData = nullptr; // 可选 // 实例化DebugUtilsMessengerEXT if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;debugMessenger) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to set up debug messenger!&quot;); &#125; &#125; void checkAvailableExtensions() &#123; uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, nullptr); std::vector&lt;VkExtensionProperties&gt; extensions(extensionCount); vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, extensions.data()); std::cout &lt;&lt; &quot;available extensions:&quot; &lt;&lt; std::endl; for (const auto&amp; extension : extensions) &#123; std::cout &lt;&lt; &quot;\\t&quot; &lt;&lt; extension.extensionName &lt;&lt; std::endl; &#125; &#125; bool checkValidationLayerSupport() &#123; uint32_t layerCount; vkEnumerateInstanceLayerProperties(&amp;layerCount, nullptr); std::vector&lt;VkLayerProperties&gt; availableLayers(layerCount); vkEnumerateInstanceLayerProperties(&amp;layerCount, availableLayers.data()); for (const char* layerName : validationLayers) &#123; //bool layerFound = false; for (const auto&amp; layerProperties : availableLayers) &#123; if (strcmp(layerName, layerProperties.layerName) == 0) &#123; //layerFound = true; return true; &#125; &#125; &#125; return false; &#125; void createInstance() &#123; // 验证层，检验VK_LAYER_KHRONOS_validation if (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) &#123; throw std::runtime_error(&quot;validation layers requested, but not available!&quot;); &#125; // 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo // 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化 VkApplicationInfo appInfo = &#123;&#125;; // Vulkan中的许多结构要求在sType成员中明确指定类型。 // 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。 appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO; appInfo.pApplicationName = &quot;Hello Triangle&quot;; appInfo.applicationVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.pEngineName = &quot;No Engine&quot;; appInfo.engineVersion = VK_MAKE_VERSION(1, 1, 0); appInfo.apiVersion = VK_API_VERSION_1_1; // Vulkan中的很多信息都是通过结构而不是函数参数传递的， // 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。 // VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 VkInstanceCreateInfo createInfo = &#123;&#125;; createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; createInfo.pNext = nullptr; createInfo.pApplicationInfo = &amp;appInfo; /* // 前两个参数很简单。 // Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。 // GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo uint32_t glfwExtensionCount = 0; const char** glfwExtensions; // 返回GLFW所需的Vulkan实例扩展。 // 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 // 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。 // 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。 glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); // 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped) // 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。 createInfo.ppEnabledLayerNames = glfwExtensions; createInfo.ppEnabledExtensionNames = glfwExtensions; createInfo.enabledExtensionCount = glfwExtensionCount; */ // 返回GLFW所需的Vulkan实例扩展, 支持消息回调 auto extensions = getRequiredExtensions(); createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size()); createInfo.ppEnabledExtensionNames = extensions.data(); // 结构体的最后两个成员确定要启用的全局验证层。 if (enableValidationLayers) &#123; createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data(); &#125; else &#123; createInfo.enabledLayerCount = 0; &#125; // VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) VkResult res = vkCreateInstance(&amp;createInfo, nullptr, &amp;instance); if (res != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create instance!&quot;); &#125; &#125; void mainLoop() &#123; // 添加一个事件循环, 使应用程序保持运行直到发生错误或窗口关闭 while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); &#125; &#125; // 在 vulkan 中推荐在创建的资源不需要后主动释放 void cleanup() &#123; // 释放debugMessenger(VkDebugUtilsMessengerEXT, 用于打印调试信息) if (enableValidationLayers) &#123; DestroyDebugUtilsMessengerEXT(instance, debugMessenger, nullptr); &#125; // 在 vulkan 中资源一般都是 vkCreateXXX 创建，由 vkDestroyXXX 或 vkFreeXXX 释放. vkDestroyInstance(instance, nullptr); // 此函数会破坏指定的窗口及其上下文。 在调用此函数时，不会为该窗口调用其他回调。 // 如果指定窗口的上下文在主线程上是最新的，则在销毁之前将其分离。 glfwDestroyWindow(window); // 此功能会释放所有剩余的窗口和光标并释放任何其他已分配的资源。 // 调用此函数后，必须再次成功调用@ref glfwInit，然后才能使用大多数GLFW函数。 glfwTerminate(); &#125; // 用于消息回调Message Callback std::vector&lt;const char*&gt; getRequiredExtensions() &#123; uint32_t glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount); if (enableValidationLayers) &#123; extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); &#125; return extensions; &#125; // 打印debug信息 static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) &#123; std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl; return VK_FALSE; &#125; // 创建 VkDebugUtilsMessengerEXT 对象debugMessenger VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pDebugMessenger) &#123; // 将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。 // 然而因为这个function是一个扩展函数，它不会自动加载。 // 必须使用vkGetInstanceProcAddr查找其地址。 auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance,&quot;vkCreateDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; return func(instance, pCreateInfo, pAllocator, pDebugMessenger); &#125; else &#123; return VK_ERROR_EXTENSION_NOT_PRESENT; &#125; &#125; // 销毁VkDebugUtilsMessengerEXT void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks* pAllocator) &#123; auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; func(instance, debugMessenger, pAllocator); &#125; &#125; // Window实例 GLFWwindow* window; // Vulkan实例 VkInstance instance; // DEBUG消息回调 VkDebugUtilsMessengerEXT debugMessenger; // 验证层 const std::vector&lt;const char*&gt; validationLayers = &#123; &quot;VK_LAYER_KHRONOS_validation&quot; &#125;;&#125;;int main() &#123; HelloTriangleApplication app; try &#123; app.run(); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; &#125; return EXIT_SUCCESS;&#125;","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]},{"title":"Vulkan入门(1)-环境配置","slug":"Vulkan入门-1-环境配置","date":"2022-02-26T13:13:24.000Z","updated":"2022-02-26T18:05:46.367Z","comments":true,"path":"2022/02/26/Vulkan入门-1-环境配置/","link":"","permalink":"https://swallowjoe.github.io/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"简述本文主要是介绍如何在 ubuntu 机器上安装并编译Vulkan程序。","text":"简述本文主要是介绍如何在 ubuntu 机器上安装并编译Vulkan程序。 参考资料 https://vulkan.lunarg.com/doc/sdk/1.2.170.0/linux/getting_started.html https://github.com/google/glog [pkg-config的用法]https://www.cnblogs.com/chris-cp/p/3580002.html [解决&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libglog.so.0: error adding symbols: DSO missing from command line]https://blog.csdn.net/u010987458/article/details/72235408 https://www.glfw.org/docs/3.3/build_guide.html#build_link_cmake_package [GLFW]https://www.glfw.org/ [GLM]https://github.com/g-truc/glm 一. 准备环境1.1 开发环境12345sudo apt-get updatesudo apt-get dist-upgradesudo apt-get install libglm-dev cmake libxcb-dri3-0 libxcb-present0 libpciaccess0 libpng-dev libxcb-keysyms1-dev libxcb-dri3-dev libx11-dev libmirclient-dev libwayland-dev libxrandr-dev libxcb-ewmh-devsudo apt-get install git libpython2.7 1.2 下载 SDK官方网站：https://vulkan.lunarg.com/ 下载SDK包：vulkan-sdk.tar.gz 1234cd ~/Programmkdir vulkancd vulkantar zxf $HOME/Downloads/vulkan-sdk.tar.gz 解压后的文件目录如下： 文件夹 描述 x86_64&#x2F;bin Vulkan工具和命令 x86_64&#x2F;include&#x2F;vulkan 编译链接头文件 x86_64&#x2F;lib Vulkan加载程序库和layer运行时库 x86_64&#x2F;etc&#x2F;explicit_layer.d .json 用于Vulkan验证层的清单文件 config 样本层设置文件，系统配置说明 doc Khronos SPIRV，Vulkan，Loader和WSI规范 examples Vulkan程序示例 samples Vulkan的示例代码 source glslang和所选Vulkan组件的源和调试库 1.3 安装SDK123456source ~/Program/vulkan/1.2.170.0/setup-env.shexport VULKAN_SDK=~/vulkan/1.2.170.0/x86_64export PATH=$VULKAN_SDK/bin:$PATHexport LD_LIBRARY_PATH=$VULKAN_SDK/lib:$LD_LIBRARY_PATHexport VK_LAYER_PATH=$VULKAN_SDK/etc/explicit_layer.d 大功告成，检查一下：输入vulkaninfo&#117;&#x62;&#117;&#110;&#116;&#117;&#64;&#x31;&#x38;&#46;&#x30;&#52;&#x4c; ~ vulkaninfoCannot create Vulkan instance.&#x2F;home&#x2F;lunarg&#x2F;sdk-build&#x2F;Vulkan-Tools&#x2F;vulkaninfo&#x2F;vulkaninfo.c:921: failed with VK_ERROR_INCOMPATIBLE_DRIVER wtf, 发生了什么？等等，貌似我们没有检查是否安装了驱动。。。 1.4 安装驱动123456789sudo add-apt-repository ppa:oibaf/graphics-driverssudo apt updatesudo apt upgradeapt install libvulkan1 mesa-vulkan-drivers vulkan-utils// 或者试试：sudo add-apt-repository ppa:graphics-drivers/ppasudo apt upgradesudo apt install nvidia-graphics-drivers-396 nvidia-settings vulkan vulkan-utils 检查一下：输入vulkaninfo 或者：vulkaninfo –html , 在当前目录生成 vulkaninfo.html 文件，用浏览器打开，可以看到更多信息 1.5. 运行示例程序12345cd Program/vulkan/1.1.160.0/examplesmkdir buildcd buildcmake ..make make成功后会在当前目录生成： 运行示例程序： 1./vkcube 一个旋转的立方体～ 二. GLFW 安装Vulkan本身是一个与平台无关的API，不包括用于创建显示渲染结果的窗口的工具。 为了从Vulkan的跨平台优势中受益并避免X11的限制，我们将使用GLFW库来创建一个支持Windows，Linux和MacOS的窗口。还有其他可用于此目的的库，如SDL，但GLFW的优势在于它除了窗口创建之外，还抽象了Vulkan中一些其他特定于平台的东西。我们将从源代码安装GLFW而不是使用软件包，因为Vulkan支持需要最新版本。 可以在官方网站上找到这些来源。将源代码解压缩到一个方便的目录，并使用CMakeLists.txt等文件打开目录中的终端。 github地址：https://github.com/glfw/glfw解压后进入其主目录：cmake .有报错： 12345678-- Looking for shmat - found-- Found X11: /usr/lib/x86_64-linux-gnu/libX11.soCMake Error at CMakeLists.txt:220 (message): The Xinerama headers were not found-- Configuring incomplete, errors occurred!See also &quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeOutput.log&quot;.See also &quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeError.log&quot;. 缺少环境： 1$ ~/Program/vulkan/glfw-master  sudo apt-get install libsdl2-dev 然后重新: cmake . 123456🦄  ~/Program/vulkan/glfw-master  cmake .-- Could NOT find Doxygen (missing: DOXYGEN_EXECUTABLE) -- Using X11 for window creation-- Configuring done-- Generating done-- Build files have been written to: /home/jh/Program/vulkan/glfw-master 濡染没有报错，但这个也是没有成功的：缺少Doxygensudo apt-get install doxygen 重新: cmake .最后: make成功后：sudo make install 三. GLM 安装与DirectX 12不同，Vulkan不包含用于线性代数运算的库，因此我们必须下载一个。GLM是一个很好的库，设计用于图形API，也常用于OpenGL。它是一个只有头的库，可以从libglm-dev包安装： sudo apt install libglm-dev 四. 手动编译示例代码4.1 在编译示例代码的时候老是报错，找不到vulkan头文件。123456$ gcc -o main main.cpp -lglfw3In file included from main.cpp:2:/usr/local/include/GLFW/glfw3.h:215:12: fatal error: vulkan/vulkan.h: 没有那个文件或目录 #include &lt;vulkan/vulkan.h&gt; ^~~~~~~~~~~~~~~~~compilation terminated. 当然是环境设置的问题：需要将头文件等拷贝到对应system文件夹 12345678cd Program/vulkan/1.2.170.0/x86_64sudo cp -r include/vulkan/ /usr/local/include/sudo cp -P lib/libvulkan.so* /usr/local/lib/sudo cp lib/libVkLayer_*.so /usr/local/lib/sudo mkdir -p /usr/local/share/vulkan/explicit_layer.dsudo cp etc/explicit_layer.d/VkLayer_*.json /usr/local/share/vulkan/explicit_layer.d sudo ldconfig 4.2 error adding symbols: DSO missing from command line123456makeg++ -std=c++17 -I/home/jh/Program/vulkan/1.1.160.0/x86_64/include -o VulkanTest main.cpp -L/home/jh/Program/vulkan/1.1.160.0/x86_64/lib -lvulkan -lglfw3/usr/bin/ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol &#x27;dlclose@@GLIBC_2.2.5&#x27;/usr/bin/ld: //lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command linecollect2: error: ld returned 1 exit statusmake: *** [Makefile:8：VulkanTest] 错误 1 cd &#x2F;usr&#x2F;lib&#x2F;ll |grep -iE “liblog”没有文件 https://github.com/google/glog下载解压, 进入解压后的主目录，执行：.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install 如果报错：autogen.sh: 5: autogen.sh: autoreconf: not foundsudo apt-get install autoconfsudo apt-get install automakesudo apt-get install libtool 重新执行：.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install可能还有权限问题： 123456-- Up-to-date: /usr/local/include/GLFWCMake Error at cmake_install.cmake:41 (file): file INSTALL cannot set permissions on &quot;/usr/local/include/GLFW&quot;make: *** [Makefile:118：install] 错误 1 执行：cd ..chmod a+x glog-master -Rcd glog-mastermake &amp;&amp; make install okay,现在可以在Makefile文件中添加：-lglog 重新 make 还是会存在这个问题，笔者查阅各种资料，大部分指明在Makefile中加入 -ldl 即可，尝试后失败。最后发现是 Makefile 文件写的有问题，改成如[#5.2]即可. 4.3 运行示例make 成功后，会在当前目录生成 VulkanTest 可执行文件: 1./VulkanTest 结果如下: 五. 主要代码5.1 main.cpp123456789101112131415161718192021222324252627282930313233#define GLFW_INCLUDE_VULKAN#include &lt;GLFW/glfw3.h&gt;#define GLM_FORCE_RADIANS#define GLM_FORCE_DEPTH_ZERO_TO_ONE#include &lt;glm/vec4.hpp&gt;#include &lt;glm/mat4x4.hpp&gt;#include &lt;iostream&gt;int main() &#123; glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); GLFWwindow* window = glfwCreateWindow(800, 600, &quot;Vulkan window&quot;, nullptr, nullptr); uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, nullptr); std::cout &lt;&lt; extensionCount &lt;&lt; &quot; extensions supported&quot; &lt;&lt; std::endl; glm::mat4 matrix; glm::vec4 vec; auto test = matrix * vec; while(!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); &#125; glfwDestroyWindow(window); glfwTerminate(); return 0;&#125; 5.2 Makefile12345678910111213141516VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/includeLDFLAGS = -L$(VULKAN_SDK_PATH)/lib -lvulkan `pkg-config --static --libs glfw3`LDFLAGS += -ldlVulkanTest: main.cpp g++ $(CFLAGS) -o VulkanTest main.cpp $(LDFLAGS).PHONY: test cleantest: VulkanTest LD_LIBRARY_PATH=$(VULKAN_SDK_PATH)/lib VK_LAYER_PATH=$(VULKAN_SDK_PATH)/etc/explicit_layer.d ./VulkanTestclean:rm -f VulkanTest","categories":[{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/categories/Android/"},{"name":"WMS","slug":"Android/WMS","permalink":"https://swallowjoe.github.io/categories/Android/WMS/"},{"name":"Input","slug":"Android/WMS/Input","permalink":"https://swallowjoe.github.io/categories/Android/WMS/Input/"},{"name":"Binder","slug":"Android/Binder","permalink":"https://swallowjoe.github.io/categories/Android/Binder/"},{"name":"SurfaceFlinger","slug":"Android/SurfaceFlinger","permalink":"https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"},{"name":"Vsync","slug":"Android/Vsync","permalink":"https://swallowjoe.github.io/categories/Android/Vsync/"},{"name":"Looper","slug":"Android/Looper","permalink":"https://swallowjoe.github.io/categories/Android/Looper/"},{"name":"图像引擎","slug":"图像引擎","permalink":"https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://swallowjoe.github.io/tags/Android/"},{"name":"WMS","slug":"WMS","permalink":"https://swallowjoe.github.io/tags/WMS/"},{"name":"Input","slug":"Input","permalink":"https://swallowjoe.github.io/tags/Input/"},{"name":"Vsync","slug":"Vsync","permalink":"https://swallowjoe.github.io/tags/Vsync/"},{"name":"Binder","slug":"Binder","permalink":"https://swallowjoe.github.io/tags/Binder/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"https://swallowjoe.github.io/tags/SurfaceFlinger/"},{"name":"Looper","slug":"Looper","permalink":"https://swallowjoe.github.io/tags/Looper/"},{"name":"Vulkan","slug":"Vulkan","permalink":"https://swallowjoe.github.io/tags/Vulkan/"}]}