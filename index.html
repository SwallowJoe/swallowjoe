<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swallowjoe.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitment","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="君子知命不惧，日日自新">
<meta property="og:type" content="website">
<meta property="og:title" content="SwallowJoe的博客">
<meta property="og:url" content="https://swallowjoe.github.io/index.html">
<meta property="og:site_name" content="SwallowJoe的博客">
<meta property="og:description" content="君子知命不惧，日日自新">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SwallowJoe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://swallowjoe.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SwallowJoe的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="SwallowJoe的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SwallowJoe的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a real go-getter,<br>NEVER SETTLE!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/swallowjoe" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-5-composer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/SurfaceFlinger-5-composer/" class="post-title-link" itemprop="url">SurfaceFlinger(5)--composer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-04 09:58:09 / 修改时间：10:12:51" itemprop="dateCreated datePublished" datetime="2022-04-04T09:58:09+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/SurfaceFlinger/" itemprop="url" rel="index"><span itemprop="name">SurfaceFlinger</span></a>
                </span>
            </span>

          
            <span id="/2022/04/04/SurfaceFlinger-5-composer/" class="post-meta-item leancloud_visitors" data-flag-title="SurfaceFlinger(5)--composer" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/04/SurfaceFlinger-5-composer/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/04/SurfaceFlinger-5-composer/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<p>接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。<br>前面我们也稍微分析了一下，直接看handleMessageRefresh方法：</p>
<p><img src="/.io//5_1_sf_onVsync.png" alt="图片"></p>
<p>从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。<br>如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。</p>
<p>这里重点分析handleMessageRefresh.</p>
<h1 id="一-handleMessageRefresh"><a href="#一-handleMessageRefresh" class="headerlink" title="一. handleMessageRefresh"></a>一. handleMessageRefresh</h1><h2 id="1-1-SurfaceFlinger-handleMessageRefresh"><a href="#1-1-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="1.1 SurfaceFlinger:handleMessageRefresh"></a>1.1 SurfaceFlinger:handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 1.2 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 重建layer堆栈, 提取可见的Laye并计算可见区域</span></span><br><span class="line">    <span class="comment">// 并将数据更新给对应的Display</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4 hwcomposer的设定，将Layer数据更新给HWC</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有Display，依次合成处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="comment">// 1.5 其实beginFrame和prepareFrame最终都是调用到FrameBufferSurface中，没有做特别的事情</span></span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="comment">// 1.6 正式的合成处理，简单来说就是申请GraphicBuffer，向其中填充帧数据</span></span><br><span class="line">        <span class="comment">// 最终给到硬件帧缓冲区</span></span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知composer,即HWC</span></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据状况决定是否更新Vsync Offset</span></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</span></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-SurfaceFlinger-perComposition"><a href="#1-2-SurfaceFlinger-perComposition" class="headerlink" title="1.2 SurfaceFlinger:perComposition"></a>1.2 SurfaceFlinger:perComposition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;preComposition&quot;</span>);</span><br><span class="line">    <span class="comment">// 记录刷新时间</span></span><br><span class="line">    mRefreshStartTime = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.1 遍历所有layer, 处理处于Drawing状态的layer</span></span><br><span class="line">    <span class="comment">// 这里使用了lambda函数</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 1.2.3 判断Layer是否需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">            <span class="comment">// 如果有layer有frame更新，则标记该值为true，表示需要下一个vsync</span></span><br><span class="line">            <span class="comment">// 做合成</span></span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> SurfaceFlinger::State::<span class="built_in">traverseInZOrder</span>(<span class="type">const</span> LayerVector::Visitor&amp; visitor) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的mDrawingState里面的stateSet为StateSet::Drawing</span></span><br><span class="line">    layersSortedByZ.<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.h</span></span><br><span class="line">State mDrawingState&#123;LayerVector::StateSet::Drawing&#125;;</span><br></pre></td></tr></table></figure>
<p>layersSortedByZ中存储的layer都是SurfaceFlinger.addClientLayer过程中添加的。</p>
<h3 id="1-2-1-LayerVector-traverseInZOrder"><a href="#1-2-1-LayerVector-traverseInZOrder" class="headerlink" title="1.2.1 LayerVector:traverseInZOrder"></a>1.2.1 LayerVector:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerVector::traverseInZOrder</span><span class="params">(StateSet stateSet, <span class="type">const</span> Visitor&amp; visitor)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; layer = (*<span class="keyword">this</span>)[i];</span><br><span class="line">        <span class="comment">// 遍历所有layer，拿到合适State的Layer做处理</span></span><br><span class="line">        <span class="comment">// 这里是拿所有Drawing状态的Layer</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; state = (stateSet == StateSet::Current) ? layer-&gt;<span class="built_in">getCurrentState</span>()</span><br><span class="line">                                                      : layer-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">        <span class="comment">// zOrderRelativeOf中的layer是上层调用setRelativeLayer后添加的</span></span><br><span class="line">        <span class="comment">// 如果为非null，则表示此Surface的Z顺序相对于此进行解释</span></span><br><span class="line">        <span class="comment">// 默认是null的。</span></span><br><span class="line">        <span class="keyword">if</span> (state.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理Layer</span></span><br><span class="line">        layer-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-Layer-traverseInZOrder"><a href="#1-2-2-Layer-traverseInZOrder" class="headerlink" title="1.2.2 Layer:traverseInZOrder"></a>1.2.2 Layer:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::traverseInZOrder</span><span class="params">(LayerVector::StateSet stateSet, <span class="type">const</span> LayerVector::Visitor&amp; visitor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> skipRelativeZUsers = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.2.1 按顺序将当前Layer所有z轴相关的layer和子layer添加至列表</span></span><br><span class="line">    <span class="type">const</span> LayerVector list = <span class="built_in">makeTraversalList</span>(stateSet, &amp;skipRelativeZUsers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也就是说首先遍历Z轴相关的Layer</span></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意Layer的添加都是按照Z轴顺序插入排序的</span></span><br><span class="line">        <span class="comment">// 这里的意思就是首先要遍历并对所有z轴小于0的Layer调用onPreComposition方法</span></span><br><span class="line">        <span class="comment">// 所以需要理解z轴小于0的意义，什么时候z轴值才会小于0？</span></span><br><span class="line">        <span class="comment">// 因为P/Q上Layer组合的数据结构是：树形结构+Z轴排序。现在Z轴的大小一般为 [-2, 2]</span></span><br><span class="line">        <span class="comment">// Z轴小的在下面会被覆盖。现在可以理解了，这里为什么碰到z大于0就要退出循环了</span></span><br><span class="line">        <span class="keyword">if</span> (relative-&gt;<span class="built_in">getZ</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对本Layer做onPreComposition</span></span><br><span class="line">    <span class="built_in">visitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后对所有Z轴不小于0的Layer做onPreComposition</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>visitor这个就是lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.3 调用onPreComposition</span></span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>总的来说就是按顺序依次调用layer的onPreComposition方法，标记其mRefreshPending为false。</p>
<h4 id="1-2-2-1-Layer-makeTraversalList"><a href="#1-2-2-1-Layer-makeTraversalList" class="headerlink" title="1.2.2.1 Layer:makeTraversalList"></a>1.2.2.1 Layer:makeTraversalList</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __attribute__((no_sanitize(&quot;unsigned-integer-overflow&quot;)))的意思</span></span><br><span class="line"><span class="comment">// 是不进行无符号int溢出检测</span></span><br><span class="line">__attribute__((<span class="built_in">no_sanitize</span>(<span class="string">&quot;unsigned-integer-overflow&quot;</span>))) <span class="function">LayerVector <span class="title">Layer::makeTraversalList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        LayerVector::StateSet stateSet, <span class="type">bool</span>* outSkipRelativeZUsers)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(stateSet == LayerVector::StateSet::Invalid,</span><br><span class="line">                        <span class="string">&quot;makeTraversalList received invalid stateSet&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里useDrawing为true</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> useDrawing = stateSet == LayerVector::StateSet::Drawing;</span><br><span class="line">    <span class="type">const</span> LayerVector&amp; children = useDrawing ? mDrawingChildren : mCurrentChildren;</span><br><span class="line">    <span class="type">const</span> State&amp; state = useDrawing ? mDrawingState : mCurrentState;</span><br><span class="line">    <span class="comment">// 假设没有zOrderRelatives，所以直接返回children</span></span><br><span class="line">    <span class="keyword">if</span> (state.zOrderRelatives.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        *outSkipRelativeZUsers = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在，则将相关的layer按照Z轴顺序加入stateSet.Drawing中</span></span><br><span class="line">    <span class="function">LayerVector <span class="title">traverse</span><span class="params">(stateSet)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> wp&lt;Layer&gt;&amp; weakRelative : state.zOrderRelatives) &#123;</span><br><span class="line">        sp&lt;Layer&gt; strongRelative = weakRelative.<span class="built_in">promote</span>();</span><br><span class="line">        <span class="keyword">if</span> (strongRelative != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            traverse.<span class="built_in">add</span>(strongRelative);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有children，将children的相关Layer添加至traverse</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;Layer&gt;&amp; child : children) &#123;</span><br><span class="line">        <span class="type">const</span> State&amp; childState = useDrawing ? child-&gt;mDrawingState : child-&gt;mCurrentState;</span><br><span class="line">        <span class="keyword">if</span> (childState.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse.<span class="built_in">add</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到1.2.2中。</p>
<h3 id="1-2-3-Layer-BufferLayer-onPreComposition"><a href="#1-2-3-Layer-BufferLayer-onPreComposition" class="headerlink" title="1.2.3 Layer:BufferLayer::onPreComposition"></a>1.2.3 Layer:BufferLayer::onPreComposition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="type">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        mFrameEventHistory.<span class="built_in">addPreComposition</span>(mCurrentFrameNumber, refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasReadyFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录开始刷新的时间，并返回该Layer是否具有可被合成的条件。</p>
<h4 id="1-2-3-1-Layer-BufferLayer-hasReadyFrame"><a href="#1-2-3-1-Layer-BufferLayer-hasReadyFrame" class="headerlink" title="1.2.3.1 Layer:BufferLayer::hasReadyFrame"></a>1.2.3.1 Layer:BufferLayer::hasReadyFrame</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::hasReadyFrame</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasFrameUpdate</span>() || <span class="built_in">getSidebandStreamChanged</span>() || <span class="built_in">getAutoRefresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-2-Layer-BufferLayer-BufferQueueLayer"><a href="#1-2-3-2-Layer-BufferLayer-BufferQueueLayer" class="headerlink" title="1.2.3.2 Layer:BufferLayer:BufferQueueLayer"></a>1.2.3.2 Layer:BufferLayer:BufferQueueLayer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::hasFrameUpdate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否具有绘制完成的frame</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getAutoRefresh</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAutoRefresh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getSidebandStreamChanged</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSidebandStreamChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-SurfaceFlinger-rebuildLayerStacks"><a href="#1-3-SurfaceFlinger-rebuildLayerStacks" class="headerlink" title="1.3 SurfaceFlinger:rebuildLayerStacks"></a>1.3 SurfaceFlinger:rebuildLayerStacks</h2><p>这个方法比较长，慢慢看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;rebuildLayerStacks&quot;</span>);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mDolphinStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个display重建其layer列表</span></span><br><span class="line">    <span class="comment">// mVisibleRegionsDirty的这个变量在如下条件会被置为true:</span></span><br><span class="line">    <span class="comment">// 1. 有layer的增删时</span></span><br><span class="line">    <span class="comment">// 2. layer可视化面积发生变化</span></span><br><span class="line">    <span class="comment">// 3. display显示设备变化</span></span><br><span class="line">    <span class="comment">// 4. set power mode on - 即亮屏时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;rebuildLayerStacks VR Dirty&quot;</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是将mGeometryInvalid置为true</span></span><br><span class="line">        <span class="comment">// 这个值影响后续是否需要hwc合成</span></span><br><span class="line">        <span class="built_in">invalidateHwcGeometry</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每一个Display做处理，适配多屏场景</span></span><br><span class="line">        <span class="comment">// mDisplays的类型是：std::map&lt;wp&lt;IBinder&gt;, sp&lt;DisplayDevice&gt;&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : mDisplays) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayDevice = pair.second;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            compositionengine::Output::OutputLayers layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            <span class="type">const</span> ui::Transform&amp; tr = displayState.transform;</span><br><span class="line">            <span class="type">const</span> Rect bounds = displayState.bounds;</span><br><span class="line">            <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">                <span class="comment">// 2.1 计算可视区域</span></span><br><span class="line">                <span class="built_in">computeVisibleRegions</span>(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 顺序遍历Z轴Layer</span></span><br><span class="line">                mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> compositionLayer = layer-&gt;<span class="built_in">getCompositionLayer</span>();</span><br><span class="line">                    <span class="keyword">if</span> (compositionLayer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> displayId = displayDevice-&gt;<span class="built_in">getId</span>();</span><br><span class="line">                    sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;<span class="built_in">getLayerFE</span>();</span><br><span class="line">                    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(layerFE.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">bool</span> needsOutputLayer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对属于给定图层堆栈上的layer, 将其可视区域与其所在Display相交</span></span><br><span class="line">                    <span class="comment">// 相交结果不为空，则说明其在或者其一部分在显示屏幕上</span></span><br><span class="line">                    <span class="comment">// needsOutputLayer标记为true</span></span><br><span class="line">                    <span class="keyword">if</span> (display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(),</span><br><span class="line">                                                 layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">                        Region <span class="built_in">drawRegion</span>(tr.<span class="built_in">transform</span>(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.<span class="built_in">andSelf</span>(bounds);</span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                            needsOutputLayer = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Layer有内容在屏幕上</span></span><br><span class="line">                    <span class="keyword">if</span> (needsOutputLayer) &#123;</span><br><span class="line">                        layersSortedByZ.<span class="built_in">emplace_back</span>(</span><br><span class="line">                                display-&gt;<span class="built_in">getOrCreateOutputLayer</span>(displayId, compositionLayer,</span><br><span class="line">                                                                layerFE));</span><br><span class="line">                        deprecated_layersSortedByZ.<span class="built_in">add</span>(layer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span>&amp; outputLayerState = layersSortedByZ.<span class="built_in">back</span>()-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                        outputLayerState.visibleRegion =</span><br><span class="line">                                tr.<span class="built_in">transform</span>(layer-&gt;visibleRegion.<span class="built_in">intersect</span>(displayState.viewport));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">                        <span class="comment">// 到这个分支里说明Layer之前有内容显示，但现在没有内容显示在屏幕上</span></span><br><span class="line">                        <span class="comment">// 此时我们需要清理该Layer对应的Fence，销毁HWC Layer</span></span><br><span class="line">                        <span class="type">bool</span> hasExistingOutputLayer =</span><br><span class="line">                                display-&gt;<span class="built_in">getOutputLayerForLayer</span>(compositionLayer.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// mLayersWithQueuedFrames 这个变量还记不，是在handlePageFlip方法中，顺序</span></span><br><span class="line">                        <span class="comment">// 遍历Z轴Layer时添加进入的。</span></span><br><span class="line">                        <span class="type">bool</span> hasQueuedFrames = std::<span class="built_in">find</span>(mLayersWithQueuedFrames.<span class="built_in">cbegin</span>(),</span><br><span class="line">                                                         mLayersWithQueuedFrames.<span class="built_in">cend</span>(),</span><br><span class="line">                                                         layer) != mLayersWithQueuedFrames.<span class="built_in">cend</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123;</span><br><span class="line">                            layersNeedingFences.<span class="built_in">add</span>(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据更新到Display中</span></span><br><span class="line">            display-&gt;<span class="built_in">setOutputLayersOrderedByZ</span>(std::<span class="built_in">move</span>(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">            displayDevice-&gt;<span class="built_in">setVisibleLayersSortedByZ</span>(deprecated_layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;<span class="built_in">setLayersNeedingFences</span>(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未定义的区域。也就是屏幕的大小减去屏幕的非透明区域opaqueRegion余下的部分。</span></span><br><span class="line">            Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">            undefinedRegion.<span class="built_in">subtractSelf</span>(tr.<span class="built_in">transform</span>(opaqueRegion));</span><br><span class="line"></span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().undefinedRegion = undefinedRegion;</span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">orSelf</span>(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，rebuildLayerStacks就是反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</p>
<h2 id="1-4-SurfaceFlinger-calculateWorkingSet"><a href="#1-4-SurfaceFlinger-calculateWorkingSet" class="headerlink" title="1.4 SurfaceFlinger::calculateWorkingSet"></a>1.4 SurfaceFlinger::calculateWorkingSet</h2><p>再看这个方法之前先瞄一眼各个Layer之前的关系：</p>
<p><img src="/.io//5_4_layer_list.png" alt="图片"></p>
<p>上图中标红的appId就是在此方法内的latchCompositionState方法中赋值的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::calculateWorkingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立HWC中的Layer列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mGeometryInvalid)) &#123;</span><br><span class="line">        mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 同样需要针对各个Display做处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> zOrder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;<span class="built_in">getOutputLayersOrderedByZ</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; compositionState = layer-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                compositionState.forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                    compositionState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Z轴顺序依次递增</span></span><br><span class="line">                compositionState.z = zOrder++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新与显示无关的合成状态，其实就是将Layer的状态信息放在CompositionState中了。</span></span><br><span class="line">                <span class="comment">// 也就是frontEnd（LayerFECompositionState）中</span></span><br><span class="line">                layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">latchCompositionState</span>(layer-&gt;<span class="built_in">getLayer</span>().<span class="built_in">editState</span>().frontEnd,</span><br><span class="line">                                                          <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新计算OutputLayer的几何状态</span></span><br><span class="line">                <span class="comment">// 比如根据显示屏全局矩阵调整该Layer的DisplayFrame、</span></span><br><span class="line">                <span class="comment">// 变换窗口裁剪以匹配缓冲区坐标系等等。</span></span><br><span class="line">                layer-&gt;<span class="built_in">updateCompositionState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将Layer更新完毕的几何状态写入HWC</span></span><br><span class="line">                layer-&gt;<span class="built_in">writeStateToHWC</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每帧的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="keyword">if</span> (!displayId) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDrawingState.colorMatrixChanged) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setColorTransform</span>(mDrawingState.colorMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        Dataspace targetDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (useColorManagement) &#123;</span><br><span class="line">            ColorMode colorMode;</span><br><span class="line">            RenderIntent renderIntent;</span><br><span class="line">            <span class="built_in">pickColorMode</span>(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent);</span><br><span class="line">            display-&gt;<span class="built_in">setColorMode</span>(colorMode, targetDataspace, renderIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">            layer-&gt;<span class="built_in">setPerFrameData</span>(displayDevice, displayState.transform, displayState.viewport,</span><br><span class="line">                                   displayDevice-&gt;<span class="built_in">getSupportedPerFrameMetadata</span>(),</span><br><span class="line">                                   <span class="built_in">isHdrColorMode</span>(displayState.colorMode) ? Dataspace::UNKNOWN</span><br><span class="line">                                                                          : targetDataspace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; layerState = layer-&gt;<span class="built_in">getCompositionLayer</span>()-&gt;<span class="built_in">editState</span>().frontEnd;</span><br><span class="line">            layerState.compositionType = <span class="built_in">static_cast</span>&lt;Hwc2::IComposerClient::Composition&gt;(</span><br><span class="line">                    layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里建立HWC中的Layer列表： </p>
<ol>
<li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li>
<li>将Layer的mActiveBuffer设置到HWComposer中</li>
</ol>
<h2 id="1-5-SurfaceFlinger-beginFrame"><a href="#1-5-SurfaceFlinger-beginFrame" class="headerlink" title="1.5 SurfaceFlinger::beginFrame"></a>1.5 SurfaceFlinger::beginFrame</h2><p>开始合成前的准备。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::beginFrame</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有待更新的区域</span></span><br><span class="line">    <span class="type">bool</span> dirty = !display-&gt;<span class="built_in">getDirtyRegion</span>(<span class="literal">false</span>).<span class="built_in">isEmpty</span>();</span><br><span class="line">    <span class="comment">// 可见Layer数量是否为0</span></span><br><span class="line">    <span class="type">bool</span> empty = displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>().<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上次合成是否有可见Layer</span></span><br><span class="line">    <span class="type">bool</span> wasEmpty = !displayState.lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有变化时或者有变化但此时没有可见Layer且上次合成时也没有就跳过</span></span><br><span class="line">    <span class="type">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> flagPrefix[] = &#123;<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(flagPrefix);</span><br><span class="line">    <span class="built_in">ALOGV_IF</span>(displayDevice-&gt;<span class="built_in">isVirtual</span>(), <span class="string">&quot;%s: %s composition for %s (%cdirty %cempty %cwasEmpty)&quot;</span>,</span><br><span class="line">             __FUNCTION__, mustRecompose ? <span class="string">&quot;doing&quot;</span> : <span class="string">&quot;skipping&quot;</span>,</span><br><span class="line">             displayDevice-&gt;<span class="built_in">getDebugName</span>().<span class="built_in">c_str</span>(), flagPrefix[dirty], flagPrefix[empty],</span><br><span class="line">             flagPrefix[wasEmpty]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里面其实没有做什么特殊的操作，我们看一下DisplayDevice相关的类</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">beginFrame</span>(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//5_5_DisplayDevice.png" alt="图片"></p>
<p>这个DiplayDevice是怎么初始化的呢，后续再看。</p>
<h2 id="1-6-SurfaceFlinger-doComposition"><a href="#1-6-SurfaceFlinger-doComposition" class="headerlink" title="1.6 SurfaceFlinger::doComposition"></a>1.6 SurfaceFlinger::doComposition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice, <span class="type">bool</span> repaintEverything)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="comment">// 将脏区转换为该屏幕的坐标空间</span></span><br><span class="line">        <span class="type">const</span> Region dirtyRegion = display-&gt;<span class="built_in">getDirtyRegion</span>(repaintEverything);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.6.1 请求buffer,做合成操作</span></span><br><span class="line">        <span class="built_in">doDisplayComposition</span>(displayDevice, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">        display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">flip</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fence同步相关处理，暂时忽略</span></span><br><span class="line">    <span class="built_in">postFramebuffer</span>(displayDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-1-SurfaceFlinger-doDisplayComposition"><a href="#1-6-1-SurfaceFlinger-doDisplayComposition" class="headerlink" title="1.6.1 SurfaceFlinger::doDisplayComposition"></a>1.6.1 SurfaceFlinger::doDisplayComposition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Region&amp; inDirtyRegion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅在以下情况下才需要实际构成显示：</span></span><br><span class="line">    <span class="comment">// 1）由HWC处理，它可能需要此操作以使其虚拟显示状态机保持同步</span></span><br><span class="line">    <span class="comment">// 2）有工作要做（脏区不为空）</span></span><br><span class="line">    <span class="keyword">if</span> (!displayDevice-&gt;<span class="built_in">getId</span>() &amp;&amp; inDirtyRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doDisplayComposition&quot;</span>);</span><br><span class="line">    base::unique_fd readyFence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.6.2 合成Surface</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">doComposeSurfaces</span>(displayDevice, Region::INVALID_REGION, &amp;readyFence)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲区，buffer已经被填充了合成所有Layer后的帧数据。</span></span><br><span class="line">    <span class="comment">// 将FrameBuffer发送给HWC, 也就是将内容渲染到硬件帧缓冲区中去</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">queueBuffer</span>(std::<span class="built_in">move</span>(readyFence));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2-SurfaceFlinger-doComposeSurfaces"><a href="#1-6-2-SurfaceFlinger-doComposeSurfaces" class="headerlink" title="1.6.2 SurfaceFlinger::doComposeSurfaces"></a>1.6.2 SurfaceFlinger::doComposeSurfaces</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> Region&amp; debugRegion, base::unique_fd* readyFence)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposeSurfaces&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; renderEngine = <span class="built_in">getRenderEngine</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> supportProtectedContent = renderEngine.<span class="built_in">supportsProtectedContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Region <span class="title">bounds</span><span class="params">(displayState.bounds)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> DisplayRenderArea <span class="title">renderArea</span><span class="params">(displayDevice)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> hasClientComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;hasClientComposition&quot;</span>, hasClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> applyColorMatrix = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    renderengine::DisplaySettings clientCompositionDisplay;</span><br><span class="line">    std::vector&lt;renderengine::LayerSettings&gt; clientCompositionLayers;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    base::unique_fd fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;hasClientComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求GraphicBuffer, 通过ANativeWindow向GPU申请</span></span><br><span class="line">        buf = display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">dequeueBuffer</span>(&amp;fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Dequeuing buffer for display [%s] failed, bailing out of &quot;</span></span><br><span class="line">                  <span class="string">&quot;client composition for this frame&quot;</span>,</span><br><span class="line">                  displayDevice-&gt;<span class="built_in">getDisplayName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将DisplayState相关信息赋值给clientCompositionDisplay，以供HWC使用</span></span><br><span class="line">        clientCompositionDisplay.physicalDisplay = displayState.scissor;</span><br><span class="line">        clientCompositionDisplay.clip = displayState.scissor;</span><br><span class="line">        <span class="type">const</span> ui::Transform&amp; displayTransform = displayState.transform;</span><br><span class="line">        clientCompositionDisplay.globalTransform = displayTransform.<span class="built_in">asMatrix4</span>();</span><br><span class="line">        clientCompositionDisplay.orientation = displayState.orientation;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line">        Dataspace outputDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (profile-&gt;<span class="built_in">hasWideColorGamut</span>()) &#123;</span><br><span class="line">            outputDataspace = displayState.dataspace;</span><br><span class="line">        &#125;</span><br><span class="line">        clientCompositionDisplay.outputDataspace = outputDataspace;</span><br><span class="line">        clientCompositionDisplay.maxLuminance =</span><br><span class="line">                profile-&gt;<span class="built_in">getHdrCapabilities</span>().<span class="built_in">getDesiredMaxLuminance</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> hasDeviceComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> skipClientColorTransform =</span><br><span class="line">                <span class="built_in">getHwComposer</span>()</span><br><span class="line">                        .<span class="built_in">hasDisplayCapability</span>(displayId,</span><br><span class="line">                                              HWC2::DisplayCapability::SkipClientColorTransform);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the global color transform matrix.</span></span><br><span class="line">        applyColorMatrix = !hasDeviceComposition &amp;&amp; !skipClientColorTransform;</span><br><span class="line">        <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">            clientCompositionDisplay.colorTransform = displayState.colorTransformMat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 现在渲染以帧缓冲区为目标的图层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Rendering client layers&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> firstLayer = <span class="literal">true</span>;</span><br><span class="line">    Region clearRegion = Region::INVALID_REGION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可见Layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">viewportRegion</span><span class="params">(displayState.viewport)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">clip</span><span class="params">(viewportRegion.intersect(layer-&gt;visibleRegion))</span></span>;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Layer: %s&quot;</span>, layer-&gt;<span class="built_in">getName</span>().<span class="built_in">string</span>());</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;  Composition type: %s&quot;</span>, <span class="built_in">toString</span>(layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (!clip.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CLIENT: &#123;</span><br><span class="line">                    renderengine::LayerSettings layerSettings;</span><br><span class="line">                    <span class="comment">// 根据相关配置设置Layer状态：渲染区域、alpha通道、颜色变换等等</span></span><br><span class="line">                    <span class="type">bool</span> prepared =</span><br><span class="line">                            layer-&gt;<span class="built_in">prepareClientLayer</span>(renderArea, clip, clearRegion,</span><br><span class="line">                                                      supportProtectedContent, layerSettings);</span><br><span class="line">                    <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                        <span class="comment">// 放入clientCompositionLayers中备用</span></span><br><span class="line">                        clientCompositionLayers.<span class="built_in">push_back</span>(layerSettings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;  Skipping for empty clip&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        firstLayer = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasClientComposition为true说明使用GPU合成</span></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        clientCompositionDisplay.clearRegion = clearRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里提高GPU频率，因为会进行色彩空间转换，比较耗时。 </span></span><br><span class="line">        <span class="comment">// 提高了GPU频率，以便GPU合成可以及时完成。</span></span><br><span class="line">        <span class="comment">// 之后必须重新设置GPU频率，因为高频率会消耗额外的电池。</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> expensiveRenderingExpected =</span><br><span class="line">                clientCompositionDisplay.outputDataspace == Dataspace::DISPLAY_P3;</span><br><span class="line">        <span class="keyword">if</span> (expensiveRenderingExpected &amp;&amp; displayId) &#123;</span><br><span class="line">            mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用渲染引擎（renderengine/gl/GLESRenderEngine.cpp）合成所有Layer</span></span><br><span class="line">        renderEngine.<span class="built_in">drawLayers</span>(clientCompositionDisplay, clientCompositionLayers,</span><br><span class="line">                                buf-&gt;<span class="built_in">getNativeBuffer</span>(), <span class="comment">/*useFramebufferCache=*/</span><span class="literal">true</span>, std::<span class="built_in">move</span>(fd),</span><br><span class="line">                                readyFence);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">        mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先请求GraphicBuffer，然后通过GLESRenderEngine合成所有Layer.</p>
<h1 id="二-计算Layer可视区域"><a href="#二-计算Layer可视区域" class="headerlink" title="二. 计算Layer可视区域"></a>二. 计算Layer可视区域</h1><p>一般来讲，我们手机App Layer如下：<br><img src="/.io//5_2_appZ.png" alt="图片"></p>
<p>计算可视区域的时候，从Z轴大的开始遍历计算。这样做的好处是，如果计算到某一层Layer时，完全不透明的可视化区域已经占满整个屏幕，那么这之下的Layer可视化区域就可以不用计算了。</p>
<p>在开始阅读代码之前，还是有必要理清楚：</p>
<ol>
<li>可见区域（Visible Region）</li>
<li>透明区域（Transparent Region）</li>
<li>半透明区域（Translucent Region）</li>
<li>完全不透明区域（Opaque Region）</li>
<li>被覆盖区域（Covered Region）</li>
</ol>
<p>如下图:</p>
<p><img src="/.io//5_3_visiableregion.png" alt="图片"></p>
<p>如果A1为W2中半透明区域，A2在W1中全透明，W2中不透明，A3为W1中完全不透明区域。<br>则对于Surface W2而言，可见区域为W2-A1-A3.</p>
<h2 id="2-1-SurfaceFlinger-computeVisibleRegions"><a href="#2-1-SurfaceFlinger-computeVisibleRegions" class="headerlink" title="2.1 SurfaceFlinger:computeVisibleRegions"></a>2.1 SurfaceFlinger:computeVisibleRegions</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;computeVisibleRegions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    outDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先找到“感兴趣的”Layer，也就是这个layer是属于SecureDisplay的</span></span><br><span class="line">    <span class="comment">// 暂时没有找到相关的说明，忽略好了</span></span><br><span class="line">    Layer* layerOfInterest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> bIgnoreLayer = <span class="literal">false</span>;</span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">isSecureDisplay</span>()) &#123;</span><br><span class="line">            bIgnoreLayer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (displayDevice-&gt;<span class="built_in">isPrimary</span>()) &#123;</span><br><span class="line">                layerOfInterest = layer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向遍历Z轴计算可视化区域</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 获取当前绘制中的Surface</span></span><br><span class="line">        <span class="type">const</span> Layer::State&amp; <span class="built_in">s</span>(layer-&gt;<span class="built_in">getDrawingState</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只考虑给定图层堆栈上的layer</span></span><br><span class="line">        <span class="keyword">if</span> (!display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略SecureDisplay中的layer</span></span><br><span class="line">        <span class="keyword">if</span> (bIgnoreLayer &amp;&amp; layerOfInterest != layer) &#123;</span><br><span class="line">            Region visibleNonTransRegion;</span><br><span class="line">            visibleNonTransRegion.<span class="built_in">set</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(visibleNonTransRegion);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全不透明的Surface区域</span></span><br><span class="line">        Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕上可见且不完全透明的Surface区域。 </span></span><br><span class="line">        <span class="comment">// 这实际上是该层的足迹减去其上方的不透明区域。</span></span><br><span class="line">        <span class="comment">// 半透明Surface覆盖的区域被认为是可见的。</span></span><br><span class="line">        Region visibleRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被其上方所有可见区域覆盖的Surface区域（包括半透明区域）。</span></span><br><span class="line">        Region coveredRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暗示完全透明的表面区域。 这仅用于告诉图层何时没有可见的非透明区域，可以将其从图层列表中删除。 </span></span><br><span class="line">        <span class="comment">// 它不会影响此层或它下面的任何层的visibleRegion。 </span></span><br><span class="line">        <span class="comment">// 如果应用程序不遵守SurfaceView限制（不幸的是，有些不遵守），则提示可能不正确。</span></span><br><span class="line">        Region transparentRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理不可见或者被隐藏的Surface的方式就是将其可视化的区域设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_LIKELY</span>(layer-&gt;<span class="built_in">isVisible</span>())) &#123;</span><br><span class="line">            <span class="comment">// 如果该Surface不是完全不透明的，则视为半透明</span></span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> translucent = !layer-&gt;<span class="built_in">isOpaque</span>(s);</span><br><span class="line">            Rect <span class="built_in">bounds</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前Surface的可视区域默认为屏幕大小或者Surface在屏幕中的大小</span></span><br><span class="line">            visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            ui::Transform tr = layer-&gt;<span class="built_in">getTransform</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Region为空则说明没有可视区域</span></span><br><span class="line">            <span class="comment">// 注意 Region 是一个矩形（Rect）集合</span></span><br><span class="line">            <span class="keyword">if</span> (!visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="comment">// 首先从可见区域移除透明区域</span></span><br><span class="line">                <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">                    <span class="comment">// 函数preserveRects的返回值为false</span></span><br><span class="line">                    <span class="comment">// 说明需要忽略掉当前正在处理的应用程序窗口的透明区域</span></span><br><span class="line">                    <span class="keyword">if</span> (tr.<span class="built_in">preserveRects</span>()) &#123;</span><br><span class="line">                        <span class="comment">// 标记透明区域，这个透明区域就是transparentRegionHint遍历</span></span><br><span class="line">                        <span class="comment">// 在 SurfaceFlinger.setClientStateLocked过程中设置的</span></span><br><span class="line">                        transparentRegion = tr.<span class="built_in">transform</span>(layer-&gt;<span class="built_in">getActiveTransparentRegion</span>(s));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 转换太复杂，无法进行透明区域优化。</span></span><br><span class="line">                        transparentRegion.<span class="built_in">clear</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算不透明区域</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> layerOrientation = tr.<span class="built_in">getOrientation</span>();</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;<span class="built_in">getAlpha</span>() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                        layer-&gt;<span class="built_in">getRoundedCornerState</span>().radius == <span class="number">0.0f</span> &amp;&amp;</span><br><span class="line">                        ((layerOrientation &amp; ui::Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时</span></span><br><span class="line">                    <span class="comment">// 那么它的完全不透明区域opaqueRegion就等于计算所得到的可见区域visibleRegion</span></span><br><span class="line">                    opaqueRegion = visibleRegion;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Surface没有可视区域，则清空相关变量，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">clearVisibilityRegions</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将覆盖区域裁剪到可见区域</span></span><br><span class="line">        <span class="comment">// aboveCoveredLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的可见区域</span></span><br><span class="line">        <span class="comment">// 将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相交，就可以得到当前正在处理的应用程序窗口的被覆盖区域coveredRegion</span></span><br><span class="line">        <span class="comment">// 而将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相或一下，就可以得到下一个应用程序窗口的所有上层应用程序窗口所组成的可见区域aboveCoveredLayers。</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.<span class="built_in">intersect</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aboveOpaqueLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的完全不透明区域</span></span><br><span class="line">        aboveCoveredLayers.<span class="built_in">orSelf</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个区域从当前正在处理的应用程序窗口的可见区域visibleRegion减去后，就可以得到当前正在处理的应用程序窗口的最终可见区域visibleRegion。</span></span><br><span class="line">        visibleRegion.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算Layer的脏区域，所谓脏区域就是需要重新执行渲染操作的</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">            <span class="comment">// 成员变量contentDirty的值为true，则说明当前正在处理的Layer上一次的状态还未来得及处理</span></span><br><span class="line">            <span class="comment">// 即它当前的内容是脏的。在这个状况下，只需要将此次的可见区域与上一次的可见区域合并即可</span></span><br><span class="line">            dirty = visibleRegion;</span><br><span class="line">            <span class="comment">// as well, as the old visible region</span></span><br><span class="line">            dirty.<span class="built_in">orSelf</span>(layer-&gt;visibleRegion);</span><br><span class="line">            layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当上一次状态已经处理了，也就是显示内容没有更新,则无需重新渲染所有区域。</span></span><br><span class="line">            <span class="comment">// 现在只需要处理一下两种情况：</span></span><br><span class="line">            <span class="comment">// 1. 之前是被覆盖的区域，但现在不被覆盖了</span></span><br><span class="line">            <span class="comment">// 2. 由于窗口大小变化而引发的新增不被覆盖区域</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第一种情况:</span></span><br><span class="line">            <span class="comment">// 将当前可见区域visibleRegion与它的上一次被覆盖区域oldCoveredRegion相交</span></span><br><span class="line">            <span class="comment">// 就可以得到之前是被覆盖的而现在不被覆盖了的区域，即可以得到第一部分需要重新渲染的区域</span></span><br><span class="line">            <span class="comment">// 上一次可见区域和被覆盖区域分别oldVisibleRegion, oldCoveredRegion</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第二种情况:</span></span><br><span class="line">            <span class="comment">// 由于将一个应用程序窗口的当前可见区域减去被覆盖区域即为它的当前不被覆盖的区域newExposed</span></span><br><span class="line">            <span class="comment">// 同理上一次不被覆盖的区域oldExposed就是上一次可见区域减去上一次被覆盖区域</span></span><br><span class="line">            <span class="comment">// 那么将一个应用程序窗口的当前不被覆盖的区域newExposed减去它的上一次不被覆盖的区域oldExposed，就可以得到新增的不被覆盖区域</span></span><br><span class="line">            <span class="type">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">            <span class="type">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将第一部分和第二部分需要重新渲染的区域组合起来，就可以得到当前Layer的脏区域dirty。</span></span><br><span class="line">            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从该脏区域dirty减去上层的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 因为后者的渲染不需要当前Layer参与</span></span><br><span class="line">        dirty.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新的脏区域dirty累计到输出参数dirtyRegion中.</span></span><br><span class="line">        outDirtyRegion.<span class="built_in">orSelf</span>(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新计算到目前为止所得到的Layer的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 这个是方便下一层Layer的计算</span></span><br><span class="line">        aboveOpaqueLayers.<span class="built_in">orSelf</span>(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前正在处理的Layer的可见区域和被覆盖区域以及可见非透明区域.</span></span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleRegion</span>(visibleRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setCoveredRegion</span>(coveredRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(</span><br><span class="line">                visibleRegion.<span class="built_in">subtract</span>(transparentRegion));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前面所有的Layer组成的完全不透明区域aboveOpaqueLayers保存在输出参数opaqueRegion中</span></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>handleMessageRefresh – SF合成所有Layer大概步骤如下：</p>
<ol>
<li>preComposition<br>合成前遍历所有layer, 处理处于Drawing状态的Layer是否被更新了</li>
<li>rebuildLayerStacks<br>反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</li>
<li>calculateWorkingSet<br>这里建立HWC中的Layer列表： </li>
<li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li>
<li>将Layer的mActiveBuffer设置到HWComposer中</li>
<li>doComposition<br>正式的合成处理，使用渲染引擎合成所有layer，然后就是申请GraphicBuffer，向其中填充帧数据, 最终给到硬件帧缓冲区</li>
<li>postComposition &amp;&amp; clear mLayersWithQueuedFrames<br>回调每个layer的onPostComposition并清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</li>
</ol>
<p>大概流程搞清楚了，接下来细细分析比如GraphicBuffer和Fence机制的工作原理, 等等，HWC好像还没有了解，先看看这个是怎么工作的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[Android Synchronization Fences – An Introduction]<a target="_blank" rel="noopener" href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li>
<li>[Android 4.0.3 显示系统深入理解]<a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li>
<li>[Clang 10 documentation ATTRIBUTES IN CLANG]<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/AttributeReference.html">https://clang.llvm.org/docs/AttributeReference.html</a></li>
<li>[「Android」SurfaceFlinger分析]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/1996swg/p/9790209.html">https://www.cnblogs.com/1996swg/p/9790209.html</a></li>
<li>[显示系统：第005课_Vsync机制:第007节_rebuildLayerStacks源码分析]<a target="_blank" rel="noopener" href="http://www.pianshen.com/article/8541345041/">http://www.pianshen.com/article/8541345041/</a></li>
<li>[Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析]<a target="_blank" rel="noopener" href="https://blog.csdn.net/luoshengyang/article/details/8079456">https://blog.csdn.net/luoshengyang/article/details/8079456</a></li>
<li>[Android Region代码分析]<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t">https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-4-Layer-Surface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/SurfaceFlinger-4-Layer-Surface/" class="post-title-link" itemprop="url">SurfaceFlinger(4)--Layer&Surface</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-04 09:57:56 / 修改时间：10:13:02" itemprop="dateCreated datePublished" datetime="2022-04-04T09:57:56+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/SurfaceFlinger/" itemprop="url" rel="index"><span itemprop="name">SurfaceFlinger</span></a>
                </span>
            </span>

          
            <span id="/2022/04/04/SurfaceFlinger-4-Layer-Surface/" class="post-meta-item leancloud_visitors" data-flag-title="SurfaceFlinger(4)--Layer&Surface" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/04/SurfaceFlinger-4-Layer-Surface/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/04/SurfaceFlinger-4-Layer-Surface/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div style="page-break-after: always;"></div>

<p><strong>Android Q</strong></p>
<p>前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。<br>接下来我们先看看SurfaceFlinger合成帧的部分。</p>
<h1 id="一-SF-EventThread接收vsync的准备"><a href="#一-SF-EventThread接收vsync的准备" class="headerlink" title="一. SF EventThread接收vsync的准备"></a>一. SF EventThread接收vsync的准备</h1><p>在SFEventThread一文中已经探明，当产生Vsync信号后，会通过BitTube发送事件(EventThreadConnection.postEvent):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::postEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event&amp; event)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就需要知道 mChannel 是被谁监听了。</p>
<h2 id="1-1-SurfaceFlinger-init"><a href="#1-1-SurfaceFlinger-init" class="headerlink" title="1.1 SurfaceFlinger.init"></a>1.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.1.1 创建SfEventThread以及EventThreadConnection</span></span><br><span class="line">    mSfConnectionHandle = mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;sf&quot;</span>, mPhaseOffsets-&gt;<span class="built_in">getCurrentSfOffset</span>(),</span><br><span class="line">                                                    resyncCallback, [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                        mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 赋值 BitTube, 用来通信</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventConnection</span>(mScheduler-&gt;<span class="built_in">getEventConnection</span>(mSfConnectionHandle));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mEventQueue是在SurfaceFlinger.onFirstRef中初始化的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onFirstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    mEventQueue-&gt;<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::init</span><span class="params">(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">true</span>);</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="built_in">Handler</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Looper就是SurfaceFlinger主线程的Looper.</p>
<h3 id="1-1-1-Scheduler-createConnection"><a href="#1-1-1-Scheduler-createConnection" class="headerlink" title="1.1.1 Scheduler.createConnection"></a>1.1.1 Scheduler.createConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;Scheduler::ConnectionHandle&gt; <span class="title">Scheduler::createConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* connectionName, <span class="type">int64_t</span> phaseOffsetNs, ResyncCallback resyncCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">        impl::EventThread::InterceptVSyncsCallback interceptCallback)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> id = sNextId++;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating a connection handle with ID: %&quot;</span> PRId64 <span class="string">&quot;\n&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 sfEventThread</span></span><br><span class="line">    std::unique_ptr&lt;EventThread&gt; eventThread =</span><br><span class="line">            <span class="built_in">makeEventThread</span>(connectionName, mPrimaryDispSync.<span class="built_in">get</span>(), phaseOffsetNs,</span><br><span class="line">                            std::<span class="built_in">move</span>(interceptCallback));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventThreadConnection</span></span><br><span class="line">    <span class="keyword">auto</span> eventThreadConnection =</span><br><span class="line">            <span class="built_in">createConnectionInternal</span>(eventThread.<span class="built_in">get</span>(), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">    <span class="comment">// 保存创建的connection</span></span><br><span class="line">    mConnections.<span class="built_in">emplace</span>(id,</span><br><span class="line">                         std::<span class="built_in">make_unique</span>&lt;Connection&gt;(<span class="keyword">new</span> <span class="built_in">ConnectionHandle</span>(id),</span><br><span class="line">                                                      eventThreadConnection,</span><br><span class="line">                                                      std::<span class="built_in">move</span>(eventThread)));</span><br><span class="line">    <span class="keyword">return</span> mConnections[id]-&gt;handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-EventThread-createEventConnection"><a href="#1-1-2-EventThread-createEventConnection" class="headerlink" title="1.1.2 EventThread.createEventConnection"></a>1.1.2 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建了 BitTube, 此时是在SurfaceFlinger主线程</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-MessageQueue-setEventConnection"><a href="#1-2-MessageQueue-setEventConnection" class="headerlink" title="1.2 MessageQueue.setEventConnection"></a>1.2 MessageQueue.setEventConnection</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEvents = connection;</span><br><span class="line">    <span class="comment">// 1.2.1 通过BitTube建立与SFEventThread的通信通道</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 有vsync事件会回调cb_eventReceiver事件</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mLooper就是SurfaceFlinger主线程的Looper.</p>
<h3 id="1-2-1-EventThreadConnection-stealReceiveChannel"><a href="#1-2-1-EventThreadConnection-stealReceiveChannel" class="headerlink" title="1.2.1 EventThreadConnection.stealReceiveChannel"></a>1.2.1 EventThreadConnection.stealReceiveChannel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mChannel就是[1.1.2]中新建的BitTube</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-SF-EventThread接收vsync"><a href="#二-SF-EventThread接收vsync" class="headerlink" title="二. SF EventThread接收vsync"></a>二. SF EventThread接收vsync</h1><p>上面我们知道了，当SFEventThread发出Vsync信号时，会通过BitTube发送该消息至SurfaceFlinger主线程，并调用MessageQueue.cb_eventReceiver方法处理。</p>
<h2 id="2-1-MessageQueue-cb-eventReceiver"><a href="#2-1-MessageQueue-cb-eventReceiver" class="headerlink" title="2.1 MessageQueue.cb_eventReceiver"></a>2.1 MessageQueue.cb_eventReceiver</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 读取消息内容</span></span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 只关心VSYNC消息</span></span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="comment">// 2.2 触发composition</span></span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-MessageQueue-Handler-dispatchInvalidate"><a href="#2-2-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="2.2 MessageQueue.Handler.dispatchInvalidate"></a>2.2 MessageQueue.Handler.dispatchInvalidate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里通过Looper发送INVALIDATE消息</span></span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            <span class="comment">// 处理INVALIDATE消息</span></span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-SurfaceFlinger-onMessageReceived"><a href="#2-3-SurfaceFlinger-onMessageReceived" class="headerlink" title="2.3 SurfaceFlinger.onMessageReceived"></a>2.3 SurfaceFlinger.onMessageReceived</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="type">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            <span class="comment">// 通过fence机制来判断是否掉帧 </span></span><br><span class="line">            <span class="type">bool</span> frameMissed = <span class="built_in">previousFrameMissed</span>();</span><br><span class="line">            <span class="type">bool</span> hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="type">bool</span> gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;FrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;HwcFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(hwcFrameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;GpuFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(gpuFrameMissed));</span><br><span class="line">            <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line">                mFrameMissedCount++;</span><br><span class="line">                mTimeStats-&gt;<span class="built_in">incrementMissedFrames</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hwcFrameMissed) &#123;</span><br><span class="line">                mHwcFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gpuFrameMissed) &#123;</span><br><span class="line">                mGpuFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行相关参数更新，比如Vsync切换</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">performSetActiveConfig</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果丢帧，则不处理此次VSYNC</span></span><br><span class="line">            <span class="keyword">if</span> (frameMissed &amp;&amp; mPropagateBackpressure) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) ||</span><br><span class="line">                    mPropagateBackpressureClientComposition) &#123;</span><br><span class="line">                    <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">// transaction主要针对Layer和Display的变化更新脏区域</span></span><br><span class="line">            <span class="comment">// 通过Layer的变化来计算脏区域，目的是需要更新我才刷新</span></span><br><span class="line">            <span class="type">bool</span> refreshNeeded = <span class="built_in">handleMessageTransaction</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 主要是调用handlePageFlip()函数，该函数在systrace图上对应latchBuffer及其所包含的方法。</span></span><br><span class="line">            <span class="comment">// 作用是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域</span></span><br><span class="line">            <span class="comment">// 并且把GraphicBuffer映射为OpenGL的texture</span></span><br><span class="line">            refreshNeeded |= <span class="built_in">handleMessageInvalidate</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">updateCursorAsync</span>();</span><br><span class="line">            <span class="built_in">updateInputFlinger</span>();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">// 发送刷新合成请求</span></span><br><span class="line">                <span class="built_in">signalRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDolphinFuncsEnabled) &#123;</span><br><span class="line">                <span class="built_in">mDolphinRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.6 SF 处理合成</span></span><br><span class="line">            <span class="built_in">handleMessageRefresh</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先忽略Fence机制，先看看大致流程。</p>
<h2 id="2-4-SurfaceFlinger-handleMessageInvalidate"><a href="#2-4-SurfaceFlinger-handleMessageInvalidate" class="headerlink" title="2.4 SurfaceFlinger.handleMessageInvalidate"></a>2.4 SurfaceFlinger.handleMessageInvalidate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="type">bool</span> refreshNeeded = <span class="built_in">handlePageFlip</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty) &#123;</span><br><span class="line">        <span class="built_in">computeLayerBounds</span>();</span><br><span class="line">        <span class="keyword">if</span> (mTracingEnabled) &#123;</span><br><span class="line">            mTracing.<span class="built_in">notify</span>(<span class="string">&quot;visibleRegionsDirty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh) &#123;</span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">        <span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRefresh.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-SurfaceFlinger-handlePageFlip"><a href="#2-5-SurfaceFlinger-handlePageFlip" class="headerlink" title="2.5 SurfaceFlinger.handlePageFlip"></a>2.5 SurfaceFlinger.handlePageFlip</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;handlePageFlip&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> latchTime = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储需要更新的图层集。 当缓冲区被锁存时，不得更改，因为可能导致死锁。</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">            frameQueued = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">nsecs_t</span> expectedPresentTime;</span><br><span class="line">            expectedPresentTime = mScheduler-&gt;<span class="built_in">expectedPresentTime</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">shouldPresentNow</span>(expectedPresentTime)) &#123;</span><br><span class="line">                <span class="comment">// mLayersWithQueuedFrames用于标记那些已经有Frame的Layer</span></span><br><span class="line">                mLayersWithQueuedFrames.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;!layer-&gt;shouldPresentNow()&quot;</span>);</span><br><span class="line">                layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mLayersWithQueuedFrames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// mStateLock is needed for latchBuffer as LayerRejecter::reject()</span></span><br><span class="line">        <span class="comment">// writes to Layer current state. See also b/119481871</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime)) &#123;</span><br><span class="line">                mLayersPendingRefresh.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;<span class="built_in">useSurfaceDamage</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">isBufferLatched</span>()) &#123;</span><br><span class="line">                newDataLatched = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line">    <span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line">    <span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line">    <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.<span class="built_in">empty</span>() || !newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enter boot animation on first buffer latch</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Enter boot animation&quot;</span>);</span><br><span class="line">        mBootStage = BootStage::BOOTANIMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line">    <span class="keyword">return</span> !mLayersWithQueuedFrames.<span class="built_in">empty</span>() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-SurfaceFlinger-handleMessageRefresh"><a href="#2-6-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="2.6 SurfaceFlinger.handleMessageRefresh"></a>2.6 SurfaceFlinger.handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建layer堆栈, 提取可见的Laye并计算可见区域，为合成准备好数据材料。</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hwcomposer的设定</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); <span class="comment">//正式的合成处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line">    <span class="comment">// 将图像传递到物理屏幕。但是在下一个vsync信号才被消费。</span></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再继续分析之前，我们需要先了解Layer的结构，以及他是如何被添加至SurfaceFlinger中的。</p>
<h1 id="三-Layer的产生"><a href="#三-Layer的产生" class="headerlink" title="三. Layer的产生"></a>三. Layer的产生</h1><p>Layer, 即图层。Layer是图像合成中最重要的单元。图层是Surface和SurfaceControl的组合。<br>说到底也就是每个Window都有对应Surface，也就对应一个Layer;SurfaceFlinger的合成就是将所有图层按照顺序和特定属性合成一帧画面。<br>每个图层都有一组属性，用于定义它与其他图层的交互方式。 </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Positional</td>
<td>定义图层在其显示屏上显示的位置。 包括诸如图层边缘的位置及其相对于其他图层的Z顺序的信息</td>
</tr>
<tr>
<td>Content</td>
<td>定义图层上显示的内容应如何在位置属性定义的边界内显示。 包括裁剪和变换等信息</td>
</tr>
<tr>
<td>Composition</td>
<td>定义图层应如何与其他图层合成。 包括混合模式和alpha合成的图层范围Alpha值等信息</td>
</tr>
<tr>
<td>Optimization</td>
<td>提供正确合成图层非必要的信息，但硬件编写器（HWC）设备可以使用该信息来优化其执行合成的方式。 包括诸如图层的可见区域以及自上一帧以来图层的哪个部分已更新的信息。</td>
</tr>
</tbody></table>
<p>在创建Window或者Window产生变化时就会更新对应的Surface所属的Layer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">    WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">    WindowManagerService.createSurfaceControl(...) --[SystemServer进程]</span><br><span class="line">    WindowStateAnimator.createSurfaceLocked(...) --[SystemServer进程] 这里传入Surface的FLAG</span><br><span class="line">    WindowSurfaceController.new() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface(WindowContainer) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Builder.build() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.new() --[SystemServer进程]</span><br><span class="line">        android_view_SurfaceControl:nativeCreate() --[JNI][SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:getDefault() --[SystemServer进程]</span><br><span class="line">            DefaultComposerClient:getComposerClient() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:onFirstRef() --[SystemServer进程]通过Binder从SF获取SurfaceComposerClient</span><br><span class="line">                SurfaceFlinger:createConnection() --[SurfaceFlinger进程] 创建SurfaceComposerClient</span><br><span class="line">        SurfaceComposerClient:createSurfaceChecked(...) --[SystemServer进程]Binder调用</span><br><span class="line">        Client:createSurface(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlinger:createLayer(...) --[SurfaceFlinger进程] 这里假设创建一个默认Surface</span><br><span class="line">            SurfaceFlinger:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlingerFactory:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            BufferQueueLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">                BufferLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">        SurfaceControl:<span class="keyword">new</span>(...) --[SystemServer进程]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//4_1.png" alt="图片"></p>
<p>Surface FLAG一览</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HIDDEN</td>
<td>0x00000004</td>
<td>Surface是隐藏的</td>
</tr>
<tr>
<td>SECURE</td>
<td>0x00000080</td>
<td>包含安全内容，禁止内容被其他进程复制。而且屏幕截图和VNC服务器将被禁用，但可能不会采用硬件加速。Window带有FLAG_SECURE标签，或者该应用禁止截图就会带有这个FLAG</td>
</tr>
<tr>
<td>NON_PREMULTIPLIED</td>
<td>0x00000100</td>
<td>预乘透明度，创建一个Surface，其中颜色分量被Alpha通道解释为“非预乘”。对于没有alpha通道的Surface，这个标志是没有意义的。 默认情况下，Surface是预乘的，这意味着每个颜色分量已经乘以其alpha值。</td>
</tr>
<tr>
<td>OPAQUE</td>
<td>0x00000400</td>
<td>表示Surface必须为不透明，即使其像素格式包含Alpha通道。</td>
</tr>
<tr>
<td>PROTECTED_APP</td>
<td>0x00000800</td>
<td>应用程序需要通过外部显示接收器的硬件保护路径。 如果硬件保护路径不可用，则此表面将不会显示在外部接收器上。</td>
</tr>
<tr>
<td>CURSOR_WINDOW</td>
<td>0x00002000</td>
<td>窗口表示光标字形。</td>
</tr>
<tr>
<td>FX_SURFACE_NORMAL</td>
<td>0x00000000</td>
<td>创建一个默认Surface</td>
</tr>
<tr>
<td>FX_SURFACE_DIM</td>
<td>0x00020000</td>
<td>创建一个暗淡的Surface。 此Surface后面的所有内容都会被{@link #setAlpha}中指定的数量调暗。 锁定Dim Surface是错误的，因为它没有后备存储。</td>
</tr>
<tr>
<td>FX_SURFACE_CONTAINER</td>
<td>创建容器Surface。 此Surface将没有缓冲区，仅用作其他Surface或其InputInfo的容器。</td>
<td></td>
</tr>
<tr>
<td>SURFACE_HIDDEN</td>
<td>0x01</td>
<td>隐藏该Surface, 等同于调用Surface.hide()</td>
</tr>
<tr>
<td>SURFACE_OPAQUE</td>
<td>0x02</td>
<td>尽可能不混合的复合材料。 更新Surface创建期间设置的值（请参阅{@link #OPAQUE}）。</td>
</tr>
</tbody></table>
<h2 id="3-1-SurfaceFlinger-createLayer"><a href="#3-1-SurfaceFlinger-createLayer" class="headerlink" title="3.1 SurfaceFlinger:createLayer"></a>3.1 SurfaceFlinger:createLayer</h2><p>当上次Window变化时，或者会创建Layer，并保存在SurfaceFlinger中.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 假设创建默认的Surface</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">            result = <span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                            format, handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 检查是否有访问SurfaceFlinger的权限</span></span><br><span class="line">    <span class="type">bool</span> addToCurrentState = <span class="built_in">callingThreadHasUnscopedSurfaceFlingerAccess</span>();</span><br><span class="line">    <span class="comment">// 3.2 保存新建的Layer</span></span><br><span class="line">    result = <span class="built_in">addClientLayer</span>(client, *handle, *gbp, layer, parentHandle, parentLayer,</span><br><span class="line">                            addToCurrentState);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-SurfaceFlinger-createBufferQueueLayer"><a href="#3-1-1-SurfaceFlinger-createBufferQueueLayer" class="headerlink" title="3.1.1 SurfaceFlinger.createBufferQueueLayer"></a>3.1.1 SurfaceFlinger.createBufferQueueLayer</h3><p>中间细琐流程略过，最终是创建了一个Layer对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Layer::<span class="built_in">Layer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">      : <span class="built_in">mFlinger</span>(args.flinger),</span><br><span class="line">        <span class="built_in">mName</span>(args.name),</span><br><span class="line">        <span class="built_in">mClientRef</span>(args.client),</span><br><span class="line">        <span class="built_in">mWindowType</span>(args.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>)) &#123;</span><br><span class="line">    mCurrentCrop.<span class="built_in">makeInvalid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> layerFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eHidden) layerFlags |= <span class="type">layer_state_t</span>::eLayerHidden;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eOpaque) layerFlags |= <span class="type">layer_state_t</span>::eLayerOpaque;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eSecure) layerFlags |= <span class="type">layer_state_t</span>::eLayerSecure;</span><br><span class="line"></span><br><span class="line">    mTransactionName = <span class="built_in">String8</span>(<span class="string">&quot;TX - &quot;</span>) + mName;</span><br><span class="line"></span><br><span class="line">    mCurrentState.active_legacy.w = args.w;</span><br><span class="line">    mCurrentState.active_legacy.h = args.h;</span><br><span class="line">    mCurrentState.flags = layerFlags;</span><br><span class="line">    mCurrentState.active_legacy.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.crop_legacy.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.requestedCrop_legacy = mCurrentState.crop_legacy;</span><br><span class="line">    mCurrentState.z = <span class="number">0</span>; <span class="comment">// 这里就是layer在Z轴的位置</span></span><br><span class="line">    mCurrentState.color.a = <span class="number">1.0f</span>;</span><br><span class="line">    mCurrentState.layerStack = <span class="number">0</span>; <span class="comment">// layer所在layerStack</span></span><br><span class="line">    mCurrentState.sequence = <span class="number">0</span>; <span class="comment">// layer序号</span></span><br><span class="line">    mCurrentState.requested_legacy = mCurrentState.active_legacy;</span><br><span class="line">    mCurrentState.active.w = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.h = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.transform = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.transformToDisplayInverse = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.crop.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.acquireFence = <span class="keyword">new</span> <span class="built_in">Fence</span>(<span class="number">-1</span>);</span><br><span class="line">    mCurrentState.dataspace = ui::Dataspace::UNKNOWN;</span><br><span class="line">    mCurrentState.hdrMetadata.validTypes = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.surfaceDamageRegion.<span class="built_in">clear</span>();</span><br><span class="line">    mCurrentState.cornerRadius = <span class="number">0.0f</span>;</span><br><span class="line">    mCurrentState.api = <span class="number">-1</span>;</span><br><span class="line">    mCurrentState.hasColorTransform = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.colorSpaceAgnostic = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.metadata = args.metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drawing state &amp; current state are identical</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    CompositorTiming compositorTiming;</span><br><span class="line">    args.flinger-&gt;<span class="built_in">getCompositorTiming</span>(&amp;compositorTiming);</span><br><span class="line">    mFrameEventHistory.<span class="built_in">initializeCompositorTiming</span>(compositorTiming);</span><br><span class="line">    mFrameTracker.<span class="built_in">setDisplayRefreshPeriod</span>(compositorTiming.interval);</span><br><span class="line"></span><br><span class="line">    mSchedulerLayerHandle = mFlinger-&gt;mScheduler-&gt;<span class="built_in">registerLayer</span>(mName.<span class="built_in">c_str</span>(), mWindowType);</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;<span class="built_in">onLayerCreated</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注的是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>z-order，表示x,y,z轴的z轴上的顺序。数字越大，表示越在上面，数字越小，表示越在下面。</td>
</tr>
<tr>
<td>layerStack</td>
<td>layerStack是存储layer的容器,我们知道每个display只会有一个layerstack来存储他要显示的layer,但是不同的display可以使用同一个layerStack,也可以使用不同的layerStack。可以理解为组的含义。也就是说属于不同组的layer之间互不干扰。SurfaceFlinger中有一个DisplayDevice类，他表示用来显示的设备，譬如LCD或者是HDMI。DisplayDevice里也有一个成员变量mLayerStack，在进行composition的时候，只有和这个device的layerstack相同的layer才可能被显示在这个设备上。</td>
</tr>
<tr>
<td>sequence</td>
<td>sSequence是一个static的变量，所以递加的效果就是为每一个layer设置一个唯一且递增的序列号。</td>
</tr>
</tbody></table>
<h2 id="3-2-SurfaceFlinger-addClientLayer"><a href="#3-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2 SurfaceFlinger.addClientLayer"></a>3.2 SurfaceFlinger.addClientLayer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">const</span> sp&lt;IBinder&gt;&amp; handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc, <span class="type">const</span> sp&lt;Layer&gt;&amp; lbc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer, <span class="type">bool</span> addToCurrentState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// add this layer to the current state list</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mStateLock);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToCurrentState) &#123;</span><br><span class="line">            <span class="comment">// 3.2.1 将新创建的Layer按照Z轴顺序存储至队列中</span></span><br><span class="line">            mCurrentState.layersSortedByZ.<span class="built_in">add</span>(lbc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gbc != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            mGraphicBufferProducerList.<span class="built_in">insert</span>(IInterface::<span class="built_in">asBinder</span>(gbc).<span class="built_in">get</span>());</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mGraphicBufferProducerList.<span class="built_in">size</span>() &gt;</span><br><span class="line">                                        mMaxGraphicBufferProducerListSize,</span><br><span class="line">                                <span class="string">&quot;Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers&quot;</span>,</span><br><span class="line">                                mGraphicBufferProducerList.<span class="built_in">size</span>(),</span><br><span class="line">                                mMaxGraphicBufferProducerListSize, mNumLayers);</span><br><span class="line">        &#125;</span><br><span class="line">        mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.2 将该Layer保存至mClient的mLayers中,键为IBinder,供后续使用</span></span><br><span class="line">    client-&gt;<span class="built_in">attachLayer</span>(handle, lbc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞清楚Layer的Z轴顺序，对与我们理解Layer合成过程有很大帮助。<br>Layer排序建议参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></p>
<h3 id="3-2-1-LayerVector-add"><a href="#3-2-1-LayerVector-add" class="headerlink" title="3.2.1 LayerVector.add"></a>3.2.1 LayerVector.add</h3><p>将新创建的Layer按照Z轴顺序存储至队列中.<br>LayerVector继承了SortedVector,并且重载了函数 do_compare.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LayerVector::do_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* lhs, <span class="type">const</span> <span class="type">void</span>* rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先对LayerStack排序，然后是Z轴排序，最后是序号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; l = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(lhs);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; r = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(rhs);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; lState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? l-&gt;<span class="built_in">getCurrentState</span>() : l-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; rState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? r-&gt;<span class="built_in">getCurrentState</span>() : r-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> ls = lState.layerStack;</span><br><span class="line">    <span class="type">uint32_t</span> rs = rState.layerStack;</span><br><span class="line">    <span class="keyword">if</span> (ls != rs)</span><br><span class="line">        <span class="keyword">return</span> (ls &gt; rs) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> lz = lState.z;</span><br><span class="line">    <span class="type">int32_t</span> rz = rState.z;</span><br><span class="line">    <span class="keyword">if</span> (lz != rz)</span><br><span class="line">        <span class="keyword">return</span> (lz &gt; rz) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;sequence == r-&gt;sequence)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (l-&gt;sequence &gt; r-&gt;sequence) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先比较layerstack，不同的layerstack分开。然后再比较z，假设都相同，就比较唯一的layer序列号。<br>但是至今为止，layerStack和z都还只是初始化时的0，所以在创建layer的时候，只是把他根据序列号放进layersSortedByZ而已，其实他的顺序还是没有设置的。</p>
<h3 id="3-2-2-SurfaceFlinger-addClientLayer"><a href="#3-2-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2.2 SurfaceFlinger:addClientLayer"></a>3.2.2 SurfaceFlinger:addClientLayer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Client::attachLayer</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLayers.<span class="built_in">add</span>(handle, layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-Layer更新流程"><a href="#3-4-Layer更新流程" class="headerlink" title="3.4 Layer更新流程"></a>3.4 Layer更新流程</h2><p>当java层调用setLayer时就会确定对应Layer的Z-Order顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App进程]</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacement(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacementLoop() --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacement(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacementNoTrace(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">WindowManagerService.openSurfaceTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.openTransaction() --[SystemServer进程] 创建Transaction, 或者计数+<span class="number">1</span></span><br><span class="line">    android_view_SurfaceControl:nativeCreateTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">WindowManagerService.applySurfaceChangesTransaction(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.mergeToGlobalTransaction(Transaction) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.merge(Transaction) --[SystemServer进程]合并更新后的属性</span><br><span class="line">    android_view_SurfaceControl:nativeMergeTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:merge(Transaction) --[SystemServer进程]也就是保存新的属性</span><br><span class="line">WindowManagerService.closeSurfaceTransaction(String) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.closeTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.apply() --[SystemServer进程]</span><br><span class="line">    android_view_SurfaceControl:nativeApplyTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:apply(bool) --[SystemServer进程]</span><br><span class="line">    SurfaceFlinger:setTransactionState(...) --[SurfaceFlinger进程]传递更新后的属性到sf</span><br><span class="line">    SurfaceFlinger:applyTransactionState(...) --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:run() --[SurfaceFlinger进程]</span><br><span class="line">            TransactionCompletedThread:threadMain() --[SurfaceFlinger子线程]</span><br><span class="line">                mConditionVariable.wait(mMutex);<span class="comment">// 等待执行</span></span><br><span class="line">                TransactionCompletedListener:onTransactionCompleted(...)--[SurfaceFlinger子线程]</span><br><span class="line">        TransactionCompletedThread:addCallback() --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:sendCallbacks() --notify TransactionCompletedThread执行</span><br><span class="line">        SurfaceFlinger:setClientStateLocked(...) --[SurfaceFlinger进程]</span><br><span class="line">            Layer:setLayer(int32_t) --[SurfaceFlinger进程] 更新Layer所处Z轴的位置</span><br></pre></td></tr></table></figure>
<p>如图：<br><img src="/.io//4_2.png" alt="图片"></p>
<p>到目前为止还只是创建了一个SurfaceControl，对应SurfaceFlinger中的BufferQueueLayer。<br>真正的Surface还没有被创建，那是什么时候创建的呢？</p>
<h1 id="四-Surface的生成"><a href="#四-Surface的生成" class="headerlink" title="四. Surface的生成"></a>四. Surface的生成</h1><p>一个ViewRootImpl对应一个Suface, 也就是一个Layer.<br>当我们创建了Layer之后，总要向其中填充数据内容，SurfaceFlinger才好做合成。<br>在RendererThread中，我们知道了Surface数据是通过渲染引擎OpenGL(android Q上是Vulkan)生成的。</p>
<h2 id="4-1-Suface的生成"><a href="#4-1-Suface的生成" class="headerlink" title="4.1 Suface的生成"></a>4.1 Suface的生成</h2><p>参阅：RenderThread深入分析(三)–绑定窗口对应的Surface到RenderThread的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals(...) --[App UI进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App UI进程]</span><br><span class="line">    mSurface.copyFrom(mSurfaceControl) 注意这里会将赋值mSurface</span><br><span class="line">    android_view_Surface:nativeCreateFromSurfaceControl(...) --[App UI进程]</span><br><span class="line">    SurfaceControl:createSurface() --[App UI进程]</span><br><span class="line">        SurfaceControl:generateSurfaceLocked()</span><br><span class="line">        Surface:<span class="keyword">new</span>() 这里创建了<span class="keyword">native</span> Surface</span><br><span class="line">ThreadedRenderer.initializeIfNeeded(...) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.initialize(Surface) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    HardwareRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    android_view_ThreadedRenderer:setSurface(...) --[App UI进程]</span><br><span class="line">        android_view_Surface:getSurface(...) --[App UI进程] 这里返回上面创建的<span class="keyword">native</span> Surface</span><br><span class="line">    RenderProxy:setSurface(Surface) --[App UI进程] 接下来转进RenderThread线程处理</span><br><span class="line">        CanvasContext:setSurface(...) --[RenderThread线程]</span><br><span class="line">        SkiaVulkanPipeline:setSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager:createSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanSurface:Create(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager.mGetPhysicalDeviceSurfaceCapabilitiesKHR(...)</span><br><span class="line">            获取Vulkan引擎中的Surface</span><br></pre></td></tr></table></figure>
<p>大致流程如下图：<br><img src="/.io//4_3.png" alt="图片"></p>
<p>现在我们已经获取了渲染引擎中的Surface，向其中填充数据的过程就是performDraw的流程；<br>这个部分在RenderThread中有分析，不在赘述。</p>
<p>那当我们的Surface中已经被填充了数据后，是如何传递给SurfaceFlinger做合成的呢？<br>这个部分我们稍后详细分析，目前仅从trace上也可以看出来：</p>
<p><img src="/.io//4_4_app.png" alt="图片"></p>
<p>上图中eglSwapBuffer最终就是通过binder通知到surfaceflinger中处理的：</p>
<p><img src="/.io//4_4_sf.png" alt="图片"></p>
<h1 id="五-Layer实例"><a href="#五-Layer实例" class="headerlink" title="五. Layer实例"></a>五. Layer实例</h1><p>以如下图为例，看看对应Layer：</p>
<img src="/.io//screenshot_phone.png" width="100" hegiht="200" align="center">

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Display 19260235133379457 HWC layers:</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> Layer name</span><br><span class="line">           Z |  Window Type |  Comp Type |  Transform |   Disp Frame (LTRB) |          Source Crop (LTRB)</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">  rel      0 |            1 |     DEVICE |          0 |    0    0 1080 2340 |    0.0    0.0 1080.0 2340.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> PopupWindow:b04e24#0</span><br><span class="line">  rel      0 |         1002 |     DEVICE |          0 |  646   56 1080  656 |    0.0    0.0  434.0  600.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> StatusBar#0</span><br><span class="line">  rel      0 |         2000 |     DEVICE |          0 |    0    0 1080   80 |    0.0    0.0 1080.0   80.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> NavigationBar0#0</span><br><span class="line">  rel      0 |         2019 |     DEVICE |          0 |    0 2214 1080 2340 |    0.0    0.0 1080.0  126.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlay#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0    0 1080  240 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlayBottom#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0 2100 1080 2340 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (5fd44db PopupWindow:b04e24#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        2, pos=(646,56), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ ContainerLayer (AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Task=5#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Task=5#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Stack=2#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;taskId:5&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Stack=2#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        5, pos=(0,0), size=(   0,   0), crop=[  0,   0, 1080, 2340], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        1, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Display Root#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Display Root#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000002, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=none</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>示意图如下：</p>
<p><img src="/.io//screenshot_phone_layer.png" alt="图片"></p>
<p>总的来说就是，树形结构+Z order排序。</p>
<h1 id="六-类图"><a href="#六-类图" class="headerlink" title="六. 类图"></a>六. 类图</h1><p><img src="/.io//4_5_classmap.png" alt="图片"></p>
<p>现在我们Surface有了，也有渲染的内容了，那SurfaceFlinger是如何将这些Surface对应的Layer合成为一帧并显示出来的呢?</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[Android Synchronization Fences – An Introduction]<a target="_blank" rel="noopener" href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li>
<li>[Android中的GraphicBuffer同步机制-Fence]<a target="_blank" rel="noopener" href="https://blog.csdn.net/jinzhuojun/article/details/39698317">https://blog.csdn.net/jinzhuojun/article/details/39698317</a></li>
<li>[深入浅出Android BufferQueue]<a target="_blank" rel="noopener" href="https://blog.51cto.com/13591395/2380727">https://blog.51cto.com/13591395/2380727</a></li>
<li>[从systrace看app冷启动过程（三）-首帧的合成与送显]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3829158b4699">https://www.jianshu.com/p/3829158b4699</a></li>
<li>[Android显示Surface]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fc3c3d6f9bf7">https://www.jianshu.com/p/fc3c3d6f9bf7</a></li>
<li>[surfaceflinger中各个layer的排序]<a target="_blank" rel="noopener" href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></li>
<li>[Android 4.0.3 显示系统深入理解]<a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li>
<li>[Android窗口管理分析（3）：窗口分组及Z-order的确定]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/90ede7b2a64a">https://www.jianshu.com/p/90ede7b2a64a</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/" class="post-title-link" itemprop="url">SurfaceFlinger(3)--AppEventThread接受vsync信号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-04 09:57:41 / 修改时间：10:13:13" itemprop="dateCreated datePublished" datetime="2022-04-04T09:57:41+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/SurfaceFlinger/" itemprop="url" rel="index"><span itemprop="name">SurfaceFlinger</span></a>
                </span>
            </span>

          
            <span id="/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/" class="post-meta-item leancloud_visitors" data-flag-title="SurfaceFlinger(3)--AppEventThread接受vsync信号" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p>前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。<br>一图以概之：</p>
<p><img src="/.io//3_1.png" alt="图片"></p>
<p>我们知道android app绘制是离不开编舞者 Choreographer 的，关于 Choreographer 这里就不赘叙，详细可以参考这篇博文。<br>接下来重点分析一下应用app进程是如何与sw vsync信号同步的。</p>
<h1 id="二-App进程与AppEventThread建立通信过程"><a href="#二-App进程与AppEventThread建立通信过程" class="headerlink" title="二. App进程与AppEventThread建立通信过程"></a>二. App进程与AppEventThread建立通信过程</h1><p>回忆一下，我们知道当应用进程的第一个具有布局的Activity启动时，会初始化Choreographer.</p>
<h2 id="2-1-Choerographer初始化"><a href="#2-1-Choerographer初始化" class="headerlink" title="2.1 Choerographer初始化"></a>2.1 Choerographer初始化</h2><p>Choerographer是个单例，意味着一个应用进程中只会存在一个实例化对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread local storage for the choreographer.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Choreographer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主线程中初始化，注意传入的第二个参数 VSYNC_SOURCE_APP</span></span><br><span class="line">        <span class="comment">// 这个值是DisplayEventReceiver.VSYNC_SOURCE_APP 也就是 0</span></span><br><span class="line">        <span class="comment">// 与ISurfaceComposer.h中的VsyncSource.eVsyncSourceApp值保持同步</span></span><br><span class="line">        <span class="comment">// 代表的就是 AppEventThread.</span></span><br><span class="line">        <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">    <span class="comment">// 初始化 DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// USE_VSYNC 值默认为true，读取属性debug.choreographer.vsync</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-FrameDisplayEventReceiver初始化"><a href="#2-2-FrameDisplayEventReceiver初始化" class="headerlink" title="2.2 FrameDisplayEventReceiver初始化"></a>2.2 FrameDisplayEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(looper, vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameDisplayEventReceiver类继承了DisplayEventReceiver类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 转到jni层</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意FrameDisplayEventReceiver类是DisplayEventReceiver的子类。</p>
<h2 id="2-3-android-view-DisplayEventReceiver-cpp-nativeInit"><a href="#2-3-android-view-DisplayEventReceiver-cpp-nativeInit" class="headerlink" title="2.3 android_view_DisplayEventReceiver.cpp:nativeInit"></a>2.3 android_view_DisplayEventReceiver.cpp:nativeInit</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject messageQueueObj, jint vsyncSource)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = <span class="built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;MessageQueue is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.4 根据传入的参数初始化NativeDisplayEventReceiver</span></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> <span class="built_in">NativeDisplayEventReceiver</span>(env,</span><br><span class="line">            receiverWeak, messageQueue, vsyncSource);</span><br><span class="line">    <span class="comment">// 2.8 连接BitTube通信信道</span></span><br><span class="line">    <span class="type">status_t</span> status = receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.<span class="built_in">appendFormat</span>(<span class="string">&quot;Failed to initialize display event receiver.  status=%d&quot;</span>, status);</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;<span class="built_in">incStrong</span>(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-NativeDisplayEventReceiver-初始化"><a href="#2-4-NativeDisplayEventReceiver-初始化" class="headerlink" title="2.4 NativeDisplayEventReceiver 初始化"></a>2.4 NativeDisplayEventReceiver 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver::<span class="built_in">NativeDisplayEventReceiver</span>(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource) :</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="built_in">DisplayEventDispatcher</span>(messageQueue-&gt;<span class="built_in">getLooper</span>(),</span><br><span class="line">                <span class="comment">// 将传入的vsyncSource（0）强制转换为VsyncSource.eVsyncSourceApp</span></span><br><span class="line">                <span class="built_in">static_cast</span>&lt;ISurfaceComposer::VsyncSource&gt;(vsyncSource)),</span><br><span class="line">        <span class="built_in">mReceiverWeakGlobal</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(receiverWeak)),</span><br><span class="line">        <span class="built_in">mMessageQueue</span>(messageQueue) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Initializing display event receiver.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NativeDisplayEventReceiver 继承了 DisplayEventDispatcher。</p>
<h2 id="2-5-DisplayEventDispatcher-初始化"><a href="#2-5-DisplayEventDispatcher-初始化" class="headerlink" title="2.5 DisplayEventDispatcher 初始化"></a>2.5 DisplayEventDispatcher 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventDispatcher::<span class="built_in">DisplayEventDispatcher</span>(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper,</span><br><span class="line">        ISurfaceComposer::VsyncSource vsyncSource) :</span><br><span class="line">        <span class="comment">// 这里的looper是app主线程的looper，mReceiver是我们所寻找的纽带</span></span><br><span class="line">        <span class="built_in">mLooper</span>(looper), <span class="built_in">mReceiver</span>(vsyncSource), <span class="built_in">mWaitingForVsync</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Initializing display event dispatcher.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mReceiver是DisplayEventReceiver类型。</p>
<h2 id="2-6-DisplayEventReceiver初始化"><a href="#2-6-DisplayEventReceiver初始化" class="headerlink" title="2.6 DisplayEventReceiver初始化"></a>2.6 DisplayEventReceiver初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::<span class="built_in">DisplayEventReceiver</span>(ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// vsyncSource就是VsyncSource.eVsyncSourceApp</span></span><br><span class="line">        <span class="comment">// 2.6.1 通过binder通信，在surfaceFlinger中创建DisplayEventConnection</span></span><br><span class="line">        mEventConnection = sf-&gt;<span class="built_in">createDisplayEventConnection</span>(vsyncSource);</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.7 取出EventThread类中新创建的BitTube的Fd（文件描述符表索引）</span></span><br><span class="line">            mDataChannel = std::<span class="built_in">make_unique</span>&lt;gui::BitTube&gt;();</span><br><span class="line">            mEventConnection-&gt;<span class="built_in">stealReceiveChannel</span>(mDataChannel.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的博文中也分析了，这里的ComposerService就是获取的SurfaceFlinger服务。</p>
<h3 id="2-6-1-SurfaceFlinger-createDisplayEventConnection"><a href="#2-6-1-SurfaceFlinger-createDisplayEventConnection" class="headerlink" title="2.6.1 SurfaceFlinger.createDisplayEventConnection"></a>2.6.1 SurfaceFlinger.createDisplayEventConnection</h3><p>进入SurfaceFlinger主线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ISurfaceComposer::VsyncSource vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> resyncCallback = mScheduler-&gt;<span class="built_in">makeResyncCallback</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">        Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里的handle为mAppConnectionHandle</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; handle =</span><br><span class="line">            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;</span><br><span class="line">    <span class="comment">// 2.6.2 创建连接</span></span><br><span class="line">    <span class="keyword">return</span> mScheduler-&gt;<span class="built_in">createDisplayEventConnection</span>(handle, std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-Scheduler-cpp-createDisplayEventConnection"><a href="#2-6-2-Scheduler-cpp-createDisplayEventConnection" class="headerlink" title="2.6.2 Scheduler.cpp:createDisplayEventConnection"></a>2.6.2 Scheduler.cpp:createDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">Scheduler::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;Scheduler::ConnectionHandle&gt;&amp; handle, ResyncCallback resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_VALUE_IF_INVALID</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// mConnections是map类型，key值表示对应的EventThread类型</span></span><br><span class="line">    <span class="comment">// 这个初始化就是在SurfaceFlinger.init方法内，创建EventThread时同步生成的</span></span><br><span class="line">    <span class="comment">// 最终mConnections[handle-&gt;id]-&gt;thread.get()拿到的就是AppEventThread</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">createConnectionInternal</span>(mConnections[handle-&gt;id]-&gt;thread.<span class="built_in">get</span>(),</span><br><span class="line">                                    std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里传入的eventThread就是appEventThread</span></span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里mConnections[handle-&gt;id]-&gt;thread.get()拿到的是handle对应的EventThread.</p>
<h3 id="2-6-3-EventThread-createEventConnection"><a href="#2-6-3-EventThread-createEventConnection" class="headerlink" title="2.6.3 EventThread.createEventConnection"></a>2.6.3 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建的BitTube管道</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>创建EventThreadConnection时新建了个BitTube管道，看来就是通信枢纽就是这个了。</p>
<p>注意到这个类有onFirstRef方法，在生成对象后，就会调用。</p>
<h3 id="2-6-4-EventThreadConnection-onFirstRef"><a href="#2-6-4-EventThreadConnection-onFirstRef" class="headerlink" title="2.6.4 EventThreadConnection.onFirstRef"></a>2.6.4 EventThreadConnection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThreadConnection::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-5-EventThread-registerDisplayEventConnection"><a href="#2-6-5-EventThread-registerDisplayEventConnection" class="headerlink" title="2.6.5 EventThread.registerDisplayEventConnection"></a>2.6.5 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should never happen</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(mDisplayEventConnections.<span class="built_in">cbegin</span>(),</span><br><span class="line">            mDisplayEventConnections.<span class="built_in">cend</span>(), connection);</span><br><span class="line">    <span class="keyword">if</span> (it != mDisplayEventConnections.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;DisplayEventConnection %p already exists&quot;</span>, connection.<span class="built_in">get</span>());</span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有新的连接了，就需要唤醒AppEventThread线程使能Vsync信号了。</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">push_back</span>(connection);</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在注意到我们仅仅是得到了一个BitTube，然而并没有用上这个管道。<br>接下来，回到[2.6 DisplayEventReceiver初始化] 创建DisplayEventReceiver的地方。</p>
<h2 id="2-7-EventThreadConnection-stealReceiveChannel"><a href="#2-7-EventThreadConnection-stealReceiveChannel" class="headerlink" title="2.7 EventThreadConnection.stealReceiveChannel"></a>2.7 EventThreadConnection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将新建的BitTube的Fd复制给outChannel, 也就是DisplayEventReceiver中的 mDataChannel.<br>虽然还是没有用上这个BitTube，不着急，继续看。</p>
<h2 id="2-8-BitTube信道连接过程"><a href="#2-8-BitTube信道连接过程" class="headerlink" title="2.8 BitTube信道连接过程"></a>2.8 BitTube信道连接过程</h2><h3 id="2-8-1-DisplayEventDispatcher-initialize"><a href="#2-8-1-DisplayEventDispatcher-initialize" class="headerlink" title="2.8.1 DisplayEventDispatcher.initialize"></a>2.8.1 DisplayEventDispatcher.initialize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventDispatcher::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mReceiver 就是DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// 这一步就是确认BitTube创建无误</span></span><br><span class="line">    <span class="type">status_t</span> result = mReceiver.<span class="built_in">initCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to initialize display event receiver, status=%d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个mLooper就是应用app进程的主线程Looper，所以这一步就是将</span></span><br><span class="line">    <span class="comment">// 创建的BitTube信道Fd添加到Looper中</span></span><br><span class="line">    <span class="type">int</span> rc = mLooper-&gt;<span class="built_in">addFd</span>(mReceiver.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个DisplayEventDispatcher是继承了LooperCallback, 所以这里的this方法就是handleEvent。</p>
<p>到这里这里整个Vsync流程已经跑通：</p>
<ol>
<li>SurfaceFlinger主线程收到硬件Vsync, 经过误差修正, 通知给DispSyncThread线程</li>
<li>DispSyncThread线程计算各个EventThread的SW Vsync信号时间并及时发出</li>
<li>AppEventThread收到sw Vsync信号，遍历各个Connection，调用sendEvent向对应BitTube管道发送事件</li>
<li>App进程的主线程收到事件，并处理</li>
</ol>
<p>接下来我们就看app收到sw vsync信号的处理过程。</p>
<h1 id="三-App进程收到SW-VSYNC信号"><a href="#三-App进程收到SW-VSYNC信号" class="headerlink" title="三. App进程收到SW VSYNC信号"></a>三. App进程收到SW VSYNC信号</h1><h2 id="3-1-DisplayEventDispatcher-handleEvent"><a href="#3-1-DisplayEventDispatcher-handleEvent" class="headerlink" title="3.1 DisplayEventDispatcher.handleEvent"></a>3.1 DisplayEventDispatcher.handleEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisplayEventDispatcher::handleEvent</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> events, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    PhysicalDisplayId vsyncDisplayId;</span><br><span class="line">    <span class="type">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="comment">// 3.1.1 读取BitTube管道中的数据，返回值为true表示读取到了数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">processPendingEvents</span>(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3.2 分发收到的sw vsync信号</span></span><br><span class="line">        <span class="built_in">dispatchVsync</span>(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1-DisplayEventDispatcher-processPendingEvents"><a href="#3-1-1-DisplayEventDispatcher-processPendingEvents" class="headerlink" title="3.1.1 DisplayEventDispatcher.processPendingEvents"></a>3.1.1 DisplayEventDispatcher.processPendingEvents</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DisplayEventDispatcher::processPendingEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span>* outTimestamp, PhysicalDisplayId* outDisplayId, <span class="type">uint32_t</span>* outCount)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="comment">// 读取管道中的所有数据</span></span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.<span class="built_in">getEvents</span>(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Read %d events.&quot;</span>, <span class="keyword">this</span>, <span class="built_in">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// 拿到最新的sw vsync信号时间</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outDisplayId = ev.header.displayId;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                <span class="built_in">dispatchHotplug</span>(ev.header.timestamp, ev.header.displayId, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_CONFIG_CHANGED:</span><br><span class="line">                <span class="built_in">dispatchConfigChanged</span>(ev.header.timestamp, ev.header.displayId, ev.config.configId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;dispatcher %p ~ ignoring unknown event type %#x&quot;</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to get events from display event dispatcher, status=%d&quot;</span>, <span class="built_in">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-NativeDisplayEventReceiver-dispatchVsync"><a href="#3-2-NativeDisplayEventReceiver-dispatchVsync" class="headerlink" title="3.2 NativeDisplayEventReceiver.dispatchVsync"></a>3.2 NativeDisplayEventReceiver.dispatchVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="type">nsecs_t</span> timestamp, PhysicalDisplayId displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, jniGetReferent(env, mReceiverWeakGlobal))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Invoking vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, displayId, count);</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Returned from vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;dispatchVsync&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过JNI回调到java层的DisplayEventReceiver.dispatchVsync方法</p>
<h2 id="3-3-DisplayEventReceiver-dispatchVsync"><a href="#3-3-DisplayEventReceiver-dispatchVsync" class="headerlink" title="3.3 DisplayEventReceiver.dispatchVsync"></a>3.3 DisplayEventReceiver.dispatchVsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    onVsync(timestampNanos, physicalDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考2.2中，这里的DisplayEventReceiver 对象就是其子类FrameDisplayEventReceiver的对象。</p>
<h2 id="3-4-FrameDisplayEventReceiver-onVsync"><a href="#3-4-FrameDisplayEventReceiver-onVsync" class="headerlink" title="3.4 FrameDisplayEventReceiver.onVsync"></a>3.4 FrameDisplayEventReceiver.onVsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    <span class="comment">// mHandler就是mFrameHandler，传入runnable立刻执行，也就是执行run里面的</span></span><br><span class="line">    <span class="comment">// doFrame方法。</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 进入Choreographer的绘图，接下来就是measure,layout,draw的过程了、</span></span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的VSYNC流程图如下：</p>
<p><img src="/.io//Vsync.jpg" alt="图片"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li>
<li><a target="_blank" rel="noopener" href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li>
<li><a target="_blank" rel="noopener" href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-2-DispSync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/SurfaceFlinger-2-DispSync/" class="post-title-link" itemprop="url">SurfaceFlinger(2)--DispSync</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-04 09:52:26 / 修改时间：10:13:24" itemprop="dateCreated datePublished" datetime="2022-04-04T09:52:26+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/SurfaceFlinger/" itemprop="url" rel="index"><span itemprop="name">SurfaceFlinger</span></a>
                </span>
            </span>

          
            <span id="/2022/04/04/SurfaceFlinger-2-DispSync/" class="post-meta-item leancloud_visitors" data-flag-title="SurfaceFlinger(2)--DispSync" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/04/SurfaceFlinger-2-DispSync/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/04/SurfaceFlinger-2-DispSync/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<h1 id="一-DispSync"><a href="#一-DispSync" class="headerlink" title="一. DispSync"></a>一. DispSync</h1><p>DispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。</p>
<p>接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。<br>我们先看DispSync线程的创建过程。</p>
<h1 id="二-DispSync初始化"><a href="#二-DispSync初始化" class="headerlink" title="二. DispSync初始化"></a>二. DispSync初始化</h1><h2 id="2-1-SurfaceFlinger"><a href="#2-1-SurfaceFlinger" class="headerlink" title="2.1 SurfaceFlinger"></a>2.1 SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFligner</span>(SurfaceFlinger::SkipInitializationTag)</span><br><span class="line">        :   <span class="built_in">BnSurfaceComposer</span>(),</span><br><span class="line">            <span class="built_in">mTransactionFlags</span>(<span class="number">0</span>),</span><br><span class="line">            ......</span><br><span class="line">            <span class="built_in">mPrimaryDispSync</span>(<span class="string">&quot;PrimaryDispSync&quot;</span>),</span><br><span class="line">            <span class="built_in">mPrimaryHWVsyncEnabled</span>(<span class="literal">false</span>),</span><br><span class="line">            ......</span><br><span class="line">            &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在SurfaceFlinger初始化的时候创建的。</p>
<h2 id="2-2-DispSync创建"><a href="#2-2-DispSync创建" class="headerlink" title="2.2 DispSync创建"></a>2.2 DispSync创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DispSync::<span class="built_in">DispSync</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">      : <span class="built_in">mName</span>(name), <span class="built_in">mRefreshSkipCount</span>(<span class="number">0</span>), <span class="built_in">mThread</span>(<span class="keyword">new</span> <span class="built_in">DispSyncThread</span>(name)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DispSyncThread</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function">        : mName(name),</span></span><br><span class="line"><span class="function">        mStop(false),</span></span><br><span class="line"><span class="function">        mPeriod(<span class="number">0</span>), // 注意这里的mPeriod初始化为<span class="number">0</span></span></span><br><span class="line"><span class="function">        mPhase(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mReferenceTime(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mWakeupLatency(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mFrameNumber(<span class="number">0</span>) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-SurfaceFlinger-SurfaceFlinger"><a href="#2-3-SurfaceFlinger-SurfaceFlinger" class="headerlink" title="2.3 SurfaceFlinger::SurfaceFlinger"></a>2.3 SurfaceFlinger::SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFlinger</span>() : <span class="built_in">SurfaceFlinger</span>(SkipInitialization) &#123;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;SurfaceFlinger is starting&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    mPrimaryDispSync.<span class="built_in">init</span>(SurfaceFlinger::hasSyncFramework, </span><br><span class="line">            SurfaceFlinger::dispSyncPresentTimeOffset);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-DispSync-init"><a href="#2-4-DispSync-init" class="headerlink" title="2.4 DispSync.init"></a>2.4 DispSync.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::init</span><span class="params">(<span class="type">bool</span> hasSyncFramework, <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> </span>&#123;</span><br><span class="line">    mIgnorePresentFences = !hasSyncFramework;</span><br><span class="line">    mPresentTimeOffset = dispSyncPresentTimeOffset;</span><br><span class="line">    <span class="comment">// 线程改名为 DispSync，调整线程优先级</span></span><br><span class="line">    mThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;DispSync&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set DispSync to SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sched_setscheduler</span>(mThread-&gt;<span class="built_in">getTid</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for DispSyncThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re not getting present fences then the ZeroPhaseTracer</span></span><br><span class="line">        <span class="comment">// would prevent HW vsync event from ever being turned off.</span></span><br><span class="line">        <span class="comment">// Even if we&#x27;re just ignoring the fences, the zero-phase tracing is</span></span><br><span class="line">        <span class="comment">// not needed because any time there is an event registered we will</span></span><br><span class="line">        <span class="comment">// turn on the HW vsync events.</span></span><br><span class="line">        <span class="keyword">if</span> (!mIgnorePresentFences &amp;&amp; kEnableZeroPhaseTracer) &#123;</span><br><span class="line">            mZeroPhaseTracer = std::<span class="built_in">make_unique</span>&lt;ZeroPhaseTracer&gt;();</span><br><span class="line">            <span class="built_in">addEventListener</span>(<span class="string">&quot;ZeroPhaseTracer&quot;</span>, <span class="number">0</span>, mZeroPhaseTracer.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-1-DispSyncThread-threadLoop"><a href="#2-4-1-DispSyncThread-threadLoop" class="headerlink" title="2.4.1 DispSyncThread.threadLoop"></a>2.4.1 DispSyncThread.threadLoop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="comment">// 获取开机到现在的时长</span></span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于此时mPeriod为0，所以会进入该分支一直等待。</span></span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-enableVysncLocked后续"><a href="#三-enableVysncLocked后续" class="headerlink" title="三. enableVysncLocked后续"></a>三. enableVysncLocked后续</h1><p>SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked</p>
<h2 id="3-1-DispSync-addEventListener"><a href="#3-1-DispSync-addEventListener" class="headerlink" title="3.1 DispSync.addEventListener"></a>3.1 DispSync.addEventListener</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t DispSync::addEventListener(const char* name, nsecs_t phase, Callback* callback) &#123;</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    return mThread-&gt;addEventListener(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-DispSync-DispSyncThread-addEventListener"><a href="#3-2-DispSync-DispSyncThread-addEventListener" class="headerlink" title="3.2 DispSync.DispSyncThread.addEventListener"></a>3.2 DispSync.DispSyncThread.addEventListener</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, DispSync::Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEventListeners[i].mCallback == callback) &#123;</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventListener listener;</span><br><span class="line">    listener.mName = name;</span><br><span class="line">    listener.mPhase = phase;</span><br><span class="line">    listener.mCallback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to allow the firstmost future event to fire without</span></span><br><span class="line">    <span class="comment">// allowing any past events to fire</span></span><br><span class="line">    listener.mLastEventTime = <span class="built_in">systemTime</span>() - mPeriod / <span class="number">2</span> + mPhase - mWakeupLatency;</span><br><span class="line"></span><br><span class="line">    mEventListeners.<span class="built_in">push</span>(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threadLooper可以继续执行了</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里还是运行在SurfaceFlinger主线程，在mCond.signal之后，DispSync线程就可以继续执行了。<br>但是注意看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的continue意味着如果mPeriod为0，还是会一直等待。</p>
<h1 id="四-setPeriod"><a href="#四-setPeriod" class="headerlink" title="四. setPeriod"></a>四. setPeriod</h1><p>这样我们就需要看mPeriod是什么时候被更改的。<br>在SurfaceFlinger初始化Display后，会调用resyncToHardwareVsync跟硬件vsync进行同步。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initializeDisplays();</span><br><span class="line">    flinger-&gt;onInitializeDisplays();</span><br><span class="line">        setPowerModeInternal()</span><br><span class="line">            resyncToHardwareVsync(true);</span><br><span class="line">                repaintEverything();</span><br></pre></td></tr></table></figure>

<h2 id="4-1-SurfaceFlinger-resyncToHardwareVsync"><a href="#4-1-SurfaceFlinger-resyncToHardwareVsync" class="headerlink" title="4.1 SurfaceFlinger.resyncToHardwareVsync"></a>4.1 SurfaceFlinger.resyncToHardwareVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">        <span class="comment">// mHWVsyncAvailable 表示 HW vsync 被 enable</span></span><br><span class="line">        mHWVsyncAvailable = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">        <span class="comment">// Hardware vsync is not currently available, so abort the resync</span></span><br><span class="line">        <span class="comment">// attempt for now</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得显示设备的刷新率，比如60HZ, 那么period就是16.6667ms,即每隔16.6667就会产生一个硬件vsync信号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; activeConfig = <span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">getActiveConfig</span>(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = activeConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是设置DispSync线程中的period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">// 4.2 设置period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mPrimaryHWVsyncEnabled表示当前的硬件vsync是否enable,</span></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        mPrimaryDispSync.<span class="built_in">beginResync</span>();</span><br><span class="line">        <span class="comment">// 如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC</span></span><br><span class="line">        <span class="comment">// 这个和DispSync的setVsyncEnabled是不一样的</span></span><br><span class="line">        <span class="comment">// 5.1 硬件Vsync控制</span></span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-DispSync-setPeriod"><a href="#4-2-DispSync-setPeriod" class="headerlink" title="4.2 DispSync.setPeriod"></a>4.2 DispSync.setPeriod</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::setPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = <span class="number">0</span>;</span><br><span class="line">    mReferenceTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Ignore recompute as mReferenceTime is zero.</span></span><br><span class="line">    <span class="comment">// mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mPeriod表示具体的硬件产生vsync的时间间隔。这样，之后的DispSync线程中的threadLoop就可以继续执行了。</p>
<h1 id="五-硬件Vsync的开关控制"><a href="#五-硬件Vsync的开关控制" class="headerlink" title="五. 硬件Vsync的开关控制"></a>五. 硬件Vsync的开关控制</h1><p>接上面 4.1，当设置DispSync的mPeriod之后，如果硬件Vsync开关是开启状态，则会通过EventControlThread打开HW Vsync<br>我们先看看EventControlThread线程的启动，其启动在SurfaceFlinger的初始化，EventThread启动之后，显示屏初始化之前。</p>
<h2 id="5-1-EventControlThread的启动"><a href="#5-1-EventControlThread的启动" class="headerlink" title="5.1 EventControlThread的启动"></a>5.1 EventControlThread的启动</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = std::<span class="built_in">make_unique</span>&lt;impl::EventControlThread&gt;(</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setVsyncEnabled</span>(HWC_DISPLAY_PRIMARY, enabled); &#125;);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里初始化时传入了函数 setVsyncEnabled。</p>
<p>注意EventControlThread中线程的初始化是在成员变量中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be last so that everything is initialized before the thread starts.</span></span><br><span class="line">std::thread mThread&#123;&amp;EventControlThread::threadMain, <span class="keyword">this</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>所以先调用threadMain，后调用构造函数。</p>
<h3 id="5-1-1-EventControlThread-threadMain"><a href="#5-1-1-EventControlThread-threadMain" class="headerlink" title="5.1.1 EventControlThread.threadMain"></a>5.1.1 EventControlThread.threadMain</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unfortunately std::unique_lock gives warnings with -Wthread-safety</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> keepRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> currentVsyncEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keepRunning) &#123;</span><br><span class="line">        <span class="comment">// 5.3 此时currentVsyncEnabled为false</span></span><br><span class="line">        <span class="built_in">mSetVSyncEnabled</span>(currentVsyncEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">// 在这里等待</span></span><br><span class="line">        mCondition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, currentVsyncEnabled, keepRunning]() NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">            <span class="keyword">return</span> currentVsyncEnabled != mVsyncEnabled || keepRunning != mKeepRunning;</span><br><span class="line">        &#125;);</span><br><span class="line">        currentVsyncEnabled = mVsyncEnabled;</span><br><span class="line">        keepRunning = mKeepRunning;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-EventControlThread初始化"><a href="#5-1-2-EventControlThread初始化" class="headerlink" title="5.1.2 EventControlThread初始化"></a>5.1.2 EventControlThread初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventControlThread::<span class="built_in">EventControlThread</span>(EventControlThread::SetVSyncEnabledFunction function)</span><br><span class="line">      : <span class="built_in">mSetVSyncEnabled</span>(function) &#123;</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), <span class="string">&quot;EventControlThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, tid, ANDROID_PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数里面设置了线程名和优先级</p>
<h2 id="5-2-EventControlThread-setVsyncEnabled"><a href="#5-2-EventControlThread-setVsyncEnabled" class="headerlink" title="5.2 EventControlThread.setVsyncEnabled"></a>5.2 EventControlThread.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::setVsyncEnabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mVsyncEnabled = enabled;</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mVsyncEnabled设置为true, 表明开启硬件Vsync.<br>mCondition.notify_all() 则通知EventControlThread线程继续执行，回到5.1.1的循环内。<br>mSetVSyncEnabled是传入的函数SurfaceFlinger.setVsyncEnabled.</p>
<h2 id="5-3-SurfaceFlinger-setVsyncEnabled"><a href="#5-3-SurfaceFlinger-setVsyncEnabled" class="headerlink" title="5.3 SurfaceFlinger.setVsyncEnabled"></a>5.3 SurfaceFlinger.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">getHwComposer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">getBE</span>().mHwc; &#125;</span><br><span class="line"><span class="function">SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br></pre></td></tr></table></figure>
<p>这里的disp &#x3D; HWC_DISPLAY_PRIMARY</p>
<h2 id="5-4-HWComposer-setVsyncEnabled"><a href="#5-4-HWComposer-setVsyncEnabled" class="headerlink" title="5.4 HWComposer.setVsyncEnabled"></a>5.4 HWComposer.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::setVsyncEnabled</span><span class="params">(DisplayId displayId, HWC2::Vsync enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_INVALID_DISPLAY</span>(displayId);</span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayData.isVirtual) &#123;</span><br><span class="line">        <span class="built_in">LOG_DISPLAY_ERROR</span>(displayId, <span class="string">&quot;Invalid operation on virtual display&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we use our own internal lock here because we have to call</span></span><br><span class="line">    <span class="comment">// into the HWC with the lock held, and we want to make sure</span></span><br><span class="line">    <span class="comment">// that even if HWC blocks (which it shouldn&#x27;t), it won&#x27;t</span></span><br><span class="line">    <span class="comment">// affect other threads.</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(displayData.vsyncEnabledLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enabled == displayData.vsyncEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">auto</span> error = displayData.hwcDisplay-&gt;<span class="built_in">setVsyncEnabled</span>(enabled);</span><br><span class="line">    <span class="built_in">RETURN_IF_HWC_ERROR</span>(error, displayId);</span><br><span class="line"></span><br><span class="line">    displayData.vsyncEnabled = enabled;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> tag = <span class="string">&quot;HW_VSYNC_ON_&quot;</span> + <span class="built_in">to_string</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(tag.<span class="built_in">c_str</span>(), enabled == HWC2::Vsync::Enable ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六-硬件Vsync信号更新"><a href="#六-硬件Vsync信号更新" class="headerlink" title="六. 硬件Vsync信号更新"></a>六. 硬件Vsync信号更新</h1><p>经过HWComposer使能硬件Vsync信号后，只要有硬件Vsync信号产生，就可回调 hook_vsync函数。<br>hook_vsync函数在HWComposer的初始化的时候被注册的。</p>
<h2 id="6-1-HWC初始化"><a href="#6-1-HWC初始化" class="headerlink" title="6.1 HWC初始化"></a>6.1 HWC初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 获取硬件HWC</span><br><span class="line">    getBE().mHwc.reset(</span><br><span class="line">            new HWComposer(std::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));</span><br><span class="line">    // 注册回调</span><br><span class="line">    getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里这里先创建的是 Hwc2::impl::Composer,然后创建HWComposer</p>
<h3 id="6-1-1-ComposerHal-cpp-Composer"><a href="#6-1-1-ComposerHal-cpp-Composer" class="headerlink" title="6.1.1 ComposerHal.cpp:Composer"></a>6.1.1 ComposerHal.cpp:Composer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Composer::<span class="built_in">Composer</span>(<span class="type">const</span> std::string&amp; serviceName)</span><br><span class="line">    : <span class="built_in">mWriter</span>(kWriterInitialSize),</span><br><span class="line">      <span class="built_in">mIsUsingVrComposer</span>(serviceName == std::<span class="built_in">string</span>(<span class="string">&quot;vr&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    mComposer = V2_1::IComposer::<span class="built_in">getService</span>(serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mComposer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to get hwcomposer service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mComposer-&gt;<span class="built_in">createClient</span>(</span><br><span class="line">            [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="type">const</span> <span class="keyword">auto</span>&amp; tmpClient)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmpError == Error::NONE) &#123;</span><br><span class="line">                    mClient = tmpClient;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (mClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create composer client&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 support is optional</span></span><br><span class="line">    sp&lt;IComposer&gt; composer_2_2 = IComposer::<span class="built_in">castFrom</span>(mComposer);</span><br><span class="line">    <span class="keyword">if</span> (composer_2_2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mClient_2_2 = IComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mClient_2_2 == <span class="literal">nullptr</span>, <span class="string">&quot;IComposer 2.2 did not return IComposerClient 2.2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsUsingVrComposer) &#123;</span><br><span class="line">        sp&lt;IVrComposerClient&gt; vrClient = IVrComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="keyword">if</span> (vrClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create vr composer client&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取composer服务。</p>
<h3 id="6-1-2-HWComposer创建"><a href="#6-1-2-HWComposer创建" class="headerlink" title="6.1.2 HWComposer创建"></a>6.1.2 HWComposer创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::<span class="built_in">HWComposer</span>(std::unique_ptr&lt;android::Hwc2::Composer&gt; composer)</span><br><span class="line">      : <span class="built_in">mHwcDevice</span>(std::<span class="built_in">make_unique</span>&lt;HWC2::Device&gt;(std::<span class="built_in">move</span>(composer))) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-注册回调HWComposer-registerCallback"><a href="#6-2-注册回调HWComposer-registerCallback" class="headerlink" title="6.2 注册回调HWComposer.registerCallback"></a>6.2 注册回调HWComposer.registerCallback</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::registerCallback</span><span class="params">(HWC2::ComposerCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    mHwcDevice-&gt;<span class="built_in">registerCallback</span>(callback, sequenceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Device::registerCallback</span><span class="params">(ComposerCallback* callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRegisteredCallback) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Callback already registered. Ignored extra registration &quot;</span></span><br><span class="line">                <span class="string">&quot;attempt.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRegisteredCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">sp&lt;ComposerCallbackBridge&gt; <span class="title">callbackBridge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> ComposerCallbackBridge(callback, sequenceId))</span></span>;</span><br><span class="line">    mComposer-&gt;<span class="built_in">registerCallback</span>(callbackBridge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Composer::registerCallback</span><span class="params">(<span class="type">const</span> sp&lt;IComposerCallback&gt;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mClient就是composer服务在SurfaceFlinger中的客户端</span></span><br><span class="line">    <span class="keyword">auto</span> ret = mClient-&gt;<span class="built_in">registerCallback</span>(callback);</span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">isOk</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to register IComposerCallback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ComposerCallbackBridge类就是实现onHotplug, onVsync等回调。<br>当HWC硬件产生vsync信号时，就会回调onVsync方法。</p>
<h2 id="6-3-Vsync信号更新"><a href="#6-3-Vsync信号更新" class="headerlink" title="6.3 Vsync信号更新"></a>6.3 Vsync信号更新</h2><h3 id="6-3-1-ComposerCallbackBridge-onVsync"><a href="#6-3-1-ComposerCallbackBridge-onVsync" class="headerlink" title="6.3.1 ComposerCallbackBridge.onVsync"></a>6.3.1 ComposerCallbackBridge.onVsync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onVsync</span><span class="params">(Hwc2::Display display, <span class="type">int64_t</span> timestamp)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mCallback-&gt;<span class="built_in">onVsyncReceived</span>(mSequenceId, display, timestamp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mCallback就是SurfaceFlinger[6.1].</p>
<h3 id="6-3-2-SurfaceFlinger-onVsyncReceived"><a href="#6-3-2-SurfaceFlinger-onVsyncReceived" class="headerlink" title="6.3.2 SurfaceFlinger.onVsyncReceived"></a>6.3.2 SurfaceFlinger.onVsyncReceived</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onVsyncReceived</span><span class="params">(<span class="type">int32_t</span> sequenceId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">hwc2_display_t</span> displayId, <span class="type">int64_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="comment">// Ignore any vsyncs from a previous hardware composer.</span></span><br><span class="line">    <span class="keyword">if</span> (sequenceId != <span class="built_in">getBE</span>().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> type;</span><br><span class="line">    <span class="comment">// 按条件决定是否过滤，记录此次HWC接收到的硬件Vsync</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">onVsync</span>(displayId, timestamp, &amp;type)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="comment">// DISPLAY_PRIMARY为0，mPrimaryHWVsyncEnabled为true</span></span><br><span class="line">        <span class="keyword">if</span> (type == DisplayDevice::DISPLAY_PRIMARY &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.<span class="built_in">addResyncSample</span>(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        <span class="built_in">enableHardwareVsync</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">disableHardwareVsync</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-DispSync-addResyncSample"><a href="#6-3-3-DispSync-addResyncSample" class="headerlink" title="6.3.3 DispSync.addResyncSample"></a>6.3.3 DispSync.addResyncSample</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DispSync::addResyncSample</span><span class="params">(<span class="type">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample(%&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>, mName, <span class="built_in">ns2us</span>(timestamp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MAX_RESYNC_SAMPLES = 32，即最大只保存32次硬件vsync时间戳，用来计算SW vsync模型.</span></span><br><span class="line">    <span class="comment">// mNumResyncSamples 表示已经有多少个硬件vsync 样本了 ，最多记录MAX_RESYNC_SAMPLES</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    mResyncSamples[idx] = timestamp;</span><br><span class="line">    <span class="comment">// 第一次收到Vsync信号，直接更新</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples == <span class="number">0</span>) &#123;</span><br><span class="line">        mPhase = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 参考时间设置为第一个硬件vsync的时间戳</span></span><br><span class="line">        mReferenceTime = timestamp;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] First resync sample: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = 0, &quot;</span></span><br><span class="line">              <span class="string">&quot;mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">              mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">        <span class="comment">// 6.3.5 通知更新DispSync线程收到Vsync信号</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新 mNumResyncSamples 或 mFirstResyncSample的值</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">        mNumResyncSamples++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFirstResyncSample = (mFirstResyncSample + <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.3.4 开始计算更新SW vsync 模型</span></span><br><span class="line">    <span class="built_in">updateModelLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">        <span class="built_in">resetErrorLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIgnorePresentFences) &#123;</span><br><span class="line">        <span class="comment">// If we don&#x27;t have the sync framework we will never have</span></span><br><span class="line">        <span class="comment">// addPresentFence called.  This means we have no way to know whether</span></span><br><span class="line">        <span class="comment">// or not we&#x27;re synchronized with the HW vsyncs, so we just request</span></span><br><span class="line">        <span class="comment">// that the HW vsync events be turned on whenever we need to generate</span></span><br><span class="line">        <span class="comment">// SW vsync events.</span></span><br><span class="line">        <span class="keyword">return</span> mThread-&gt;<span class="built_in">hasAnyEventListeners</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against kErrorThreshold / 2 to add some hysteresis before having to</span></span><br><span class="line">    <span class="comment">// resync again</span></span><br><span class="line">    <span class="type">bool</span> modelLocked = mModelUpdated &amp;&amp; mError &lt; (kErrorThreshold / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample returning %s&quot;</span>, mName, modelLocked ? <span class="string">&quot;locked&quot;</span> : <span class="string">&quot;unlocked&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !modelLocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是收到硬件Vsync信号, 在SurfaceFlinger主线程执行，在经过误差更正后，通知DispSync线程处理分发事件。</p>
<h3 id="6-3-4-DispSync-updateModelLocked"><a href="#6-3-4-DispSync-updateModelLocked" class="headerlink" title="6.3.4 DispSync.updateModelLocked"></a>6.3.4 DispSync.updateModelLocked</h3><p>这一步是计算模型参数如偏移、硬件Vsync更新间隔等。在分析前，我们先了解下几个重要参数的含义：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>mNumResyncSamples</td>
<td>-</td>
<td>当前保存的硬件Vsyc信号数量，最大值为32</td>
</tr>
<tr>
<td>MIN_RESYNC_SAMPLES_FOR_UPDATE</td>
<td>6</td>
<td>更新模型参数的最小硬件Vsync数量</td>
</tr>
<tr>
<td>mPeriod</td>
<td>-</td>
<td>硬件刷新率，根据保存的Vsync去掉最大和最小求得的平均值</td>
</tr>
<tr>
<td>mPhase</td>
<td>-</td>
<td>偏移时间，仅作为针对mPeriod的一个偏移</td>
</tr>
<tr>
<td>mReferenceTime</td>
<td>第一个硬件Vsync事件</td>
<td>每次计算sw vsync模型时的基准时间，以减少误差</td>
</tr>
<tr>
<td>mRefreshSkipCount</td>
<td>0</td>
<td>多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::updateModelLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);</span><br><span class="line">    <span class="comment">// MIN_RESYNC_SAMPLES_FOR_UPDATE = 6, 也就是收到6次硬件Vsync之后，开始计算sw vsync模型</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Computing...&quot;</span>, mName);</span><br><span class="line">        <span class="type">nsecs_t</span> durationSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> minDuration = INT64_MAX;</span><br><span class="line">        <span class="type">nsecs_t</span> maxDuration = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里计算总时长，以及拿到最长和最短的硬件vsync间隔</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">            durationSum += duration;</span><br><span class="line">            minDuration = <span class="built_in">min</span>(minDuration, duration);</span><br><span class="line">            maxDuration = <span class="built_in">max</span>(maxDuration, duration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算平均间隔，去掉一个最大和一个最小的间隔</span></span><br><span class="line">        durationSum -= minDuration + maxDuration;</span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPeriod = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPeriod));</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> sampleAvgX = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> sampleAvgY = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="built_in">double</span>(mPeriod);</span><br><span class="line">        <span class="comment">// 跳过第一个Vsync，因为第一个Vsync已经更新到DispSync中了。</span></span><br><span class="line">        <span class="comment">// mReferenceTime是第一个Vsync的时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;</span><br><span class="line">            <span class="type">double</span> samplePhase = <span class="built_in">double</span>(sample % mPeriod) * scale;</span><br><span class="line">            sampleAvgX += <span class="built_in">cos</span>(samplePhase);</span><br><span class="line">            sampleAvgY += <span class="built_in">sin</span>(samplePhase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sampleAvgX /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line">        sampleAvgY /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        mPhase = <span class="built_in">nsecs_t</span>(<span class="built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        <span class="comment">// 如果偏移值是负值，绝对值超过了mPeroid的一半</span></span><br><span class="line">        <span class="comment">// 则调整偏移值为对应正值</span></span><br><span class="line">        <span class="keyword">if</span> (mPhase &lt; -(mPeriod / <span class="number">2</span>)) &#123;</span><br><span class="line">            mPhase += mPeriod;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Period&quot;</span>, mPeriod);</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Phase&quot;</span>, mPhase + mPeriod / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mRefreshSkipCount表示多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</span></span><br><span class="line">        mPeriod += mPeriod * mRefreshSkipCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.3.5 更新sw model. 这个方法会唤醒DispSync线程</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">        mModelUpdated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里算偏移还用上了反三角函数。mPeriod的含义就是圆周长，最终算出来的 mPhase 就是弧BC的长度。<br>也就是基于mPeriod的偏移值，如下图：</p>
<p><img src="/.io//2_1.png" alt="图片"></p>
<p>这个偏移值有什么用处呢？</p>
<h3 id="6-3-5-DispSync-DispSyncThread-updateModel"><a href="#6-3-5-DispSync-DispSyncThread-updateModel" class="headerlink" title="6.3.5 DispSync.DispSyncThread.updateModel"></a>6.3.5 DispSync.DispSyncThread.updateModel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateModel</span><span class="params">(<span class="type">nsecs_t</span> period, <span class="type">nsecs_t</span> phase, <span class="type">nsecs_t</span> referenceTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = phase;</span><br><span class="line">    mReferenceTime = referenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModel: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = %&quot;</span> PRId64</span><br><span class="line">          <span class="string">&quot; mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">          mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mPhase), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">    <span class="comment">// 这里通知正在等待的DispSync线程开始执行</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新mPeriod和时间戳。<br>mCond.signal 后转DispSyncThread线程[2.4.1]DispSyncThread.threadLoop继续执行</p>
<h1 id="七-SW-Vsync更新"><a href="#七-SW-Vsync更新" class="headerlink" title="七. SW Vsync更新"></a>七. SW Vsync更新</h1><p>硬件Vsync信号经过DispSync的简单加工，会将相应的值更新，然后唤醒DispSyncThread线程</p>
<h2 id="7-1-DispSync-DispSyncThread-threadLoop"><a href="#7-1-DispSync-DispSyncThread-threadLoop" class="headerlink" title="7.1 DispSync.DispSyncThread.threadLoop"></a>7.1 DispSync.DispSyncThread.threadLoop</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2 计算下一个SW Vsync时间点</span></span><br><span class="line">            targetTime = <span class="built_in">computeNextEventTimeLocked</span>(now);</span><br><span class="line">            <span class="type">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果计算出来的下一次vsync事件还没有到来，就等时间到了，才发送SW VSYNC信号</span></span><br><span class="line">            <span class="comment">// 可以看出 DispSyncThread的发送的vsync信号和真正硬件发生的vsync信号没有直接的关系，</span></span><br><span class="line">            <span class="comment">// 发送给app/sf的vsync信号都是由 DispSyncThread发送出去的.</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;DispSync waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetTime == INT64_MAX) &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting forever&quot;</span>, mName);</span><br><span class="line">                    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(targetTime));</span><br><span class="line">                    err = mCond.<span class="built_in">waitRelative</span>(mMutex, targetTime - now);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待超时，主动醒来，发送SW Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">                    isWakeup = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算wake up消耗的时间, 但是不能超过1.5 ms</span></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">nsecs_t</span> kMaxWakeupLatency = <span class="built_in">us2ns</span>(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">                <span class="comment">// 乍一看没明白为什么这么算。仔细想，每次wakeup时间是累加的，这个为了减小抖动？</span></span><br><span class="line">                mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) + (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">                mWakeupLatency = <span class="built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.3 搜集EventListener回调，一般就两个：SF和App EventThread</span></span><br><span class="line">            <span class="comment">// 并不是所有的wakeup都是等待了sw vsync的targetTime，如果SurfaceFlinger</span></span><br><span class="line">            <span class="comment">// 主线程收到硬件Vsync,也会唤醒此线程，此时isWakeup为false</span></span><br><span class="line">            <span class="comment">// 这里的callbackInvocations集合就为null，只有now&gt;=targetTime才不为null</span></span><br><span class="line">            callbackInvocations = <span class="built_in">gatherCallbackInvocationsLocked</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackInvocations.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fireCallbackInvocations</span>(callbackInvocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-DispSync-DispSyncThread-computeNextEventTimeLocked"><a href="#7-2-DispSync-DispSyncThread-computeNextEventTimeLocked" class="headerlink" title="7.2 DispSync.DispSyncThread.computeNextEventTimeLocked"></a>7.2 DispSync.DispSyncThread.computeNextEventTimeLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeNextEventTimeLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] computeNextEventTimeLocked&quot;</span>, mName);</span><br><span class="line">    <span class="type">nsecs_t</span> nextEventTime = INT64_MAX;</span><br><span class="line">    <span class="comment">// 对所有的EventListener进行分别计算，里面的mLastEventTime值不同</span></span><br><span class="line">    <span class="comment">// 找出一个最小的Vsync时间，即最近的时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], now);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; nextEventTime) &#123;</span><br><span class="line">            nextEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] nextEventTime = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(nextEventTime));</span><br><span class="line">    <span class="keyword">return</span> nextEventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的EventListeners里面只有两个，一个是SF EventThread，另一个就是App EventThread.</p>
<h3 id="7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked"><a href="#7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked" class="headerlink" title="7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked"></a>7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeListenerNextEventTimeLocked</span><span class="params">(<span class="type">const</span> EventListener&amp; listener, <span class="type">nsecs_t</span> baseTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listener.mLasteEventTime就是上次SW VSync的时间点，mWakeupLatency就是上次线程醒来的耗时</span></span><br><span class="line">    <span class="type">nsecs_t</span> lastEventTime = listener.mLastEventTime + mWakeupLatency;</span><br><span class="line">    <span class="comment">// 一般baseTime也就是nowTime, 是大于lasterEventTime，除了第一次进入   </span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; lastEventTime) &#123;</span><br><span class="line">        baseTime = lastEventTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// baseTime减去第一次硬件Vsync的时间，算duration时长</span></span><br><span class="line">    baseTime -= mReferenceTime;</span><br><span class="line">    <span class="comment">// 偏移就是SW Vsync本身的偏移值加上各EventThread本身的偏移</span></span><br><span class="line">    <span class="comment">// sf 使用的是 SF_VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="comment">// APP使用的VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="type">nsecs_t</span> phase = mPhase + listener.mPhase;</span><br><span class="line">    <span class="comment">// baseTime也减去偏移</span></span><br><span class="line">    baseTime -= phase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// baseTime小于0，只有第一次进入的时候才会发生。</span></span><br><span class="line">    <span class="comment">// 此时硬件Vsync已经发生了，所以设置baseTime为-mPeriod这样后面算的numPeriod为-1</span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        baseTime = -mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出下一个SW Vsync的时间点</span></span><br><span class="line">    <span class="comment">// 先得到baseTime对应第几个sw Vsync，也就是现在时间点发送了多少个sw Vsync</span></span><br><span class="line">    <span class="type">nsecs_t</span> numPeriods = baseTime / mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numberPeriods+1也就是下一个sw Vysnc，再加上偏移        </span></span><br><span class="line">    <span class="type">nsecs_t</span> t = (numPeriods + <span class="number">1</span>) * mPeriod + phase;</span><br><span class="line">    </span><br><span class="line">    t += mReferenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Absolute t = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个vsync距离上一个vsync时间小于3/5个mPeriod的话，</span></span><br><span class="line">    <span class="comment">// 为了避免连续的两个sw vsync, 那么这次sw vsync就放弃了，直接放到下一个周期里</span></span><br><span class="line">    <span class="keyword">if</span> (t - listener.mLastEventTime &lt; (<span class="number">3</span> * mPeriod / <span class="number">5</span>)) &#123;</span><br><span class="line">        t += mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出来的时间减掉wakeup累积时间，最大1.5ms</span></span><br><span class="line">    t -= mWakeupLatency;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="/.io//2_2.png" alt="图片"></p>
<p>看到这里就有一个疑问，sw vsync信号是在DispSyncThread收到第一个硬件Vsync更新sw model后就可以不依赖<br>硬件Vsync信号了，后续可以自己产生。那为什么google没有在这里disable硬件Vsync呢，因为sw vsync还是有误差<br>并不能与硬件Vsync完全保持一致，所以需要updateModelLocked持续消减误差。<br>重新梳理一下完整流程：</p>
<ol>
<li>SurfaceFlinger主线程收到硬件Vsync</li>
<li>DispSync.updateModelLocked及时更新sw model，并通知DispSyncThread线程</li>
<li>DispSyncThread线程更新mPeriod，mPhase等参数通过computeNextEventTimeLocked计算新的targetTime</li>
<li>继续等待直到新的targetTime，通知SF EventThread或者AppEventThread有sw vsync信号</li>
</ol>
<p>我们知道SF EventThread和App EventThread是有间隔的，并不同步，这里是如何实现的呢？<br>注意我们计算出来的targetTime是sf和app中最近的一次，那么继续看往下看。</p>
<h2 id="7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked"><a href="#7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked" class="headerlink" title="7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked"></a>7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked</h2><p>now是当前应该被触发的sw vsync时间点，可能是sf vsync也可能是app vsync。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为什么是拿一个vsync周期前的时间点呢？</span></span><br><span class="line">    <span class="type">nsecs_t</span> onePeriodAgo = now - mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算各个EventListener(也就是sf 和app EventThread)的对应的下一次vsync时间.</span></span><br><span class="line">    <span class="comment">// 因为对于时间点now来讲，sf 和 app的下一次vsync时间可能尚未到来。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], onePeriodAgo);</span><br><span class="line">        <span class="comment">// 如果下一次vsync时间尚未到达，这一次就不通知给对应EventListener</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;</span><br><span class="line">            CallbackInvocation ci;</span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">            ci.mEventTime = t;</span><br><span class="line">            callbackInvocations.<span class="built_in">push</span>(ci);</span><br><span class="line">            <span class="comment">// 记录本次sw Vsync时间点</span></span><br><span class="line">            mEventListeners.<span class="built_in">editItemAt</span>(i).mLastEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完这个方法，其实不难理解，DispSyncThread中的targetTime是变化的值，有可能是app EventThread的下一次sw vsync时间，也可能是sf的。如下图：</p>
<p><img src="/.io//2_3.png" alt="图片"></p>
<p>到这里，sw vsync的流程基本梳理完毕了。</p>
<p>接下来继续看EventThread.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li>
<li><a target="_blank" rel="noopener" href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li>
<li><a target="_blank" rel="noopener" href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-1-SFEventThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/SurfaceFlinger-1-SFEventThread/" class="post-title-link" itemprop="url">SurfaceFlinger(1)--SFEventThread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-04 09:52:04 / 修改时间：10:13:32" itemprop="dateCreated datePublished" datetime="2022-04-04T09:52:04+08:00">2022-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/SurfaceFlinger/" itemprop="url" rel="index"><span itemprop="name">SurfaceFlinger</span></a>
                </span>
            </span>

          
            <span id="/2022/04/04/SurfaceFlinger-1-SFEventThread/" class="post-meta-item leancloud_visitors" data-flag-title="SurfaceFlinger(1)--SFEventThread" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/04/04/SurfaceFlinger-1-SFEventThread/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/04/04/SurfaceFlinger-1-SFEventThread/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<h1 id="一-SFEventThread"><a href="#一-SFEventThread" class="headerlink" title="一. SFEventThread"></a>一. SFEventThread</h1><ol>
<li>EventControlThread: 控制硬件vsync的开关</li>
<li>DispSyncThread: 软件产生vsync的线程</li>
<li>SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染</li>
<li>App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图</li>
</ol>
<p>从这4个线程，可以将vsync分为4种不同的类型</p>
<ol>
<li>HW vsync, 真实由硬件产生的vsync信号</li>
<li>SW vsync, 由DispSync产生的vsync信号</li>
<li>SF vsync,  SF接收到的vsync信号</li>
<li>App vsync, App接收到的vsync信号</li>
</ol>
<p>这里我们着重看看SF EventThread.</p>
<h2 id="1-1-BitTube"><a href="#1-1-BitTube" class="headerlink" title="1.1 BitTube"></a>1.1 BitTube</h2><p>先大致了解下BitTube，其实现是socketpairt套接字，用于传递消息。<br>Buffer大小是4KB。</p>
<h1 id="二-EventThread启动"><a href="#二-EventThread启动" class="headerlink" title="二. EventThread启动"></a>二. EventThread启动</h1><h2 id="2-1-SurfaceFlinger-init"><a href="#2-1-SurfaceFlinger-init" class="headerlink" title="2.1 SurfaceFlinger.init"></a>2.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    mEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,</span><br><span class="line">                                             <span class="literal">true</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">    mEventThread = std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                       [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                       impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>(),</span><br><span class="line">                                                       <span class="string">&quot;appEventThread&quot;</span>);</span><br><span class="line">    mSfEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,</span><br><span class="line">                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;sf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSFEventThread =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mSfEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                    mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                <span class="string">&quot;sfEventThread&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意传入的偏移是不同的。</p>
<ol>
<li>app EventThread : vsyncPhaseOffsetNs &#x3D; 2000000ns</li>
<li>sf EventThread : sfVsyncPhaseOffsetNs &#x3D; 6000000ns</li>
</ol>
<p>这个值是编译期间固定的，定义在BoardConfig.mk中</p>
<h2 id="2-2-EventThread初始化"><a href="#2-2-EventThread初始化" class="headerlink" title="2.2 EventThread初始化"></a>2.2 EventThread初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">EventThread::<span class="built_in">EventThread</span>(VSyncSource* src, ResyncWithRateLimitCallback resyncWithRateLimitCallback,</span><br><span class="line">                         InterceptVSyncsCallback interceptVSyncsCallback, <span class="type">const</span> <span class="type">char</span>* threadName)</span><br><span class="line">      : <span class="built_in">mVSyncSource</span>(src),</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>(resyncWithRateLimitCallback),</span><br><span class="line">        <span class="built_in">mInterceptVSyncsCallback</span>(interceptVSyncsCallback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; event : mVSyncEvent) &#123;</span><br><span class="line">        event.header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        event.header.id = <span class="number">0</span>;</span><br><span class="line">        event.header.timestamp = <span class="number">0</span>;</span><br><span class="line">        event.vsync.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定thread函数</span></span><br><span class="line">    mThread = std::<span class="built_in">thread</span>(&amp;EventThread::threadMain, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置thread名称</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), threadName);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> EVENT_THREAD_PRIORITY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = EVENT_THREAD_PRIORITY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_setschedparam</span>(mThread.<span class="built_in">native_handle</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for EventThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-EventThread-threadMain"><a href="#2-3-EventThread-threadMain" class="headerlink" title="2.3 EventThread.threadMain"></a>2.3 EventThread.threadMain</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (mKeepRunning) &#123;</span><br><span class="line">        DisplayEventReceiver::Event event;</span><br><span class="line">        Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">        <span class="comment">// 2.4 阻塞等待事件</span></span><br><span class="line">        signalConnections = <span class="built_in">waitForEventLocked</span>(&amp;lock, &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分发事件给connection</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> count = signalConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="function"><span class="type">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line">            <span class="comment">// 2.5 分发事件</span></span><br><span class="line">            <span class="type">status_t</span> err = conn-&gt;<span class="built_in">postEvent</span>(event);</span><br><span class="line">            <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">                <span class="comment">// The destination doesn&#x27;t accept events anymore, it&#x27;s probably</span></span><br><span class="line">                <span class="comment">// full. For now, we just drop the events on the floor.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> Note that some events cannot be dropped and would have</span></span><br><span class="line">                <span class="comment">// to be re-sent later.</span></span><br><span class="line">                <span class="comment">// Right-now we don&#x27;t have the ability to do this.</span></span><br><span class="line">                <span class="comment">//ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;, event.header.type,</span></span><br><span class="line">                <span class="comment">//      conn.get());</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// handle any other error on the pipe as fatal. the only</span></span><br><span class="line">                <span class="comment">// reasonable thing to do is to clean-up this connection.</span></span><br><span class="line">                <span class="comment">// The most common error we&#x27;ll get here is -EPIPE.</span></span><br><span class="line">                <span class="built_in">removeDisplayEventConnectionLocked</span>(signalConnections[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-EventThread-waitForEventLocked"><a href="#2-4-EventThread-waitForEventLocked" class="headerlink" title="2.4 EventThread.waitForEventLocked"></a>2.4 EventThread.waitForEventLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will return when (1) a vsync event has been received, and (2) there was</span></span><br><span class="line"><span class="comment">// at least one connection interested in receiving it when we started waiting.</span></span><br><span class="line">Vector&lt;sp&lt;EventThread::Connection&gt; &gt; EventThread::<span class="built_in">waitForEventLocked</span>(</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt;* lock, DisplayEventReceiver::Event* event) &#123;</span><br><span class="line">    Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (signalConnections.<span class="built_in">isEmpty</span>() &amp;&amp; mKeepRunning) &#123;</span><br><span class="line">        <span class="type">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// 当timestamp不为0时，说明有事件发生</span></span><br><span class="line">                <span class="keyword">if</span> (mInterceptVSyncsCallback) &#123;</span><br><span class="line">                    <span class="built_in">mInterceptVSyncsCallback</span>(timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                <span class="comment">// 置timestamp为0，标记为当前事件被消费</span></span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mDisplayEventConnections保存的是注册的Connection的,</span></span><br><span class="line">        <span class="comment">// SF EventThread线程里只有一个Connection, 而这个Connection主要是用来渲染</span></span><br><span class="line">        <span class="comment">// 而如果是APP EventThread, 这里会有多个connection</span></span><br><span class="line">        <span class="type">size_t</span> count = mDisplayEventConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; count) &#123;</span><br><span class="line">            <span class="comment">// 没有vsync事件， 来看下是否有其它pending的event, 这里主要是hotplug的事件</span></span><br><span class="line">            eventPending = !mPendingEvents.<span class="built_in">isEmpty</span>();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;</span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];</span><br><span class="line">                mPendingEvents.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count;) &#123;</span><br><span class="line">            <span class="function">sp&lt;Connection&gt; <span class="title">connection</span><span class="params">(mDisplayEventConnections[i].promote())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// Connection-&gt;count的值大小含义如下：</span></span><br><span class="line">                <span class="comment">// 1. &gt;=1:  表示持续接收Vsync信号</span></span><br><span class="line">                <span class="comment">// 2. ==0:  只接收一次Vsync信号</span></span><br><span class="line">                <span class="comment">// 3. ==-1: 不接收Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果有 connection-&gt;count &gt;= 0，说明需要Vsync信号</span></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123; <span class="comment">// 大于0.说明有事件</span></span><br><span class="line">                        <span class="comment">// 处理本次事件</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                   (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don&#x27;t have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn&#x27;t promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.<span class="built_in">removeAt</span>(i);</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 收到Vsync信号，但是没有Connection监听，所以关闭Vsync</span></span><br><span class="line">            <span class="built_in">disableVSyncLocked</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 有Connection监听，但是还没有Vsync信号，所以打开Vsync</span></span><br><span class="line">            <span class="built_in">enableVSyncLocked</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有事件发生</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123; <span class="comment">// 如果有connection监听，则需要等待Vsync事件</span></span><br><span class="line">                <span class="comment">// 以防止硬件Driver出问题，设置一个超时时间16ms</span></span><br><span class="line">                <span class="type">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line">                <span class="keyword">auto</span> timeout = softwareSync ? <span class="number">16</span>ms : <span class="number">1000</span>ms;</span><br><span class="line">                <span class="keyword">if</span> (mCondition.<span class="built_in">wait_for</span>(*lock, timeout) == std::cv_status::timeout) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        <span class="built_in">ALOGW</span>(<span class="string">&quot;Timed out waiting for hw vsync; faking it&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有connection监听，也没有收到事件，则一直等待</span></span><br><span class="line">                mCondition.<span class="built_in">wait</span>(*lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we&#x27;re guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we&#x27;ll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当EventThread初始化进入时，由于没有Connection，timestamp也为0，直接进入waitForEventLocked一直等待。</p>
<h2 id="2-5-EventThread-Connection-postEvent"><a href="#2-5-EventThread-Connection-postEvent" class="headerlink" title="2.5 EventThread.Connection.postEvent"></a>2.5 EventThread.Connection.postEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">postEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过BitTube发送事件。</p>
<h1 id="三-SF-EventThread-添加Connection"><a href="#三-SF-EventThread-添加Connection" class="headerlink" title="三. SF EventThread 添加Connection"></a>三. SF EventThread 添加Connection</h1><h2 id="3-1-SurfaceFlinger-init"><a href="#3-1-SurfaceFlinger-init" class="headerlink" title="3.1 SurfaceFlinger.init"></a>3.1 SurfaceFlinger.init</h2><p>sfEventThread添加Connection是在这个线程启动后就添加的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// mEventQueue就是MessageQueue类的对象</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventThread</span>(mSFEventThread.<span class="built_in">get</span>());</span><br><span class="line">    mVsyncModulator.<span class="built_in">setEventThreads</span>(mSFEventThread.<span class="built_in">get</span>(), mEventThread.<span class="built_in">get</span>());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-MessageQueue-setEventThread"><a href="#3-2-MessageQueue-setEventThread" class="headerlink" title="3.2 MessageQueue.setEventThread"></a>3.2 MessageQueue.setEventThread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(android::EventThread* eventThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventThread == eventThread) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    <span class="comment">// 3.3 创建Connection</span></span><br><span class="line">    mEvents = eventThread-&gt;<span class="built_in">createEventConnection</span>();</span><br><span class="line">    <span class="comment">// 3.4 建立BitTube连接</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 3.5 接受BitTube事件，调用cb_eventReceiver方法</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-EventThread-createEventConnection"><a href="#3-3-EventThread-createEventConnection" class="headerlink" title="3.3 EventThread.createEventConnection"></a>3.3 EventThread.createEventConnection</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;BnDisplayEventConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Connection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThread::Connection::<span class="built_in">Connection</span>(EventThread* eventThread)</span><br><span class="line">      <span class="comment">// 注意这里的count是被赋值为-1，也就是不接收Vsync事件</span></span><br><span class="line">      : <span class="built_in">count</span>(<span class="number">-1</span>), <span class="built_in">mEventThread</span>(eventThread), <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-EventThread-Connection-onFirstRef"><a href="#3-3-1-EventThread-Connection-onFirstRef" class="headerlink" title="3.3.1 EventThread.Connection.onFirstRef"></a>3.3.1 EventThread.Connection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> EventThread::Connection::<span class="built_in">onFirstRef</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Connection对象生成之后，就被注册到其对应的EventThread中</p>
<h3 id="3-3-2-EventThread-registerDisplayEventConnection"><a href="#3-3-2-EventThread-registerDisplayEventConnection" class="headerlink" title="3.3.2 EventThread.registerDisplayEventConnection"></a>3.3.2 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 添加到mDisplayEventConnections集合中</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">    <span class="comment">// waitForEventLocked 可以继续执行了。</span></span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册connection后，waitForEventLocked便可以开始继续执行了。但是由于只有这一个connection，而且这个connection.count 还是 -1，所以最后还是会在waitForEventLocked中一直等待Vsync事件</p>
<h2 id="3-4-EventThread-Connection-stealReceiveChannel"><a href="#3-4-EventThread-Connection-stealReceiveChannel" class="headerlink" title="3.4  EventThread.Connection.stealReceiveChannel"></a>3.4  EventThread.Connection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">stealReceiveChannel</span>(gui::BitTube* outChannel) &#123;</span><br><span class="line">    <span class="comment">// 将Connection的mChannel复制</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-SF-EventThread-connection开始监听Vsync信号"><a href="#3-5-SF-EventThread-connection开始监听Vsync信号" class="headerlink" title="3.5 SF EventThread connection开始监听Vsync信号"></a>3.5 SF EventThread connection开始监听Vsync信号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::initializeDisplays</span><br><span class="line">    SurfaceFlinger::onInitializeDisplays</span><br><span class="line">        SurfaceFlinger::setTransactionState</span><br><span class="line">            SurfaceFlinger::setTransactionFlags</span><br><span class="line">                SurfaceFlinger::signalTransaction</span><br><span class="line">                    MessageQueue::invalidate</span><br><span class="line">                        EventThread::Connection::requestNextVsync</span><br><span class="line">                            EventThread::requestNextVsync</span><br></pre></td></tr></table></figure>
<p>也就是说当显示屏准备完毕，sfEventThread就可以开始监听Vsync信号了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResyncWithRateLimitCallback) &#123;</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>; <span class="comment">// 只接受一次Vsync信号</span></span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-MessageQueue-cb-eventReceiver-处理Vsync信号"><a href="#3-6-MessageQueue-cb-eventReceiver-处理Vsync信号" class="headerlink" title="3.6 MessageQueue.cb_eventReceiver 处理Vsync信号"></a>3.6 MessageQueue.cb_eventReceiver 处理Vsync信号</h2><p>当SF EventThread收到Vsync信号时，最终会通过BitTube发送给对应connection的receiver[2.5]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-1-MessageQueue-Handler-dispatchInvalidate"><a href="#3-6-1-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="3.6.1 MessageQueue.Handler.dispatchInvalidate"></a>3.6.1 MessageQueue.Handler.dispatchInvalidate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转到SufaceFlinger主线程中处理了。</p>
<h1 id="四-开启硬件Vsync"><a href="#四-开启硬件Vsync" class="headerlink" title="四. 开启硬件Vsync"></a>四. 开启硬件Vsync</h1><h2 id="4-1-EventThread-enableVSyncLocked"><a href="#4-1-EventThread-enableVSyncLocked" class="headerlink" title="4.1 EventThread.enableVSyncLocked"></a>4.1 EventThread.enableVSyncLocked</h2><p>当显示屏准备完毕后，SF EventThread请求一次Vsync信号。那么走到waitForEventLocked中，会调用enableVSyncLocked方法开启硬件Vsync信号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::enableVSyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mUseSoftwareVSync) &#123; </span><br><span class="line">        <span class="comment">// mUseSoftwareVSync也就是显示屏power状态</span></span><br><span class="line">        <span class="comment">// 灭屏为true，亮屏置为false</span></span><br><span class="line">        <span class="keyword">if</span> (!mVsyncEnabled) &#123;</span><br><span class="line">            mVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setCallback</span>(<span class="keyword">this</span>);</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setVSyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mDebugVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-DispSyncSource-setVSyncEnabled"><a href="#4-2-DispSyncSource-setVSyncEnabled" class="headerlink" title="4.2 DispSyncSource.setVSyncEnabled"></a>4.2 DispSyncSource.setVSyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSyncSource::setVSyncEnabled</span><span class="params">(<span class="type">bool</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mVsyncMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">addEventListener</span>(mName, mPhaseOffset,</span><br><span class="line">                                                   <span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                   mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error registering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 1);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">removeEventListener</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                      &amp;mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error unregistering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启Vsync信号就是添加EventListener，关闭就是将这个listener移除</p>
<h2 id="4-3-DispSync-addEventListener"><a href="#4-3-DispSync-addEventListener" class="headerlink" title="4.3 DispSync.addEventListener"></a>4.3 DispSync.addEventListener</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DispSync::addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> mThread-&gt;<span class="built_in">addEventListener</span>(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是到了DispSync部分了。</p>
<p>大致流程如下：</p>
<p><img src="/.io//1_1.png" alt="图片"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/" class="post-title-link" itemprop="url">App申请帧率(4)--SF切换帧率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:54:03 / 修改时间：04:00:41" itemprop="dateCreated datePublished" datetime="2022-02-27T03:54:03+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Vsync/" itemprop="url" rel="index"><span itemprop="name">Vsync</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/" class="post-meta-item leancloud_visitors" data-flag-title="App申请帧率(4)--SF切换帧率" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下分析基于Android R.</p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。</p>
<p>接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/" class="post-title-link" itemprop="url">App申请帧率(3)--SF计算最佳帧率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:53:53 / 修改时间：04:00:06" itemprop="dateCreated datePublished" datetime="2022-02-27T03:53:53+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Vsync/" itemprop="url" rel="index"><span itemprop="name">Vsync</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/" class="post-meta-item leancloud_visitors" data-flag-title="App申请帧率(3)--SF计算最佳帧率" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下分析基于Android R.</p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一章我们分析了App是如何通过更改一个小小的WindowManager的LayoutParam的属性，来影响Framework决策帧率变化的。</p>
<p>接来下我们详细看看SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/" class="post-title-link" itemprop="url">App申请帧率(2)--Framework选择最近帧率范围</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:53:41 / 修改时间：03:58:50" itemprop="dateCreated datePublished" datetime="2022-02-27T03:53:41+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Vsync/" itemprop="url" rel="index"><span itemprop="name">Vsync</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/" class="post-meta-item leancloud_visitors" data-flag-title="App申请帧率(2)--Framework选择最近帧率范围" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以下分析基于Android Q.</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/" class="post-title-link" itemprop="url">App申请帧率(1)--简述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:53:29 / 修改时间：03:58:12" itemprop="dateCreated datePublished" datetime="2022-02-27T03:53:29+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Vsync/" itemprop="url" rel="index"><span itemprop="name">Vsync</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/" class="post-meta-item leancloud_visitors" data-flag-title="App申请帧率(1)--简述" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- TOC -->

<ul>
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%8F%AF%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%B7%E6%96%B0%E7%8E%87%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87">查看设备可支持的刷新率和分辨率</a></li>
<li><a href="#app%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E5%B8%A7%E7%8E%87">App设置设备帧率</a><ul>
<li><a href="#android-q%E5%8F%8A%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC">Android Q及以下版本</a></li>
<li><a href="#android-r">Android R</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着手机屏幕硬件能力的提升，越来越多的厂商提供支持多档次刷新率的Android设备。<br>而在Android Q上也是支持App指定当前屏幕帧率的，也有一套帧率分辨率切换的逻辑。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Looper-Android中的消息机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:48:26 / 修改时间：03:57:34" itemprop="dateCreated datePublished" datetime="2022-02-27T03:48:26+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Looper/" itemprop="url" rel="index"><span itemprop="name">Looper</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="Looper-Android中的消息机制" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div style="page-break-after: always;"></div>

<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文详细分析android的消息机制Looper的底层原理。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/" class="post-title-link" itemprop="url">Vulkan入门(15)-图像视图和采样器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:35:34 / 修改时间：03:44:47" itemprop="dateCreated datePublished" datetime="2022-02-27T03:35:34+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(15)-图像视图和采样器" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>回顾上一篇章中的读取图像的步骤:</p>
<ol>
<li>首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存</li>
<li>通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象</li>
<li>用VkBuffer图像文件中的像素填充创建的VkImage图像对象<ol>
<li>填充图像对象需要使用VkImageMemoryBarrier</li>
<li>使用vkCmdPipelineBarrier使得图像填充Barrier生效</li>
<li>通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充)</li>
<li>再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样</li>
</ol>
</li>
<li>创建图像视图和图像采样器</li>
<li>添加一个组合的图像采样器描述符来从纹理中采样颜色</li>
</ol>
<p>在图像采样器创建之前，我们首先看看纹理图像视图，这个是在我们创建交换链的时候见过:</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/" class="post-title-link" itemprop="url">Vulkan入门(14)-VkImage图像的创建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:35:18 / 修改时间：03:44:04" itemprop="dateCreated datePublished" datetime="2022-02-27T03:35:18+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(14)-VkImage图像的创建" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在之前我们使用顶点着色器以及描述符来实现绘制有颜色的几何体，还实现了旋转动画。接下来我们学习一下纹理贴图，这个将是我们实现加载绘制基本3D模型的基础。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Vulkan入门(13)-描述符布局及缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:34:54 / 修改时间：03:43:22" itemprop="dateCreated datePublished" datetime="2022-02-27T03:34:54+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(13)-描述符布局及缓存" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/" class="post-title-link" itemprop="url">Vulkan入门(12)-暂存缓冲和索引缓冲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:34:41 / 修改时间：03:42:33" itemprop="dateCreated datePublished" datetime="2022-02-27T03:34:41+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(12)-暂存缓冲和索引缓冲" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>虽然现在我们创建的顶点缓冲区工作正常，但是从CPU访问它的内存类型可能不是图形显卡本身读取的最佳内存类型，最理想的内存具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT位标志，并且通常不可由专用图形显卡上的CPU访问。而且我们上一篇最后实现的随鼠标移动的功能也没有考虑同步，简单一点，考虑读写分离。</p>
<p>现在创建两个顶点缓冲区：CPU可访问内存中的一个暂存缓冲区用于从顶点数组上传数据，最终顶点缓冲区位于设备本地内存中。然后我们将使用一个缓冲区复制命令将数据从暂存缓冲区移动到实际的顶点缓冲区。简单来说就是暂存缓冲区用于cpu写入，顶点缓冲区用于GPU读取数据。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/" class="post-title-link" itemprop="url">Vulkan入门(11)-顶点输入描述及顶点缓冲的创建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:34:26 / 修改时间：03:41:34" itemprop="dateCreated datePublished" datetime="2022-02-27T03:34:26+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(11)-顶点输入描述及顶点缓冲的创建" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>接下来，我们将用内存中的顶点缓冲区替换顶点着色器中的硬编码顶点数据。我们将从创建CPU可见缓冲区的最简单方法开始，并使用memcpy将顶点数据直接复制到其中，然后我们将看到如何使用分段缓冲区将顶点数据复制到高性能内存。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/" class="post-title-link" itemprop="url">Vulkan入门(10)-重建交换链</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:34:10 / 修改时间：03:40:23" itemprop="dateCreated datePublished" datetime="2022-02-27T03:34:10+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(10)-重建交换链" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在上一篇里，我们已经成功绘制了一个颜色渐变的三角形，并将其显示在窗口上了。但是窗口Surface可能会发生变化，从而使交换链不再与之兼容，比如是窗口大小的变化。所以我们必须捕获这些事件并重新创建交换链。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/" class="post-title-link" itemprop="url">Vulkan入门(9)-渲染和显示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:33:58 / 修改时间：03:39:31" itemprop="dateCreated datePublished" datetime="2022-02-27T03:33:58+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(9)-渲染和显示" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在这一章里，所有的事情都要集中起来。我们将编写drawFrame函数，该函数将在主循环中被调用，以将三角形置于屏幕上。创建函数并从mainLoop调用它.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        <span class="built_in">drawFrame</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/" class="post-title-link" itemprop="url">Vulkan入门(8)-帧缓冲区和指令缓冲区</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:33:45 / 修改时间：03:39:14" itemprop="dateCreated datePublished" datetime="2022-02-27T03:33:45+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(8)-帧缓冲区和指令缓冲区" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Framebuffers, 帧缓冲区。之前我们在学习’Swap Chain-交换链’时提到Vulkan没有“默认帧缓冲区”的概念，取而代之的是名为 “swap chain” 即交换链，也就是渲染的缓冲区，必须在Vulkan中明确创建。 现在我们已经设置了渲染过程，以期望使用与交换链图像相同格式的单个帧缓冲区，但实际上我们还没有创建任何帧缓冲区。</p>
<p>通过将渲染过程创建期间指定的附件包装到VkFramebuffer对象中来绑定附件。</p>
<p>帧缓冲区对象引用表示附件的所有VkImageView对象。在我们的情况下，这将只是一个单一的：颜色附件。但是，我们必须用于附件的图像取决于在检索用于表示的图像时交换链返回的图像。这意味着我们必须为交换链中的所有图像创建一个帧缓冲区，并使用与绘制时检索到的图像相对应的帧缓冲区。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/" class="post-title-link" itemprop="url">Vulkan入门(7)-渲染过程及创建图形管道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:22:14 / 修改时间：03:29:57" itemprop="dateCreated datePublished" datetime="2022-02-27T03:22:14+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(7)-渲染过程及创建图形管道" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Render passes, 即渲染过程。在完成创建管道之前，我们需要告诉Vulkan渲染时将使用的帧缓冲区附件。</p>
<p>我们需要指定将有多少颜色和深度缓冲区，为每个缓冲区使用多少个样本，以及在整个渲染操作中应如何处理它们的内容。</p>
<p>所有这些信息都包装在一个render pass对象中，为其创建一个新的createRenderPass函数。在createGraphicsPipeline之前从initVulkan调用此函数。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Vulkan入门(6)-创建管道的几个固定操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:22:00 / 修改时间：03:29:09" itemprop="dateCreated datePublished" datetime="2022-02-27T03:22:00+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(6)-创建管道的几个固定操作" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>其他图形API为图形管道的大多数阶段提供了默认状态。但在Vulkan中，必须明确所有内容，从视口大小到颜色混合功能。<br>接下来我们试着填写配置这些固定功能操作的所有结构。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SwallowJoe"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SwallowJoe</p>
  <div class="site-description" itemprop="description">君子知命不惧，日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swallowjoe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swallowjoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:swallowjoe@foxmail.com" title="E-Mail → mailto:swallowjoe@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.cn/injobs/in/joseph-huang-9597b822b" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.cn&#x2F;injobs&#x2F;in&#x2F;joseph-huang-9597b822b" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>LinkedIn</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwallowJoe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"RfLcPyiwrSaXOBtMHLnzE6S4-gzGzoHsz","app_key":"J0WdcjIXqW9jxT4zOpMG5BeE","server_url":"https://rflcpyiw.lc-cn-n1-shared.com","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RfLcPyiwrSaXOBtMHLnzE6S4-gzGzoHsz',
      appKey     : 'J0WdcjIXqW9jxT4zOpMG5BeE',
      placeholder: "Say something...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://rflcpyiw.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
