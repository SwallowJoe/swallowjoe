<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swallowjoe.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitment","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="简述我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。">
<meta property="og:type" content="article">
<meta property="og:title" content="Vulkan入门(13)-描述符布局及缓存">
<meta property="og:url" content="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/index.html">
<meta property="og:site_name" content="SwallowJoe的博客">
<meta property="og:description" content="简述我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-26T19:34:54.000Z">
<meta property="article:modified_time" content="2022-02-26T19:43:22.440Z">
<meta property="article:author" content="SwallowJoe">
<meta property="article:tag" content="Vulkan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Vulkan入门(13)-描述符布局及缓存 | SwallowJoe的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="SwallowJoe的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SwallowJoe的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Be a real go-getter,<br>NEVER SETTLE!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/swallowjoe" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SwallowJoe">
      <meta itemprop="description" content="君子知命不惧，日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SwallowJoe的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Vulkan入门(13)-描述符布局及缓存
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-02-27 03:34:54 / 修改时间：03:43:22" itemprop="dateCreated datePublished" datetime="2022-02-27T03:34:54+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">图像引擎</span></a>
                </span>
            </span>

          
            <span id="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/" class="post-meta-item leancloud_visitors" data-flag-title="Vulkan入门(13)-描述符布局及缓存" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。</p>
<span id="more"></span>

<p>在Vulkan中解决这个问题的正确方法是使用资源描述符（resource descriptor）。描述符是着色器自由访问缓冲区和图像等资源的一种方式。我们将设置一个包含变换矩阵的缓冲区，并让顶点着色器通过描述符访问它们。描述符的使用包括三个部分：</p>
<ol>
<li>在管道创建期间指定描述符布局</li>
<li>从描述符池分配描述符集</li>
<li>渲染期间绑定描述符集</li>
</ol>
<p>描述符是表示着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。描述符被组织成描述符集，这些描述符集在命令记录期间被绑定，以便在后续的绘制命令中使用。每个描述符集中内容的安排由描述符集布局决定，该布局决定了可以在其中存储哪些描述符。管道可使用的描述符集布局序列在管道布局中指定。每个管道对象最多可以使用maxBoundDescriptorSets(参见限制)描述符集。</p>
<p>描述符布局指定管道要访问的资源类型，就像渲染过程指定要访问的附件类型一样。描述符集指定将绑定到描述符的实际缓冲区或图像资源，就像帧缓冲区指定要绑定到渲染过程附件的实际图像视图一样。然后为绘图命令绑定描述符集，就像顶点缓冲区和帧缓冲区一样。</p>
<p>着色器通过装饰有描述符集和绑定数的变量访问资源，这些变量将它们连接到描述符集中的描述符。着色器接口到绑定描述符集的映射在着色器资源接口部分描述。着色器也可以通过64位地址使用物理存储缓冲区访问，而不需要通过描述符来访问缓冲区。</p>
<p>描述符有很多种类型，这里使用统一缓冲区对象(UBO)。如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UniformBufferObject</span> &#123;</span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    glm::mat4 view;</span><br><span class="line">    glm::mat4 proj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用GLM中的数据类型精确匹配着色器中的定义。矩阵中的数据与着色器期望的方式是二进制兼容的，因此我们可以稍后将UniformBufferObject的memcpy转换为VkBuffer。</p>
<p>需要更改顶点着色器:</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> UniformBufferObject &#123;</span><br><span class="line">    <span class="type">mat4</span> model;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">    <span class="type">mat4</span> proj;</span><br><span class="line">&#125; ubo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定指令类似于属性的位置指令。 我们将在描述符布局中引用此绑定。 更改了带有gl_Position的行，以使用转换来计算剪辑坐标中的最终位置。 与2D三角形不同，剪辑坐标的最后一个分量可能不是1，这在转换为屏幕上的最终归一化设备坐标时将导致除法。 这在透视投影中用作透视划分，对于使较近的对象看起来比较远的对象看起来更大，这是必不可少的。</p>
<h1 id="一-描述符集布局"><a href="#一-描述符集布局" class="headerlink" title="一. 描述符集布局"></a>一. 描述符集布局</h1><p>我们需要提供着色器中用于管道创建的每个描述符绑定的详细信息，就像我们必须为每个顶点属性及其位置索引所做的那样。我们将设置一个新函数来定义所有这些信息，称为createDescriptorSetLayout。在创建管道之前应该调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorSetLayout</span>();</span><br><span class="line">    <span class="built_in">createGraphicsPipeline</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个绑定都需要通过VkDescriptorSetLayoutBinding结构来描述。前两个字段指定在着色器中使用的绑定和描述符的类型，该描述符是一个统一的缓冲区对象。着色器变量可能表示一个统一缓冲区对象的数组，而描述符计数指定该数组中值的数量。 例如，这可用于为骨骼动画指定骨骼中每个骨骼的变换。 我们的MVP转换位于单个统一缓冲区对象中，因此我们使用的描述符数为1。</p>
<h2 id="1-1-VkDescriptorSetLayoutBinding"><a href="#1-1-VkDescriptorSetLayoutBinding" class="headerlink" title="1.1 VkDescriptorSetLayoutBinding"></a>1.1 VkDescriptorSetLayoutBinding</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutBinding</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>              binding;</span><br><span class="line">    VkDescriptorType      descriptorType;</span><br><span class="line">    <span class="type">uint32_t</span>              descriptorCount;</span><br><span class="line">    VkShaderStageFlags    stageFlags;</span><br><span class="line">    <span class="type">const</span> VkSampler*      pImmutableSamplers;</span><br><span class="line">&#125; VkDescriptorSetLayoutBinding;</span><br></pre></td></tr></table></figure>
<ol>
<li>binding是此条目的绑定号，并且与着色器阶段中具有相同绑定号的资源相对应。</li>
<li>descriptorType是VkDescriptorType，它指定用于此绑定的资源描述符的类型。</li>
<li>descriptorCount是绑定中包含的描述符数量，在着色器中以数组形式访问，除非描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，在这种情况下，描述符计数是嵌入式统一块的字节大小。如果描述符计数为零，则此绑定条目被保留，并且不得使用设置的布局在任何管道内通过任何绑定从任何阶段访问资源。</li>
<li>stageFlags成员是VkShaderStageFlagBits的位掩码，用于指定哪些管道着色器阶段可以访问此绑定的资源。 VK_SHADER_STAGE_ALL是一种简写形式，用于指定所有定义的着色器阶段，包括扩展定义的任何其他阶段，都可以访问该资源。如果stageFlags中未包含着色器阶段，则不得使用设置的布局在任何管道中通过此绑定从该阶段访问资源。除了限于片段着色器的输入附件之外，对于阶段的哪些组合可以使用描述符绑定没有任何限制，特别是图形阶段和计算阶段都可以使用绑定。</li>
<li>pImmutableSamplers影响采样器的初始化。如果描述符类型指定VK_DESCRIPTOR_TYPE_SAMPLER或VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型描述符，则可以使用pImmutableSamplers初始化一组不可变的采样器。不可变的采样器永久绑定到设置的布局中，不得更改。不允许使用不可变采样器更新VK_DESCRIPTOR_TYPE_SAMPLER描述符，并且使用不可变采样器更新VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER描述符不会修改采样器（将更新图像视图，但会忽略采样器更新）。如果pImmutableSamplers不为NULL，则它指向一个采样器句柄数组，该数组将被复制到set布局中并用于相应的绑定。仅采样器句柄被复制；在最终使用集合布局以及使用它创建的任何描述符池和集合之前，不得破坏采样器对象。如果pImmutableSamplers为NULL，则采样器插槽是动态的，必须使用此布局将采样器句柄绑定到描述符集中。如果描述符类型不是这些描述符类型之一，则将忽略pImmutableSamplers。</li>
</ol>
<h3 id="1-1-1-VkDescriptorType"><a href="#1-1-1-VkDescriptorType" class="headerlink" title="1.1.1 VkDescriptorType"></a>1.1.1 VkDescriptorType</h3><p>其中描述符的类型VkDescriptorType有如下取值:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkDescriptorType</span> &#123;</span><br><span class="line">    VK_DESCRIPTOR_TYPE_SAMPLER = <span class="number">0</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = <span class="number">1</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = <span class="number">2</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = <span class="number">3</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = <span class="number">4</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = <span class="number">5</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = <span class="number">6</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = <span class="number">7</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = <span class="number">8</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = <span class="number">9</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = <span class="number">10</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = <span class="number">1000138000</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = <span class="number">1000165000</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkDescriptorType;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_DESCRIPTOR_TYPE_SAMPLER: 指定采样器描述符</li>
<li>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: 指定组合图像采样器描述符</li>
<li>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: 指定采样图像描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: 指定存储映像描述符</li>
<li>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: 指定统一纹理像素缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: 指定存储纹理元素缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: 统一缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: 指定存储缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: 指定动态统一缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: 指定动态存储缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: 指定输入附件描述符</li>
<li>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: 指定内联统一块</li>
</ol>
<h3 id="1-1-2-VkShaderStageFlags"><a href="#1-1-2-VkShaderStageFlags" class="headerlink" title="1.1.2 VkShaderStageFlags"></a>1.1.2 VkShaderStageFlags</h3><p>需要指定一个或多个着色器阶段的命令和结构使用位对应于阶段的位掩码来指定。可以设置为指定着色器阶段的位有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkShaderStageFlagBits</span> &#123;</span><br><span class="line">    VK_SHADER_STAGE_VERTEX_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_SHADER_STAGE_GEOMETRY_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_SHADER_STAGE_FRAGMENT_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_SHADER_STAGE_COMPUTE_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL_GRAPHICS = <span class="number">0x0000001F</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL = <span class="number">0x7FFFFFFF</span>,</span><br><span class="line">    VK_SHADER_STAGE_RAYGEN_BIT_NV = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_SHADER_STAGE_ANY_HIT_BIT_NV = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_SHADER_STAGE_MISS_BIT_NV = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_SHADER_STAGE_INTERSECTION_BIT_NV = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_SHADER_STAGE_CALLABLE_BIT_NV = <span class="number">0x00002000</span>,</span><br><span class="line">    VK_SHADER_STAGE_TASK_BIT_NV = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_SHADER_STAGE_MESH_BIT_NV = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkShaderStageFlagBits;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_SHADER_STAGE_VERTEX_BIT: 顶点阶段</li>
<li>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: 细分控制阶段</li>
<li>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: 细分评估阶段</li>
<li>VK_SHADER_STAGE_GEOMETRY_BIT: 几何图形阶段</li>
<li>VK_SHADER_STAGE_FRAGMENT_BIT: 片段阶段</li>
<li>VK_SHADER_STAGE_COMPUTE_BIT: 计算阶段</li>
<li>VK_SHADER_STAGE_ALL_GRAPHICS: 用作速记的位的组合，用于指定上面定义的所有图形阶段（计算阶段除外）</li>
<li>VK_SHADER_STAGE_ALL: 用作简写的位的组合，用于指定设备支持的所有着色器阶段，包括扩展引入的所有其他阶段</li>
<li>VK_SHADER_STAGE_TASK_BIT_NV: 任务阶段</li>
<li>VK_SHADER_STAGE_MESH_BIT_NV: 网格阶段</li>
<li>VK_SHADER_STAGE_RAYGEN_BIT_NV: 射线生成阶段</li>
<li>VK_SHADER_STAGE_ANY_HIT_BIT_NV: 任何命中阶段</li>
<li>VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: 最接近的命中阶段</li>
<li>VK_SHADER_STAGE_MISS_BIT_NV: 未命中阶段</li>
<li>VK_SHADER_STAGE_INTERSECTION_BIT_NV: 相交阶段</li>
<li>VK_SHADER_STAGE_CALLABLE_BIT_NV: 可调用阶段</li>
</ol>
<h2 id="1-2-创建VkDescriptorSetLayout"><a href="#1-2-创建VkDescriptorSetLayout" class="headerlink" title="1.2 创建VkDescriptorSetLayout"></a>1.2 创建VkDescriptorSetLayout</h2><p>所有描述符绑定都合并到一个vkDescriptorSetLayout对象中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">VkDescriptorSetLayout descriptorSetLayout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;;</span><br><span class="line">    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;</span><br><span class="line">    layoutInfo.bindingCount = <span class="number">1</span>;</span><br><span class="line">    layoutInfo.pBindings = &amp;uboLayoutBinding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建描述符集布局</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorSetLayout</span>(device, &amp;layoutInfo, <span class="literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor set layout!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-VkDescriptorSetLayoutCreateInfo"><a href="#1-2-1-VkDescriptorSetLayoutCreateInfo" class="headerlink" title="1.2.1 VkDescriptorSetLayoutCreateInfo"></a>1.2.1 VkDescriptorSetLayoutCreateInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                            pNext;</span><br><span class="line">    VkDescriptorSetLayoutCreateFlags       flags;</span><br><span class="line">    <span class="type">uint32_t</span>                               bindingCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayoutBinding*    pBindings;</span><br><span class="line">&#125; VkDescriptorSetLayoutCreateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType就是这种结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</li>
<li>pNext为NULL或指向特定于扩展的结构的指针</li>
<li>flags是VkDescriptorSetLayoutCreateFlagBits的位掩码，用于指定描述符集布局创建的选项</li>
<li>bindingCount是pBindings中的元素数</li>
<li>pBindings是指向VkDescriptorSetLayoutBinding结构数组的指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkDescriptorSetLayoutCreateFlagBits</span> &#123;</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkDescriptorSetLayoutCreateFlagBits;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: 指定不得使用此布局分配描述符集，而是由vkCmdPushDescriptorSetKHR推送描述符</li>
<li>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: 指定描述符集使用此布局必须从创建一个描述符池分配VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT位集。描述符集布局创建这部分设置有备用限制描述符的最大数量每级和per-pipeline布局。non-UpdateAfterBind限制仅计数在没有此标志的情况下创建的集合中的描述符。UpdateAfterBind限制计算所有描述符，但是限制可能高于非UpdateAfterBind限制。</li>
</ol>
<h3 id="1-2-2-vkCreateDescriptorSetLayout"><a href="#1-2-2-vkCreateDescriptorSetLayout" class="headerlink" title="1.2.2 vkCreateDescriptorSetLayout"></a>1.2.2 vkCreateDescriptorSetLayout</h3><p>描述符集布局对象由零个或多个描述符绑定的数组定义。每个单独的描述符绑定由描述符类型、绑定中描述符数量的计数（数组大小）、可以访问绑定的一组着色器阶段以及（如果使用不可变采样器）采样器描述符数组指定。</p>
<p>创建描述符集布局可以使用函数: vkCreateDescriptorSetLayout</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorSetLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSetLayout*                      pSetLayout)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建描述符集布局的逻辑设备</li>
<li>pCreateInfo: 指向VkDescriptorSetLayoutCreateInfo结构的指针，它指定了描述符集布局对象的状态</li>
<li>pAllocator: 控制主机内存分配</li>
<li>pSetLayout: 指向VkDescriptorSetLayout句柄的指针，在这个句柄中返回结果描述符集布局对象</li>
</ol>
<p>当然通过vkCreate*创建的对象或资源，一般需要显示销毁:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="built_in">vkDestroyDescriptorSetLayout</span>(device, descriptorSetLayout, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-管道指定描述符集布局"><a href="#1-3-管道指定描述符集布局" class="headerlink" title="1.3 管道指定描述符集布局"></a>1.3 管道指定描述符集布局</h2><p>我们需要在管道创建期间指定描述符集布局，以告诉Vulkan着色器将使用哪些描述符。描述符集布局在管道布局对象中指定。修改VkPipelineLayoutCreateInfo以引用布局对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;;</span><br><span class="line">pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;</span><br><span class="line">pipelineLayoutInfo.setLayoutCount = <span class="number">1</span>;</span><br><span class="line">pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout;</span><br></pre></td></tr></table></figure>
<p>这里留个悬念，为什么可以指定多个描述符集布局。</p>
<h2 id="1-4-统一缓存"><a href="#1-4-统一缓存" class="headerlink" title="1.4 统一缓存"></a>1.4 统一缓存</h2><p>我们将指定包含着色器的UBO数据的缓冲区，但是我们需要首先创建这个缓冲区。我们将在每一帧将新数据复制到统一缓冲区，因此使用暂存缓冲区实际上没有任何意义。在这种情况下，它只会增加额外的开销，而且可能会降低性能。</p>
<p>我们应该有多个缓冲区，因为多个帧可能在同一时间绘制，我们不想更新缓冲区，准备下一帧，而前一帧仍在读取它！我们可以为每个帧或每个交换链图像提供统一的缓冲区。然而，由于我们需要从每个交换链映像所拥有的命令缓冲区引用统一缓冲区，因此最好也为每个交换链映像创建一个统一缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">VkBuffer indexBuffer;</span><br><span class="line">VkDeviceMemory indexBufferMemory;</span><br><span class="line"></span><br><span class="line">std::vector&lt;VkBuffer&gt; uniformBuffers;</span><br><span class="line">std::vector&lt;VkDeviceMemory&gt; uniformBuffersMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    <span class="built_in">createIndexBuffer</span>();</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createUniformBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br><span class="line">    uniformBuffers.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    uniformBuffersMemory.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImages.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">                VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">                uniformBuffers[i], uniformBuffersMemory[i],</span><br><span class="line">                VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将编写一个单独的函数，在每一帧用一个新的转换来更新统一缓冲区，所以这里没有vkMapMemory。</p>
<p>统一数据将被用于所有的draw调用，所以包含它的缓冲区只有在我们停止渲染时才会被销毁。因为它也取决于交换链图像的数量，这可能会在重新创建后改变，所以在cleanupSwapChain中清理它:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; uniformBuffers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">vkDestroyBuffer</span>(device, uniformBuffers[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">vkFreeMemory</span>(device, uniformBuffersMemory[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createFramebuffers</span>();</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-更新统一缓存数据"><a href="#1-5-更新统一缓存数据" class="headerlink" title="1.5 更新统一缓存数据"></a>1.5 更新统一缓存数据</h2><p>在绘制更新交换链帧的时候更新统一缓存数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">updateUniformBuffer</span>(imageIndex);</span><br><span class="line"></span><br><span class="line">    VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUniformBuffer</span><span class="params">(<span class="type">uint32_t</span> currentImage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>updateUniformBuffer函数将在每帧生成一个新的变换，以使几何体旋转。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保glm::rotate之类的函数使用弧度作为参数是必要的，以避免任何可能的混淆</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_RADIANS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// chrono标准库标头公开了执行精确计时的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUniformBuffer</span><span class="params">(<span class="type">uint32_t</span> currentImage)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> currentTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 计算时长</span></span><br><span class="line">    <span class="type">float</span> time = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">float</span>, std::chrono::seconds::period&gt;(currentTime - startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    UniformBufferObject ubo = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 在统一缓冲区对象中定义模型，视图和投影转换。 使用时间变量，模型旋转将是围绕Z轴的简单旋转</span></span><br><span class="line">    <span class="comment">// 意思是每秒旋转90度</span></span><br><span class="line">    ubo.model = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), time * glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="comment">// 设置视图角度，从上方以45度角查看几何图形。 glm :: lookAt函数将眼睛位置，中心位置和上轴作为参数。</span></span><br><span class="line">    ubo.view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用具有45度垂直视场的透视投影。</span></span><br><span class="line">    <span class="comment">// 其他参数是长宽比，近视平面和远视平面。 重要的是使用当前交换链范围来计算纵横比，以考虑调整大小后窗口的新宽度和高度。</span></span><br><span class="line">    ubo.proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), swapChainExtent.width / (<span class="type">float</span>) swapChainExtent.height, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLM最初是为OpenGL(左手坐标系)设计的，将其中坐标的Y坐标反转。 最简单的补偿方法是在投影矩阵中翻转Y轴缩放比例上的符号。 </span></span><br><span class="line">    <span class="comment">// 如果不这样做，那么图像将被倒置呈现。</span></span><br><span class="line">    ubo.proj[<span class="number">1</span>][<span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将统一缓冲区对象中的数据复制到当前的统一缓冲区中。 与使用顶点缓冲区的方式完全相同，只是不需要暂存缓冲区（因为每帧都要更新）：</span></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, uniformBuffersMemory[currentImage], <span class="number">0</span>, <span class="built_in">sizeof</span>(ubo), <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;ubo, <span class="built_in">sizeof</span>(ubo));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, uniformBuffersMemory[currentImage]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然此时编译运行程序是不成功的，因为我们仅仅是更新数据，但是没有将描述符集绑定到图形管道中。</p>
<h1 id="二-描述符"><a href="#二-描述符" class="headerlink" title="二. 描述符"></a>二. 描述符</h1><p>前面我们创建了描述符集布局，描述了可以绑定的描述符的类型，现在我们给统一缓冲区的每个缓冲创建一个描述符集，然后将其绑定到统一缓冲区描述符中。</p>
<h2 id="2-1-描述符池"><a href="#2-1-描述符池" class="headerlink" title="2.1 描述符池"></a>2.1 描述符池</h2><p>描述符集无法直接创建，它们必须从命令缓冲区之类的池中分配。描述符集又称为描述符池。 我们将编写一个新函数createDescriptorPool进行设置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorPoolSize poolSize = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 我们创建的是统一缓冲的描述符</span></span><br><span class="line">    poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    poolSize.descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;;</span><br><span class="line">    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;</span><br><span class="line">    poolInfo.poolSizeCount = <span class="number">1</span>;</span><br><span class="line">    poolInfo.pPoolSizes = &amp;poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了可用的单个描述符的最大数量外，还需要指定可以分配的最大描述符集数量：与交换链图像数量一致</span></span><br><span class="line">    poolInfo.maxSets = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 创建描述符池</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorPool</span>(device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要使用VkDescriptorPoolSize结构来描述我们的描述符集将包含哪些描述符类型以及其中有多少个描述符类型。</p>
<h3 id="2-1-1-VkDescriptorPoolSize"><a href="#2-1-1-VkDescriptorPoolSize" class="headerlink" title="2.1.1 VkDescriptorPoolSize"></a>2.1.1 VkDescriptorPoolSize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolSize</span> &#123;</span><br><span class="line">    VkDescriptorType    type;</span><br><span class="line">    <span class="type">uint32_t</span>            descriptorCount;</span><br><span class="line">&#125; VkDescriptorPoolSize;</span><br></pre></td></tr></table></figure>
<ol>
<li>type是描述符的类型</li>
<li>descriptorCount是要分配的该类型的描述符数。如果类型是VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则descriptorCount是要为此类型的描述符分配的字节数</li>
</ol>
<h3 id="2-1-2-VkDescriptorPoolCreateInfo"><a href="#2-1-2-VkDescriptorPoolCreateInfo" class="headerlink" title="2.1.2 VkDescriptorPoolCreateInfo"></a>2.1.2 VkDescriptorPoolCreateInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                    pNext;</span><br><span class="line">    VkDescriptorPoolCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                       maxSets;</span><br><span class="line">    <span class="type">uint32_t</span>                       poolSizeCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorPoolSize*    pPoolSizes;</span><br><span class="line">&#125; VkDescriptorPoolCreateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType是此结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>flags是VkDescriptorPoolCreateFlagBits的位掩码，用于指定池中某些受支持的操作</li>
<li>maxSets是可以从池中分配的描述符集的最大数量</li>
<li>poolSizeCount是pPoolSizes中的元素数</li>
<li>pPoolSizes是一个指向VkDescriptorPoolSize结构数组的指针，每个结构都包含一个描述符类型和要在池中分配的该类型的描述符数量</li>
</ol>
<h3 id="2-1-3-vkCreateDescriptorPool"><a href="#2-1-3-vkCreateDescriptorPool" class="headerlink" title="2.1.3 vkCreateDescriptorPool"></a>2.1.3 vkCreateDescriptorPool</h3><p>描述符池维护着一个描述符池，从中分配描述符集。 描述符池是外部同步的，这意味着应用程序不得同时从多个线程中的同一池中分配和&#x2F;或释放描述符集。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorPoolCreateInfo*           pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorPool*                           pDescriptorPool)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建描述符池的逻辑设备</li>
<li>pCreateInfo: 指向VkDescriptorPoolCreateInfo结构的指针，该结构指定描述符池对象的状态</li>
<li>pAllocator: 内存分配</li>
<li>pDescriptorPool: 指向VkDescriptorPool句柄的指针，在该句柄中返回生成的描述符池对象</li>
</ol>
<p>别忘了手动清理描述符池：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">vkDestroyDescriptorPool</span>(device, descriptorPool, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-描述符集"><a href="#2-2-描述符集" class="headerlink" title="2.2 描述符集"></a>2.2 描述符集</h2><p>有了描述符池就可以分配描述符集了。为此添加createDescriptorSets函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">VkDescriptorPool descriptorPool;</span><br><span class="line">std::vector&lt;VkDescriptorSet&gt; descriptorSets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createDescriptorSets</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createDescriptorSets</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;VkDescriptorSetLayout&gt; <span class="title">layouts</span><span class="params">(swapChainImages.size(), descriptorSetLayout)</span></span>;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.descriptorPool = descriptorPool;</span><br><span class="line">    allocInfo.descriptorSetCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    allocInfo.pSetLayouts = layouts.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 重置大小</span></span><br><span class="line">    descriptorSets.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 内存分配描述符集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateDescriptorSets</span>(device, &amp;allocInfo, descriptorSets.<span class="built_in">data</span>()) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate descriptor sets!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; descriptorSets.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 引用缓冲区的描述符（例如我们的统一缓冲区描述符）使用VkDescriptorBufferInfo结构进行配置</span></span><br><span class="line">        <span class="comment">// 指定缓冲区以及其中包含描述符数据的区域。</span></span><br><span class="line">        VkDescriptorBufferInfo bufferInfo = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 绑定缓冲区</span></span><br><span class="line">        bufferInfo.buffer = uniformBuffers[i];</span><br><span class="line">        bufferInfo.offset = <span class="number">0</span>;</span><br><span class="line">        bufferInfo.range = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br><span class="line"></span><br><span class="line">        VkWriteDescriptorSet descriptorWrite = &#123;&#125;;</span><br><span class="line">        descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">        descriptorWrite.dstSet = descriptorSets[i];</span><br><span class="line">        descriptorWrite.dstBinding = <span class="number">0</span>;</span><br><span class="line">        descriptorWrite.dstArrayElement = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">        descriptorWrite.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        descriptorWrite.pBufferInfo = &amp;bufferInfo;</span><br><span class="line">        descriptorWrite.pImageInfo = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">        descriptorWrite.pTexelBufferView = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用描述符集更新</span></span><br><span class="line">        <span class="built_in">vkUpdateDescriptorSets</span>(device, <span class="number">1</span>, &amp;descriptorWrite, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>描述符集分配用VkDescriptorSetAllocateInfo结构描述。需要指定要从中分配的描述符池、要分配的描述符集的数量以及基于它们的描述符布局。</p>
<h3 id="2-2-1-VkDescriptorSetAllocateInfo"><a href="#2-2-1-VkDescriptorSetAllocateInfo" class="headerlink" title="2.2.1 VkDescriptorSetAllocateInfo"></a>2.2.1 VkDescriptorSetAllocateInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType                 sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                     pNext;</span><br><span class="line">    VkDescriptorPool                descriptorPool;</span><br><span class="line">    <span class="type">uint32_t</span>                        descriptorSetCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayout*    pSetLayouts;</span><br><span class="line">&#125; VkDescriptorSetAllocateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType是此结构的类型</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>descriptorPool是从中分配集合的池</li>
<li>descriptorSetCount确定要从池中分配的描述符集的数量</li>
<li>pSetLayouts是一个指向描述符集布局数组的指针，每个成员指定如何分配相应的描述符集</li>
</ol>
<h3 id="2-2-2-vkAllocateDescriptorSets"><a href="#2-2-2-vkAllocateDescriptorSets" class="headerlink" title="2.2.2 vkAllocateDescriptorSets"></a>2.2.2 vkAllocateDescriptorSets</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetAllocateInfo*          pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSet*                            pDescriptorSets)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 拥有描述符池的逻辑设备</li>
<li>pAllocateInfo: 指向VkDescriptorSetAllocateInfo结构的指针，该结构描述分配参数</li>
<li>pDescriptorSets: 指向VkDescriptorSet句柄数组的指针，在该数组中返回生成的描述符集对象</li>
</ol>
<p>无需手动清理描述符集，因为在销毁描述符池时，会自动释放描述符集。 对vkAllocateDescriptorSets的调用将分配描述符集，每个描述符集具有一个统一的缓冲区描述符。</p>
<h3 id="2-2-3-VkDescriptorBufferInfo"><a href="#2-2-3-VkDescriptorBufferInfo" class="headerlink" title="2.2.3 VkDescriptorBufferInfo"></a>2.2.3 VkDescriptorBufferInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorBufferInfo</span> &#123;</span><br><span class="line">    VkBuffer        buffer;</span><br><span class="line">    VkDeviceSize    offset;</span><br><span class="line">    VkDeviceSize    range;</span><br><span class="line">&#125; VkDescriptorBufferInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>buffer是缓冲区资源</li>
<li>offset是从缓冲区开始的偏移量（以字节为单位）。 通过此描述符访问缓冲存储器将使用相对于此起始偏移量的寻址</li>
<li>range是用于此描述符更新的大小（以字节为单位），或者是VK_WHOLE_SIZE以使用从偏移量到缓冲区末尾的范围</li>
</ol>
<h3 id="2-2-4-VkWriteDescriptorSet"><a href="#2-2-4-VkWriteDescriptorSet" class="headerlink" title="2.2.4 VkWriteDescriptorSet"></a>2.2.4 VkWriteDescriptorSet</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkWriteDescriptorSet</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkDescriptorSet                  dstSet;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstBinding;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstArrayElement;</span><br><span class="line">    <span class="type">uint32_t</span>                         descriptorCount;</span><br><span class="line">    VkDescriptorType                 descriptorType;</span><br><span class="line">    <span class="type">const</span> VkDescriptorImageInfo*     pImageInfo;</span><br><span class="line">    <span class="type">const</span> VkDescriptorBufferInfo*    pBufferInfo;</span><br><span class="line">    <span class="type">const</span> VkBufferView*              pTexelBufferView;</span><br><span class="line">&#125; VkWriteDescriptorSet;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType是此结构的类型, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>dstSet是要更新的目标描述符集</li>
<li>dstBinding是该集合内的描述符绑定</li>
<li>dstArrayElement是该数组中的起始元素。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则dstArrayElement指定绑定内的起始字节偏移量</li>
<li>descriptorCount是要更新的描述符的数量（pImageInfo，pBufferInfo或pTexelBufferView中的元素数量，或者与pNext链中的VkWriteDescriptorSetInlineUniformBlockEXT结构的dataSize成员匹配的值，或者与pNext中的VkWriteDescriptorSetAccelerationStructureNV结构的AccelerationStructureCount匹配的值。链 ）。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则描述符计数指定要更新的字节数</li>
<li>descriptorType是VkDescriptorType，用于指定pImageInfo，pBufferInfo或pTexelBufferView中每个描述符的类型，如下所述。它必须与在dstBinding中为dstSet的VkDescriptorSetLayoutBinding中指定的类型相同。描述符的类型还控制描述符从哪个数组获取</li>
<li>pImageInfo是指向VkDescriptorImageInfo结构数组的指针</li>
<li>pBufferInfo是指向VkDescriptorBufferInfo结构数组的指针</li>
<li>pTexelBufferView是指向VkBufferView句柄数组的指针</li>
</ol>
<h3 id="2-2-5-vkUpdateDescriptorSets"><a href="#2-2-5-vkUpdateDescriptorSets" class="headerlink" title="2.2.5 vkUpdateDescriptorSets"></a>2.2.5 vkUpdateDescriptorSets</h3><p>内存分配后，描述符集可以使用写和复制操作的组合进行更新。 要更新描述符集，调用：vkUpdateDescriptorSets</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkUpdateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorWriteCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkWriteDescriptorSet*                 pDescriptorWrites,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorCopyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCopyDescriptorSet*                  pDescriptorCopies)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device是更新描述符集的逻辑设备</li>
<li>descriptorWriteCount是pDescriptorWrites数组中元素的数量</li>
<li>pDescriptorWrites是指向VkWriteDescriptorSet结构数组的指针，该结构描述了要写入的描述符集</li>
<li>descriptorCopyCount是pDescriptorCopies数组中元素的数量</li>
<li>pDescriptorCopies是指向VkCopyDescriptorSet结构数组的指针，该结构描述了要在其间复制的描述符集</li>
</ol>
<h2 id="2-3-使用描述符集"><a href="#2-3-使用描述符集" class="headerlink" title="2.3 使用描述符集"></a>2.3 使用描述符集</h2><p>现在，我们需要更新createCommandBuffers函数，以将每个交换链图像的正确描述符集实际绑定到具有cmdBindDescriptorSets的着色器中的描述符。 </p>
<p>需要在vkCmdDrawIndexed调用之前完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindDescriptorSets</span>(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;descriptorSets[i], <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkCmdDrawIndexed</span>(commandBuffers[i], <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(indices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>与顶点和索引缓冲区不同，描述符集不是图形管线所独有的。因此，我们需要指定是否要将描述符集绑定到图形或计算管道–vkCmdBindDescriptorSets。</p>
<p>现在运行程序，是看不到任何内容的。问题在于，由于我们在投影矩阵中进行了Y翻转，因此现在以顺时针顺序而不是逆时针顺序绘制了顶点。这将导致背面剔除，并阻止绘制任何几何图形。</p>
<p>在createGraphicsPipeline函数中VkPipelineRasterizationStateCreateInfo中修改frontFace来更正此问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;</span><br><span class="line">rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;</span><br></pre></td></tr></table></figure>

<p>frontFace是VkFrontFace结构体内的类型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkFrontFace</span> &#123;</span><br><span class="line">    VK_FRONT_FACE_COUNTER_CLOCKWISE = <span class="number">0</span>,</span><br><span class="line">    VK_FRONT_FACE_CLOCKWISE = <span class="number">1</span>,</span><br><span class="line">    VK_FRONT_FACE_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkFrontFace;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_FRONT_FACE_COUNTER_CLOCKWISE 指定具有正面积的三角形被认为是朝前的</li>
<li>VK_FRONT_FACE_CLOCKWISE 指定具有负面积的三角形被认为是朝前的</li>
</ol>
<p>如何计算面积的正负，后续研究。现在运行程序可以看到我们的图像在沿着逆时针旋转~</p>
<h3 id="2-3-1-vkCmdBindDescriptorSets"><a href="#2-3-1-vkCmdBindDescriptorSets" class="headerlink" title="2.3.1 vkCmdBindDescriptorSets"></a>2.3.1 vkCmdBindDescriptorSets</h3><p>绑定描述符集调用 vkCmdBindDescriptorSets:<br>一个参数是描述符所基于的布局。接下来的三个参数指定第一个描述符集的索引，要绑定的集的数量以及要绑定的集的数组。我们待会儿再讲这个。最后两个参数指定用于动态描述符的偏移量数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineBindPoint                         pipelineBindPoint,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout                            layout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstSet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorSetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSet*                      pDescriptorSets,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    dynamicOffsetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint32_t</span>*                             pDynamicOffsets)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是描述符集将绑定到的命令缓冲区</li>
<li>pipelineBindPoint是一个VkPipelineBindPoint，它指示描述符是由图形管线还是由计算管线使用。 每个图形和计算都有一组单独的绑定点，因此绑定一个不会干扰另一个</li>
<li>layout是一个VkPipelineLayout对象，用于对绑定进行编程</li>
<li>firstSet是要绑定的第一个描述符集的集号</li>
<li>descriptorSetCount是pDescriptorSets数组中元素的数量</li>
<li>pDescriptorSets是指向VkDescriptorSet对象的句柄数组的指针，该对象描述了要写入的描述符集</li>
<li>dynamicOffsetCount是pDynamicOffsets数组中的动态偏移量</li>
<li>pDynamicOffsets是指向指定动态偏移量的uint32_t值数组的指针</li>
</ol>
<p>vkCmdBindDescriptorSets导致编号为[firstSet..firstSet + descriptorSetCount-1]的集合使用存储在pDescriptorSets [0..descriptorSetCount-1]中的绑定用于后续渲染命令（根据pipelineBindPoint计算或图形）。以前通过这些集合应用的任何绑定都不再有效。</p>
<p>绑定后，描述符集会影响命令缓冲区中后续图形或计算命令的渲染，直到将不同的集绑定到相同的集编号，或者直到该集受到干扰（如管线布局兼容性中所述）为止。</p>
<p>在记录绘制或分派命令以使用该管道执行时，必须为管道中任何着色器访问的所有设定编号绑定一个兼容的描述符集。但是，如果管道中的所有着色器都不静态使用具有特定集合号的任何绑定，则即使该管道编号包括该集合号的非平凡描述符集合布局，也不需要为该集合号绑定任何描述符集。</p>
<p>如果要绑定的任何集合包括动态统一缓冲区或存储缓冲区，则pDynamicOffsets会为每个集合中每个动态描述符类型绑定中的每个数组元素包含一个元素。从pDynamicOffsets中获取值的顺序是：集合N的所有条目都在集合N + 1之前；在一个集合中，条目按描述符集合布局中的绑定号排序；在绑定数组中，元素是有序的。 dynamicOffsetCount必须等于要绑定的集合中动态描述符的总数。</p>
<p>用于动态统一和存储缓冲区绑定的有效偏移量是从pDynamicOffsets获取的相对偏移量与缓冲区的基地址加描述符集中的基本偏移量之和。动态统一和存储缓冲区绑定的范围是描述符集中指定的缓冲区范围。</p>
<p>每个pDescriptorSet都必须与layout指定的管道布局兼容。用于编程绑定的布局还必须与后续图形或计算命令中使用的管线兼容，如“管线布局兼容性”部分中所定义。</p>
<p>调用vkCmdBindDescriptorSets绑定的描述符集内容可能在以下时间使用：</p>
<ol>
<li>对于使用VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT位置1创建的描述符绑定，在将命令缓冲区提交到队列时，在着色器执行结果绘制和调度时或在两者之间的任何时间，内容都可能被消耗。</li>
<li>在命令的主机执行期间，或在着色器执行结果绘制和派发期间，或之间的任何时间。</li>
</ol>
<p>因此，在描述符集合绑定的内容可能被消耗的第一个时间点和该命令在队列上完成执行之间，不得更改（由更新命令覆盖或释放）描述符集绑定的内容。</p>
<p>在执行vkCmdBindDescriptorSets时，pDynamicOffsets的内容将立即消耗。一旦所有待定用途都已完成，就可以更新和重用描述符集。</p>
<h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><p>描述符的使用包括三个部分：</p>
<ol>
<li>在管道创建期间指定描述符布局</li>
<li>从描述符池分配描述符集</li>
<li>渲染期间绑定描述符集</li>
</ol>
<p>所谓描述符，就是用来描述着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。</p>
<p>接下来，我们尝试一些更让人激动的东西–贴图。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>SwallowJoe
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/" title="Vulkan入门(13)-描述符布局及缓存">https://swallowjoe.github.io/2022/02/27/Vulkan入门-13-描述符布局及缓存/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Vulkan/" rel="tag"># Vulkan</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/" rel="prev" title="Vulkan入门(12)-暂存缓冲和索引缓冲">
      <i class="fa fa-chevron-left"></i> Vulkan入门(12)-暂存缓冲和索引缓冲
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/" rel="next" title="Vulkan入门(14)-VkImage图像的创建">
      Vulkan入门(14)-VkImage图像的创建 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0"><span class="nav-text">简述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86%E5%B8%83%E5%B1%80"><span class="nav-text">一. 描述符集布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-VkDescriptorSetLayoutBinding"><span class="nav-text">1.1 VkDescriptorSetLayoutBinding</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-VkDescriptorType"><span class="nav-text">1.1.1 VkDescriptorType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-VkShaderStageFlags"><span class="nav-text">1.1.2 VkShaderStageFlags</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E5%88%9B%E5%BB%BAVkDescriptorSetLayout"><span class="nav-text">1.2 创建VkDescriptorSetLayout</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-VkDescriptorSetLayoutCreateInfo"><span class="nav-text">1.2.1 VkDescriptorSetLayoutCreateInfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-vkCreateDescriptorSetLayout"><span class="nav-text">1.2.2 vkCreateDescriptorSetLayout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E7%AE%A1%E9%81%93%E6%8C%87%E5%AE%9A%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86%E5%B8%83%E5%B1%80"><span class="nav-text">1.3 管道指定描述符集布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E7%BB%9F%E4%B8%80%E7%BC%93%E5%AD%98"><span class="nav-text">1.4 统一缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-%E6%9B%B4%E6%96%B0%E7%BB%9F%E4%B8%80%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="nav-text">1.5 更新统一缓存数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-text">二. 描述符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0"><span class="nav-text">2.1 描述符池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-VkDescriptorPoolSize"><span class="nav-text">2.1.1 VkDescriptorPoolSize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-VkDescriptorPoolCreateInfo"><span class="nav-text">2.1.2 VkDescriptorPoolCreateInfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-vkCreateDescriptorPool"><span class="nav-text">2.1.3 vkCreateDescriptorPool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86"><span class="nav-text">2.2 描述符集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-VkDescriptorSetAllocateInfo"><span class="nav-text">2.2.1 VkDescriptorSetAllocateInfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-vkAllocateDescriptorSets"><span class="nav-text">2.2.2 vkAllocateDescriptorSets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-VkDescriptorBufferInfo"><span class="nav-text">2.2.3 VkDescriptorBufferInfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-VkWriteDescriptorSet"><span class="nav-text">2.2.4 VkWriteDescriptorSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-vkUpdateDescriptorSets"><span class="nav-text">2.2.5 vkUpdateDescriptorSets</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E4%BD%BF%E7%94%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86"><span class="nav-text">2.3 使用描述符集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-vkCmdBindDescriptorSets"><span class="nav-text">2.3.1 vkCmdBindDescriptorSets</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E6%80%BB%E7%BB%93"><span class="nav-text">三. 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SwallowJoe"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SwallowJoe</p>
  <div class="site-description" itemprop="description">君子知命不惧，日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/swallowjoe" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;swallowjoe" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:swallowjoe@foxmail.com" title="E-Mail → mailto:swallowjoe@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.cn/injobs/in/joseph-huang-9597b822b" title="LinkedIn → https:&#x2F;&#x2F;www.linkedin.cn&#x2F;injobs&#x2F;in&#x2F;joseph-huang-9597b822b" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>LinkedIn</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SwallowJoe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"RfLcPyiwrSaXOBtMHLnzE6S4-gzGzoHsz","app_key":"J0WdcjIXqW9jxT4zOpMG5BeE","server_url":"https://rflcpyiw.lc-cn-n1-shared.com","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'RfLcPyiwrSaXOBtMHLnzE6S4-gzGzoHsz',
      appKey     : 'J0WdcjIXqW9jxT4zOpMG5BeE',
      placeholder: "Say something...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : 'https://rflcpyiw.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
