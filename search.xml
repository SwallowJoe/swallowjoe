<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>App申请帧率(1)--简述</title>
    <url>/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E8%83%8C%E6%99%AF">背景</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%8F%AF%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%B7%E6%96%B0%E7%8E%87%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87">查看设备可支持的刷新率和分辨率</a></li>
<li><a href="#app%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E5%B8%A7%E7%8E%87">App设置设备帧率</a><ul>
<li><a href="#android-q%E5%8F%8A%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC">Android Q及以下版本</a></li>
<li><a href="#android-r">Android R</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着手机屏幕硬件能力的提升，越来越多的厂商提供支持多档次刷新率的Android设备。<br>而在Android Q上也是支持App指定当前屏幕帧率的，也有一套帧率分辨率切换的逻辑。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/142212769?from_voters_page=true">https://zhuanlan.zhihu.com/p/142212769?from_voters_page=true</a></li>
</ol>
<h2 id="查看设备可支持的刷新率和分辨率"><a href="#查看设备可支持的刷新率和分辨率" class="headerlink" title="查看设备可支持的刷新率和分辨率"></a>查看设备可支持的刷新率和分辨率</h2><p>使用命令：<br>adb shell dumpsys display dump |grep -A 10 -iE “mSupportedModes”</p>
<p>这里设备使用的是OnePlus8Pro，结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mSupportedModes=</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=1, width=1080, height=2376, fps=60.000004&#125;&#125;</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=2, width=1440, height=3168, fps=120.00001&#125;&#125;</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=3, width=1440, height=3168, fps=60.000004&#125;&#125;</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=4, width=1080, height=2376, fps=120.00001&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是有四种模式：</p>
<ol>
<li>1080 + 60Hz</li>
<li>2K + 120Hz</li>
<li>2K + 60Hz</li>
<li>1080 + 120Hz</li>
</ol>
<h2 id="App设置设备帧率"><a href="#App设置设备帧率" class="headerlink" title="App设置设备帧率"></a>App设置设备帧率</h2><h3 id="Android-Q及以下版本"><a href="#Android-Q及以下版本" class="headerlink" title="Android Q及以下版本"></a>Android Q及以下版本</h3><p>在Android Q或更低版本上，可以通过指定当前Window的帧率来设置屏幕刷新率，如选择设备可支持的最高刷新率：</p>
<figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> highestMode: Display.Mode = mWindowManager!!.defaultDisplay.supportedModes[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> (mode <span class="keyword">in</span> mWindowManager!!.defaultDisplay.supportedModes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode.refreshRate &gt; highestMode.refreshRate) &#123;</span><br><span class="line">        highestMode = mode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wmParams!!.preferredDisplayModeId = highestMode.modeId</span><br></pre></td></tr></table></figure>

<h3 id="Android-R"><a href="#Android-R" class="headerlink" title="Android R"></a>Android R</h3><p>如 <a href="https://zhuanlan.zhihu.com/p/142212769?from_voters_page=true">Google建议</a>利用可变刷新率</p>
<p>在较旧的 Android 版本 (Android 11 之前) 中并不存在 setFrameRate API，这时应用仍然可以通过直接将WindowManager.LayoutParams.preferredDisplayModeId设置为Display.getSupportedModes中的可用模式之一来影响刷新率。</p>
<p>从 Android 11 开始，我们不建议大家采用这种方法，因为平台会不知道应用的渲染意图。</p>
<p>例如，如果一个设备支持 48Hz、60Hz 和 120Hz，屏幕上有两个应用分别调用 setFrameRate(60, …) 和 setFrameRate(24, …)，那么平台可以选择 120Hz 来同时满足这两个应用。</p>
<p>而如果这些应用使用了preferredDisplayModeId，它们很可能会把模式设置为 60Hz 和 48Hz，那这时平台就无法使用 120Hz 了。<br>这时平台只能从 60Hz 或 48Hz 中选择一个，从而影响到另一个应用的显示效果。</p>
<ol>
<li><p>获取刷新率：</p>
<ol>
<li>SDK</li>
</ol>
</li>
</ol>
<p>通过 DisplayManager.DisplayListener 注册一个显示监听器，并通过 Display.getRefreshRate 查询刷新率。<br>   2. NDK<br>使用 AChoreographer_registerRefreshRateCallback 注册回调 (API 级别30)。</p>
<ol start="2">
<li>设置刷新率应用可以调用以下方法之一:<ol>
<li>SDK<ol>
<li><a href="https://developer.android.google.cn/reference/android/view/Surface#setFrameRate(float,%20int)">Surface.setFrameRate</a></li>
<li><a href="https://developer.android.google.cn/reference/android/view/SurfaceControl.Transaction.html#setFrameRate(android.view.SurfaceControl,%20float,%20int)">SurfaceControl.Transaction.setFrameRate</a></li>
</ol>
</li>
<li>NDK<ol>
<li><a href="https://developer.android.google.cn/ndk/reference/group/a-native-window#anativewindow_setframerate">ANativeWindow_setRrameRate</a></li>
<li>ASurfaceTransaction_setFrameRate</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Vsync</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
      </tags>
  </entry>
  <entry>
    <title>App申请帧率(2)--Framework选择最近帧率范围</title>
    <url>/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<p>以下分析基于Android Q.</p>
<span id="more"></span>

<h1 id="一-preferredDisplayModeId改变"><a href="#一-preferredDisplayModeId改变" class="headerlink" title="一. preferredDisplayModeId改变"></a>一. preferredDisplayModeId改变</h1><p>上篇文章讲到，只要将window的Param设置就可以更改屏幕分辨率：</p>
<figure class="highlight kt"><table><tr><td class="code"><pre><span class="line">wmParams!!.preferredDisplayModeId = highestMode.modeId</span><br></pre></td></tr></table></figure>
<p>代码是和实现的呢, 在App接受vsync信号后，会回调Choreographer.CALLBACK_TRAVERSAL，也就会调用到ViewRootImpl.doTraversal.</p>
<p>调用栈如下:</p>
<ol>
<li>Choreographer.onVsync()</li>
<li>Choreographer.doFrame() &#x2F;&#x2F; doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</li>
<li>ViewRootImpl.doTraversal()</li>
<li>ViewRootImpl.performTraversals()</li>
<li>ViewRootImpl.relayoutWindow() &#x2F;&#x2F; 这里将当前Window的Attr传入WindowManagerService</li>
<li>IWindowSession.relayout() &#x2F;&#x2F; 通过binder调用 Session.relayout</li>
<li>WindowManagerService.relayoutWindow() &#x2F;&#x2F; 进入SystenServer进程</li>
<li>WindowSurfacePlacer.performSurfacePlacement()</li>
<li>WindowSurfacePlacer.performSurfacePlacementLoop()</li>
<li>RootWindowContainer.performSurfacePlacement()</li>
<li>RootWindowContainer.performSurfacePlacementNoTrace()</li>
<li>RootWindowContainer.applySurfaceChangesTransaction()<ol>
<li>DisplayContent.applySurfaceChangesTransaction()<ol>
<li>DisplayContent.mApplySurfaceChangesTransaction &#x2F;&#x2F; 对所有window遍历执行，如果有属性变化响应变化</li>
<li>DisplayManagerService.setDisplayProperties &#x2F;&#x2F; 计算并保存合适的modeId</li>
</ol>
</li>
<li>DisplayManagerInternal.performTraversal(mDisplayTransaction) &#x2F;&#x2F; 应用modeId变化</li>
</ol>
</li>
</ol>
<h2 id="1-1-RootWindowContainer-applySurfaceChangesTransaction"><a href="#1-1-RootWindowContainer-applySurfaceChangesTransaction" class="headerlink" title="1.1 RootWindowContainer.applySurfaceChangesTransaction"></a>1.1 RootWindowContainer.applySurfaceChangesTransaction</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">applySurfaceChangesTransaction</span><span class="params">(<span class="type">boolean</span> recoveringMemory)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mChildren.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; ++j) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> mChildren.get(j);</span><br><span class="line">        <span class="comment">// 1.2 对每个display都计算变化</span></span><br><span class="line">        dc.applySurfaceChangesTransaction(recoveringMemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 通知SurfaceFlinger改变ModeId</span></span><br><span class="line">    mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction);</span><br><span class="line">    SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-DisplayContent-applySurfaceChangesTransaction"><a href="#1-2-DisplayContent-applySurfaceChangesTransaction" class="headerlink" title="1.2 DisplayContent.applySurfaceChangesTransaction()"></a>1.2 DisplayContent.applySurfaceChangesTransaction()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applySurfaceChangesTransaction</span><span class="params">(<span class="type">boolean</span> recoveringMemory)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;applyWindowSurfaceChanges&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.3 遍历所有window, 按照Z轴从上到下</span></span><br><span class="line">        forAllWindows(mApplySurfaceChangesTransaction, <span class="literal">true</span> <span class="comment">/* traverseTopToBottom */</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    prepareSurfaces();</span><br><span class="line"></span><br><span class="line">    mLastHasContent = mTmpApplySurfaceChangesTransactionState.displayHasContent;</span><br><span class="line">    <span class="comment">// 1.4 应用需要Display属性变化</span></span><br><span class="line">    mWmService.mDisplayManagerInternal.setDisplayProperties(mDisplayId,</span><br><span class="line">            mLastHasContent,</span><br><span class="line">            mTmpApplySurfaceChangesTransactionState.preferredRefreshRate,</span><br><span class="line">            mTmpApplySurfaceChangesTransactionState.preferredModeId,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/* inTraversal, must call performTraversalInTrans... below */</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-DisplayContent-mApplySurfaceChangesTransaction"><a href="#1-3-DisplayContent-mApplySurfaceChangesTransaction" class="headerlink" title="1.3 DisplayContent.mApplySurfaceChangesTransaction"></a>1.3 DisplayContent.mApplySurfaceChangesTransaction</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!mTmpApplySurfaceChangesTransactionState.obscured) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 获取wmParams.preferredDisplayModeId中的modeId</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">preferredModeId</span> <span class="operator">=</span> getDisplayPolicy().getRefreshRatePolicy()</span><br><span class="line">                .getPreferredModeId(w);</span><br><span class="line">        <span class="comment">// 注意这里是按照Z轴从上到下遍历Window，所以只会取第一个可见的有Surface的且被设置的window的modeId</span></span><br><span class="line">        <span class="keyword">if</span> (mTmpApplySurfaceChangesTransactionState.preferredModeId == <span class="number">0</span></span><br><span class="line">                &amp;&amp; preferredModeId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 标记preferredModeId</span></span><br><span class="line">            mTmpApplySurfaceChangesTransactionState.preferredModeId = preferredModeId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-DisplayManagerService-setDisplayProperties"><a href="#1-4-DisplayManagerService-setDisplayProperties" class="headerlink" title="1.4 DisplayManagerService.setDisplayProperties"></a>1.4 DisplayManagerService.setDisplayProperties</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDisplayProperties</span><span class="params">(<span class="type">int</span> displayId, <span class="type">boolean</span> hasContent,</span></span><br><span class="line"><span class="params">        <span class="type">float</span> requestedRefreshRate, <span class="type">int</span> requestedMode, <span class="type">boolean</span> inTraversal)</span> &#123;</span><br><span class="line">    setDisplayPropertiesInternal(displayId, hasContent, requestedRefreshRate,</span><br><span class="line">            requestedMode, inTraversal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setDisplayPropertiesInternal</span><span class="params">(<span class="type">int</span> displayId, <span class="type">boolean</span> hasContent,</span></span><br><span class="line"><span class="params">        <span class="type">float</span> requestedRefreshRate, <span class="type">int</span> requestedModeId, <span class="type">boolean</span> inTraversal)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        <span class="type">LogicalDisplay</span> <span class="variable">display</span> <span class="operator">=</span> mLogicalDisplays.get(displayId);</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display.hasContentLocked() != hasContent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">&quot;Display &quot;</span> + displayId + <span class="string">&quot; hasContent flag changed: &quot;</span></span><br><span class="line">                        + <span class="string">&quot;hasContent=&quot;</span> + hasContent + <span class="string">&quot;, inTraversal=&quot;</span> + inTraversal);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            display.setHasContentLocked(hasContent);</span><br><span class="line">            scheduleTraversalLocked(inTraversal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当应用仅仅设置了刷新率，而没有设置modeId时，需要找到一个合适的modeId</span></span><br><span class="line">        <span class="comment">// 为什么这么做呢，因为modeId不仅仅包含刷新率，还有分辨率。</span></span><br><span class="line">        <span class="comment">// 当请求刷新率变化时，是不能或不必要改变分辨率的，所以就需要找到分辨率不变的modeId</span></span><br><span class="line">        <span class="keyword">if</span> (requestedModeId == <span class="number">0</span> &amp;&amp; requestedRefreshRate != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Scan supported modes returned by display.getInfo() to find a mode with the same</span></span><br><span class="line">            <span class="comment">// size as the default display mode but with the specified refresh rate instead.</span></span><br><span class="line">            requestedModeId = display.getDisplayInfoLocked().findDefaultModeByRefreshRate(</span><br><span class="line">                    requestedRefreshRate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.1 发现有应用请求Display改变modeId</span></span><br><span class="line">        mDisplayModeDirector.getAppRequestObserver().setAppRequestedMode(</span><br><span class="line">                displayId, requestedModeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-DisplayModeDirector"><a href="#二-DisplayModeDirector" class="headerlink" title="二. DisplayModeDirector"></a>二. DisplayModeDirector</h1><p>这个类是用于决策当前设备刷新率的</p>
<h2 id="2-1-DisplayModeDirector-AppRequestObserver-setAppRequestedMode"><a href="#2-1-DisplayModeDirector-AppRequestObserver-setAppRequestedMode" class="headerlink" title="2.1 DisplayModeDirector.AppRequestObserver.setAppRequestedMode"></a>2.1 DisplayModeDirector.AppRequestObserver.setAppRequestedMode</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppRequestedMode</span><span class="params">(<span class="type">int</span> displayId, <span class="type">int</span> modeId)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        setAppRequestedModeLocked(displayId, modeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setAppRequestedModeLocked</span><span class="params">(<span class="type">int</span> displayId, <span class="type">int</span> modeId)</span> &#123;</span><br><span class="line">    <span class="comment">// 做一个参数检查，确保displayId和modeId参数是可接受的</span></span><br><span class="line">    <span class="keyword">final</span> Display.<span class="type">Mode</span> <span class="variable">requestedMode</span> <span class="operator">=</span> findModeByIdLocked(displayId, modeId);</span><br><span class="line">    <span class="comment">// 如果当前displayId下的modeId已经是App所需的modeId，就不用继续了</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(requestedMode, mAppRequestedModeByDisplay.get(displayId))) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Vote refreshRateVote;</span><br><span class="line">    <span class="keyword">final</span> Vote sizeVote;</span><br><span class="line">    <span class="keyword">if</span> (requestedMode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存当前App设置的参数</span></span><br><span class="line">        mAppRequestedModeByDisplay.put(displayId, requestedMode);</span><br><span class="line">        <span class="type">float</span> <span class="variable">refreshRate</span> <span class="operator">=</span> requestedMode.getRefreshRate();</span><br><span class="line">        <span class="comment">// 创建刷新率Vote</span></span><br><span class="line">        refreshRateVote = Vote.forRefreshRates(refreshRate, refreshRate);</span><br><span class="line">        sizeVote = Vote.forSize(requestedMode.getPhysicalWidth(),</span><br><span class="line">                requestedMode.getPhysicalHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAppRequestedModeByDisplay.remove(displayId);</span><br><span class="line">        refreshRateVote = <span class="literal">null</span>;</span><br><span class="line">        sizeVote = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateVoteLocked(displayId, Vote.PRIORITY_APP_REQUEST_REFRESH_RATE, refreshRateVote);</span><br><span class="line">    updateVoteLocked(displayId, Vote.PRIORITY_APP_REQUEST_SIZE, sizeVote);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-DisplayModeDirector-Vote-updateVoteLocked"><a href="#2-2-DisplayModeDirector-Vote-updateVoteLocked" class="headerlink" title="2.2 DisplayModeDirector.Vote.updateVoteLocked"></a>2.2 DisplayModeDirector.Vote.updateVoteLocked</h2><p>更新Vote策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateVoteLocked</span><span class="params">(<span class="type">int</span> displayId, <span class="type">int</span> priority, Vote vote)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;updateVoteLocked(displayId=&quot;</span> + displayId</span><br><span class="line">                + <span class="string">&quot;, priority=&quot;</span> + Vote.priorityToString(priority)</span><br><span class="line">                + <span class="string">&quot;, vote=&quot;</span> + vote + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (priority &lt; Vote.MIN_PRIORITY || priority &gt; Vote.MAX_PRIORITY) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Received a vote with an invalid priority, ignoring:&quot;</span></span><br><span class="line">                + <span class="string">&quot; priority=&quot;</span> + Vote.priorityToString(priority)</span><br><span class="line">                + <span class="string">&quot;, vote=&quot;</span> + vote, <span class="keyword">new</span> <span class="title class_">Throwable</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前display的所有Vote</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;Vote&gt; votes = getOrCreateVotesByDisplay(displayId);</span><br><span class="line">    <span class="comment">// 获取PRIORITY_APP_REQUEST_REFRESH_RATE优先级的Vote，不过根本没有用？</span></span><br><span class="line">    <span class="type">Vote</span> <span class="variable">currentVote</span> <span class="operator">=</span> votes.get(priority);</span><br><span class="line">    <span class="comment">// 传入的Vote不为空，说明有符合要求的ModeId,就保存，没有就移除当前优先级的Vote</span></span><br><span class="line">    <span class="keyword">if</span> (vote != <span class="literal">null</span>) &#123;</span><br><span class="line">        votes.put(priority, vote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        votes.remove(priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (votes.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;No votes left for display &quot;</span> + displayId + <span class="string">&quot;, removing.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mVotesByDisplay.remove(displayId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知ModeId改变</span></span><br><span class="line">    notifyAllowedModesChangedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-DisplayModeDirector-Vote-notifyAllowedModesChangedLocked"><a href="#2-3-DisplayModeDirector-Vote-notifyAllowedModesChangedLocked" class="headerlink" title="2.3 DisplayModeDirector.Vote.notifyAllowedModesChangedLocked"></a>2.3 DisplayModeDirector.Vote.notifyAllowedModesChangedLocked</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyAllowedModesChangedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="literal">null</span> &amp;&amp; !mHandler.hasMessages(MSG_ALLOWED_MODES_CHANGED)) &#123;</span><br><span class="line">        <span class="comment">// We need to post this to a handler to avoid calling out while holding the lock</span></span><br><span class="line">        <span class="comment">// since we know there are things that both listen for changes as well as provide</span></span><br><span class="line">        <span class="comment">// information. If we did call out while holding the lock, then there&#x27;s no guaranteed</span></span><br><span class="line">        <span class="comment">// lock order and we run the real of risk deadlock.</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_ALLOWED_MODES_CHANGED, mListener);</span><br><span class="line">        msg.sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DisplayModeDirectorHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    DisplayModeDirectorHandler(Looper looper) &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/*async*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_ALLOWED_MODES_CHANGED:</span><br><span class="line">                <span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> (Listener) msg.obj;</span><br><span class="line">                listener.onAllowedDisplayModesChanged();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转到DisplayThread线程处理，也就是回调onAllowedDisplayModesChanged.<br>这里的mListener是调用DisplayModeDirector.setListener设置的，这个是在DisplayManagerService中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called when the system is ready to go.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">systemReady</span><span class="params">(<span class="type">boolean</span> safeMode, <span class="type">boolean</span> onlyCore)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        mSafeMode = safeMode;</span><br><span class="line">        mOnlyCore = onlyCore;</span><br><span class="line">        mSystemReady = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Just in case the top inset changed before the system was ready. At this point, any</span></span><br><span class="line">        <span class="comment">// relevant configuration should be in place.</span></span><br><span class="line">        recordTopInsetLocked(mLogicalDisplays.get(Display.DEFAULT_DISPLAY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里：</span></span><br><span class="line">    mDisplayModeDirector.setListener(<span class="keyword">new</span> <span class="title class_">AllowedDisplayModeObserver</span>());</span><br><span class="line">    mDisplayModeDirector.start(mSensorManager);</span><br><span class="line"></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_REGISTER_ADDITIONAL_DISPLAY_ADAPTERS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-DisplayManagerService-onAllowedDisplayModesChangedInternal"><a href="#2-4-DisplayManagerService-onAllowedDisplayModesChangedInternal" class="headerlink" title="2.4 DisplayManagerService.onAllowedDisplayModesChangedInternal"></a>2.4 DisplayManagerService.onAllowedDisplayModesChangedInternal</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onAllowedDisplayModesChangedInternal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mLogicalDisplays.size();</span><br><span class="line">        <span class="comment">// 遍历所有的Display，依次设置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">LogicalDisplay</span> <span class="variable">display</span> <span class="operator">=</span> mLogicalDisplays.valueAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">displayId</span> <span class="operator">=</span> mLogicalDisplays.keyAt(i);</span><br><span class="line">            <span class="comment">// 2.5 获取displayId对应的ModeIds</span></span><br><span class="line">            <span class="type">int</span>[] allowedModes = mDisplayModeDirector.getAllowedModes(displayId);</span><br><span class="line">            <span class="comment">// Note that order is important here since not all display devices are capable of</span></span><br><span class="line">            <span class="comment">// automatically switching, so we do actually want to check for equality and not</span></span><br><span class="line">            <span class="comment">// just equivalent contents (regardless of order).</span></span><br><span class="line">            <span class="keyword">if</span> (!Arrays.equals(allowedModes, display.getAllowedDisplayModesLocked())) &#123;</span><br><span class="line">                <span class="comment">// 保存modeId集，以便判断是否有modeId变化，这个判断条件内getAllowedDisplayModesLocked</span></span><br><span class="line">                <span class="comment">// 拿到的modeId数组就是上一次在这里保存的</span></span><br><span class="line">                display.setAllowedDisplayModesLocked(allowedModes);</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有改变, 请求下一次Vsync, 以确保通知到SurfaceFlinger有modeId更改</span></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            scheduleTraversalLocked(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-DisplayModeDirector-getAllowedModes"><a href="#2-5-DisplayModeDirector-getAllowedModes" class="headerlink" title="2.5 DisplayModeDirector.getAllowedModes"></a>2.5 DisplayModeDirector.getAllowedModes</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getAllowedModes(<span class="type">int</span> displayId) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 取出displayId对应的所有Vote，注意这里包含GLOBAL_ID(-1), 即全局生效的Vote</span></span><br><span class="line">        SparseArray&lt;Vote&gt; votes = getVotesLocked(displayId);</span><br><span class="line">        Display.Mode[] modes = mSupportedModesByDisplay.get(displayId);</span><br><span class="line">        Display.<span class="type">Mode</span> <span class="variable">defaultMode</span> <span class="operator">=</span> mDefaultModeByDisplay.get(displayId);</span><br><span class="line">        <span class="keyword">if</span> (modes == <span class="literal">null</span> || defaultMode == <span class="literal">null</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Asked about unknown display, returning empty allowed set! (id=&quot;</span></span><br><span class="line">                    + displayId + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.5.1 计算</span></span><br><span class="line">        <span class="keyword">return</span> getAllowedModesLocked(votes, modes, defaultMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算displayId对应允许的可自由切换的modeId列表</p>
<h3 id="2-5-1-DisplayModeDirector-getAllowedModesLocked"><a href="#2-5-1-DisplayModeDirector-getAllowedModesLocked" class="headerlink" title="2.5.1 DisplayModeDirector.getAllowedModesLocked"></a>2.5.1 DisplayModeDirector.getAllowedModesLocked</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] getAllowedModesLocked(<span class="meta">@NonNull</span> SparseArray&lt;Vote&gt; votes,</span><br><span class="line">        <span class="meta">@NonNull</span> Display.Mode[] modes, <span class="meta">@NonNull</span> Display.Mode defaultMode) &#123;</span><br><span class="line">    <span class="comment">// 从最低优先级开始遍历，不过为什么会有两层循环？</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lowestConsideredPriority</span> <span class="operator">=</span> Vote.MIN_PRIORITY;</span><br><span class="line">    <span class="keyword">while</span> (lowestConsideredPriority &lt;= Vote.MAX_PRIORITY) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">minRefreshRate</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">maxRefreshRate</span> <span class="operator">=</span> Float.POSITIVE_INFINITY;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Vote.INVALID_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> Vote.INVALID_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从优先级最大的开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">priority</span> <span class="operator">=</span> Vote.MAX_PRIORITY;</span><br><span class="line">                priority &gt;= lowestConsideredPriority;</span><br><span class="line">                priority--) &#123;</span><br><span class="line">            <span class="type">Vote</span> <span class="variable">vote</span> <span class="operator">=</span> votes.get(priority);</span><br><span class="line">            <span class="keyword">if</span> (vote == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 刷新率最小值取两者中的较大值</span></span><br><span class="line">            minRefreshRate = Math.max(minRefreshRate, vote.minRefreshRate);</span><br><span class="line">            <span class="comment">// 刷新率最大值取两者中的较小值</span></span><br><span class="line">            maxRefreshRate = Math.min(maxRefreshRate, vote.maxRefreshRate);</span><br><span class="line">            <span class="comment">// 显示大小只需要取第一个值</span></span><br><span class="line">            <span class="keyword">if</span> (height == Vote.INVALID_SIZE &amp;&amp; width == Vote.INVALID_SIZE</span><br><span class="line">                    &amp;&amp; vote.height &gt; <span class="number">0</span> &amp;&amp; vote.width &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                width = vote.width;</span><br><span class="line">                height = vote.height;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we don&#x27;t have anything specifying the width / height of the display, just use the</span></span><br><span class="line">        <span class="comment">// default width and height. We don&#x27;t want these switching out from underneath us since</span></span><br><span class="line">        <span class="comment">// it&#x27;s a pretty disruptive behavior.</span></span><br><span class="line">        <span class="keyword">if</span> (height == Vote.INVALID_SIZE || width == Vote.INVALID_SIZE) &#123;</span><br><span class="line">            width = defaultMode.getPhysicalWidth();</span><br><span class="line">            height = defaultMode.getPhysicalHeight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.5.2 获取可取的mode</span></span><br><span class="line">        <span class="type">int</span>[] availableModes =</span><br><span class="line">                filterModes(modes, width, height, minRefreshRate, maxRefreshRate);</span><br><span class="line">        <span class="keyword">if</span> (availableModes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableModes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前优先级下没有找到合适的modeId时，提高优先级重新搜索</span></span><br><span class="line">        lowestConsideredPriority++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we still haven&#x27;t found anything that matches our current set of votes, just fall back</span></span><br><span class="line">    <span class="comment">// to the default mode.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; defaultMode.getModeId() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里刷新率的算法是，遍历所有优先级的Vote，最终的minRefreshRate取所有Vote的最小刷新率中的最大值。<br>maxRefreshRate取所有Vote中最大刷新率的最小值。</p>
<p>这里有个地方一开始比较难理解，就是为什么是用双层循环，而且第一层循环是从优先级最低的开始，最内层是优先级最大的开始。不着急我们先看#2.5.2</p>
<h3 id="2-5-2-DisplayModeDirector-filterModes"><a href="#2-5-2-DisplayModeDirector-filterModes" class="headerlink" title="2.5.2 DisplayModeDirector.filterModes"></a>2.5.2 DisplayModeDirector.filterModes</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] filterModes(Display.Mode[] supportedModes,</span><br><span class="line">        <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">float</span> minRefreshRate, <span class="type">float</span> maxRefreshRate) &#123;</span><br><span class="line">    ArrayList&lt;Display.Mode&gt; availableModes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Display.Mode mode : supportedModes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode.getPhysicalWidth() != width || mode.getPhysicalHeight() != height) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">refreshRate</span> <span class="operator">=</span> mode.getRefreshRate();</span><br><span class="line">        <span class="comment">// EPSILON = 0.001f</span></span><br><span class="line">        <span class="comment">// 为啥会有这呢，因为小数计算会有误差</span></span><br><span class="line">        <span class="comment">// 比如60Hz的刷新的vsync间隔是16.666666ms</span></span><br><span class="line">        <span class="comment">// 计算得来的refreshRate就是：1000/16.666666 = 60.0000024</span></span><br><span class="line">        <span class="comment">// 不是恰好为60，所以需要去掉这个误差</span></span><br><span class="line">        <span class="keyword">if</span> (refreshRate &lt; (minRefreshRate - EPSILON)</span><br><span class="line">                || refreshRate &gt; (maxRefreshRate + EPSILON)) &#123;</span><br><span class="line">            <span class="comment">// 当该mode的刷新率不符合边界条件时，抛弃该mode</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        availableModes.add(mode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> availableModes.size();</span><br><span class="line">    <span class="type">int</span>[] availableModeIds = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        availableModeIds[i] = availableModes.get(i).getModeId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回符合要求的modeId集合</span></span><br><span class="line">    <span class="keyword">return</span> availableModeIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实实际推演一下就不难理解了, 假设我们有如下Votes:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mSupportedModesByDisplay:</span><br><span class="line">    0 -&gt; [</span><br><span class="line">        &#123;id=1, width=1080, height=2376, fps=60.000004&#125;, </span><br><span class="line">        &#123;id=2, width=1440, height=3168, fps=120.00001&#125;, </span><br><span class="line">        &#123;id=3, width=1440, height=3168, fps=60.000004&#125;, </span><br><span class="line">        &#123;id=4, width=1080, height=2376, fps=120.00001&#125;]</span><br><span class="line"></span><br><span class="line">  mVotesByDisplay:</span><br><span class="line">    -1:</span><br><span class="line">      PRIORITY_LOW_POWER_MODE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=60.0&#125;</span><br><span class="line">      PRIORITY_USER_SETTING_PEAK_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=120.0&#125;</span><br><span class="line">      PRIORITY_USER_SETTING_MIN_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=Infinity&#125;</span><br><span class="line">    0:</span><br><span class="line">      PRIORITY_APP_REQUEST_SIZE -&gt; Vote&#123;width=1080, height=2376, minRefreshRate=0.0, maxRefreshRate=Infinity&#125;</span><br><span class="line">      PRIORITY_APP_REQUEST_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=120.00001, maxRefreshRate=120.00001&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意这里的优先级:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>PRIORITY_LOW_BRIGHTNESS</td>
<td>0</td>
</tr>
<tr>
<td>PRIORITY_USER_SETTING_MIN_REFRESH_RATE</td>
<td>1</td>
</tr>
<tr>
<td>PRIORITY_APP_REQUEST_REFRESH_RATE</td>
<td>2</td>
</tr>
<tr>
<td>PRIORITY_APP_REQUEST_SIZE</td>
<td>3</td>
</tr>
<tr>
<td>PRIORITY_USER_SETTING_PEAK_REFRESH_RATE</td>
<td>4</td>
</tr>
<tr>
<td>PRIORITY_LOW_POWER_MODE</td>
<td>5</td>
</tr>
</tbody></table>
<p><strong>当外层循环第一次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_LOW_BRIGHTNESS &#x3D; 0</p>
<p>内层循环会遍历所有Vote(包含-1，和当前displayId,这里是0):</p>
<p>算出的minRefreshRate &#x3D; Infinity, maxRefreshRate &#x3D;0</p>
<p>当然，在filterModes中是找不到合适的mode的，所以优先级+1，继续搜索</p>
<p><strong>外层循环第二次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_USER_SETTING_MIN_REFRESH_RATE &#x3D; 1</p>
<p>此时排除优先级为0的所有Vote，其实结果还是一样，所以lowestConsideredPriority继续+1</p>
<p><strong>外层循环第三次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_APP_REQUEST_REFRESH_RATE &#x3D; 2</p>
<p>此时排除优先级小于PRIORITY_APP_REQUEST_REFRESH_RATE的所有Vote，结果还是一样，所以lowestConsideredPriority继续+1</p>
<p><strong>外层循环第四次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_APP_REQUEST_SIZE &#x3D; 3</p>
<p>此时排除优先级小于PRIORITY_APP_REQUEST_SIZE的所有Vote，结果还是一样，所以lowestConsideredPriority继续+1</p>
<p><strong>外层循环第五次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_USER_SETTING_PEAK_REFRESH_RATE &#x3D; 4</p>
<p>此时排除优先级小于PRIORITY_USER_SETTING_PEAK_REFRESH_RATE的所有Vote</p>
<p>内层循环其实只有两个选项：</p>
<p>PRIORITY_LOW_POWER_MODE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;60.0}</p>
<p>PRIORITY_USER_SETTING_PEAK_REFRESH_RATE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;120.0}</p>
<p>此时结果为minRefreshRate &#x3D; 60, maxRefreshRate &#x3D;0，当然还是没有有效的modeId</p>
<p><strong>外层循环第六次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_LOW_POWER_MODE &#x3D; 5</p>
<p>只有选项：PRIORITY_LOW_POWER_MODE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;60.0}</p>
<p>所以最终的minRefreshRate &#x3D; 0.0, maxRefreshRate &#x3D; 60.0，width&#x3D;1080, height&#x3D;2376</p>
<p>最后满足条件的modeId就只有mSupportedModesByDisplay中的0了.</p>
<p>最终算出来了modeId, 这里面计算复杂，弯弯绕绕，为什么Google如此设计呢，个人猜测是为了尽可能满足低优先级下的刷新率要求，并不是优先级最高就能决定modeId的取值,<br>而是找到尽快满足更多优先级下合适刷新率的modeId集提供给SurfaceFlinger选择.</p>
<p>继续往下看，framework将这个modeId集传给SurfaceFlinger.</p>
<h1 id="三-通知SurfaceFlinger变化"><a href="#三-通知SurfaceFlinger变化" class="headerlink" title="三. 通知SurfaceFlinger变化"></a>三. 通知SurfaceFlinger变化</h1><h2 id="3-1-DisplayManagerInternal-performTraversal"><a href="#3-1-DisplayManagerInternal-performTraversal" class="headerlink" title="3.1 DisplayManagerInternal.performTraversal"></a>3.1 DisplayManagerInternal.performTraversal</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTraversal</span><span class="params">(SurfaceControl.Transaction t)</span> &#123;</span><br><span class="line">    performTraversalInternal(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-DisplayManagerService-performTraversalInternal"><a href="#3-2-DisplayManagerService-performTraversalInternal" class="headerlink" title="3.2 DisplayManagerService.performTraversalInternal"></a>3.2 DisplayManagerService.performTraversalInternal</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performTraversalInternal</span><span class="params">(SurfaceControl.Transaction t)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mPendingTraversal) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingTraversal = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3.2.1 通知SF有相关状态变化</span></span><br><span class="line">        performTraversalLocked(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List is self-synchronized copy-on-write.</span></span><br><span class="line">    <span class="keyword">for</span> (DisplayTransactionListener listener : mDisplayTransactionListeners) &#123;</span><br><span class="line">        listener.onDisplayTransaction(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-DisplayManagerService-performTraversalLocked"><a href="#3-2-1-DisplayManagerService-performTraversalLocked" class="headerlink" title="3.2.1 DisplayManagerService.performTraversalLocked"></a>3.2.1 DisplayManagerService.performTraversalLocked</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversalLocked</span><span class="params">(SurfaceControl.Transaction t)</span> &#123;</span><br><span class="line">    <span class="comment">// Clear all viewports before configuring displays so that we can keep</span></span><br><span class="line">    <span class="comment">// track of which ones we have configured.</span></span><br><span class="line">    clearViewportsLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.2 对每个Display都做配置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mDisplayDevices.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">DisplayDevice</span> <span class="variable">device</span> <span class="operator">=</span> mDisplayDevices.get(i);</span><br><span class="line">        <span class="comment">// 与SurfaceFlinger通信，这里的device我们视为默认的LocalDisplayDevice</span></span><br><span class="line">        configureDisplayLocked(t, device);</span><br><span class="line">        device.performTraversalLocked(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-DisplayManagerService-configureDisplayLocked"><a href="#3-2-2-DisplayManagerService-configureDisplayLocked" class="headerlink" title="3.2.2 DisplayManagerService.configureDisplayLocked"></a>3.2.2 DisplayManagerService.configureDisplayLocked</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t, DisplayDevice device)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 拿到对应LogicalDisplay</span></span><br><span class="line">    <span class="type">LogicalDisplay</span> <span class="variable">display</span> <span class="operator">=</span> findLogicalDisplayForDeviceLocked(device);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 3.2.3 应用状态变化</span></span><br><span class="line">    display.configureDisplayLocked(t, device, info.state == Display.STATE_OFF);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-LogicalDisplay-configureDisplayLocked"><a href="#3-2-3-LogicalDisplay-configureDisplayLocked" class="headerlink" title="3.2.3 LogicalDisplay.configureDisplayLocked"></a>3.2.3 LogicalDisplay.configureDisplayLocked</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t,</span></span><br><span class="line"><span class="params">        DisplayDevice device,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isBlanked)</span> &#123;</span><br><span class="line">    <span class="comment">// Set the layer stack.</span></span><br><span class="line">    device.setLayerStackLocked(t, isBlanked ? BLANK_LAYER_STACK : mLayerStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 应用配置变化，注意这里的device是LocalDisplayDevice</span></span><br><span class="line">    <span class="keyword">if</span> (device == mPrimaryDisplayDevice) &#123;</span><br><span class="line">        device.setAllowedDisplayModesLocked(mAllowedDisplayModes);</span><br><span class="line">        device.setRequestedColorModeLocked(mRequestedColorMode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Reset to default for non primary displays</span></span><br><span class="line">        device.setAllowedDisplayModesLocked(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>&#125;);</span><br><span class="line">        device.setRequestedColorModeLocked(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-LocalDisplayAdapter-LocalDisplayDevice-setAllowedDisplayModesLocked"><a href="#3-3-LocalDisplayAdapter-LocalDisplayDevice-setAllowedDisplayModesLocked" class="headerlink" title="3.3 LocalDisplayAdapter.LocalDisplayDevice.setAllowedDisplayModesLocked"></a>3.3 LocalDisplayAdapter.LocalDisplayDevice.setAllowedDisplayModesLocked</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAllowedDisplayModesLocked</span><span class="params">(<span class="type">int</span>[] modes)</span> &#123;</span><br><span class="line">    updateAllowedModesLocked(modes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAllowedModesLocked</span><span class="params">(<span class="type">int</span>[] allowedModes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Arrays.equals(allowedModes, mAllowedModeIds) &amp;&amp; !mAllowedModeIdsInvalid) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (updateAllowedModesInternalLocked(allowedModes)) &#123;</span><br><span class="line">        updateDeviceInfoLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateAllowedModesInternalLocked</span><span class="params">(<span class="type">int</span>[] allowedModes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;updateAllowedModesInternalLocked(allowedModes=&quot;</span></span><br><span class="line">                + Arrays.toString(allowedModes) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] allowedPhysIndexes = <span class="keyword">new</span> <span class="title class_">int</span>[allowedModes.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将modeId转化为物理modeId，简单来说就是 physicalId = modeId - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> modeId : allowedModes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">physIndex</span> <span class="operator">=</span> findDisplayInfoIndexLocked(modeId);</span><br><span class="line">        <span class="keyword">if</span> (physIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Requested mode ID &quot;</span> + modeId + <span class="string">&quot; not available,&quot;</span></span><br><span class="line">                    + <span class="string">&quot; dropping from allowed set.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            allowedPhysIndexes[size++] = physIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 3.4 通过SurfaceControl通知SurfaceFlinger有modeId变化，binder通信</span></span><br><span class="line">    SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes);</span><br><span class="line">    <span class="type">int</span> <span class="variable">activePhysIndex</span> <span class="operator">=</span> SurfaceControl.getActiveConfig(getDisplayTokenLocked());</span><br><span class="line">    <span class="keyword">return</span> updateActiveModeLocked(activePhysIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-SurfaceControl-setAllowedDisplayConfigs"><a href="#3-4-SurfaceControl-setAllowedDisplayConfigs" class="headerlink" title="3.4 SurfaceControl.setAllowedDisplayConfigs"></a>3.4 SurfaceControl.setAllowedDisplayConfigs</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">nativeSetAllowedDisplayConfigs</span><span class="params">(IBinder displayToken,</span></span><br><span class="line"><span class="params">                                                                 <span class="type">int</span>[] allowedConfigs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setAllowedDisplayConfigs</span><span class="params">(IBinder displayToken, <span class="type">int</span>[] allowedConfigs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (displayToken == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;displayToken must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allowedConfigs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;allowedConfigs must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// JNI调用</span></span><br><span class="line">    <span class="keyword">return</span> nativeSetAllowedDisplayConfigs(displayToken, allowedConfigs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-android-view-SurfaceControl-nativeSetAllowedDisplayConfigs"><a href="#3-5-android-view-SurfaceControl-nativeSetAllowedDisplayConfigs" class="headerlink" title="3.5 android_view_SurfaceControl::nativeSetAllowedDisplayConfigs"></a>3.5 android_view_SurfaceControl::nativeSetAllowedDisplayConfigs</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">nativeSetAllowedDisplayConfigs</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject tokenObj, jintArray configArray)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">token</span><span class="params">(ibinderForJavaObject(env, tokenObj))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">nullptr</span>) <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; allowedConfigs;</span><br><span class="line">    jsize configArraySize = env-&gt;<span class="built_in">GetArrayLength</span>(configArray);</span><br><span class="line">    allowedConfigs.<span class="built_in">reserve</span>(configArraySize);</span><br><span class="line"></span><br><span class="line">    jint* configArrayElements = env-&gt;<span class="built_in">GetIntArrayElements</span>(configArray, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; configArraySize; i++) &#123;</span><br><span class="line">        allowedConfigs.<span class="built_in">push_back</span>(configArrayElements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="built_in">ReleaseIntArrayElements</span>(configArray, configArrayElements, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3.5.1 通过SurfaceComposerClient</span></span><br><span class="line">    <span class="type">size_t</span> result = SurfaceComposerClient::<span class="built_in">setAllowedDisplayConfigs</span>(token, allowedConfigs);</span><br><span class="line">    <span class="keyword">return</span> result == NO_ERROR ? JNI_TRUE : JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-1-SurfaceComposerClient-setAllowedDisplayConfigs"><a href="#3-5-1-SurfaceComposerClient-setAllowedDisplayConfigs" class="headerlink" title="3.5.1 SurfaceComposerClient::setAllowedDisplayConfigs"></a>3.5.1 SurfaceComposerClient::setAllowedDisplayConfigs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceComposerClient::setAllowedDisplayConfigs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken, <span class="type">const</span> std::vector&lt;<span class="type">int32_t</span>&gt;&amp; allowedConfigs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过binder调用到SurfaceFlinger</span></span><br><span class="line">    <span class="keyword">return</span> ComposerService::<span class="built_in">getComposerService</span>()-&gt;<span class="built_in">setAllowedDisplayConfigs</span>(displayToken,</span><br><span class="line">                                                                           allowedConfigs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-SurfaceFlinger-setAllowedDisplayConfigs"><a href="#3-6-SurfaceFlinger-setAllowedDisplayConfigs" class="headerlink" title="3.6 SurfaceFlinger::setAllowedDisplayConfigs"></a>3.6 SurfaceFlinger::setAllowedDisplayConfigs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::setAllowedDisplayConfigs</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> std::vector&lt;<span class="type">int32_t</span>&gt;&amp; allowedConfigs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!displayToken || allowedConfigs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDebugDisplayConfigSetByBackdoor) &#123;</span><br><span class="line">        <span class="comment">// ignore this request as config is overridden by backdoor</span></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postMessageSync</span>(<span class="keyword">new</span> <span class="built_in">LambdaMessage</span>([&amp;]() &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken);</span><br><span class="line">        <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Attempt to set allowed display configs for invalid display token %p&quot;</span>,</span><br><span class="line">                  displayToken.<span class="built_in">get</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (display-&gt;<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Attempt to set allowed display configs for virtual display&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">            <span class="built_in">setAllowedDisplayConfigsInternal</span>(display, allowedConfigs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，app设置屏幕显示刷新的流程就走完了，接下来就是SurfaceFlinger去和硬件交互，通知切换刷新率了。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Vsync</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
      </tags>
  </entry>
  <entry>
    <title>App申请帧率(3)--SF计算最佳帧率</title>
    <url>/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/</url>
    <content><![CDATA[<p>以下分析基于Android R.</p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一章我们分析了App是如何通过更改一个小小的WindowManager的LayoutParam的属性，来影响Framework决策帧率变化的。</p>
<p>接来下我们详细看看SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。</p>
<span id="more"></span>

<h1 id="一-SurfaceFlinger接受帧率变化"><a href="#一-SurfaceFlinger接受帧率变化" class="headerlink" title="一. SurfaceFlinger接受帧率变化"></a>一. SurfaceFlinger接受帧率变化</h1><p>接上一章，从 SurfaceFlinger::setAllowedDisplayConfigs 开始. 但是Android R上入口函数些许变化：</p>
<p>由SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes)</p>
<p>&#x3D;》SurfaceControl.setDesiredDisplayConfigSpecs(displayToken, configSpecs);</p>
<p>这里的configSpecs是DesiredDisplayConfigSpecs类型</p>
<h2 id="1-1-SurfaceControl-setDesiredDisplayConfigSpecs"><a href="#1-1-SurfaceControl-setDesiredDisplayConfigSpecs" class="headerlink" title="1.1 SurfaceControl.setDesiredDisplayConfigSpecs"></a>1.1 SurfaceControl.setDesiredDisplayConfigSpecs</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> boolean <span class="title">setDesiredDisplayConfigSpecs</span><span class="params">(IBinder displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">        SurfaceControl.DesiredDisplayConfigSpecs desiredDisplayConfigSpecs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (displayToken == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="string">&quot;displayToken must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">nativeSetDesiredDisplayConfigSpecs</span>(displayToken, desiredDisplayConfigSpecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-1-android-view-SurfaceControl-nativeSetDesiredDisplayConfigSpecs"><a href="#1-1-1-android-view-SurfaceControl-nativeSetDesiredDisplayConfigSpecs" class="headerlink" title="1.1.1 android_view_SurfaceControl.nativeSetDesiredDisplayConfigSpecs"></a>1.1.1 android_view_SurfaceControl.nativeSetDesiredDisplayConfigSpecs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">nativeSetDesiredDisplayConfigSpecs</span><span class="params">(JNIEnv* env, jclass clazz, jobject tokenObj,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   jobject desiredDisplayConfigSpecs)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">token</span><span class="params">(ibinderForJavaObject(env, tokenObj))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">nullptr</span>) <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    jint defaultConfig = env-&gt;<span class="built_in">GetIntField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                                          gDesiredDisplayConfigSpecsClassInfo.defaultConfig);</span><br><span class="line">    jfloat primaryRefreshRateMin =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.primaryRefreshRateMin);</span><br><span class="line">    jfloat primaryRefreshRateMax =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.primaryRefreshRateMax);</span><br><span class="line">    jfloat appRequestRefreshRateMin =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.appRequestRefreshRateMin);</span><br><span class="line">    jfloat appRequestRefreshRateMax =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.appRequestRefreshRateMax);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> result = SurfaceComposerClient::<span class="built_in">setDesiredDisplayConfigSpecs</span>(token, defaultConfig,</span><br><span class="line">                                                                        primaryRefreshRateMin,</span><br><span class="line">                                                                        primaryRefreshRateMax,</span><br><span class="line">                                                                        appRequestRefreshRateMin,</span><br><span class="line">                                                                        appRequestRefreshRateMax);</span><br><span class="line">    <span class="keyword">return</span> result == NO_ERROR ? JNI_TRUE : JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-SurfaceComposerClient-setDesiredDisplayConfigSpecs"><a href="#1-1-2-SurfaceComposerClient-setDesiredDisplayConfigSpecs" class="headerlink" title="1.1.2 SurfaceComposerClient.setDesiredDisplayConfigSpecs"></a>1.1.2 SurfaceComposerClient.setDesiredDisplayConfigSpecs</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceComposerClient::setDesiredDisplayConfigSpecs</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">int32_t</span> defaultConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> primaryRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> primaryRefreshRateMax,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> appRequestRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> appRequestRefreshRateMax)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转到SurfaceFlinger</span></span><br><span class="line">    <span class="keyword">return</span> ComposerService::<span class="built_in">getComposerService</span>()</span><br><span class="line">            -&gt;<span class="built_in">setDesiredDisplayConfigSpecs</span>(displayToken, defaultConfig, primaryRefreshRateMin,</span><br><span class="line">                                           primaryRefreshRateMax, appRequestRefreshRateMin,</span><br><span class="line">                                           appRequestRefreshRateMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-SurfaceFlinger-setDesiredDisplayConfigSpecs"><a href="#1-2-SurfaceFlinger-setDesiredDisplayConfigSpecs" class="headerlink" title="1.2 SurfaceFlinger.setDesiredDisplayConfigSpecs"></a>1.2 SurfaceFlinger.setDesiredDisplayConfigSpecs</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::setDesiredDisplayConfigSpecs</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">int32_t</span> defaultConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> primaryRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> primaryRefreshRateMax,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> appRequestRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> appRequestRefreshRateMax)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!displayToken) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> future = <span class="built_in">schedule</span>([=]() -&gt; <span class="type">status_t</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken);</span><br><span class="line">        <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Attempt to set desired display configs for invalid display token %p&quot;</span>,</span><br><span class="line">                  displayToken.<span class="built_in">get</span>());</span><br><span class="line">            <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (display-&gt;<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Attempt to set desired display configs for virtual display&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">using</span> Policy = scheduler::RefreshRateConfigs::Policy;</span><br><span class="line">            <span class="comment">// 初始化policy</span></span><br><span class="line">            <span class="type">const</span> Policy policy&#123;<span class="built_in">HwcConfigIndexType</span>(defaultConfig),</span><br><span class="line">                                &#123;primaryRefreshRateMin, primaryRefreshRateMax&#125;,</span><br><span class="line">                                &#123;appRequestRefreshRateMin, appRequestRefreshRateMax&#125;&#125;;</span><br><span class="line">            <span class="keyword">constexpr</span> <span class="type">bool</span> kOverridePolicy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setDesiredDisplayConfigSpecsInternal</span>(display, policy, kOverridePolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> future.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-SurfaceFlinger-schedule"><a href="#1-2-1-SurfaceFlinger-schedule" class="headerlink" title="1.2.1 SurfaceFlinger.schedule"></a>1.2.1 SurfaceFlinger.schedule</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::future&lt;T&gt; <span class="title">SurfaceFlinger::schedule</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [task, future] = <span class="built_in">makeTask</span>(std::<span class="built_in">move</span>(f));</span><br><span class="line">    mEventQueue-&gt;<span class="built_in">postMessage</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  MessageQueue.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">makeTask</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    sp&lt;Task&lt;F&gt;&gt; task = <span class="keyword">new</span> <span class="built_in">Task</span>&lt;F&gt;(std::<span class="built_in">move</span>(f));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(task, task-&gt;mTask.<span class="built_in">get_future</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  MessageQueue.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> : <span class="keyword">public</span> MessageHandler &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">makeTask</span><span class="params">(G&amp;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(F&amp;&amp; f)</span> : mTask(std::move(f)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleMessage</span><span class="params">(<span class="type">const</span> Message&amp;)</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">mTask</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">invoke_result_t</span>&lt;F&gt;;</span><br><span class="line">    std::packaged_task&lt;<span class="built_in">T</span>()&gt; mTask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-SurfaceFlinger-setDesiredDisplayConfigSpecsInternal"><a href="#1-3-SurfaceFlinger-setDesiredDisplayConfigSpecsInternal" class="headerlink" title="1.3 SurfaceFlinger.setDesiredDisplayConfigSpecsInternal"></a>1.3 SurfaceFlinger.setDesiredDisplayConfigSpecsInternal</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::setDesiredDisplayConfigSpecsInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; display,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::optional&lt;scheduler::RefreshRateConfigs::Policy&gt;&amp; policy, <span class="type">bool</span> overridePolicy)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// overridePolicy 一般都是false</span></span><br><span class="line">    <span class="type">status_t</span> setPolicyResult = overridePolicy</span><br><span class="line">            ? mRefreshRateConfigs-&gt;<span class="built_in">setOverridePolicy</span>(policy)</span><br><span class="line">            <span class="comment">// 1.3.1 更改当前帧率策略</span></span><br><span class="line">            : mRefreshRateConfigs-&gt;<span class="built_in">setDisplayManagerPolicy</span>(*policy);</span><br><span class="line">    <span class="keyword">if</span> (setPolicyResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setPolicyResult == scheduler::RefreshRateConfigs::CURRENT_POLICY_UNCHANGED) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduler::RefreshRateConfigs::Policy currentPolicy = mRefreshRateConfigs-&gt;<span class="built_in">getCurrentPolicy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Setting desired display config specs: defaultConfig: %d primaryRange: [%.0f %.0f]&quot;</span></span><br><span class="line">          <span class="string">&quot; expandedRange: [%.0f %.0f]&quot;</span>,</span><br><span class="line">          currentPolicy.defaultConfig.<span class="built_in">value</span>(), currentPolicy.primaryRange.min,</span><br><span class="line">          currentPolicy.primaryRange.max, currentPolicy.appRequestRange.min,</span><br><span class="line">          currentPolicy.appRequestRange.max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/140204874): Leave the event in until we do proper testing with all apps that might</span></span><br><span class="line">    <span class="comment">// be depending in this callback.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> vsyncPeriod =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(display-&gt;<span class="built_in">getActiveConfig</span>())</span><br><span class="line">                    .<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    mScheduler-&gt;<span class="built_in">onPrimaryDisplayConfigChanged</span>(mAppConnectionHandle, display-&gt;<span class="built_in">getId</span>()-&gt;value,</span><br><span class="line">                                              display-&gt;<span class="built_in">getActiveConfig</span>(), vsyncPeriod);</span><br><span class="line">    <span class="built_in">toggleKernelIdleTimer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3.3 获取configId</span></span><br><span class="line">    <span class="keyword">auto</span> configId = mScheduler-&gt;<span class="built_in">getPreferredConfigId</span>();</span><br><span class="line">    <span class="comment">// configId是std::optional&lt;HwcConfigIndexType&gt;类型的，这里判断是否存在值，一般存在</span></span><br><span class="line">    <span class="comment">// 根据HwcConfigIndexType获取实际的 RefreshRate 参数</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; preferredRefreshRate = configId</span><br><span class="line">            ? mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(*configId)</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> Choose the default config ID, if Scheduler doesn&#x27;t have one in mind.</span></span><br><span class="line">            : mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(currentPolicy.defaultConfig);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;trying to switch to Scheduler preferred config %d (%s)&quot;</span>,</span><br><span class="line">          preferredRefreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>(), preferredRefreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断RefreshRate是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isDisplayConfigAllowed</span>(preferredRefreshRate.<span class="built_in">getConfigId</span>())) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;switching to Scheduler preferred config %d&quot;</span>,</span><br><span class="line">              preferredRefreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>());</span><br><span class="line">        <span class="comment">// 1.4 设置帧率</span></span><br><span class="line">        <span class="built_in">setDesiredActiveConfig</span>(</span><br><span class="line">                &#123;preferredRefreshRate.<span class="built_in">getConfigId</span>(), Scheduler::ConfigEvent::Changed&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;Desired config not allowed: %d&quot;</span>,</span><br><span class="line">                         preferredRefreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-RefreshRateConfigs-setDisplayManagerPolicy"><a href="#1-3-1-RefreshRateConfigs-setDisplayManagerPolicy" class="headerlink" title="1.3.1 RefreshRateConfigs.setDisplayManagerPolicy"></a>1.3.1 RefreshRateConfigs.setDisplayManagerPolicy</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">RefreshRateConfigs::setDisplayManagerPolicy</span><span class="params">(<span class="type">const</span> Policy&amp; policy)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isPolicyValid</span>(policy)) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前策略，如果mOverridePolicy是false，也就是没有覆写</span></span><br><span class="line">    <span class="comment">// 就是用的mDisplayManagerPolicy</span></span><br><span class="line">    Policy previousPolicy = *<span class="built_in">getCurrentPolicyLocked</span>();</span><br><span class="line">    mDisplayManagerPolicy = policy;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">getCurrentPolicyLocked</span>() == previousPolicy) &#123;</span><br><span class="line">        <span class="keyword">return</span> CURRENT_POLICY_UNCHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.3.2 根据策略构建最终刷新率</span></span><br><span class="line">    <span class="built_in">constructAvailableRefreshRates</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-RefreshRateConfigs-constructAvailableRefreshRates"><a href="#1-3-2-RefreshRateConfigs-constructAvailableRefreshRates" class="headerlink" title="1.3.2 RefreshRateConfigs.constructAvailableRefreshRates"></a>1.3.2 RefreshRateConfigs.constructAvailableRefreshRates</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RefreshRateConfigs::constructAvailableRefreshRates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Filter configs based on current policy and sort based on vsync period</span></span><br><span class="line">    <span class="type">const</span> Policy* policy = <span class="built_in">getCurrentPolicyLocked</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; defaultConfig = mRefreshRates.<span class="built_in">at</span>(policy-&gt;defaultConfig)-&gt;hwcConfig;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;constructAvailableRefreshRates: default %d group %d primaryRange=[%.2f %.2f]&quot;</span></span><br><span class="line">          <span class="string">&quot; appRequestRange=[%.2f %.2f]&quot;</span>,</span><br><span class="line">          policy-&gt;defaultConfig.<span class="built_in">value</span>(), defaultConfig-&gt;<span class="built_in">getConfigGroup</span>(), policy-&gt;primaryRange.min,</span><br><span class="line">          policy-&gt;primaryRange.max, policy-&gt;appRequestRange.min, policy-&gt;appRequestRange.max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambuda A</span></span><br><span class="line">    <span class="keyword">auto</span> filterRefreshRates = [&amp;](<span class="type">float</span> min, <span class="type">float</span> max, <span class="type">const</span> <span class="type">char</span>* listName,</span><br><span class="line">                                  std::vector&lt;<span class="type">const</span> RefreshRate*&gt;* outRefreshRates) &#123;</span><br><span class="line">        <span class="comment">// lambuda B</span></span><br><span class="line">        <span class="built_in">getSortedRefreshRateList</span>(</span><br><span class="line">                [&amp;](<span class="type">const</span> RefreshRate&amp; refreshRate) <span class="built_in">REQUIRES</span>(mLock) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span>&amp; hwcConfig = refreshRate.hwcConfig;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> hwcConfig-&gt;<span class="built_in">getHeight</span>() == defaultConfig-&gt;<span class="built_in">getHeight</span>() &amp;&amp;</span><br><span class="line">                            hwcConfig-&gt;<span class="built_in">getWidth</span>() == defaultConfig-&gt;<span class="built_in">getWidth</span>() &amp;&amp;</span><br><span class="line">                            hwcConfig-&gt;<span class="built_in">getDpiX</span>() == defaultConfig-&gt;<span class="built_in">getDpiX</span>() &amp;&amp;</span><br><span class="line">                            hwcConfig-&gt;<span class="built_in">getDpiY</span>() == defaultConfig-&gt;<span class="built_in">getDpiY</span>() &amp;&amp;</span><br><span class="line">                            (policy-&gt;allowGroupSwitching ||</span><br><span class="line">                             hwcConfig-&gt;<span class="built_in">getConfigGroup</span>() == defaultConfig-&gt;<span class="built_in">getConfigGroup</span>()) &amp;&amp;</span><br><span class="line">                            refreshRate.<span class="built_in">inPolicy</span>(min, max);</span><br><span class="line">                &#125;,</span><br><span class="line">                outRefreshRates);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(outRefreshRates-&gt;<span class="built_in">empty</span>(),</span><br><span class="line">                            <span class="string">&quot;No matching configs for %s range: min=%.0f max=%.0f&quot;</span>, listName, min,</span><br><span class="line">                            max);</span><br><span class="line">        <span class="keyword">auto</span> stringifyRefreshRates = [&amp;]() -&gt; std::string &#123;</span><br><span class="line">            std::string str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> refreshRate : *outRefreshRates) &#123;</span><br><span class="line">                base::<span class="built_in">StringAppendF</span>(&amp;str, <span class="string">&quot;%s &quot;</span>, refreshRate-&gt;name.<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;%s refresh rates: %s&quot;</span>, listName, <span class="built_in">stringifyRefreshRates</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">filterRefreshRates</span>(policy-&gt;primaryRange.min, policy-&gt;primaryRange.max, <span class="string">&quot;primary&quot;</span>,</span><br><span class="line">                       &amp;mPrimaryRefreshRates);</span><br><span class="line">    <span class="built_in">filterRefreshRates</span>(policy-&gt;appRequestRange.min, policy-&gt;appRequestRange.max, <span class="string">&quot;app request&quot;</span>,</span><br><span class="line">                       &amp;mAppRequestRefreshRates);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RefreshRateConfigs::getSortedRefreshRateList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::function&lt;<span class="type">bool</span>(<span class="type">const</span> RefreshRate&amp;)&gt;&amp; shouldAddRefreshRate,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::vector&lt;<span class="type">const</span> RefreshRate*&gt;* outRefreshRates)</span> </span>&#123;</span><br><span class="line">    outRefreshRates-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    outRefreshRates-&gt;<span class="built_in">reserve</span>(mRefreshRates.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 遍历所有可能的RefreshRate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [type, refreshRate] : mRefreshRates) &#123;</span><br><span class="line">        <span class="comment">// 调用上面的lambuda B方法, 其实就是条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shouldAddRefreshRate</span>(*refreshRate)) &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;getSortedRefreshRateList: config %d added to list policy&quot;</span>,</span><br><span class="line">                  refreshRate-&gt;configId.<span class="built_in">value</span>());</span><br><span class="line">            outRefreshRates-&gt;<span class="built_in">push_back</span>(refreshRate.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照帧率大小排序，VsyncPeriod越大，Fps越小。</span></span><br><span class="line">    <span class="comment">// 这里就是按照Fps升序排序了</span></span><br><span class="line">    std::<span class="built_in">sort</span>(outRefreshRates-&gt;<span class="built_in">begin</span>(), outRefreshRates-&gt;<span class="built_in">end</span>(),</span><br><span class="line">              [](<span class="type">const</span> <span class="keyword">auto</span> refreshRate1, <span class="type">const</span> <span class="keyword">auto</span> refreshRate2) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (refreshRate1-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>() !=</span><br><span class="line">                      refreshRate2-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>()) &#123;</span><br><span class="line">                      <span class="keyword">return</span> refreshRate1-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>() &gt;</span><br><span class="line">                              refreshRate2-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> refreshRate1-&gt;hwcConfig-&gt;<span class="built_in">getConfigGroup</span>() &gt;</span><br><span class="line">                              refreshRate2-&gt;hwcConfig-&gt;<span class="built_in">getConfigGroup</span>();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里吐槽一下，写的很丑。直接说明，在 mRefreshRates中寻找符合要求的configId(modeId)放入对应的集合中。</p>
<p>这里说的符合要求是指：</p>
<ol>
<li>宽高与所设置的Policy中的defaultConfig的宽高一致</li>
<li>其帧率在所设置的Policy的最小和最大帧率之中</li>
</ol>
<p>最终将结果保存在变量：mPrimaryRefreshRates以及mAppRequestRefreshRates中。</p>
<h3 id="1-3-3-Scheduler-getPreferredConfigId"><a href="#1-3-3-Scheduler-getPreferredConfigId" class="headerlink" title="1.3.3 Scheduler.getPreferredConfigId"></a>1.3.3 Scheduler.getPreferredConfigId</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::optional&lt;HwcConfigIndexType&gt; <span class="title">Scheduler::getPreferredConfigId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mFeatureStateLock)</span></span>;</span><br><span class="line">    <span class="comment">// Make sure that the default config ID is first updated, before returned.</span></span><br><span class="line">    <span class="comment">// mFeatures 是一个结构体</span></span><br><span class="line">    <span class="keyword">if</span> (mFeatures.configId.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="comment">// configId是一个 std:optional的变量</span></span><br><span class="line">        <span class="comment">// 计算当前刷新率的configId</span></span><br><span class="line">        mFeatures.configId = <span class="built_in">calculateRefreshRateConfigIndexType</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mFeatures.configId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方原以为mFeatures.configId一般是存在value的，其实并不是。</p>
<h3 id="1-3-4-Scheduler-calculateRefreshRateConfigIndexType"><a href="#1-3-4-Scheduler-calculateRefreshRateConfigIndexType" class="headerlink" title="1.3.4 Scheduler.calculateRefreshRateConfigIndexType"></a>1.3.4 Scheduler.calculateRefreshRateConfigIndexType</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// consideredSignals 的默认参数是nullptr的</span></span><br><span class="line"><span class="function">HwcConfigIndexType <span class="title">Scheduler::calculateRefreshRateConfigIndexType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        scheduler::RefreshRateConfigs::GlobalSignals* consideredSignals)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> touchActive = mTouchTimer &amp;&amp; mFeatures.touch == TouchState::Active;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> idle = mIdleTimer &amp;&amp; mFeatures.idleTimer == TimerState::Expired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 1.3.5 获取最佳ConfigId, 根据framework传来的帧率范围, 以及当下Layer投票产生</span></span><br><span class="line">    <span class="keyword">return</span> mRefreshRateConfigs</span><br><span class="line">            .<span class="built_in">getBestRefreshRate</span>(mFeatures.contentRequirements, &#123;.touch = touchActive, .idle = idle&#125;,</span><br><span class="line">                                consideredSignals)</span><br><span class="line">            .<span class="built_in">getConfigId</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-5-RefreshRateConfigs-getBestRefreshRate"><a href="#1-3-5-RefreshRateConfigs-getBestRefreshRate" class="headerlink" title="1.3.5 RefreshRateConfigs.getBestRefreshRate"></a>1.3.5 RefreshRateConfigs.getBestRefreshRate</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> RefreshRate&amp; <span class="title">RefreshRateConfigs::getBestRefreshRate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;LayerRequirement&gt;&amp; layers, <span class="type">const</span> GlobalSignals&amp; globalSignals,</span></span></span><br><span class="line"><span class="params"><span class="function">        GlobalSignals* outSignalsConsidered)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;getRefreshRateForContent %zu layers&quot;</span>, layers.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意传入的outSignalsConsidered是nullptr的</span></span><br><span class="line">    <span class="keyword">if</span> (outSignalsConsidered) *outSignalsConsidered = &#123;&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> setTouchConsidered = [&amp;] &#123;</span><br><span class="line">        <span class="keyword">if</span> (outSignalsConsidered) &#123;</span><br><span class="line">            outSignalsConsidered-&gt;touch = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> setIdleConsidered = [&amp;] &#123;</span><br><span class="line">        <span class="keyword">if</span> (outSignalsConsidered) &#123;</span><br><span class="line">            outSignalsConsidered-&gt;idle = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">// 开始投票</span></span><br><span class="line">    <span class="comment">// 首先计算所有不同LayerVoteType的数量</span></span><br><span class="line">    <span class="comment">// 这里的Type稍后介绍</span></span><br><span class="line">    <span class="type">int</span> noVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> explicitDefaultVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> explicitExactOrMultipleVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最大的权重</span></span><br><span class="line">    <span class="type">float</span> maxExplicitWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : layers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer.vote == LayerVoteType::NoVote) &#123;</span><br><span class="line">            noVoteLayers++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::Min) &#123;</span><br><span class="line">            minVoteLayers++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::Max) &#123;</span><br><span class="line">            maxVoteLayers++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitDefault) &#123;</span><br><span class="line">            explicitDefaultVoteLayers++;</span><br><span class="line">            maxExplicitWeight = std::<span class="built_in">max</span>(maxExplicitWeight, layer.weight);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitExactOrMultiple) &#123;</span><br><span class="line">            explicitExactOrMultipleVoteLayers++;</span><br><span class="line">            maxExplicitWeight = std::<span class="built_in">max</span>(maxExplicitWeight, layer.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> hasExplicitVoteLayers =</span><br><span class="line">            explicitDefaultVoteLayers &gt; <span class="number">0</span> || explicitExactOrMultipleVoteLayers &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $1. 如果没有显式Layer, 考虑触摸事件, 如果存在触摸事件, 选择最大帧率</span></span><br><span class="line">    <span class="keyword">if</span> (globalSignals.touch &amp;&amp; !hasExplicitVoteLayers) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;TouchBoost - choose %s&quot;</span>, <span class="built_in">getMaxRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">setTouchConsidered</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果刷新率范围由单个刷新率组成，那么只有当层显式请求不同的刷新率时，才能选择超出范围</span></span><br><span class="line">    <span class="type">const</span> Policy* policy = <span class="built_in">getCurrentPolicyLocked</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> primaryRangeIsSingleRate = policy-&gt;primaryRange.min == policy-&gt;primaryRange.max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $2. 没有touch事件，屏幕处于idle状态, 刷新率存在一定范围或者不存在显示请求刷新率的Layer时</span></span><br><span class="line">    <span class="comment">// 选择最小帧率</span></span><br><span class="line">    <span class="keyword">if</span> (!globalSignals.touch &amp;&amp; globalSignals.idle &amp;&amp;</span><br><span class="line">        !(primaryRangeIsSingleRate &amp;&amp; hasExplicitVoteLayers)) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Idle - choose %s&quot;</span>, <span class="built_in">getMinRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">setIdleConsidered</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMinRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $3. 没有Layer或者所有Layer都没有投票(NoVote)时, 选择最大帧率？？？</span></span><br><span class="line">    <span class="keyword">if</span> (layers.<span class="built_in">empty</span>() || noVoteLayers == layers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $4. 存在Layer且所有Layer要么不投票，要么请求最小帧率时，选择最小帧率</span></span><br><span class="line">    <span class="keyword">if</span> (noVoteLayers + minVoteLayers == layers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;all layers Min - choose %s&quot;</span>, <span class="built_in">getMinRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMinRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $5. 计算找到最佳刷新率</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">const</span> RefreshRate*, <span class="type">float</span>&gt;&gt; scores;</span><br><span class="line">    scores.<span class="built_in">reserve</span>(mAppRequestRefreshRates.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> refreshRate : mAppRequestRefreshRates) &#123;</span><br><span class="line">        scores.<span class="built_in">emplace_back</span>(refreshRate, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有Layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : layers) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Calculating score for %s (%s, weight %.2f)&quot;</span>, layer.name.<span class="built_in">c_str</span>(),</span><br><span class="line">              <span class="built_in">layerVoteTypeString</span>(layer.vote).<span class="built_in">c_str</span>(), layer.weight);</span><br><span class="line">        <span class="comment">// 忽略不投票或者投票选择最小帧率的Layer</span></span><br><span class="line">        <span class="keyword">if</span> (layer.vote == LayerVoteType::NoVote || layer.vote == LayerVoteType::Min) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> weight = layer.weight;</span><br><span class="line">        <span class="comment">// 注意这里还有一层循环，分别计算每个AppRequestRefreshRate的得分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0u</span>; i &lt; scores.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">bool</span> inPrimaryRange =</span><br><span class="line">                    scores[i].first-&gt;<span class="built_in">inPolicy</span>(policy-&gt;primaryRange.min, policy-&gt;primaryRange.max);</span><br><span class="line">            <span class="keyword">if</span> ((primaryRangeIsSingleRate || !inPrimaryRange) &amp;&amp;</span><br><span class="line">                !(layer.focused &amp;&amp;</span><br><span class="line">                  (layer.vote == LayerVoteType::ExplicitDefault ||</span><br><span class="line">                   layer.vote == LayerVoteType::ExplicitExactOrMultiple))) &#123;</span><br><span class="line">                <span class="comment">// $$5.1 只有具有显式帧速率设置的聚焦层才允许对主范围之外的刷新率进行评分</span></span><br><span class="line">                <span class="comment">// 换句话说，只有ExplicitDefault或者ExplicitExactOrMultiple类型的Layer，且该Layer是有焦点的</span></span><br><span class="line">                <span class="comment">// 才允许投票超出刷新率请求范围的帧率</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $$5.2 如果图层想要最大值，给更高的刷新率评分</span></span><br><span class="line">            <span class="keyword">if</span> (layer.vote == LayerVoteType::Max) &#123;</span><br><span class="line">                <span class="comment">// 用当前layer(app)请求的帧率除以最后一个layer(app)请求的帧率</span></span><br><span class="line">                <span class="comment">// 注意到mAppRequestRefreshRates中fps是按照升序排序的，最后一个是最大的</span></span><br><span class="line">                <span class="comment">// 所以这里就是用 当前请求的帧率除以最大的请求帧率得到一个 (0, 1] 的比值</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> ratio = scores[i].first-&gt;fps / scores.<span class="built_in">back</span>().first-&gt;fps;</span><br><span class="line">                <span class="comment">// 使用比值的平方得到一个较低的分数 ==&gt; 为啥？</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> layerScore = ratio * ratio;</span><br><span class="line">                <span class="built_in">ALOGV</span>(<span class="string">&quot;%s (Max, weight %.2f) gives %s score of %.2f&quot;</span>, layer.name.<span class="built_in">c_str</span>(), weight,</span><br><span class="line">                      scores[i].first-&gt;name.<span class="built_in">c_str</span>(), layerScore);</span><br><span class="line">                <span class="comment">// 将比值的平方乘上权重系数，作为该layer的分数</span></span><br><span class="line">                scores[i].second += weight * layerScore;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏幕刷新率</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> displayPeriod = scores[i].first-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">            <span class="comment">// Layer所需的刷新率</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> layerPeriod = <span class="built_in">round</span>&lt;<span class="type">nsecs_t</span>&gt;(<span class="number">1e9</span>f / layer.desiredRefreshRate);</span><br><span class="line">            <span class="comment">// $$5.3 如果是ExplicitDefault类型的Layer</span></span><br><span class="line">            <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitDefault) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> layerScore = [&amp;]() &#123;</span><br><span class="line">                    <span class="comment">// 找到Layer将渲染的实际速率，假设layerPeriod是渲染帧的最短时间</span></span><br><span class="line">                    <span class="keyword">auto</span> actualLayerPeriod = displayPeriod;</span><br><span class="line">                    <span class="type">int</span> multiplier = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 刷新时长依次翻倍，直到满足该Layer刷新的最低时长，也就是fps大小每次折半</span></span><br><span class="line">                    <span class="comment">// MARGIN_FOR_PERIOD_CALCULATION = 800us</span></span><br><span class="line">                    <span class="keyword">while</span> (layerPeriod &gt; actualLayerPeriod + MARGIN_FOR_PERIOD_CALCULATION) &#123;</span><br><span class="line">                        multiplier++;</span><br><span class="line">                        actualLayerPeriod = displayPeriod * multiplier;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 此时layer分数为 layer所需的时长除以满足刷新要求的最长时长</span></span><br><span class="line">                    <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="number">1.0f</span>,</span><br><span class="line">                                    <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(layerPeriod) /</span><br><span class="line">                                            <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(actualLayerPeriod));</span><br><span class="line">                &#125;();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">ALOGV</span>(<span class="string">&quot;%s (ExplicitDefault, weight %.2f) %.2fHz gives %s score of %.2f&quot;</span>,</span><br><span class="line">                      layer.name.<span class="built_in">c_str</span>(), weight, <span class="number">1e9</span>f / layerPeriod, scores[i].first-&gt;name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      layerScore);</span><br><span class="line">                <span class="comment">// layer分数乘上权重作为该layer的最终分数</span></span><br><span class="line">                scores[i].second += weight * layerScore;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $$5.4 如果是ExplicitExactOrMultiple或者Heuristic类型的Layer</span></span><br><span class="line">            <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitExactOrMultiple ||</span><br><span class="line">                layer.vote == LayerVoteType::Heuristic) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> layerScore = [&amp;] &#123;</span><br><span class="line">                    <span class="comment">// 计算我们需要多少个显示vSync来显示这个层的一个帧</span></span><br><span class="line">                    <span class="comment">// 其实就是计算 layerPeriod/displayPeriod 得到商和余数</span></span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> [displayFramesQuot, displayFramesRem] =</span><br><span class="line">                            <span class="built_in">getDisplayFrames</span>(layerPeriod, displayPeriod);</span><br><span class="line">                    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> MAX_FRAMES_TO_FIT =</span><br><span class="line">                            <span class="number">10</span>; <span class="comment">// Stop calculating when score &lt; 0.1</span></span><br><span class="line">                    <span class="keyword">if</span> (displayFramesRem == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 整除的时候，直接返回1?</span></span><br><span class="line">                        <span class="comment">// 说明layer请求的fps是比display的fps小，得分直接拉满</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (displayFramesQuot == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 当layer请求的fps比display中的fps要大的时候</span></span><br><span class="line">                        <span class="comment">// 返回layer period除以display period的商的十一分之一</span></span><br><span class="line">                        <span class="comment">// 比如 layer = 120Hz， display = 90Hz</span></span><br><span class="line">                        <span class="comment">//                    8.33333         1.0</span></span><br><span class="line">                        <span class="comment">//  return =  -----------  *   ----</span></span><br><span class="line">                        <span class="comment">//                     11.1111         11</span></span><br><span class="line">                        <span class="comment">// 为啥怎么算呢，这里分数的极限值也就是1/11，最大限度排除这个layer请求的帧率？</span></span><br><span class="line">                        <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(layerPeriod) /</span><br><span class="line">                                <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(displayPeriod)) *</span><br><span class="line">                                (<span class="number">1.0f</span> / (MAX_FRAMES_TO_FIT + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// layer所需的刷新率低于的显示刷新率，但又不是整数倍关系，检查它是否符合节奏</span></span><br><span class="line">                    <span class="comment">// 计算差值: 用 Pl 表述 layer period，Pd表示display period</span></span><br><span class="line">                    <span class="comment">// diff = | (Pl mod Pd) * 2 - Pd |</span></span><br><span class="line">                    <span class="comment">// 这里的意思是在计算多少帧内，display 刷新可以匹配 layer请求的刷新</span></span><br><span class="line">                    <span class="keyword">auto</span> diff = std::<span class="built_in">abs</span>(displayFramesRem - (displayPeriod - displayFramesRem));</span><br><span class="line">                    <span class="type">int</span> iter = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">while</span> (diff &gt; MARGIN_FOR_PERIOD_CALCULATION &amp;&amp; iter &lt; MAX_FRAMES_TO_FIT) &#123;</span><br><span class="line">                        <span class="comment">// 循环计算，总结公式：</span></span><br><span class="line">                        <span class="comment">// 1. diff0 = 2 * (Pl mod Pd) - Pd, Pl &gt; Pd 且 K ∈ &#123;1,2,3,...,9&#125;</span></span><br><span class="line">                        <span class="comment">// 2. 当diff0 &gt; 0 时, diff = (Pl mod Pd) * 2^k - Pd * (2^k-1)</span></span><br><span class="line">                        <span class="comment">// 3. 当diff0 &lt; 0 时, diff = Pd - 2^k * (Pl mode Pd)</span></span><br><span class="line">                        diff = diff - (displayPeriod - diff);</span><br><span class="line">                        iter++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 得分取值范围是[0.1, 0.5]</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1.0f</span> / iter;</span><br><span class="line">                &#125;();</span><br><span class="line">                <span class="built_in">ALOGV</span>(<span class="string">&quot;%s (%s, weight %.2f) %.2fHz gives %s score of %.2f&quot;</span>, layer.name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      <span class="built_in">layerVoteTypeString</span>(layer.vote).<span class="built_in">c_str</span>(), weight, <span class="number">1e9</span>f / layerPeriod,</span><br><span class="line">                      scores[i].first-&gt;name.<span class="built_in">c_str</span>(), layerScore);</span><br><span class="line">                <span class="comment">// 照例，乘上权重作为分数</span></span><br><span class="line">                scores[i].second += weight * layerScore;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $6 如果存在请求最大帧率的layer就反向遍历</span></span><br><span class="line">    <span class="comment">// 找到得分最大的帧率</span></span><br><span class="line">    <span class="type">const</span> RefreshRate* bestRefreshRate = maxVoteLayers &gt; <span class="number">0</span></span><br><span class="line">            ? <span class="built_in">getBestRefreshRate</span>(scores.<span class="built_in">rbegin</span>(), scores.<span class="built_in">rend</span>())</span><br><span class="line">            : <span class="built_in">getBestRefreshRate</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示主刷新率没有范围，只有定值时</span></span><br><span class="line">    <span class="keyword">if</span> (primaryRangeIsSingleRate) &#123;</span><br><span class="line">        <span class="comment">// 如果没有layer参与评分，从显示主刷新范围选取最大值</span></span><br><span class="line">        <span class="comment">// 否则返回计算得出的最佳刷新率</span></span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">all_of</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(),</span><br><span class="line">                        [](std::pair&lt;<span class="type">const</span> RefreshRate*, <span class="type">float</span>&gt; p) &#123; <span class="keyword">return</span> p.second == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;layers not scored - choose %s&quot;</span>,</span><br><span class="line">                  <span class="built_in">getMaxRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *bestRefreshRate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有explicitDefaultLayers，请考虑touch事件。</span></span><br><span class="line">    <span class="comment">// ExplicitDefault主要是交互式的（与ExplicitExactOrMultiple相反），因此如果那些Layer发布了一个显式投票，</span></span><br><span class="line">    <span class="comment">// 那么存在touch事件，就不应该更改它。只有在触摸增强会增加刷新率超过正常选择时才应用。</span></span><br><span class="line">    <span class="type">const</span> RefreshRate&amp; touchRefreshRate = <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在touch事件，不存在ExplicitDefault的Layer且显示主范围刷新率最大值大于计算的刷新率时</span></span><br><span class="line">    <span class="comment">// 采用最大刷新率</span></span><br><span class="line">    <span class="keyword">if</span> (globalSignals.touch &amp;&amp; explicitDefaultVoteLayers == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        bestRefreshRate-&gt;fps &lt; touchRefreshRate.fps) &#123;</span><br><span class="line">        <span class="built_in">setTouchConsidered</span>();</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;TouchBoost - choose %s&quot;</span>, touchRefreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> touchRefreshRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *bestRefreshRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Emmmm…. 这一言难尽的代码。</p>
<p>总结一下，在上层计算传入两个刷新率范围后，这里主要是根据Layer投票以及一系列判断得到最终所需的刷新率。</p>
<p>说明一下几个概念：</p>
<ol>
<li>显示主范围刷新率: DisplayModeDirector中投票算出的包含所有请求帧率的最小范围</li>
<li>layerPeriod: 根据当前layer.desiredRefreshRate计算出一帧的时长</li>
<li>displayPeriod: 当前AppReqeustRefereshRate中HwcConfig计算的一帧时长</li>
</ol>
<p><strong>整个投票过程简述:</strong></p>
<ol>
<li>首先计算所有不同LayerVoteType的数量</li>
<li>如果没有显式Layer,即ExplicitDefault和ExplicitExactOrMultiple类型,且存在触摸事件, 直接选择主范围刷新率最大帧率</li>
<li>没有touch事件且屏幕处于idle状态, 刷新率存在一定范围或者不存在显示请求刷新率的Layer时, 选择主范围刷新率最小帧率</li>
<li>没有Layer或者所有Layer都没有投票(NoVote)时, 选择最大帧率</li>
<li>存在Layer且所有Layer要么不投票，要么请求最小帧率时，选择最小帧率</li>
<li>当上述条件都不满足时，遍历所有Layer计算每个AppRequestRefreshRate的得分，找到最佳刷新率, 注意遍历时, 忽略不投票或者投票选择最小帧率的Layer<ol>
<li>遍历所有AppRequestRefreshRate<ol>
<li>只有ExplicitDefault或者ExplicitExactOrMultiple类型的Layer，且该Layer是有焦点的才允许投票超出刷新率请求范围的帧率，否则忽略该Layer</li>
<li>如果Layer是Max类型<ol>
<li>用当前layer(app)请求的帧率除以最后一个layer(app)请求的帧率,得到的比值的平方乘以权重，计入当前AppRequestRefreshRate的分数</li>
</ol>
</li>
<li>如果是ExplicitDefault类型的Layer<ol>
<li>找到Layer将渲染的实际速率，首先假设layer.desiredRefreshRate计算的Period是渲染帧的最短时间</li>
<li>将该AppReqeustRefereshRate中的Display Period刷新时长依次翻倍，直到满足该Layer刷新的最低时长，也就是fps大小每次折半</li>
<li>此时layer分数为 layer所需的时长除以满足刷新要求的最长时长在乘以权重计入当前AppRequestRefreshRate的分数</li>
</ol>
</li>
<li>如果是ExplicitExactOrMultiple或者Heuristic类型的Layer<ol>
<li>首先计算需要多少个显示vSync来显示这个层的一个帧，即计算 layerPeriod&#x2F;displayPeriod 得到商 quot 和余数 rem</li>
<li>如果是整数倍关系，当前AppRequestRefreshRate的分数直接加上该Layer的权重</li>
<li>当layer请求的fps比AppReqeustRefereshRate中的实际display的fps要大的时候，得分是layer period除以display period的商的十一分之一乘以layer的权重</li>
<li>layer所需的刷新率低于的显示刷新率，但又不是整数倍关系时，用 Pl 表述 layer period，Pd表示display period<ol>
<li>diff0 &#x3D; 2 * (Pl mod Pd) - Pd, Pl &gt; Pd 且 K ∈ {1,2,3,…,9}</li>
<li>当diff0 &gt; 0 时, diff &#x3D; (Pl mod Pd) * 2^k - Pd * (2^k-1)</li>
<li>当diff0 &lt; 0 时, diff &#x3D; Pd - 2^k * (Pl mode Pd)</li>
<li>当diff小于800时(差值小于800us), 或者k&gt;9结束, 得分是当前Layer的权重乘以1&#x2F;(2K)</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如果存在请求最大帧率的layer就反向遍历,找到得分最大的帧率 bestRefreshRate</li>
<li>如果显示主刷新率没有范围，比如最小值和最大值都是120Hz时<ol>
<li>如果没有layer参与评分，从显示主刷新范围选取最大值</li>
<li>否则返回计算得出的最佳刷新率</li>
</ol>
</li>
<li>如果存在touch事件, 不存在ExplicitDefault的Layer且显示主范围刷新率最大值大于计算的刷新率时, 采用最大刷新率</li>
<li>以上条件均不满足时，返回计算的bestRefreshRate</li>
</ol>
<p>好了，本次分析到此为止，接下来就是继续看SurfaceFlinger如何通知HWC硬件切换帧率了。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Vsync</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
      </tags>
  </entry>
  <entry>
    <title>App申请帧率(4)--SF切换帧率</title>
    <url>/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/</url>
    <content><![CDATA[<p>以下分析基于Android R.</p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。</p>
<p>接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。</p>
<span id="more"></span>

<h1 id="一-SurfaceFlinger接受帧率变化"><a href="#一-SurfaceFlinger接受帧率变化" class="headerlink" title="一. SurfaceFlinger接受帧率变化"></a>一. SurfaceFlinger接受帧率变化</h1><p>接上一章，从 SurfaceFlinger::setDesiredActiveConfig 开始. </p>
<p>这里的ActiveConfigInfo就是SurfaceFlinger根据Framework传入的帧率范围以及各个Layer投票计算的最终帧率信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ActiveConfigInfo</span> &#123;</span><br><span class="line">        HwcConfigIndexType configId;</span><br><span class="line">        Scheduler::ConfigEvent event = Scheduler::ConfigEvent::None;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ActiveConfigInfo&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> configId != other.configId || event != other.event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-1-SurfaceFlinger-setDesiredActiveConfig"><a href="#1-1-SurfaceFlinger-setDesiredActiveConfig" class="headerlink" title="1.1 SurfaceFlinger.setDesiredActiveConfig"></a>1.1 SurfaceFlinger.setDesiredActiveConfig</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setDesiredActiveConfig</span><span class="params">(<span class="type">const</span> ActiveConfigInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate = mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(info.configId);</span><br><span class="line">    mVsyncPeriod = refreshRate.<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;setDesiredActiveConfig(%s)&quot;</span>, refreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mActiveConfigLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mDesiredActiveConfigChanged) &#123;</span><br><span class="line">        <span class="comment">// 如果帧率切换正在发生，缓存此次帧率切换</span></span><br><span class="line">        <span class="type">const</span> Scheduler::ConfigEvent prevConfig = mDesiredActiveConfig.event;</span><br><span class="line">        mDesiredActiveConfig = info;</span><br><span class="line">        mDesiredActiveConfig.event = mDesiredActiveConfig.event | prevConfig;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前帧率已经是请求的帧率了，直接返回</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">        <span class="keyword">if</span> (!display || display-&gt;<span class="built_in">getActiveConfig</span>() == refreshRate.<span class="built_in">getConfigId</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记正在做帧率切换</span></span><br><span class="line">        mDesiredActiveConfigChanged = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 存储即将切换的帧率配置信息</span></span><br><span class="line">        mDesiredActiveConfig = info;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 触发HWC刷新而不重置空闲计时器。</span></span><br><span class="line">        <span class="built_in">repaintEverythingForHWC</span>();</span><br><span class="line">        <span class="comment">// 1.3 现在开始接收vsync样本，这可以检测到硬件周期切换。</span></span><br><span class="line">        mScheduler-&gt;<span class="built_in">resyncToHardwareVsync</span>(<span class="literal">true</span>, refreshRate.<span class="built_in">getVsyncPeriod</span>());</span><br><span class="line">        <span class="comment">// 1.4 调用onRefreshRateChangeCompleted, 通知更新偏移量</span></span><br><span class="line">        mVSyncModulator-&gt;<span class="built_in">onRefreshRateChangeInitiated</span>();</span><br><span class="line">        <span class="comment">// 保存即将更新的Fps</span></span><br><span class="line">        mPhaseConfiguration-&gt;<span class="built_in">setRefreshRateFps</span>(refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line">        <span class="comment">// 1.5 再次更新偏移量, 不过这一次是根据即将更新的Fps拿到的固定偏移量</span></span><br><span class="line">        mVSyncModulator-&gt;<span class="built_in">setPhaseOffsets</span>(mPhaseConfiguration-&gt;<span class="built_in">getCurrentOffsets</span>());</span><br><span class="line">        mScheduler-&gt;<span class="built_in">setConfigChangePending</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRefreshRateOverlay) &#123;</span><br><span class="line">        mRefreshRateOverlay-&gt;<span class="built_in">changeRefreshRate</span>(refreshRate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-SurfaceFlinger-repaintEverythingForHWC"><a href="#1-2-SurfaceFlinger-repaintEverythingForHWC" class="headerlink" title="1.2 SurfaceFlinger.repaintEverythingForHWC"></a>1.2 SurfaceFlinger.repaintEverythingForHWC</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::repaintEverythingForHWC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记全部重绘制</span></span><br><span class="line">    mRepaintEverything = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 通知Power模组, Display将更新，OEM厂商自行实现这个标准接口</span></span><br><span class="line">    mPowerAdvisor.<span class="built_in">notifyDisplayUpdateImminent</span>();</span><br><span class="line">    <span class="comment">// EventThread请求下一帧Vsync</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Scheduler-resyncToHardwareVsync"><a href="#1-3-Scheduler-resyncToHardwareVsync" class="headerlink" title="1.3 Scheduler.resyncToHardwareVsync"></a>1.3 Scheduler.resyncToHardwareVsync</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scheduler::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable, <span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">            mHWVsyncAvailable = makeAvailable;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">            <span class="comment">// 硬件Vsync被禁止，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数不合法</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知到软件Vsync产生模块，更新Vsync周期</span></span><br><span class="line">    <span class="built_in">setVsyncPeriod</span>(period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-Scheduler-setVsyncPeriod"><a href="#1-3-1-Scheduler-setVsyncPeriod" class="headerlink" title="1.3.1 Scheduler.setVsyncPeriod"></a>1.3.1 Scheduler.setVsyncPeriod</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scheduler::setVsyncPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">    <span class="comment">// 1.3.2 更新软件Vsync周期</span></span><br><span class="line">    mPrimaryDispSync-&gt;<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        <span class="comment">// 硬件Vsync关闭的情况下, 直接更改软件vsync周期，这里我们加上是开启的</span></span><br><span class="line">        mPrimaryDispSync-&gt;<span class="built_in">beginResync</span>();</span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在R上软件Vsync产生更改了架构，由Q上DispSync改成VSyncReactor, 不过原理不变就不分析了, 具体可以参考文章-SurfaceFlinger(2)–DispSync。</p>
<p>可以通过将属性debug.sf.vsync_reactor置为false后重启，切回Q上的DispSync机制</p>
<h3 id="1-3-2-VSyncReactor-setPeriod"><a href="#1-3-2-VSyncReactor-setPeriod" class="headerlink" title="1.3.2 VSyncReactor.setPeriod"></a>1.3.2 VSyncReactor.setPeriod</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::setPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;VSR-setPeriod&quot;</span>, period);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mLastHwVsync.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mSupportKernelIdleTimer的是由属性控制的，Google源码中默认是true的</span></span><br><span class="line">    <span class="comment">// PRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.surface_flinger.support_kernel_idle_timer=true</span></span><br><span class="line">    <span class="keyword">if</span> (!mSupportKernelIdleTimer &amp;&amp; period == <span class="built_in">getPeriod</span>()) &#123;</span><br><span class="line">        <span class="built_in">endPeriodTransition</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 开始更新</span></span><br><span class="line">        <span class="built_in">startPeriodTransition</span>(period);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-VSyncReactor-startPeriodTransition"><a href="#1-3-3-VSyncReactor-startPeriodTransition" class="headerlink" title="1.3.3 VSyncReactor.startPeriodTransition"></a>1.3.3 VSyncReactor.startPeriodTransition</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::startPeriodTransition</span><span class="params">(<span class="type">nsecs_t</span> newPeriod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记各个变量，并记录待更新的Fps对应一帧的刷新时长</span></span><br><span class="line">    mPeriodConfirmationInProgress = <span class="literal">true</span>;</span><br><span class="line">    mPeriodTransitioningTo = newPeriod;</span><br><span class="line">    mMoreSamplesNeeded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 忽略当前Fence，其实就是清空mUnfiredFences中的fence</span></span><br><span class="line">    <span class="built_in">setIgnorePresentFencesInternal</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::setIgnorePresentFencesInternal</span><span class="params">(<span class="type">bool</span> ignoration)</span> </span>&#123;</span><br><span class="line">    mInternalIgnoreFences = ignoration;</span><br><span class="line">    <span class="built_in">updateIgnorePresentFencesInternal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::updateIgnorePresentFencesInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExternalIgnoreFences || mInternalIgnoreFences) &#123;</span><br><span class="line">        mUnfiredFences.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-VSyncModulator-onRefreshRateChangeInitiated"><a href="#1-4-VSyncModulator-onRefreshRateChangeInitiated" class="headerlink" title="1.4 VSyncModulator.onRefreshRateChangeInitiated"></a>1.4 VSyncModulator.onRefreshRateChangeInitiated</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::onRefreshRateChangeInitiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRefreshRateChangePending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshRateChangePending = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">updateOffsets</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::updateOffsets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="built_in">updateOffsetsLocked</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::updateOffsetsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.4.1 选择偏移量</span></span><br><span class="line">    <span class="type">const</span> Offsets&amp; offsets = <span class="built_in">getNextOffsets</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.2 更新对应的偏移量，这个mPhaseOffsetControl其实就是Scheduler</span></span><br><span class="line">    mPhaseOffsetControl.<span class="built_in">setPhaseOffset</span>(mSfConnectionHandle, offsets.sf);</span><br><span class="line">    mPhaseOffsetControl.<span class="built_in">setPhaseOffset</span>(mAppConnectionHandle, offsets.app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新偏移量</span></span><br><span class="line">    mOffsets = offsets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个trace的debug开关是由属性: debug.sf.vsync_trace_detailed_info 0/1 决定的</span></span><br><span class="line">    <span class="keyword">if</span> (!mTraceDetailedInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isEarly = &amp;offsets == &amp;mOffsetsConfig.early;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isEarlyGl = &amp;offsets == &amp;mOffsetsConfig.earlyGl;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isLate = &amp;offsets == &amp;mOffsetsConfig.late;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-EarlyOffsetsOn&quot;</span>, isEarly);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-EarlyGLOffsetsOn&quot;</span>, isEarlyGl);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-LateOffsetsOn&quot;</span>, isLate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-1-VSyncModulator-getNextOffsets"><a href="#1-4-1-VSyncModulator-getNextOffsets" class="headerlink" title="1.4.1 VSyncModulator.getNextOffsets"></a>1.4.1 VSyncModulator.getNextOffsets</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> VSyncModulator::Offsets&amp; <span class="title">VSyncModulator::getNextOffsets</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行刷新率更改，或者最近开始了一个事务，则使用early偏移量。</span></span><br><span class="line">    <span class="keyword">if</span> (mExplicitEarlyWakeup || mTransactionStart == Scheduler::TransactionStart::EarlyEnd ||</span><br><span class="line">        mRemainingEarlyFrameCount &gt; <span class="number">0</span> || mRefreshRateChangePending) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.early;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mRemainingRenderEngineUsageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.earlyGl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.late;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-DispSyncSource-setPhaseOffset"><a href="#1-4-2-DispSyncSource-setPhaseOffset" class="headerlink" title="1.4.2 DispSyncSource.setPhaseOffset"></a>1.4.2 DispSyncSource.setPhaseOffset</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSyncSource::setPhaseOffset</span><span class="params">(<span class="type">nsecs_t</span> phaseOffset)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mVsyncMutex)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = mDispSync-&gt;<span class="built_in">getPeriod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常来讲偏移量在 [-period, period) 之间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numPeriods = phaseOffset / period;</span><br><span class="line">    phaseOffset -= numPeriods * period;</span><br><span class="line">    <span class="keyword">if</span> (mPhaseOffset == phaseOffset) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPhaseOffset = phaseOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尚未使能，就不需要通知给各个listener</span></span><br><span class="line">    <span class="keyword">if</span> (!mEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.3 DispSyncSource是继承了DispSync::Callback的</span></span><br><span class="line">    <span class="type">status_t</span> err =</span><br><span class="line">            mDispSync-&gt;<span class="built_in">changePhaseOffset</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>), mPhaseOffset);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;error changing vsync offset: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-VSyncReactor-changePhaseOffset"><a href="#1-4-3-VSyncReactor-changePhaseOffset" class="headerlink" title="1.4.3 VSyncReactor.changePhaseOffset"></a>1.4.3 VSyncReactor.changePhaseOffset</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">VSyncReactor::changePhaseOffset</span><span class="params">(DispSync::Callback* callback, <span class="type">nsecs_t</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> it = mCallbacks.<span class="built_in">find</span>(callback);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(it == mCallbacks.<span class="built_in">end</span>(), <span class="string">&quot;callback was %p not registered&quot;</span>, callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用start，更新VSyncDispatchTimerQueue中相关信息</span></span><br><span class="line">    it-&gt;second-&gt;<span class="built_in">start</span>(phase);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-4-VSyncReactor-CallbackRepeater-start"><a href="#1-4-4-VSyncReactor-CallbackRepeater-start" class="headerlink" title="1.4.4 VSyncReactor.CallbackRepeater.start"></a>1.4.4 VSyncReactor.CallbackRepeater.start</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">nsecs_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mStopped = <span class="literal">false</span>;</span><br><span class="line">    mOffset = offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> schedule_result = mRegistration.<span class="built_in">schedule</span>(<span class="built_in">calculateWorkload</span>(), mLastCallTime);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>((schedule_result != ScheduleResult::Scheduled),</span><br><span class="line">                        <span class="string">&quot;Error scheduling callback: rc %X&quot;</span>, schedule_result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-VSyncCallbackRegistration-schedule"><a href="#1-4-5-VSyncCallbackRegistration-schedule" class="headerlink" title="1.4.5 VSyncCallbackRegistration.schedule"></a>1.4.5 VSyncCallbackRegistration.schedule</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ScheduleResult <span class="title">VSyncCallbackRegistration::schedule</span><span class="params">(<span class="type">nsecs_t</span> workDuration, <span class="type">nsecs_t</span> earliestVsync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mValidToken) &#123;</span><br><span class="line">        <span class="keyword">return</span> ScheduleResult::Error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDispatch.<span class="built_in">get</span>().<span class="built_in">schedule</span>(mToken, workDuration, earliestVsync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ScheduleResult <span class="title">VSyncDispatchTimerQueue::schedule</span><span class="params">(CallbackToken token, <span class="type">nsecs_t</span> workDuration,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">nsecs_t</span> earliestVsync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = ScheduleResult::Error;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;<span class="title">decltype</span><span class="params">(mMutex)</span>&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = mCallbacks.<span class="built_in">find</span>(token);</span><br><span class="line">        <span class="keyword">if</span> (it == mCallbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>&amp; callback = it-&gt;second;</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> now = mTimeKeeper-&gt;<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计时器线程即将运行，通过回调计时器重新计算应用此工作更新，以避免取消即将触发的回调。</span></span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> rearmImminent = now &gt; mIntendedWakeupTime;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(rearmImminent)) &#123;</span><br><span class="line">            callback-&gt;<span class="built_in">addPendingWorkloadUpdate</span>(workDuration, earliestVsync);</span><br><span class="line">            <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = callback-&gt;<span class="built_in">schedule</span>(workDuration, earliestVsync, mTracker, now);</span><br><span class="line">        <span class="keyword">if</span> (result == ScheduleResult::CannotSchedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback-&gt;<span class="built_in">wakeupTime</span>() &lt; mIntendedWakeupTime - mTimerSlack) &#123;</span><br><span class="line">            <span class="built_in">rearmTimerSkippingUpdateFor</span>(now, it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ScheduleResult <span class="title">VSyncDispatchTimerQueueEntry::schedule</span><span class="params">(<span class="type">nsecs_t</span> workDuration, <span class="type">nsecs_t</span> earliestVsync,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      VSyncTracker&amp; tracker, <span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> nextVsyncTime =</span><br><span class="line">            tracker.<span class="built_in">nextAnticipatedVSyncTimeFrom</span>(std::<span class="built_in">max</span>(earliestVsync, now + workDuration));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="type">const</span> wouldSkipAVsyncTarget =</span><br><span class="line">            mArmedInfo &amp;&amp; (nextVsyncTime &gt; (mArmedInfo-&gt;mActualVsyncTime + mMinVsyncDistance));</span><br><span class="line">    <span class="keyword">if</span> (wouldSkipAVsyncTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="type">const</span> alreadyDispatchedForVsync = mLastDispatchTime &amp;&amp;</span><br><span class="line">            ((*mLastDispatchTime + mMinVsyncDistance) &gt;= nextVsyncTime &amp;&amp;</span><br><span class="line">             (*mLastDispatchTime - mMinVsyncDistance) &lt;= nextVsyncTime);</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedForVsync) &#123;</span><br><span class="line">        nextVsyncTime =</span><br><span class="line">                tracker.<span class="built_in">nextAnticipatedVSyncTimeFrom</span>(*mLastDispatchTime + mMinVsyncDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> nextWakeupTime = nextVsyncTime - workDuration;</span><br><span class="line">    mWorkDuration = workDuration;</span><br><span class="line">    mEarliestVsync = earliestVsync;</span><br><span class="line">    mArmedInfo = &#123;nextWakeupTime, nextVsyncTime&#125;;</span><br><span class="line">    <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-VSyncModulator-setPhaseOffsets"><a href="#1-5-VSyncModulator-setPhaseOffsets" class="headerlink" title="1.5 VSyncModulator.setPhaseOffsets"></a>1.5 VSyncModulator.setPhaseOffsets</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::setPhaseOffsets</span><span class="params">(<span class="type">const</span> OffsetsConfig&amp; config)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mOffsetsConfig = config;</span><br><span class="line">    <span class="comment">// 见 1.4 流程</span></span><br><span class="line">    <span class="built_in">updateOffsetsLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的OffsetsConfig是通过PhaseOffsets拿到的</p>
<h3 id="1-5-1-PhaseOffsets-getCurrentOffsets"><a href="#1-5-1-PhaseOffsets-getCurrentOffsets" class="headerlink" title="1.5.1 PhaseOffsets.getCurrentOffsets"></a>1.5.1 PhaseOffsets.getCurrentOffsets</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Offsets <span class="title">getCurrentOffsets</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getOffsetsForRefreshRate</span>(mRefreshRateFps); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PhaseOffsets::Offsets <span class="title">PhaseOffsets::getOffsetsForRefreshRate</span><span class="params">(<span class="type">float</span> fps)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> iter = std::<span class="built_in">find_if</span>(mOffsets.<span class="built_in">begin</span>(), mOffsets.<span class="built_in">end</span>(),</span><br><span class="line">                                   [&amp;fps](<span class="type">const</span> std::pair&lt;<span class="type">float</span>, Offsets&gt;&amp; candidateFps) &#123;</span><br><span class="line">                                       <span class="keyword">return</span> <span class="built_in">fpsEqualsWithMargin</span>(fps, candidateFps.first);</span><br><span class="line">                                   &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter != mOffsets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unknown refresh rate. This might happen if we get a hotplug event for an external display.</span></span><br><span class="line">    <span class="comment">// In this case just construct the offset.</span></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;Can&#x27;t find offset for %.2f fps&quot;</span>, fps);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getPhaseOffsets</span>(fps, <span class="built_in">static_cast</span>&lt;<span class="type">nsecs_t</span>&gt;(<span class="number">1e9</span>f / fps));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PhaseOffsets::Offsets <span class="title">PhaseOffsets::getPhaseOffsets</span><span class="params">(<span class="type">float</span> fps, <span class="type">nsecs_t</span> vsyncPeriod)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里根据帧率大小，分两种情况获取偏移量，具体就不看了，和参数配置相关</span></span><br><span class="line">    <span class="keyword">if</span> (fps &gt; <span class="number">65.0f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHighFpsOffsets</span>(vsyncPeriod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDefaultOffsets</span>(vsyncPeriod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哦吼，到这里setDesiredActiveConfig的流程也算是差不多分析完了，主要做的事情也就下面这些：</p>
<ol>
<li>触发HWC刷新而不重置空闲计时器。</li>
<li>软件Vsync产生模块记录更新的Vsync周期到mPeriodTransitioningTo中，且开始接收硬件vsync，这可以检测到硬件刷新率切换。</li>
<li>调用onRefreshRateChangeCompleted, 通知更新偏移量</li>
<li>保存即将更新的Fps到mPhaseConfiguration中</li>
<li>再次根据即将更新的Fps拿到的固定偏移量更新偏移量</li>
</ol>
<h1 id="二-硬件切换帧率"><a href="#二-硬件切换帧率" class="headerlink" title="二. 硬件切换帧率"></a>二. 硬件切换帧率</h1><p>上面的流程跑完后，实际上硬件帧率在哪儿切换还是没有看到，包括mPeriodTransitioningTo是怎么更新到实际软件Vsync中的呢？</p>
<p>注意到在步骤#1.2中也就是repaintEverythingForHWC会请求下一帧的Vsync，很自然的想法就是实际帧率切换应该是在下一帧到来的时候才开始的。</p>
<p>我们知道SurfaceFlinger接受到Vsync信号后，会调用onMessageInvalidate（Q上是onMessageReceived）方法开始更新、合成Layer。</p>
<p>回顾这个方法，很快就可以找到实际vsync切换在这一块代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先注意到这个参数默认是false的，也就是说</span></span><br><span class="line"><span class="comment">// 调用setDesiredActiveConfig方法后的第一帧是无法进入该分支的</span></span><br><span class="line"><span class="comment">// 我们先跳过这段代码</span></span><br><span class="line"><span class="keyword">if</span> (mSetActiveConfigPending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (framePending) &#123;</span><br><span class="line">        mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从HWC收到了当前的fence，假设它成功地更新了配置，因此更新SF各个状态</span></span><br><span class="line">    mSetActiveConfigPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 2.2 更新SurfaceFlinger的状态，此时HWC是已经更新了帧率</span></span><br><span class="line">    <span class="built_in">ON_MAIN_THREAD</span>(<span class="built_in">setActiveConfigInternal</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="comment">// 因为Layer更新刷新率, 重新来选择刷新率</span></span><br><span class="line">    <span class="comment">// 这里涉及到Layer的VoteType、权限等记录，有兴趣自行研究</span></span><br><span class="line">    mScheduler-&gt;<span class="built_in">chooseRefreshRateForContent</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 更新当前帧率设置</span></span><br><span class="line"><span class="built_in">ON_MAIN_THREAD</span>(<span class="built_in">performSetActiveConfig</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>

<h2 id="2-1-SurfaceFlinger-performSetActiveConfig"><a href="#2-1-SurfaceFlinger-performSetActiveConfig" class="headerlink" title="2.1 SurfaceFlinger.performSetActiveConfig"></a>2.1 SurfaceFlinger.performSetActiveConfig</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::performSetActiveConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;performSetActiveConfig&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断mDesiredActiveConfigChanged是否为true，获取变量mDesiredActiveConfig</span></span><br><span class="line">    <span class="comment">// 否则返回nullopt, 说明不需要帧率切换</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> desiredActiveConfig = <span class="built_in">getDesiredActiveConfig</span>();</span><br><span class="line">    <span class="keyword">if</span> (!desiredActiveConfig) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在需要切换的帧率配置(mDesiredActiveConfig)，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(desiredActiveConfig-&gt;configId);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;performSetActiveConfig changing active config to %d(%s)&quot;</span>,</span><br><span class="line">          refreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>(), refreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">    <span class="keyword">if</span> (!display || display-&gt;<span class="built_in">getActiveConfig</span>() == desiredActiveConfig-&gt;configId) &#123;</span><br><span class="line">        <span class="comment">// 显示设备无效，或者已经处于请求的帧率模式下，标记帧率请求已经完成</span></span><br><span class="line">        <span class="built_in">desiredActiveConfigChangeDone</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所需的活动配置已设置，它与当前使用的配置不同，但是在处理刷新时，允许的配置可能已更改。</span></span><br><span class="line">    <span class="comment">// 确保所需的配置仍然被允许</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isDisplayConfigAllowed</span>(desiredActiveConfig-&gt;configId)) &#123;</span><br><span class="line">        <span class="built_in">desiredActiveConfigChangeDone</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUpcomingActiveConfig = *desiredActiveConfig;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!displayId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;ActiveConfigFPS_HWC&quot;</span>, refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/142753666) use constrains</span></span><br><span class="line">    hal::VsyncPeriodChangeConstraints constraints;</span><br><span class="line">    constraints.desiredTimeNanos = <span class="built_in">systemTime</span>();</span><br><span class="line">    constraints.seamlessRequired = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1.1 通知HWC更新帧率</span></span><br><span class="line">    hal::VsyncPeriodChangeTimeline outTimeline;</span><br><span class="line">    <span class="keyword">auto</span> status =</span><br><span class="line">            <span class="built_in">getHwComposer</span>().<span class="built_in">setActiveConfigWithConstraints</span>(*displayId,</span><br><span class="line">                                                           mUpcomingActiveConfig.configId.<span class="built_in">value</span>(),</span><br><span class="line">                                                           constraints, &amp;outTimeline);</span><br><span class="line">    <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// setActiveConfigWithConstraints may fail if a hotplug event is just about</span></span><br><span class="line">        <span class="comment">// to be sent. We just log the error in this case.</span></span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;setActiveConfigWithConstraints failed: %d&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScheduler-&gt;<span class="built_in">onNewVsyncPeriodChangeTimeline</span>(outTimeline);</span><br><span class="line">    <span class="comment">// 如果需要，Scheduler将向HWC提交一个空帧，回到onMessageInvalidate中处理</span></span><br><span class="line">    <span class="comment">// 也就是在下一帧会处理，距离调用setDesiredActiveConfig就是第二个帧了。</span></span><br><span class="line">    mSetActiveConfigPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做一些合法性判断，最重要的是告诉HWC去更新帧率了。</p>
<h2 id="2-1-1-HWComposer-setActiveConfigWithConstraints"><a href="#2-1-1-HWComposer-setActiveConfigWithConstraints" class="headerlink" title="2.1.1 HWComposer.setActiveConfigWithConstraints"></a>2.1.1 HWComposer.setActiveConfigWithConstraints</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">HWComposer::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        DisplayId displayId, <span class="type">size_t</span> configId, <span class="type">const</span> hal::VsyncPeriodChangeConstraints&amp; constraints,</span></span></span><br><span class="line"><span class="params"><span class="function">        hal::VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_INVALID_DISPLAY</span>(displayId, BAD_INDEX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line">    <span class="keyword">if</span> (displayData.configMap.<span class="built_in">count</span>(configId) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DISPLAY_ERROR</span>(displayId, (<span class="string">&quot;Invalid config &quot;</span> + std::<span class="built_in">to_string</span>(configId)).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hwcDisplay是HWC2::impl::Display，用来描述硬件显示设备的</span></span><br><span class="line">    <span class="keyword">auto</span> error =</span><br><span class="line">            displayData.hwcDisplay-&gt;<span class="built_in">setActiveConfigWithConstraints</span>(displayData.configMap[configId],</span><br><span class="line">                                                                   constraints, outTimeline);</span><br><span class="line">    <span class="built_in">RETURN_IF_HWC_ERROR</span>(error, displayId, UNKNOWN_ERROR);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-HWC2-impl-Display-setActiveConfigWithConstraints"><a href="#2-1-2-HWC2-impl-Display-setActiveConfigWithConstraints" class="headerlink" title="2.1.2 HWC2::impl::Display.setActiveConfigWithConstraints"></a>2.1.2 HWC2::impl::Display.setActiveConfigWithConstraints</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Display::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> HWC2::Display::Config&gt;&amp; config,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> VsyncPeriodChangeConstraints&amp; constraints, VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%&quot;</span> PRIu64 <span class="string">&quot;] setActiveConfigWithConstraints&quot;</span>, mId);</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;<span class="built_in">getDisplayId</span>() != mId) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;setActiveConfigWithConstraints received config %u for the wrong display %&quot;</span> PRIu64</span><br><span class="line">              <span class="string">&quot; (expected %&quot;</span> PRIu64 <span class="string">&quot;)&quot;</span>,</span><br><span class="line">              config-&gt;<span class="built_in">getId</span>(), config-&gt;<span class="built_in">getDisplayId</span>(), mId);</span><br><span class="line">        <span class="keyword">return</span> Error::BAD_CONFIG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持Vsync Period切换</span></span><br><span class="line">    <span class="comment">// 我们假设支持，其实不支持的话无非是换成调用setActiveConfig</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isVsyncPeriodSwitchSupported</span>()) &#123;</span><br><span class="line">        Hwc2::IComposerClient::VsyncPeriodChangeConstraints hwc2Constraints;</span><br><span class="line">        hwc2Constraints.desiredTimeNanos = constraints.desiredTimeNanos;</span><br><span class="line">        hwc2Constraints.seamlessRequired = constraints.seamlessRequired;</span><br><span class="line"></span><br><span class="line">        Hwc2::VsyncPeriodChangeTimeline vsyncPeriodChangeTimeline = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 2.2.2 通知HWComposer切换帧率</span></span><br><span class="line">        <span class="keyword">auto</span> intError =</span><br><span class="line">                mComposer.<span class="built_in">setActiveConfigWithConstraints</span>(mId, config-&gt;<span class="built_in">getId</span>(), hwc2Constraints,</span><br><span class="line">                                                         &amp;vsyncPeriodChangeTimeline);</span><br><span class="line">        outTimeline-&gt;newVsyncAppliedTimeNanos = vsyncPeriodChangeTimeline.newVsyncAppliedTimeNanos;</span><br><span class="line">        outTimeline-&gt;refreshRequired = vsyncPeriodChangeTimeline.refreshRequired;</span><br><span class="line">        outTimeline-&gt;refreshTimeNanos = vsyncPeriodChangeTimeline.refreshTimeNanos;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Error&gt;(intError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-ComposerHal-setActiveConfigWithConstraints"><a href="#2-1-3-ComposerHal-setActiveConfigWithConstraints" class="headerlink" title="2.1.3 ComposerHal.setActiveConfigWithConstraints"></a>2.1.3 ComposerHal.setActiveConfigWithConstraints</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">V2_4::Error <span class="title">Composer::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Display display, Config config,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> IComposerClient::VsyncPeriodChangeConstraints&amp; vsyncPeriodChangeConstraints,</span></span></span><br><span class="line"><span class="params"><span class="function">        VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Error = V2_4::Error;</span><br><span class="line">    <span class="keyword">if</span> (!mClient_2_4) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error::UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Error error = kDefaultError_2_4;</span><br><span class="line">    <span class="comment">// 转到composer service处理. 也就是给硬件厂商实现</span></span><br><span class="line">    mClient_2_4-&gt;<span class="built_in">setActiveConfigWithConstraints</span>(display, config, vsyncPeriodChangeConstraints,</span><br><span class="line">                                                [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="type">const</span> <span class="keyword">auto</span>&amp; tmpTimeline) &#123;</span><br><span class="line">                                                    error = tmpError;</span><br><span class="line">                                                    <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">                                                        <span class="keyword">return</span>;</span><br><span class="line">                                                    &#125;</span><br><span class="line"></span><br><span class="line">                                                    *outTimeline = tmpTimeline;</span><br><span class="line">                                                &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里HWC切换帧率已经完成了。</p>
<h2 id="2-2-SurfaceFlinger-setActiveConfigInternal"><a href="#2-2-SurfaceFlinger-setActiveConfigInternal" class="headerlink" title="2.2 SurfaceFlinger.setActiveConfigInternal"></a>2.2 SurfaceFlinger.setActiveConfigInternal</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setActiveConfigInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">    <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; oldRefreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(display-&gt;<span class="built_in">getActiveConfig</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mActiveConfigLock)</span></span>;</span><br><span class="line">    <span class="comment">// 更新配置为最新的帧率信息</span></span><br><span class="line">    mRefreshRateConfigs-&gt;<span class="built_in">setCurrentConfigId</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    mRefreshRateStats-&gt;<span class="built_in">setConfigMode</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    <span class="comment">// 将新的帧率保存在DisplayDevice中</span></span><br><span class="line">    display-&gt;<span class="built_in">setActiveConfig</span>(mUpcomingActiveConfig.configId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    <span class="keyword">if</span> (refreshRate.<span class="built_in">getVsyncPeriod</span>() != oldRefreshRate.<span class="built_in">getVsyncPeriod</span>()) &#123;</span><br><span class="line">        <span class="comment">// 前后帧率不一致，记录此次帧率切换，就是次数（refreshRateSwitches）+1</span></span><br><span class="line">        mTimeStats-&gt;<span class="built_in">incrementRefreshRateSwitches</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偏移量管理类也要更新FPS信息</span></span><br><span class="line">    mPhaseConfiguration-&gt;<span class="built_in">setRefreshRateFps</span>(refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line">    <span class="comment">// HWC更新帧率了，偏移量再次更新</span></span><br><span class="line">    mVSyncModulator-&gt;<span class="built_in">setPhaseOffsets</span>(mPhaseConfiguration-&gt;<span class="built_in">getCurrentOffsets</span>());</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;ActiveConfigFPS&quot;</span>, refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的event就是:Scheduler::ConfigEvent::Changed</span></span><br><span class="line">    <span class="keyword">if</span> (mUpcomingActiveConfig.event != Scheduler::ConfigEvent::None) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">nsecs_t</span> vsyncPeriod =</span><br><span class="line">                mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(mUpcomingActiveConfig.configId)</span><br><span class="line">                        .<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">        <span class="comment">// 更新AppEventThread中的Vsync间隔信息</span></span><br><span class="line">        mScheduler-&gt;<span class="built_in">onPrimaryDisplayConfigChanged</span>(mAppConnectionHandle, display-&gt;<span class="built_in">getId</span>()-&gt;value,</span><br><span class="line">                                                  mUpcomingActiveConfig.configId, vsyncPeriod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此帧率切换的过程，差不多就告一段落，当然这里面还有很对细节的部分。</p>
<p>比如硬件Vsync是怎么影响到VsyncRecator产生软件Vsync的，或者软件Vsync和硬件Vsync是怎么校准的。</p>
<p>不过我们先总结一下：</p>
<ol>
<li>SurfaceFlinger收到setDesiredDisplayConfigSpecs更新帧率配置后，根据传入的帧率配置以及当前Layer选择一个最佳帧率</li>
<li>将这个最佳帧率信息存储在mDesiredActiveConfig中，然后请求下一帧Vsync，顺便更新一下偏移量</li>
<li>下一帧Vsync到来后，首先根据Layer再次计算一下最佳帧率，然后通知HWC更新帧率，在等待下一帧</li>
<li>第二个Vsync到来后，实际此时硬件HWC的Vsync已经更新了，现在就是同步更新SurfaceFlinger中各个变量中的状态，然后通知给AppEventThread更新</li>
</ol>
<p>所以一个完整的帧率切换至少包含2个Vsync周期，不过这两个Vsync周期并不相同哦</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Vsync</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder(1)--App使用Binder通信</title>
    <url>/2022/04/04/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在初学Android的时候，一般是从四大组件开始学起的。最开始学，是通过追代码流程的方式快速熟悉Android系统框架。</p>
<p>在这个速学的过程中，很多细节部分就被忽略掉了(这也是必须的，否则学起来极其痛苦且缓慢)。</p>
<p>比如四大组件之一的Service，在跨进程通信的时候，我们只知道是通过Binder通信的。至于内部实现是如何就不甚了了。</p>
<p>接下来我们通过一个简单的Demo深入探究这个跨进程通信的过程。</p>
<span id="more"></span>

<h1 id="一-在App之间使用Binder通信"><a href="#一-在App之间使用Binder通信" class="headerlink" title="一. 在App之间使用Binder通信"></a>一. 在App之间使用Binder通信</h1><p>目标是在AppClient中给AppServer发送一个简单的字符串</p>
<h2 id="1-1-创建Interface"><a href="#1-1-创建Interface" class="headerlink" title="1.1 创建Interface"></a>1.1 创建Interface</h2><p>首先在服务端提供接口文件：IDemoInterface. </p>
<p>Android Studio中通过”File-&gt;New-&gt;AIDL”创建这个 aidl 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface IDemoInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void sayHello(long aLong, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建之后需要在 “Build-&gt;Rebuild Project”, 生成对应可用的文件</p>
<h2 id="1-2-实现服务端接口"><a href="#1-2-实现服务端接口" class="headerlink" title="1.2 实现服务端接口"></a>1.2 实现服务端接口</h2><figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> mName = <span class="string">&quot;DemoService&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoBinder</span>:<span class="type">IDemoInterface.Stub</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(aLong: <span class="type">Long</span>, aString: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;DemoService&quot;</span>, <span class="string">&quot;<span class="variable">$aString</span>:<span class="variable">$aLong</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binder = DemoBinder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> binder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，就是将传入的字符串输出出来。但是这个地方就有一个疑问，为啥是继承IDemoInterface.Stub呢？直接看这个文件的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oneplus.opbench.server;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDemoInterface</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/** Default implementation for IDemoInterface. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Default</span> <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">         * and return values in AIDL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.oneplus.opbench.server.IDemoInterface&quot;</span>;</span><br><span class="line">    <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cast an IBinder object into an com.oneplus.opbench.server.IDemoInterface interface,</span></span><br><span class="line"><span class="comment">     * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.oneplus.opbench.server.IDemoInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.oneplus.opbench.server.IDemoInterface)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">      java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(descriptor);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_sayHello:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          <span class="type">long</span> _arg0;</span><br><span class="line">          _arg0 = data.readLong();</span><br><span class="line">          java.lang.String _arg1;</span><br><span class="line">          _arg1 = data.readString();</span><br><span class="line">          <span class="built_in">this</span>.sayHello(_arg0, _arg1);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote)</span><br><span class="line">      &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">           * and return values in AIDL.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">      &#123;</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          _data.writeLong(aLong);</span><br><span class="line">          _data.writeString(aString);</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            getDefaultImpl().sayHello(aLong, aString);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_sayHello</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setDefaultImpl</span><span class="params">(com.oneplus.opbench.server.IDemoInterface impl)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Stub.Proxy.sDefaultImpl == <span class="literal">null</span> &amp;&amp; impl != <span class="literal">null</span>) &#123;</span><br><span class="line">        Stub.Proxy.sDefaultImpl = impl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">getDefaultImpl</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Stub.Proxy.sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">       * and return values in AIDL.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释的就很清楚，是自动生成的文件。Stub是一个静态内部抽象类，继承了Binder和接口IDemoInterface。</p>
<h2 id="1-3-客户端调用"><a href="#1-3-客户端调用" class="headerlink" title="1.3 客户端调用"></a>1.3 客户端调用</h2><p>注意把服务端aidl文件夹内容拷贝到客户端项目的aidl文件内，然后客户端也rebuild一下project.</p>
<figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        &lt;!-- for binder(aidl) --&gt;</span></span><br><span class="line"><span class="comment">        &lt;service android:name=&quot;.server.DemoService&quot;</span></span><br><span class="line"><span class="comment">            android:process=&quot;.DemoService&quot;</span></span><br><span class="line"><span class="comment">            android:enabled=&quot;true&quot;</span></span><br><span class="line"><span class="comment">            android:exported=&quot;true&quot; &gt;</span></span><br><span class="line"><span class="comment">            &lt;intent-filter&gt;</span></span><br><span class="line"><span class="comment">                &lt;action android:name=&quot;android.intent.action.DemoService&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;/intent-filter&gt;</span></span><br><span class="line"><span class="comment">        &lt;/service&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">attemptToBindService</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> intent = Intent()</span><br><span class="line">      Log.e(<span class="string">&quot;client&quot;</span>, <span class="string">&quot; connected now&quot;</span>)</span><br><span class="line">      intent.action = <span class="string">&quot;android.intent.action.DemoService&quot;</span> <span class="comment">//服务类的Action</span></span><br><span class="line">      intent.`<span class="keyword">package</span>` = <span class="string">&quot;com.oneplus.opbench&quot;</span> <span class="comment">//服务端包名</span></span><br><span class="line">      <span class="comment">// 建立通信</span></span><br><span class="line">      bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mDemoServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindingDied</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService died!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(p0: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService disconnected!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">          <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">          <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关类图"><a href="#相关类图" class="headerlink" title="相关类图"></a>相关类图</h2><p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png" alt="DemoInterface"></p>
<p>接下来我们从客户端的bindService建立远程连接开始看看是怎么通信的，当然这里我们重点是binder通信，而不是service的bind流程。</p>
<h1 id="二-通信过程"><a href="#二-通信过程" class="headerlink" title="二. 通信过程"></a>二. 通信过程</h1><p>分析跨进程通信的过程，一定要时刻谨记当前代码所处的进程哦, 为了方便和聚焦, 忽略非紧要代码。</p>
<h2 id="2-1-Client-x3D-gt-ContextImpl-bindService"><a href="#2-1-Client-x3D-gt-ContextImpl-bindService" class="headerlink" title="2.1 Client&#x3D;&gt;ContextImpl.bindService"></a>2.1 Client&#x3D;&gt;ContextImpl.bindService</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, <span class="literal">null</span>, mMainThread.getHandler(), <span class="literal">null</span>,</span><br><span class="line">            getUser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.1 获取IServiceConnection对象</span></span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">        <span class="comment">// 2.2 看来是先与Android系统中的AMS服务通信</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-LoadedApk-getServiceDispatcher"><a href="#2-1-1-LoadedApk-getServiceDispatcher" class="headerlink" title="2.1.1 LoadedApk.getServiceDispatcher"></a>2.1.1 LoadedApk.getServiceDispatcher</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title function_">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">        Context context, Handler handler, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getServiceDispatcherCommon(c, context, handler, <span class="literal">null</span>, flags);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> IServiceConnection <span class="title function_">getServiceDispatcherCommon</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">        Context context, Handler handler, Executor executor, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Returning existing dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, executor, flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第一次建立连接，当然需要新建</span></span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, handler, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Creating new dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的是ServiceDispatcher里的mIServiceConnection对象,是InnerConnection</span></span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是将ServiceConnection做一个打包，存起来，隐藏细节，注意到返回的是 InnerConnection 类型哦。<br>相关类图如下：</p>
<p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_2_InnerConnection%E7%B1%BB%E5%9B%BE.png" alt="InnerConnection"></p>
<h2 id="2-2-SytemServer-x3D-gt-AMS-bindIsolatedService"><a href="#2-2-SytemServer-x3D-gt-AMS-bindIsolatedService" class="headerlink" title="2.2 SytemServer&#x3D;&gt;AMS.bindIsolatedService"></a>2.2 SytemServer&#x3D;&gt;AMS.bindIsolatedService</h2><p>这里其实就存在Binder通信，但是我们先不看，假设直接call过来了（四大组件之Service）.</p>
<p>我们知道，当服务端app进程没有启动时，会先将进程启动，然后继续进行bindService操作，为了方便，这里假设服务端进程已启动。</p>
<p>这里忽略中间一系列调用，走到ActiveServices.bindServiceLocked中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">            String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            String instanceName, String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span></span><br><span class="line">            <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 注意这里传入的connection是IServiceConnection</span></span><br><span class="line">    <span class="comment">// retrieveServiceLocked是从已安装的package中找到对应包以及指定Service组件</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">            retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                    Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="literal">true</span>,</span><br><span class="line">                    callerFg, isBindExternal, allowInstant);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> res.record;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 根据我们之前的研究过的Service知识，这个AppBindRecord就是记录App之间Service通信的</span></span><br><span class="line">        <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionRecord</span>(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent,</span><br><span class="line">                callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line">        <span class="comment">// 注意这里的connection.asBinder调用的就是IServiceConnection.Stub.Proxy.asBinder</span></span><br><span class="line">        <span class="comment">// 返回的就是mRemote</span></span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">          <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">          <span class="comment">// publish the connection.</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// c.conn就是Client端传入的IServiceConnection</span></span><br><span class="line">              <span class="comment">// 所以这里又调回去Client进程了，注意传入的b.intent.binder对象</span></span><br><span class="line">              <span class="comment">// 这个传入的b.intent.binder对象就是服务端App发布Service时传入的（publishServiceLocked）</span></span><br><span class="line">              <span class="comment">// 其实可以猜得到是这个就是对应服务端App的IDemoInterface对象</span></span><br><span class="line">              <span class="comment">// 2.3 转到Client进程</span></span><br><span class="line">              c.conn.connected(s.name, b.intent.binder, <span class="literal">false</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              Slog.w(TAG, <span class="string">&quot;Failure sending service &quot;</span> + s.shortInstanceName</span><br><span class="line">                      + <span class="string">&quot; to connection &quot;</span> + c.conn.asBinder()</span><br><span class="line">                      + <span class="string">&quot; (in &quot;</span> + c.binding.client.processName + <span class="string">&quot;)&quot;</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Client-x3D-gt-LoadedApk-ServiceDispatcher-InnerConnection-connected"><a href="#2-3-Client-x3D-gt-LoadedApk-ServiceDispatcher-InnerConnection-connected" class="headerlink" title="2.3 Client&#x3D;&gt;LoadedApk.ServiceDispatcher.InnerConnection.connected"></a>2.3 Client&#x3D;&gt;LoadedApk.ServiceDispatcher.InnerConnection.connected</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="literal">null</span>) &#123;</span><br><span class="line">        sd.connected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-LoadedApk-ServiceDispatcher-connected"><a href="#2-3-1-LoadedApk-ServiceDispatcher-connected" class="headerlink" title="2.3.1 LoadedApk.ServiceDispatcher.connected"></a>2.3.1 LoadedApk.ServiceDispatcher.connected</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="literal">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.3.2 这里其实最后还是调用到了doConnected</span></span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-LoadedApk-ServiceDispatcher-doConnected"><a href="#2-3-2-LoadedApk-ServiceDispatcher-doConnected" class="headerlink" title="2.3.2 LoadedApk.ServiceDispatcher.doConnected"></a>2.3.2 LoadedApk.ServiceDispatcher.doConnected</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个service就是服务端App中的DemoBinder中的mRemote了</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mDemoServiceConnection通知已经建立连接</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-客户端的ServiceConnection"><a href="#2-3-3-客户端的ServiceConnection" class="headerlink" title="2.3.3 客户端的ServiceConnection"></a>2.3.3 客户端的ServiceConnection</h3><figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">    <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">    <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，Android系统中两个进程通过四大组件之一的Service进行跨进程通信的连接已经建立了。</p>
<p>简单来说这个过程借助了SystemServer的帮助：Client app &lt;–&gt; SystemServer &lt;–&gt; Server app</p>
<p>Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。这样Client App就有了和Server App通信的基础。</p>
<p>搞清楚是怎么建立连接的过程，接下来深入探究下mProxyBinder.sayHello调用到不同进程对应的方法的细节。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Binder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder(2)--sayHello之BinderProxy的创建过程</title>
    <url>/2022/04/04/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，首先回顾一下IBinder相关接口的类图：</p>
<p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png" alt="DemoInterfac"></p>
<p>现在我们Client进程已经拿到Server端IDemoInterface中的IBinder对象，但是这个IBinder对象到底是哪个呢，Stub本身？还是Proxy亦或是Proxy中的mRemote？</p>
<p>还是看sayHello的调用过程先:</p>
<figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">    <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">    <span class="comment">// 1.1 这个asInterface是做了什么操作呢？</span></span><br><span class="line">    <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.1 sayHello!</span></span><br><span class="line">        mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="一-asInterface方法"><a href="#一-asInterface方法" class="headerlink" title="一. asInterface方法"></a>一. asInterface方法</h1><h2 id="1-1-IDemoInterface-Stub-asInterface"><a href="#1-1-IDemoInterface-Stub-asInterface" class="headerlink" title="1.1 IDemoInterface.Stub.asInterface"></a>1.1 IDemoInterface.Stub.asInterface</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2 生成IInterface</span></span><br><span class="line">    android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.oneplus.opbench.server.IDemoInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.oneplus.opbench.server.IDemoInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.3 转换成Proxy对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是自动生成的，看起来就是通过IBinder生成一个IInterface或者Proxy？</p>
<h2 id="1-2-Binder-queryLocalInterface"><a href="#1-2-Binder-queryLocalInterface" class="headerlink" title="1.2 Binder.queryLocalInterface"></a>1.2 Binder.queryLocalInterface</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> IInterface <span class="title function_">queryLocalInterface</span><span class="params">(<span class="meta">@NonNull</span> String descriptor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDescriptor != <span class="literal">null</span> &amp;&amp; mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachInterface</span><span class="params">(<span class="meta">@Nullable</span> IInterface owner, <span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">    mOwner = owner;</span><br><span class="line">    mDescriptor = descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看类图我们也知道，只有Binder实现了IBinder接口，而也只有IDemoInterface.Stub继承了Binder。这么说起来，SystemServer回传的IBinder对象实际上是服务端的IDemoInterface.Stub？然而mOwner此时还是null的，注意我们现在在Client进程中。这里我们直接debug client进程发现queryLocalInterface返回的null值，而且传入的IBinder的类型居然是BinderProxy的！这里什么时候返回非null，传入的IBinder是什么时候变成BinderProxy的呢，先留个疑问。</p>
<p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_1_IBinder%E7%B1%BB%E5%9B%BE.png" alt="2_1_IBinder类图"></p>
<h2 id="1-3-创建IDemoInterface-Stub-Proxy对象"><a href="#1-3-创建IDemoInterface-Stub-Proxy对象" class="headerlink" title="1.3 创建IDemoInterface.Stub.Proxy对象"></a>1.3 创建IDemoInterface.Stub.Proxy对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">Proxy(android.os.IBinder remote)</span><br><span class="line">&#123;</span><br><span class="line">  mRemote = remote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明白了，现在这个mRemote对象实际上是指代的BinderProxy!</p>
<h1 id="二-sayHello"><a href="#二-sayHello" class="headerlink" title="二. sayHello"></a>二. sayHello</h1><h2 id="2-1-Proxy-sayHello"><a href="#2-1-Proxy-sayHello" class="headerlink" title="2.1 Proxy.sayHello"></a>2.1 Proxy.sayHello</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">  android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">  android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 按顺序写入参数, 注意DESCRIPTOR</span></span><br><span class="line">    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">    _data.writeLong(aLong);</span><br><span class="line">    _data.writeString(aString);</span><br><span class="line">    <span class="comment">// 2.2 实质上是mRemote起作用的，在1.3中我们通过Debug知道这个其实是BinderProxy对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">      getDefaultImpl().sayHello(aLong, aString);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _reply.readException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-BinderProxy-transact"><a href="#2-2-BinderProxy-transact" class="headerlink" title="2.2 BinderProxy.transact"></a>2.2 BinderProxy.transact</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3 忽略其他代码，这个是call了一个native方法，通过JNI调用</span></span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-android-util-Binder-cpp-android-os-BinderProxy-transact"><a href="#2-3-android-util-Binder-cpp-android-os-BinderProxy-transact" class="headerlink" title="2.3 android_util_Binder.cpp#android_os_BinderProxy_transact"></a>2.3 android_util_Binder.cpp#android_os_BinderProxy_transact</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3.1 首先从名字中可以推出是获取远程通信的目标</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3.2 继续</span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-android-util-Binder-cpp-getBPNativeData"><a href="#2-3-1-android-util-Binder-cpp-getBPNativeData" class="headerlink" title="2.3.1 android_util_Binder.cpp#getBPNativeData"></a>2.3.1 android_util_Binder.cpp#getBPNativeData</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinderProxyNativeData</span> &#123;</span><br><span class="line">    <span class="comment">// Both fields are constant and not null once javaObjectForIBinder returns this as</span></span><br><span class="line">    <span class="comment">// part of a BinderProxy.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The native IBinder proxied by this BinderProxy.</span></span><br><span class="line">    sp&lt;IBinder&gt; mObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Death recipients for mObject. Reference counted only because DeathRecipients</span></span><br><span class="line">    <span class="comment">// hold a weak reference that can be temporarily promoted.</span></span><br><span class="line">    sp&lt;DeathRecipientList&gt; mOrgue;  <span class="comment">// Death recipients for mObject.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">binderproxy_offsets_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mGetInstance;</span><br><span class="line">    jmethodID mSendDeathNotice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData.</span></span><br><span class="line">&#125; gBinderProxyOffsets;</span><br><span class="line"></span><br><span class="line"><span class="function">BinderProxyNativeData* <span class="title">getBPNativeData</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其实就是读取BinderProxy对象中保存的long类型的mNativeData数据</span></span><br><span class="line">    <span class="comment">// 然后强制转换成BinderProxyNativeData类型</span></span><br><span class="line">    <span class="keyword">return</span> (BinderProxyNativeData *) env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderProxyOffsets.mNativeData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里并不知道BinderProxy从哪儿来的，Native层也没有定义，应该就是指代java层的BinderProxy。</p>
<h3 id="2-3-2-IBinder-transact"><a href="#2-3-2-IBinder-transact" class="headerlink" title="2.3.2 IBinder#transact"></a>2.3.2 IBinder#transact</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>        <span class="title">transact</span><span class="params">(   <span class="type">uint32_t</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Parcel* reply,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里我们知道getBpNativeData中的mObject是IBinder类型的。但是是一个虚函数，没有具体实现，怎么往下查呢。</p>
<p>Native的Debug方式也有，但是总归不方便，那我们先梳理一下Native层关于IBinder的类图吧。注意现在我们还是在Client进程内的。</p>
<p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_2_NativeIBinder%E7%B1%BB%E5%9B%BE.png" alt="2_2_NativeIBinder类图"></p>
<p>IBinder相关类之间的关系大致理清楚了，从这个函数名称getBPNativeData可以猜出来应该是指代的BpBinder!</p>
<p>但是怎么确认呢，那我们回到Client App和Server App建立通信的过程中，溯源BinderProxy。</p>
<h1 id="三-BinderProxy的创建过程"><a href="#三-BinderProxy的创建过程" class="headerlink" title="三. BinderProxy的创建过程"></a>三. BinderProxy的创建过程</h1><h2 id="3-1-publishServiceLocked"><a href="#3-1-publishServiceLocked" class="headerlink" title="3.1 publishServiceLocked"></a>3.1 publishServiceLocked</h2><ol>
<li>ServerApp:        ActivityThread.handleBindService(BindServiceData data)</li>
<li>SystemServer: ActivityManagerService.publishService(IBinder token, Intent intent, IBinder service)</li>
<li>SystemServer: ActiveService.publishServiceLocked(ServiceRecord r, Intent intent, IBinder service)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个mService就是Service在被调用onCreate方法的时候存入的</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">&quot;handleBindService s=&quot;</span> + s + <span class="string">&quot; rebind=&quot;</span> + data.rebind);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">// 3.1.1 所以这个onBind，就是Service中我们实现的onBind方法了</span></span><br><span class="line">                    <span class="comment">// 这里的binder就是对应我们实现的IDemoInterface.Stub</span></span><br><span class="line">                    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">// 告诉SystemServer该服务已准备就绪</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里就是rebind</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1-服务端的Stub初始化"><a href="#3-1-1-服务端的Stub初始化" class="headerlink" title="3.1.1 服务端的Stub初始化"></a>3.1.1 服务端的Stub初始化</h3><figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoBinder</span>:<span class="type">IDemoInterface.Stub</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(aLong: <span class="type">Long</span>, aString: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;DemoService&quot;</span>, <span class="string">&quot;<span class="variable">$aString</span>:<span class="variable">$aLong</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看这个Stub的初始化过程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binder = DemoBinder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">    <span class="comment">// 所以Service中的onBind含义就是通知到AMS</span></span><br><span class="line">    <span class="comment">// 本服务已准备继续，随时可以工作</span></span><br><span class="line">    <span class="keyword">return</span> binder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还要注意的是，初始化DemoBinder过程，会调用父类的构造函数哦：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachInterface</span><span class="params">(<span class="meta">@Nullable</span> IInterface owner, <span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 噢噢，这个mOwner就是在这里保存的！</span></span><br><span class="line">    <span class="comment">// 它代表的就是IDemoInterface.Stub类的对象，其实就是DemoBinder</span></span><br><span class="line">    mOwner = owner;</span><br><span class="line">    mDescriptor = descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里还是没有找到BinderProxy对象的创建。不过我们知道，Binder通信是通过往Parcel中写入数据的；</p>
<p>而AMS.publishService函数中最后一个参数就是IBinder类型的。</p>
<h2 id="3-2-publishService写入参数"><a href="#3-2-publishService写入参数" class="headerlink" title="3.2 publishService写入参数"></a>3.2 publishService写入参数</h2><p>通过查看IActivityManager.aidl文件编译后生成的IActivityManager.Stub.Proxy.class(想想为啥不是Stub而是Proxy)文件可以知道这个函数的具体内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">  <span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">  <span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _data.writeInterfaceToken(<span class="string">&quot;android.app.IActivityManager&quot;</span>);</span><br><span class="line">    _data.writeStrongBinder(token);</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="literal">null</span>) &#123;</span><br><span class="line">      _data.writeInt(<span class="number">1</span>);</span><br><span class="line">      intent.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.1.3 IBinder对象是通过writeStrongBinder方法写入的</span></span><br><span class="line">    <span class="comment">// 注意这个IBinder就是Service实现的onBind方法中返回的, 就是IDemoInterface.Stub类型</span></span><br><span class="line">    _data.writeStrongBinder(service);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> <span class="built_in">this</span>.mRemote.transact(<span class="number">32</span>, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; IActivityManager.Stub.getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">      IActivityManager.Stub.getDefaultImpl().publishService(token, intent, service);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    _reply.readException();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-1-Parcel-writeStrongBinder"><a href="#3-2-1-Parcel-writeStrongBinder" class="headerlink" title="3.2.1 Parcel.writeStrongBinder"></a>3.2.1 Parcel.writeStrongBinder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeStrongBinder</span><span class="params">(IBinder val)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的mNativePtr就是此Parcel在Native的对应标识</span></span><br><span class="line">    nativeWriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看样子直接去了Native层干活去了。</p>
<h3 id="3-2-2-android-os-Parcel-android-os-Parcel-writeStrongBinder"><a href="#3-2-2-android-os-Parcel-android-os-Parcel-writeStrongBinder" class="headerlink" title="3.2.2 android_os_Parcel#android_os_Parcel_writeStrongBinder"></a>3.2.2 android_os_Parcel#android_os_Parcel_writeStrongBinder</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 转成Native的Parcel</span></span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.2.1 注意这个ibinderForJavaObject方法，将java层IBinder转成Native层的</span></span><br><span class="line">        <span class="comment">// 3.2.3 然后是保存这个Native的IBinder</span></span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> err = parcel-&gt;<span class="built_in">writeStrongBinder</span>(<span class="built_in">ibinderForJavaObject</span>(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">signalExceptionForError</span>(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-1-android-util-Binder-ibinderForJavaObject"><a href="#3-2-2-1-android-util-Binder-ibinderForJavaObject" class="headerlink" title="3.2.2.1 android_util_Binder#ibinderForJavaObject"></a>3.2.2.1 android_util_Binder#ibinderForJavaObject</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance of Binder?</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="comment">// 3.2.2.2 返回一个IBinder</span></span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance of BinderProxy?</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块首次出现了BinderProxy，不过当前我们还处于Service App进程对吧，而且上层传入的IBinder明显只是一个IDemoInterface.Stub类型。</p>
<p>所以这里还是将这个jobject转换成了JavaBBinderHolder！不过我们有理由猜测，BinderProxy是在AMS所处的SystemServer进程中转换的。</p>
<h4 id="3-2-2-2-android-util-Binder-JavaBBinderHolder-get"><a href="#3-2-2-2-android-util-Binder-JavaBBinderHolder-get" class="headerlink" title="3.2.2.2 android_util_Binder#JavaBBinderHolder#get"></a>3.2.2.2 android_util_Binder#JavaBBinderHolder#get</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;JavaBBinder&gt; <span class="title">get</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    sp&lt;JavaBBinder&gt; b = mBinder.<span class="built_in">promote</span>();</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.2.3 创建JavaBBinder</span></span><br><span class="line">        b = <span class="keyword">new</span> <span class="built_in">JavaBBinder</span>(env, obj);</span><br><span class="line">        <span class="keyword">if</span> (mVintf) &#123;</span><br><span class="line">            ::android::internal::Stability::<span class="built_in">markVintf</span>(b.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mExtension != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            b.<span class="built_in">get</span>()-&gt;<span class="built_in">setExtension</span>(mExtension);</span><br><span class="line">        &#125;</span><br><span class="line">        mBinder = b;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBinder %p (refs %p) for Object %p, weakCount=%&quot;</span> PRId32 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                b.<span class="built_in">get</span>(), b-&gt;<span class="built_in">getWeakRefs</span>(), obj, b-&gt;<span class="built_in">getWeakRefs</span>()-&gt;<span class="built_in">getWeakCount</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回的JavaBBinder,说明JavaBBinder继承了IBinder</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-3-创建Native层的IBinder对象-JavaBBinder"><a href="#3-2-2-3-创建Native层的IBinder对象-JavaBBinder" class="headerlink" title="3.2.2.3 创建Native层的IBinder对象-JavaBBinder"></a>3.2.2.3 创建Native层的IBinder对象-JavaBBinder</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JavaBBinder</span>(JNIEnv* env, jobject <span class="comment">/* Java Binder */</span> object)</span><br><span class="line">        : <span class="built_in">mVM</span>(<span class="built_in">jnienv_to_javavm</span>(env)), <span class="built_in">mObject</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(object))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBBinder %p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 这些先不管</span></span><br><span class="line">    gNumLocalRefsCreated.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">gcIfManyNewRefs</span>(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在看看现在Native层和IBinder有关系的类的类图:</p>
<p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_3_IBinder%E7%B1%BB%E5%9B%BE_JavaBBinder.png" alt="2_3_IBinder类图_JavaBBinder.png"></p>
<p>果然JavaBBinder继承了IBinder。回到#3.2.2中，继续往下就是writeStrongBinder了。</p>
<h3 id="3-2-3-Parcel-writeStrongBinder"><a href="#3-2-3-Parcel-writeStrongBinder" class="headerlink" title="3.2.3 Parcel#writeStrongBinder"></a>3.2.3 Parcel#writeStrongBinder</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flattenBinder</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::flattenBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.3.1 是local还是remote？</span></span><br><span class="line">        BBinder *local = binder-&gt;<span class="built_in">localBinder</span>();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进入！</span></span><br><span class="line">            <span class="keyword">if</span> (local-&gt;<span class="built_in">isRequestingSid</span>()) &#123;</span><br><span class="line">                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里的type，是BINDER_TYPE_BINDER！</span></span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            <span class="comment">// 保存BBinder的弱引用，这个是干啥用的?</span></span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            <span class="comment">// 保存BBinder对象</span></span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.4 完成IBinder的写入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">finishFlattenBinder</span>(binder, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对local和remote存在不同的处理方式，不过我们先仅仅关注其中一个分支。</p>
<h4 id="3-2-3-1-IBinder-localBinder"><a href="#3-2-3-1-IBinder-localBinder" class="headerlink" title="3.2.3.1 IBinder#localBinder"></a>3.2.3.1 IBinder#localBinder</h4><p>我们这里的IBinder就是JavaBBinder类的对象，前面我们看过了JavaBBinder的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BBinder* <span class="title">IBinder::localBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意IBinder调用的是这个</span></span><br><span class="line"><span class="function">BBinder* <span class="title">BBinder::localBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里的IBinder指针是指向其子类的子类JavaBBinder,然后其子类BBinder实现了虚函数localBinder，而JavaBBinder并没有。</p>
<p>所以这里是local的！</p>
<h3 id="3-2-4-Parcel-finishFlattenBinder"><a href="#3-2-4-Parcel-finishFlattenBinder" class="headerlink" title="3.2.4 Parcel#finishFlattenBinder"></a>3.2.4 Parcel#finishFlattenBinder</h3><p>flatten的意思是压平，其实可以理解为打包，将JavaBBinder打包然后发送出去。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::finishFlattenBinder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="type">const</span> flat_binder_object&amp; flat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 写入内存区域，这一块没有接触过，暂时先不管，后面研究</span></span><br><span class="line">    <span class="comment">// 理解为将IBinder保存到内存中的某个特定区域</span></span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">writeObject</span>(flat, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    internal::Stability::<span class="built_in">tryMarkCompilationUnit</span>(binder.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">writeInt32</span>(internal::Stability::<span class="built_in">get</span>(binder.<span class="built_in">get</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们知道了Java层的IBinder对象是如何通过Parcel保存到Native中的。</p>
<h2 id="3-3-SystemServer接收参数"><a href="#3-3-SystemServer接收参数" class="headerlink" title="3.3 SystemServer接收参数"></a>3.3 SystemServer接收参数</h2><p>这里我们先不去细究通信的过程，因为这本身就是一次Binder通信。先看AMS收到Server App发布Service的IBinder对象是什么。</p>
<p>还是通过看编译后生成的IActivityManager.Stub.Class文件中对应的publishService方法，注意我们现在切换到了SystemServer进程(忽略进程切换过程)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    data.enforceInterface(descriptor);</span><br><span class="line">    <span class="comment">// 读取IBinder对象，不过这个是token, 不是我们想要的Service的IBinder</span></span><br><span class="line">    <span class="comment">// 用过Binder通信知道，是按顺序来读写的，所以我们看最后一个IBinder</span></span><br><span class="line">    iBinder11 = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != data.readInt()) &#123;</span><br><span class="line">      intent6 = (Intent)Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      intent6 = <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 3.3.1 这里就是我们想要的Service的IBinder了</span></span><br><span class="line">    iBinder26 = data.readStrongBinder();</span><br><span class="line">    publishService(iBinder11, intent6, iBinder26);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-Parcel-readStrongBinder"><a href="#3-3-1-Parcel-readStrongBinder" class="headerlink" title="3.3.1 Parcel.readStrongBinder"></a>3.3.1 Parcel.readStrongBinder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title function_">readStrongBinder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeReadStrongBinder(mNativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是直接切到Native.</p>
<h3 id="3-3-2-android-os-Parcel-android-os-Parcel-readStrongBinder"><a href="#3-3-2-android-os-Parcel-android-os-Parcel-readStrongBinder" class="headerlink" title="3.3.2 android_os_Parcel#android_os_Parcel_readStrongBinder"></a>3.3.2 android_os_Parcel#android_os_Parcel_readStrongBinder</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">android_os_Parcel_readStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.3.2.1 先看Parce-&gt;readStrongBinder</span></span><br><span class="line">        <span class="comment">// 3.3.3  将IBinder转换成jobject</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">javaObjectForIBinder</span>(env, parcel-&gt;<span class="built_in">readStrongBinder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-1-Parcel-readStrongBinder"><a href="#3-3-2-1-Parcel-readStrongBinder" class="headerlink" title="3.3.2.1 Parcel#readStrongBinder"></a>3.3.2.1 Parcel#readStrongBinder</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">Parcel::readStrongBinder</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    <span class="comment">// 暂时不明确IBinder指代的是具体哪个子类吼</span></span><br><span class="line">    <span class="built_in">readNullableStrongBinder</span>(&amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">readNullableStrongBinder</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (status == OK &amp;&amp; !val-&gt;<span class="built_in">get</span>()) &#123;</span><br><span class="line">        status = UNEXPECTED_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 来了，解压的过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unflattenBinder</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-2-Parcel-unflattenBinder"><a href="#3-3-2-2-Parcel-unflattenBinder" class="headerlink" title="3.3.2.2 Parcel#unflattenBinder"></a>3.3.2.2 Parcel#unflattenBinder</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::unflattenBinder</span><span class="params">(sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从内存区域中读取当前位置的数据</span></span><br><span class="line">    <span class="type">const</span> flat_binder_object* flat = <span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="comment">// 我们在flatten中的Type就是这个！</span></span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">                <span class="comment">// 转成IBinder，没有问题，我们存入的JavaBBinder，其父类的父类就是IBinder</span></span><br><span class="line">                sp&lt;IBinder&gt; binder = <span class="built_in">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="comment">// 3.3.2.3 完成数据解压</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">                sp&lt;IBinder&gt; binder =</span><br><span class="line">                    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方留个心眼哦，这里的flat-&gt;hdr.type真的还是原来的BINDER_TYPE_BINDER吗？</p>
<h4 id="3-3-2-3-Parcel-finishUnflattenBinder"><a href="#3-3-2-3-Parcel-finishUnflattenBinder" class="headerlink" title="3.3.2.3 Parcel#finishUnflattenBinder"></a>3.3.2.3 Parcel#finishUnflattenBinder</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::finishUnflattenBinder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> stability;</span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">readInt32</span>(&amp;stability);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    status = internal::Stability::<span class="built_in">set</span>(binder.<span class="built_in">get</span>(), stability, <span class="literal">true</span> <span class="comment">/*log*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out指向这个内存区域</span></span><br><span class="line">    *out = binder;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这个IBinder到底是什么类型的呢？先回到#3.3.2中，继续readStrongBinder的过程</p>
<h3 id="3-3-3-android-util-Binder-javaObjectForIBinder"><a href="#3-3-3-android-util-Binder-javaObjectForIBinder" class="headerlink" title="3.3.3 android_util_Binder#javaObjectForIBinder"></a>3.3.3 android_util_Binder#javaObjectForIBinder</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 3.3.3.1 这里决定是不是直接返回JavaBBinder的类型</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;<span class="built_in">checkSubclass</span>(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="built_in">static_cast</span>&lt;JavaBBinder*&gt;(val.<span class="built_in">get</span>())-&gt;<span class="built_in">object</span>();</span><br><span class="line">        <span class="built_in">LOGDEATH</span>(<span class="string">&quot;objectForBinder %p: it&#x27;s our own %p!\n&quot;</span>, val.<span class="built_in">get</span>(), object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3.4 终于看到和BinderProxy相关的了, 至少名字上看都有关系</span></span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> <span class="built_in">BinderProxyNativeData</span>();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    <span class="comment">// 将从内存中读取的IBinder对象存起来</span></span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3.5 调用到java方法mGetInstance，生成BinderProxy！</span></span><br><span class="line">    jobject object = env-&gt;<span class="built_in">CallStaticObjectMethod</span>(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 所以这里最终返回是BinderProxy对象对应JNI的jobject.</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-1-IBinder-checkSubclass"><a href="#3-3-3-1-IBinder-checkSubclass" class="headerlink" title="3.3.3.1 IBinder#checkSubclass"></a>3.3.3.1 IBinder#checkSubclass</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IBinder::checkSubclass</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* <span class="comment">/*subclassID*/</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaBBinder:</span></span><br><span class="line"><span class="function"><span class="type">bool</span>    <span class="title">checkSubclass</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* subclassID)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 3.3.3.2 gBinderOffsets的初始化</span></span><br><span class="line">    <span class="keyword">return</span> subclassID == &amp;gBinderOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里思考一个问题，注意我们现在已经处于SystemServer进程了，这里的IBinder指向一块内存区域，是从Server App中拷贝而来的，与JavaBBinder数据保持一致。</p>
<p>那我们强制转换转成了IBinder，然后调用IBinder中的函数是调用IBinder中函数实现还是JavaBBinder中的函数实现呢？</p>
<h4 id="3-3-3-2-android-util-Binder-int-register-android-os-Binder"><a href="#3-3-3-2-android-util-Binder-int-register-android-os-Binder" class="headerlink" title="3.3.3.2 android_util_Binder#int_register_android_os_Binder"></a>3.3.3.2 android_util_Binder#int_register_android_os_Binder</h4><p>首先gBinderOffsets是bindernative_offsets_t类型的结构体，其在int_register_android_os_Binder中被填充数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);</span><br><span class="line"></span><br><span class="line">    gBinderOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">    gBinderOffsets.mGetInterfaceDescriptor = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;getInterfaceDescriptor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    gBinderOffsets.mObject = <span class="built_in">GetFieldIDOrDie</span>(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，在Java中，每个进程都有自己的虚拟机环境，所以对于不同进程来说，JNIEnv肯定也是不同的，这就导致gBinderOffsets也是不同的。</p>
<p>所以对于3.3.3.1中checkSubclass来说，返回的就是false了。</p>
<h3 id="3-3-4-创建BinderProxyNativeData"><a href="#3-3-4-创建BinderProxyNativeData" class="headerlink" title="3.3.4 创建BinderProxyNativeData"></a>3.3.4 创建BinderProxyNativeData</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinderProxyNativeData</span> &#123;</span><br><span class="line">    <span class="comment">// Both fields are constant and not null once javaObjectForIBinder returns this as</span></span><br><span class="line">    <span class="comment">// part of a BinderProxy.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The native IBinder proxied by this BinderProxy.</span></span><br><span class="line">    sp&lt;IBinder&gt; mObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Death recipients for mObject. Reference counted only because DeathRecipients</span></span><br><span class="line">    <span class="comment">// hold a weak reference that can be temporarily promoted.</span></span><br><span class="line">    sp&lt;DeathRecipientList&gt; mOrgue;  <span class="comment">// Death recipients for mObject.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哦噢，空欢喜？这里只是一个结构体，将IBinder和DeathRecipientList组合起来。</p>
<h3 id="3-3-5-gBinderProxyOffsets-mGetInstance-x3D-gt-BinderProxy-getInstance"><a href="#3-3-5-gBinderProxyOffsets-mGetInstance-x3D-gt-BinderProxy-getInstance" class="headerlink" title="3.3.5 gBinderProxyOffsets.mGetInstance &#x3D;&gt; BinderProxy.getInstance"></a>3.3.5 gBinderProxyOffsets.mGetInstance &#x3D;&gt; BinderProxy.getInstance</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BinderProxy <span class="title function_">getInstance</span><span class="params">(<span class="type">long</span> nativeData, <span class="type">long</span> iBinder)</span> &#123;</span><br><span class="line">    BinderProxy result;</span><br><span class="line">    <span class="keyword">synchronized</span> (sProxyMap) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = sProxyMap.get(iBinder);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建BinderProxy对象！</span></span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">BinderProxy</span>(nativeData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// We&#x27;re throwing an exception (probably OOME); don&#x27;t drop nativeData.</span></span><br><span class="line">            NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer,</span><br><span class="line">                    nativeData);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData);</span><br><span class="line">        <span class="comment">// The registry now owns nativeData, even if registration threw an exception.</span></span><br><span class="line">        sProxyMap.set(iBinder, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">BinderProxy</span><span class="params">(<span class="type">long</span> nativeData)</span> &#123;</span><br><span class="line">    <span class="comment">// 所以这个nativeData原来是代表的BinderProxyNativeData</span></span><br><span class="line">    mNativeData = nativeData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过JNI调用到Java方法，最终生成BinderProxy对象。</p>
<h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h1><p>到这里我们就理清了BinderProxy这个是怎么来的了。总结一下：</p>
<ol>
<li>Server App实现Service的onBind方法，返回一个IBinder对象，这个IBinder对象是继承了某个aidl接口的Stub类，记为StubIBinder</li>
<li>Server App调用publishService，将StubIBinder通过一系列方法，在Native层转成JavaBBinder，保存在Parce的内存区域中</li>
<li>Binder驱动拷贝Parcel并将其传给SystemServer进程(这个过程我们稍后分析)</li>
<li>SystemServer接收到Parcel内存数据，将其中JavaBBinder所在的内存区域强制转成IBinder类型，并将其保存为Java层的BinderProxy对象</li>
</ol>
<p>同理我们知道Client App通过调用bindService获取了一个IBinder对象，那这个IBinder对象也是BinderProxy类型的, 只不过这里有点点小差异:</p>
<p>SystemServer通过IServiceConnection向Client App发送Server App注册的BinderProxy对象时，在Parcel.writeStrongBinder过程中，存入cookie的是BinderProxy:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为Binder对象</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为BinderProxy对象</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="comment">// SystemServer向Client App发送Server App的BinderProxy对象，走这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在接下来打包flattenBinder的过程中, type 的类型其实是 BINDER_TYPE_HANDLE</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::flattenBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// ......</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 注意此时我们身处SystemServer进程，传入的IBinder实际上是对应BinderProxy</span></span></span><br><span class="line"><span class="function">        BBinder *local </span>= binder-&gt;<span class="built_in">localBinder</span>();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (local-&gt;<span class="built_in">isRequestingSid</span>()) &#123;</span><br><span class="line">                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line">            &#125;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-新的疑问"><a href="#4-1-新的疑问" class="headerlink" title="4.1 新的疑问"></a>4.1 新的疑问</h2><p>哦吼，新的问题来了，这个binder-&gt;localBinder()调用的到底是那个方法呢？IBinder, BBinder中都有实现。</p>
<p>如果是直接拷贝的话，那么按理说也是会调用到BBinder的localBinder，这样这里还是个local!</p>
<p>如果拷贝后在新进程中调用的是IBinder的localBinder，那么接下来的remoteBinder也是IBinder的，还是返回null！</p>
<p>这样也说不通，因为如果remoteBinder返回的也是空，那么打包后传入的信息就不能识别Server App的IDemoInterface了。</p>
<p>这里曾困扰我一段时间，这个IBinder到底是什么是我们理解Binder通信的基础。</p>
<p>按照网上一大堆的文章来说，从Binder通信到了另一个进程，那么BBinder就会转成了BpBinder。</p>
<p>然而我们梳理了上层代码，并没有发现这个转变过程。在Parcel整个压缩和解包的过程中都没有发现将IBinder强制转成BpBinder。</p>
<h2 id="4-2-binder驱动"><a href="#4-2-binder驱动" class="headerlink" title="4.2 binder驱动"></a>4.2 binder驱动</h2><p>其实这里是在驱动层做的处理：android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">struct</span> binder_thread *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span></span><br><span class="line"><span class="params"><span class="function">			       <span class="type">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;</span><br><span class="line">            buffer_offset += <span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> *fp;</span><br><span class="line"></span><br><span class="line">                fp = <span class="built_in">to_flat_binder_object</span>(hdr);</span><br><span class="line">                ret = <span class="built_in">binder_translate_binder</span>(fp, t, thread);</span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_translate_binder</span><span class="params">(<span class="keyword">struct</span> flat_binder_object *fp,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="keyword">struct</span> binder_transaction *t,</span></span></span><br><span class="line"><span class="params"><span class="function">				   <span class="keyword">struct</span> binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">        <span class="comment">// 这里，如果读取的hdr.type是BINDER_TYPE_BINDER</span></span><br><span class="line">        <span class="comment">// 将会被改成BINDER_TYPE_HANDLE！！！</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在驱动层传输数据的时候会加工一次！怪不得上层找不到任何信息，这个可真的是太容易误导了。</p>
<h2 id="4-3-SystemServer-x3D-gt-Parcel-unflattenBinder"><a href="#4-3-SystemServer-x3D-gt-Parcel-unflattenBinder" class="headerlink" title="4.3 SystemServer &#x3D;&gt; Parcel#unflattenBinder"></a>4.3 SystemServer &#x3D;&gt; Parcel#unflattenBinder</h2><p>所以在 #3.3.2.2 中 Parcel#unflattenBinder 解包数据时，对IBinder对象的处理是另外一条路径了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::unflattenBinder</span><span class="params">(sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从内存区域中读取当前位置的数据</span></span><br><span class="line">    <span class="type">const</span> flat_binder_object* flat = <span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">                sp&lt;IBinder&gt; binder = <span class="built_in">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">                <span class="comment">// 注意此时收到的数据是经过Binder驱动加工过的，我们现在是在SystemServer进程</span></span><br><span class="line">                <span class="comment">// 所以这个hdr.type从BINDER_TYPE_BINDER转成了BINDER_TYPE_HANDLE！</span></span><br><span class="line">                <span class="comment">// 这里解包，注意flat_binder_object这个结构体，他里面的binder和handle是被组合成union结构的!</span></span><br><span class="line">                <span class="comment">// 所以封包的时候写存入的binder就是此时读取的handle，这也代表了Server App中对应的BBinder</span></span><br><span class="line">                sp&lt;IBinder&gt; binder =</span><br><span class="line">                    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="comment">// 这里我们在回到#3.3.2中android_os_Parcel#android_os_Parcel_readStrongBinder</span></span><br><span class="line">                <span class="comment">// 就可以知道，其实SystemServer自始至终都是保存了来自Server App的BBinder相同数据但是转成了BpBinder的IBinder对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个疑问吼，我们看这个flat_binder_object结构的内容:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __u32 <span class="type">binder_size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span>	<span class="title">hdr</span>;</span></span><br><span class="line">	__u32				flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 8 bytes of data. */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">binder_uintptr_t</span>	binder;	<span class="comment">/* local object */</span></span><br><span class="line">		__u32			handle;	<span class="comment">/* remote object */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* extra data associated with local object */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span>	cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个handle是一个__u32类型的数据，说明该变量占4字节。</p>
<h3 id="4-3-1-ProcessState-getStrongProxyForHandle-int32-t-handle"><a href="#4-3-1-ProcessState-getStrongProxyForHandle-int32-t-handle" class="headerlink" title="4.3.1 ProcessState#getStrongProxyForHandle(int32_t handle)"></a>4.3.1 ProcessState#getStrongProxyForHandle(int32_t handle)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">// 4.3.2 从mHandleToObject中获取handle对应的handle_entry</span></span><br><span class="line">    handle_entry* e = <span class="built_in">lookupHandleLocked</span>(handle);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="comment">// 第一次当然是null的</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;<span class="built_in">attemptIncWeak</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.3.3 创建BpBinder!!!</span></span><br><span class="line">            b = BpBinder::<span class="built_in">create</span>(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="built_in">getWeakRefs</span>();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;<span class="built_in">decWeak</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个result就是新创建的BpBinder,或者之前创建缓存的BpBinder</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-ProcessState-lookupHandleLocked"><a href="#4-3-2-ProcessState-lookupHandleLocked" class="headerlink" title="4.3.2 ProcessState#lookupHandleLocked"></a>4.3.2 ProcessState#lookupHandleLocked</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ProcessState::handle_entry* <span class="title">ProcessState::lookupHandleLocked</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mHandleToObject 是Vector类型的数据集合</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> N=mHandleToObject.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="type">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">nullptr</span>;</span><br><span class="line">        e.refs = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">status_t</span> err = mHandleToObject.<span class="built_in">insertAt</span>(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.<span class="built_in">editItemAt</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的handle其实是Server App在打包数据时，获取的：obj.binder &#x3D; reinterpret_cast<uintptr_t>(local-&gt;getWeakRefs()), 然后经过驱动加工，可以视为BBinder的映射BpBinder的Token. 这里的细节我们后面分析。</uintptr_t></p>
<p>一般来说每个BBinder都不一样(为什么呢，涉及到binder驱动以及Android的智能指针)，所以，这里的mHandleToObject是缓存IBinder对象，防止频繁创建销毁消耗资源。</p>
<h3 id="4-3-3-创建BpBinder"><a href="#4-3-3-创建BpBinder" class="headerlink" title="4.3.3 创建BpBinder"></a>4.3.3 创建BpBinder</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BpBinder* <span class="title">BpBinder::create</span><span class="params">(<span class="type">int32_t</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> trackedUid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// sCountByUidEnabled默认是false的，SystemServer进程是再开机过程中打开的</span></span><br><span class="line">    <span class="keyword">if</span> (sCountByUidEnabled) &#123;</span><br><span class="line">        <span class="comment">// 获取Server App的UID</span></span><br><span class="line">        trackedUid = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>();</span><br><span class="line">        <span class="comment">// 接下来是判断Server App是否存在过多的binder proxy对象</span></span><br><span class="line">        <span class="comment">// 默认2500个, 对于SystemServer进程是6000个(也是开机过程中设置的nSetBinderProxyCountWatermarks)</span></span><br><span class="line">        AutoMutex _l(sTrackingLock);</span><br><span class="line">        <span class="type">uint32_t</span> trackedValue = sTrackingMap[trackedUid];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(trackedValue &amp; LIMIT_REACHED_MASK)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((trackedValue &amp; COUNTING_VALUE_MASK) &gt;= sBinderProxyCountHighWatermark) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)&quot;</span>,</span><br><span class="line">                      <span class="built_in">getuid</span>(), trackedUid, trackedValue);</span><br><span class="line">                sTrackingMap[trackedUid] |= LIMIT_REACHED_MASK;</span><br><span class="line">                <span class="keyword">if</span> (sLimitCallback) <span class="built_in">sLimitCallback</span>(trackedUid);</span><br><span class="line">                <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                    <span class="built_in">ALOGI</span>(<span class="string">&quot;Throttling binder proxy creates from uid %d in uid %d until binder proxy&quot;</span></span><br><span class="line">                          <span class="string">&quot; count drops below %d&quot;</span>,</span><br><span class="line">                          trackedUid, <span class="built_in">getuid</span>(), sBinderProxyCountLowWatermark);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该UID创建了新的BpBinder</span></span><br><span class="line">        sTrackingMap[trackedUid]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BpBinder</span>(handle, trackedUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BpBinder::<span class="built_in">BpBinder</span>(<span class="type">int32_t</span> handle, <span class="type">int32_t</span> trackedUid)</span><br><span class="line">    : <span class="built_in">mHandle</span>(handle)</span><br><span class="line">    , <span class="built_in">mStability</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mAlive</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mObitsSent</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mObituaries</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mTrackedUid</span>(trackedUid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating BpBinder %p handle %d\n&quot;</span>, <span class="keyword">this</span>, mHandle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">extendObjectLifetime</span>(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    <span class="comment">// 给此BpBinder新增一个弱引用</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">incWeakHandle</span>(handle, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后补上一张IBinder类图:</p>
<p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png" alt="2_4_IBinder全类图"></p>
<p>了解了IBinder转换过程的原理，BinderProxy的生成过程，也知道了BBinder和BpBinder的映射关系，接下来就是在Client App和Server App之间的通信了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li>
<li>msm-4.14 Code <a href="https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c">https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Binder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder(3)--sayHello之ioctl</title>
    <url>/2022/04/04/Binder-3-sayHello%E4%B9%8Bioctl/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，首先回顾一下IBinder相关接口的类图：</p>
<p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png" alt="2_4_IBinder全类图"></p>
<p>我们知道在Client App中获取的IBinder实际上是BinderProxy类型的对象。那么在上一文中Client App调用sayHello方法过程的的#2.3.2中，我们卡住了，现在可以继续了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>        <span class="title">transact</span><span class="params">(   <span class="type">uint32_t</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Parcel* reply,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="一-IBinder-transact"><a href="#一-IBinder-transact" class="headerlink" title="一. IBinder.transact"></a>一. IBinder.transact</h1><ol>
<li>Service.onServiceConnected</li>
<li>IDemoInterface.Stub.Proxy.sayHello</li>
<li>BinderProxy.transact(Stub.TRANSACTION_sayHello, ……)</li>
</ol>
<h2 id="1-1-BinderProxy-transact"><a href="#1-1-BinderProxy-transact" class="headerlink" title="1.1 BinderProxy.transact"></a>1.1 BinderProxy.transact</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不多废话，直接开始, 注意我们现在的进程环境是Client App哦</span></span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-android-util-Binder-android-os-BinderProxy-transact"><a href="#1-2-android-util-Binder-android-os-BinderProxy-transact" class="headerlink" title="1.2 android_util_Binder#android_os_BinderProxy_transact"></a>1.2 android_util_Binder#android_os_BinderProxy_transact</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 获取IBinder对象，这里我们已经知道了，是BinderProxy对应Native的IBinder对象</span></span><br><span class="line">    <span class="comment">// 也就是对应Server App存入的JavaBBinder, 是Parcel:flattenBinder中存入cookie的BBinder</span></span><br><span class="line">    <span class="comment">// 然后在通信过程中经过Binder驱动转成了对应的BpBinder</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 上一篇文章我们就分析了，这个target就是BpBinder</span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-BpBinder-transact"><a href="#1-3-BpBinder-transact" class="headerlink" title="1.3 BpBinder#transact"></a>1.3 BpBinder#transact</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NOLINTNEXTLINE(google-default-arguments)</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一旦Binder对象死掉，就不会复活</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.4 IPCThreadState!</span></span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-IPCThreadState-transact"><a href="#1-4-IPCThreadState-transact" class="headerlink" title="1.4 IPCThreadState#transact"></a>1.4 IPCThreadState#transact</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.1 将数据写入mOut中存储, cmd 是BC_TRANSACTION</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// TF_ONE_WAY 是代表这个binder调用是one_way的，不需要等待回传</span></span><br><span class="line">        <span class="comment">// 这个分支表示需要回传数据</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            <span class="comment">// 1.5 当传入的reply Parcel不为null时</span></span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当直接传入一个null的Parcel作为reply时</span></span><br><span class="line">            <span class="comment">// 创建一个假的Parcel接收可能的回写数据</span></span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要回传数据</span></span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transaction的flag一共有四种：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>value</th>
<th>function</th>
</tr>
</thead>
<tbody><tr>
<td>TF_ONE_WAY</td>
<td>0x01</td>
<td>代表oneway的binder调用，不需要回传数据</td>
</tr>
<tr>
<td>TF_ROOT_OBJECT</td>
<td>0x04</td>
<td>内容是组件的根对象</td>
</tr>
<tr>
<td>TF_STATUS_CODE</td>
<td>0x08</td>
<td>内容是32位的状态代码</td>
</tr>
<tr>
<td>TF_ACCEPT_FDS</td>
<td>0x10</td>
<td>允许使用文件描述符答复</td>
</tr>
</tbody></table>
<p>首先将需要传递的数据写入out中存储，然后去和binder driver通信。</p>
<p>这里我们先忽略IPCThreadState的初始化过程。</p>
<h3 id="1-4-1-IPCThreadState-writeTransactionData"><a href="#1-4-1-IPCThreadState-writeTransactionData" class="headerlink" title="1.4.1 IPCThreadState#writeTransactionData"></a>1.4.1 IPCThreadState#writeTransactionData</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// cmd为BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    <span class="comment">// 将data保存在mOut中</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里折后就是将数据保存在mOut中，这里是怎么保证多线程并发的时的处理呢？稍后我们研究IPC的初始化就知道了。</p>
<h2 id="1-5-IPCThreadState-waitForResponse"><a href="#1-5-IPCThreadState-waitForResponse" class="headerlink" title="1.5 IPCThreadState#waitForResponse"></a>1.5 IPCThreadState#waitForResponse</h2><p>从名字也可以猜出来，这里应该就是与binder.c驱动通信。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.6 显而易见, 与驱动通信</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// #1.6中已经通过ioctl与binder驱动通信了，回传的输入也写入了mIn中</span></span><br><span class="line">        <span class="comment">// 读取的第一个uint32_t的数据代表binder通信类型</span></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            err = FAILED_TRANSACTION;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(acquireResult != <span class="literal">NULL</span>, <span class="string">&quot;Unexpected brACQUIRE_RESULT&quot;</span>);</span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> result = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">                <span class="keyword">if</span> (!acquireResult) <span class="keyword">continue</span>;</span><br><span class="line">                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="comment">// 一般非oneway的通信就是走的这里</span></span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                <span class="comment">// 读取从binder驱动回传的数据</span></span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将回传的数据存入reply中</span></span><br><span class="line">                        reply-&gt;<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-IPCThreadState-talkWithDriver"><a href="#1-6-IPCThreadState-talkWithDriver" class="headerlink" title="1.6 IPCThreadState#talkWithDriver"></a>1.6 IPCThreadState#talkWithDriver</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_write_read是一个保存了传输数据以及回传数据信息的结构体</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断读缓冲区是否为空</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仍在从输入缓冲区中剩余的数据中读取数据，并且调用者已请求读取下一个数据，则不编写任何内容</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将待传入的数据存入bwr中，以便通过binder驱动传输</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要回传的数据时</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">// 读缓冲区大小设置为可接受的最大大小</span></span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        <span class="comment">// 将bwr中读缓冲区指针指向mIn中的data，后续驱动直接将数据填充到这里</span></span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Finished read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在回传的数据，则标记</span></span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok, 到这里我们对Binder通信已经有了一个初步的认知,最核心跨进程的通信手段是通过ioctl这个东东。</p>
<h1 id="二-ioctl介绍"><a href="#二-ioctl介绍" class="headerlink" title="二. ioctl介绍"></a>二. ioctl介绍</h1><p>本身对Linux内核驱动不太了解，可以参考这篇博文: <a href="https://blog.csdn.net/qq_19923217/article/details/82698787">https://blog.csdn.net/qq_19923217/article/details/82698787</a></p>
<p>ioctl（）系统调用操作特殊文件的底层设备参数。特别是，字符特殊文件（例如终端）的许多操作特性可以通过ioctl（）请求来控制。</p>
<blockquote>
<p>ioctl 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fd</td>
<td>文件描述符</td>
</tr>
<tr>
<td>cmd</td>
<td>交互协议，设备驱动将根据 cmd 执行对应操作</td>
</tr>
<tr>
<td>…</td>
<td>可变参数 arg，依赖 cmd 指定长度以及类型</td>
</tr>
</tbody></table>
<h2 id="2-1-API"><a href="#2-1-API" class="headerlink" title="2.1 API"></a>2.1 API</h2><ol>
<li>头文件: #include &lt;sys&#x2F;ioctl.h&gt;, 用于指定ioctl（）请求的宏和定义位于文件&lt;sys&#x2F;ioctl.h&gt;中。</li>
<li>参数:  int ioctl(int fd, unsigned long request, …);<ol>
<li>fd 必须是打开文件描述符。</li>
<li>cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作</li>
<li>argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。</li>
</ol>
</li>
<li>返回值: ioctl() 函数执行成功时返回 0，失败则返回 -1 并设置全局变量 errorno 值<ol>
<li>EBADF  fd不是有效的文件描述符。</li>
<li>EFAULT 默认argp引用不可访问的内存区域。</li>
<li>EINVAL 请求或argp无效。</li>
<li>ENOTTY fd与字符专用设备不关联。</li>
<li>ENOTTY 指定的请求不适用于文件描述符fd引用的对象类型。</li>
</ol>
</li>
</ol>
<h2 id="2-2-ioctl用户与驱动之间的协议"><a href="#2-2-ioctl用户与驱动之间的协议" class="headerlink" title="2.2 ioctl用户与驱动之间的协议"></a>2.2 ioctl用户与驱动之间的协议</h2><blockquote>
<p>参考:<a href="https://blog.csdn.net/zifehng/article/details/59576539">https://blog.csdn.net/zifehng/article/details/59576539</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个sayHello的过程，我们对binder通信有了基本概念。知道BBinder, BpBinder, IBinder, IInterface等等类的作用。</p>
<p>接下来我们先看看Binder驱动的加载过程，之后在继续分析ioctl接下来的流程：比如Client发送请求后，binder驱动是怎么找到对应Server的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li>
<li>msm-4.14 Code <a href="https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c">https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c</a></li>
<li>linux 内核 - ioctl 函数详解 <a href="https://blog.csdn.net/qq_19923217/article/details/82698787">https://blog.csdn.net/qq_19923217/article/details/82698787</a></li>
<li>ioctl(2) — Linux manual page <a href="https://man7.org/linux/man-pages/man2/ioctl.2.html">https://man7.org/linux/man-pages/man2/ioctl.2.html</a></li>
<li>ioctl()分析——从用户空间到设备驱动 <a href="https://blog.csdn.net/zifehng/article/details/59576539">https://blog.csdn.net/zifehng/article/details/59576539</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Binder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder(4)--binder驱动的加载</title>
    <url>/2022/04/04/Binder-4-binder%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，想要了解binder驱动的工作原理，我们从binder驱动加载过程开始：</p>
<p>在android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c中，我们可以看到有这么一行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure>

<p>在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它的initcall 的level为6。</p>
<p>他可以将驱动设备加载进内核中，以供后续使用。</p>
<span id="more"></span>

<h1 id="一-Linux内核init-call过程"><a href="#一-Linux内核init-call过程" class="headerlink" title="一. Linux内核init call过程"></a>一. Linux内核init call过程</h1><p>在<a href="https://blog.csdn.net/u014535072/article/details/82936972">Android开机流程(一)</a>一文中有阐述Android开机过程。</p>
<p>我们知道系统加电自检后，引导程序执行完毕，内核映像被加载到内存并获得控制权之后，会启动kernel_init。</p>
<h2 id="1-1-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c"><a href="#1-1-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c" class="headerlink" title="1.1 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c"></a>1.1 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 初始化kernel参数</span></span><br><span class="line">	<span class="built_in">kernel_init_freeable</span>()</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-kernel-init-freeable"><a href="#1-2-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-kernel-init-freeable" class="headerlink" title="1.2 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:kernel_init_freeable"></a>1.2 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:kernel_init_freeable</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> noinline <span class="type">void</span> __init <span class="title">kernel_init_freeable</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="built_in">do_basic_setup</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_basic_setup</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 调用各种initcall</span></span><br><span class="line">	<span class="built_in">do_initcalls</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_initcalls</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> level;</span><br><span class="line">    <span class="comment">// initcall_levels 的大小是9，所以这里level是从0到7的</span></span><br><span class="line">	<span class="keyword">for</span> (level = <span class="number">0</span>; level &lt; <span class="built_in">ARRAY_SIZE</span>(initcall_levels) - <span class="number">1</span>; level++)</span><br><span class="line">		<span class="built_in">do_initcall_level</span>(level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-do-initcall-level"><a href="#1-3-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-do-initcall-level" class="headerlink" title="1.3 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:do_initcall_level"></a>1.3 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:do_initcall_level</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Keep these in sync with initcalls in include/linux/init.h */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *initcall_level_names[] __initdata = &#123;</span><br><span class="line">	<span class="string">&quot;pure&quot;</span>,</span><br><span class="line">	<span class="string">&quot;core&quot;</span>,</span><br><span class="line">	<span class="string">&quot;postcore&quot;</span>,</span><br><span class="line">	<span class="string">&quot;arch&quot;</span>,</span><br><span class="line">	<span class="string">&quot;subsys&quot;</span>,</span><br><span class="line">	<span class="string">&quot;fs&quot;</span>,</span><br><span class="line">	<span class="string">&quot;device&quot;</span>,</span><br><span class="line">	<span class="string">&quot;late&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_initcall_level</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 按顺序执行initcall_levels，其实就是initcall_level_names中的顺序。</span></span><br><span class="line">	<span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line">		<span class="built_in">do_one_initcall</span>(<span class="built_in">initcall_from_entry</span>(fn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实Andorid开机过程中的init.rc中各种init进程和这里类似。</p>
<h1 id="二-binder驱动的初始化"><a href="#二-binder驱动的初始化" class="headerlink" title="二. binder驱动的初始化"></a>二. binder驱动的初始化</h1><p>在了解Linux内核各种init call之后, 我们注意到binder.c最后几行代码中有这么一行:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">device_initcall</span>(binder_init);</span><br></pre></td></tr></table></figure>

<p>而在android&#x2F;kernel&#x2F;msm-4.9&#x2F;include&#x2F;linux&#x2F;init.h中可以看到定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pure_initcall(fn)		__define_initcall(fn, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall(fn)		__define_initcall(fn, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall_sync(fn)		__define_initcall(fn, 1s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall(fn)		__define_initcall(fn, 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall_sync(fn)	__define_initcall(fn, 2s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall(fn)		__define_initcall(fn, 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall_sync(fn)		__define_initcall(fn, 3s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall(fn)		__define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall_sync(fn)	__define_initcall(fn, 4s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall(fn)			__define_initcall(fn, 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall_sync(fn)		__define_initcall(fn, 5s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rootfs_initcall(fn)		__define_initcall(fn, rootfs)</span></span><br><span class="line"><span class="comment">// HERE!!!</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall(fn)		__define_initcall(fn, 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall_sync(fn)	__define_initcall(fn, 6s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall(fn)		__define_initcall(fn, 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall_sync(fn)		__define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure>

<p>所以binder驱动的加载时机是先于Android的init进程的，在Linux内核启动中是以level为6（device）的优先级加载的。</p>
<h2 id="2-1-binder-c-binder-init"><a href="#2-1-binder-c-binder-init" class="headerlink" title="2.1 binder.c:binder_init"></a>2.1 binder.c:binder_init</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> *device_name, *device_tmp;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_device</span> *device;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">hlist_node</span> *tmp;</span><br><span class="line">	<span class="type">char</span> *device_names = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化binder缓冲区,其实就是一个list_lru结构体:binder_alloc_lru</span></span><br><span class="line">	ret = <span class="built_in">binder_alloc_shrinker_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建binder相关文件</span></span><br><span class="line">    <span class="comment">// 在sys/kernel/debug目录下，创建binder目录　- debugfs是一种用户内核调试的虚拟文件系统</span></span><br><span class="line">	binder_debugfs_dir_entry_root = <span class="built_in">debugfs_create_dir</span>(<span class="string">&quot;binder&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建sys/kernel/debug/binder/proc目录</span></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">		binder_debugfs_dir_entry_proc = <span class="built_in">debugfs_create_dir</span>(<span class="string">&quot;proc&quot;</span>,</span><br><span class="line">						 binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建其余文件</span></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">		<span class="built_in">debugfs_create_file</span>(<span class="string">&quot;state&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="comment">// 2.1.1 操作函数的定义</span></span><br><span class="line">				    &amp;binder_state_fops);</span><br><span class="line">		<span class="built_in">debugfs_create_file</span>(<span class="string">&quot;stats&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_stats_fops);</span><br><span class="line">		<span class="built_in">debugfs_create_file</span>(<span class="string">&quot;transactions&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    <span class="literal">NULL</span>,</span><br><span class="line">				    &amp;binder_transactions_fops);</span><br><span class="line">		<span class="built_in">debugfs_create_file</span>(<span class="string">&quot;transaction_log&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    &amp;binder_transaction_log,</span><br><span class="line">				    &amp;binder_transaction_log_fops);</span><br><span class="line">		<span class="built_in">debugfs_create_file</span>(<span class="string">&quot;failed_transaction_log&quot;</span>,</span><br><span class="line">				    <span class="number">0444</span>,</span><br><span class="line">				    binder_debugfs_dir_entry_root,</span><br><span class="line">				    &amp;binder_transaction_log_failed,</span><br><span class="line">				    &amp;binder_transaction_log_fops);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CONFIG_ANDROID_BINDERFS是编译配置,一般都是定义的，所以这个分支不进入</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_ENABLED</span>(CONFIG_ANDROID_BINDERFS) &amp;&amp;</span><br><span class="line">	    <span class="built_in">strcmp</span>(binder_devices_param, <span class="string">&quot;&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 初始化binder文件系统</span></span><br><span class="line">	ret = <span class="built_in">init_binderfs</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是创建了sys&#x2F;kernel&#x2F;debug&#x2F;binder目录，以及其子目录或文件:</p>
<ol>
<li>proc:记录调用Binder各个进程的内容</li>
<li>state:记录状态信息，操作函数binder_state_fops</li>
<li>stats:记录统计信息，操作函数binder_stats_fops</li>
<li>transactions:记录transaction相关信息，操作函数binder_transactions_fops</li>
<li>transaction_log:记录transaction日志，操作函数binder_transaction_log_fops</li>
<li>failed_transaction_log:记录失败的transaction日志信息，操作函数binder_transaction_log_fops</li>
</ol>
<p>这里比较奇怪的是没有找到创建文件(目录)时的操作函数的定义,比如binder_state_fops。</p>
<h3 id="2-1-1-操作函数的定义"><a href="#2-1-1-操作函数的定义" class="headerlink" title="2.1.1 操作函数的定义"></a>2.1.1 操作函数的定义</h3><p>以binder_state_fops为例，其实这些函数的定义是通过宏定义统一实现的。</p>
<p>在文件android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h中我们可以看到有如下函数的声明:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_stats_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_stats);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_state_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_state);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_transactions_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_transactions);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_transaction_log_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_transaction_log);</span><br></pre></td></tr></table></figure>

<p>我们看binder_state_show这个函数下面的DEFINE_SHOW_ATTRIBUTE这个宏。</p>
<h3 id="2-1-2-DEFINE-SHOW-ATTRIBUTE"><a href="#2-1-2-DEFINE-SHOW-ATTRIBUTE" class="headerlink" title="2.1.2 DEFINE_SHOW_ATTRIBUTE"></a>2.1.2 DEFINE_SHOW_ATTRIBUTE</h3><p>这个宏的申明是在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;include&#x2F;linux&#x2F;seq_file.h#148</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SHOW_ATTRIBUTE(__name)					\</span></span><br><span class="line"><span class="meta">static int __name ## _open(struct inode *inode, struct file *file)	\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	return single_open(file, __name ## _show, inode-&gt;i_private);	\</span></span><br><span class="line"><span class="meta">&#125;									\</span></span><br><span class="line"><span class="meta">									\</span></span><br><span class="line"><span class="meta">static const struct file_operations __name ## _fops = &#123;			\</span></span><br><span class="line"><span class="meta">	.owner		= THIS_MODULE,					\</span></span><br><span class="line"><span class="meta">	.open		= __name ## _open,				\</span></span><br><span class="line"><span class="meta">	.read		= seq_read,					\</span></span><br><span class="line"><span class="meta">	.llseek		= seq_lseek,					\</span></span><br><span class="line"><span class="meta">	.release	= single_release,				\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>把这个宏展开就是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __name_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> single_open(file, __name_show, inode-&gt;i_private);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> __<span class="title">name_fops</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.open		= __name_open,</span><br><span class="line">	.read		= seq_read,</span><br><span class="line">	.llseek		= seq_lseek,</span><br><span class="line">	.release	= single_release,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当声明函数binder_state_show时，也就通过DEFINE_SHOW_ATTRIBUTE(binder_state)申明了：</p>
<ol>
<li>函数:   binder_state_open</li>
<li>结构体: binder_state_fops</li>
</ol>
<h2 id="2-2-init-binderfs-初始化binder文件系统"><a href="#2-2-init-binderfs-初始化binder文件系统" class="headerlink" title="2.2 init_binderfs 初始化binder文件系统"></a>2.2 init_binderfs 初始化binder文件系统</h2><p>在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h#init_binderfs</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ANDROID_BINDERFS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __init <span class="title function_">init_binderfs</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __init <span class="title function_">init_binderfs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里的CONFIG_ANDROID_BINDERFS就对应内核编译时的配置:android-base.config#20</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_ANDROID_BINDERFS=y</span><br></pre></td></tr></table></figure>
<p>y就是定义该宏。</p>
<p>这里是引用了外部文件的函数: init_binderfs, 在该头文件的同目录下的文件binderfs.c可以找到对应函数实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __init <span class="title">init_binderfs</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_devices_param是定义在binder.c文件中的：</span></span><br><span class="line">    <span class="comment">//  char *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES;</span></span><br><span class="line">    <span class="comment">// 而CONFIG_ANDROID_BINDER_DEVICES 是编译配置: </span></span><br><span class="line">    <span class="comment">//  CONFIG_ANDROID_BINDER_DEVICES=&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line">	<span class="comment">// 所以这里的name就是&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line">    name = binder_devices_param;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证默认的binderfs设备名是否合法有效</span></span><br><span class="line">    <span class="comment">// 检验的方式是判断名字中是否含有字符&#x27;,&#x27;</span></span><br><span class="line">	<span class="keyword">for</span> (len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>); len &gt; <span class="number">0</span>; len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// BINDERFS_MAX_NAME = 255</span></span><br><span class="line">		<span class="keyword">if</span> (len &gt; BINDERFS_MAX_NAME)</span><br><span class="line">			<span class="keyword">return</span> -E2BIG;</span><br><span class="line">		name += len;</span><br><span class="line">		<span class="keyword">if</span> (*name == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">			name++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 动态分配binder设备编号</span></span><br><span class="line">	ret = <span class="built_in">alloc_chrdev_region</span>(&amp;binderfs_dev, <span class="number">0</span>, BINDERFS_MAX_MINOR,</span><br><span class="line">				  <span class="string">&quot;binder&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2.1 注册binder文件系统</span></span><br><span class="line">	ret = <span class="built_in">register_filesystem</span>(&amp;binder_fs_type);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">unregister_chrdev_region</span>(binderfs_dev, BINDERFS_MAX_MINOR);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_system_type</span> binder_fs_type = &#123;</span><br><span class="line">	.name		= <span class="string">&quot;binder&quot;</span>,</span><br><span class="line">	.mount		= binderfs_mount,</span><br><span class="line">	.kill_sb	= binderfs_kill_super,</span><br><span class="line">	.fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化binder文件系统，三件事：</p>
<ol>
<li>验证binder_devices_param也就是编译配置文件中的：CONFIG_ANDROID_BINDER_DEVICES是否合法</li>
<li>分配binder设备编号</li>
<li>注册binder文件系统</li>
</ol>
<p>在这一步之后我们就可以通过　cat proc&#x2F;devices 查到binder驱动对应的设备号了:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SS9805:/ # cat proc/devices</span><br><span class="line">Character devices:</span><br><span class="line">......</span><br><span class="line">488 binder</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>比如这次我们机器中binder驱动的设备号为488，而且还可以看到这里是注册成字符设备的。</p>
<blockquote>
<p>Linux 中的设备有2种类型：字符设备(无缓冲且只能顺序存取)、块设备(有缓冲且可以随机存取)。</p>
</blockquote>
<p>在Linux下，一切皆文件，设备也不例外，为了管理这些设备，系统为它们各自都编了号，而每个设备号又分为主设备号和次设备号。主设备号用来区分不同类型的设备，而次设备号用来区分同一类型内的多个设备（及其设备分区）。</p>
<h3 id="2-2-1-register-filesystem"><a href="#2-2-1-register-filesystem" class="headerlink" title="2.2.1 register_filesystem"></a>2.2.1 register_filesystem</h3><p>定义在android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;filesystems.c中:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_system_type</span> ** p;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BUG_ON</span>(<span class="built_in">strchr</span>(fs-&gt;name, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">	<span class="keyword">if</span> (fs-&gt;next)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line">	<span class="built_in">write_lock</span>(&amp;file_systems_lock);</span><br><span class="line">    <span class="comment">// 在file_systems链表中找到合适位置，插入</span></span><br><span class="line">	p = <span class="built_in">find_filesystem</span>(fs-&gt;name, <span class="built_in">strlen</span>(fs-&gt;name));</span><br><span class="line">	<span class="comment">// 如果不为空，说明已经注册过了，不能重复注册</span></span><br><span class="line">    <span class="keyword">if</span> (*p)</span><br><span class="line">		res = -EBUSY;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*p = fs;</span><br><span class="line">	<span class="built_in">write_unlock</span>(&amp;file_systems_lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(register_filesystem);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_system_type</span> **<span class="built_in">find_filesystem</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file_system_type</span> **p;</span><br><span class="line">	<span class="keyword">for</span> (p = &amp;file_systems; *p; p = &amp;(*p)-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strncmp</span>((*p)-&gt;name, name, len) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    !(*p)-&gt;name[len])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是将传入的fs插入file_systems链表的末尾，且不能重复注册。</p>
<h1 id="三-binder设备创建及挂载－debugfs挂载"><a href="#三-binder设备创建及挂载－debugfs挂载" class="headerlink" title="三.binder设备创建及挂载－debugfs挂载"></a>三.binder设备创建及挂载－debugfs挂载</h1><p>上面的步骤我们分析了binder驱动的初始化，最后会注册binder文件系统。这一过程都是在kernel初始化的device_initcall中完成的。</p>
<p>当kernel启动到一定程度，将文件系统挂载后，自然binder驱动会运作起来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct file_system_type binder_fs_type = &#123;</span><br><span class="line">	.name		= &quot;binder&quot;,</span><br><span class="line">	.mount		= binderfs_mount, // 文件系统挂载后调用函数</span><br><span class="line">	.kill_sb	= binderfs_kill_super,</span><br><span class="line">	.fs_flags	= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>文件系统挂载后，就会调用binderfs_mount函数.</p>
<h2 id="3-1-binderfs-c-binderfs-mount"><a href="#3-1-binderfs-c-binderfs-mount" class="headerlink" title="3.1 binderfs.c#binderfs_mount"></a>3.1 binderfs.c#binderfs_mount</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">dentry</span> *<span class="built_in">binderfs_mount</span>(<span class="keyword">struct</span> file_system_type *fs_type,</span><br><span class="line">				     <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name,</span><br><span class="line">				     <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 留意这个binderfs_fill_super</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mount_nodev</span>(fs_type, flags, data, binderfs_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-android-x2F-kernel-x2F-msm-4-19-x2F-fs-x2F-super-c-mount-nodev"><a href="#3-2-android-x2F-kernel-x2F-msm-4-19-x2F-fs-x2F-super-c-mount-nodev" class="headerlink" title="3.2 android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;super.c#mount_nodev"></a>3.2 android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;super.c#mount_nodev</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *<span class="built_in">mount_nodev</span>(<span class="keyword">struct</span> file_system_type *fs_type,</span><br><span class="line">	<span class="type">int</span> flags, <span class="type">void</span> *data,</span><br><span class="line">	<span class="built_in">int</span> (*fill_super)(<span class="keyword">struct</span> super_block *, <span class="type">void</span> *, <span class="type">int</span>))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">    <span class="comment">// 获取超级块</span></span><br><span class="line">    <span class="comment">// 超级块代表了整个文件系统，超级块是文件系统的控制块，有整个文件系统信息</span></span><br><span class="line">    <span class="comment">// 一个文件系统所有的inode都要连接到超级块上，可以说，一个超级块就代表了一个文件系统。</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">super_block</span> *s = <span class="built_in">sget</span>(fs_type, <span class="literal">NULL</span>, set_anon_super, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(s))</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_CAST</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用传入的函数fill_super</span></span><br><span class="line">	error = <span class="built_in">fill_super</span>(s, data, flags &amp; SB_SILENT ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="built_in">deactivate_locked_super</span>(s);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(error);</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;s_flags |= SB_ACTIVE;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dget</span>(s-&gt;s_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(mount_nodev);</span><br></pre></td></tr></table></figure>
<p>这些设计文件系统挂载知识，后续我们在研究一下。</p>
<p>调用mount_nodev后，获取超级块如果一切正常，会调用传入的fill_super函数，这里对应的就是binderfs_fill_super!</p>
<h2 id="3-3-binderfs-c-binderfs-fill-super"><a href="#3-3-binderfs-c-binderfs-fill-super" class="headerlink" title="3.3 binderfs.c#binderfs_fill_super"></a>3.3 binderfs.c#binderfs_fill_super</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binderfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binderfs_device</span> device_info = &#123; &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件系统中数据块大小，以字节单位为一页(一般为4096)</span></span><br><span class="line">	sb-&gt;s_blocksize = PAGE_SIZE;</span><br><span class="line">	sb-&gt;s_blocksize_bits = PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// kmalloc用于内核空间申请内存，申请的内存位于物理内存映射区域，而且在物理上也是连续的</span></span><br><span class="line">    <span class="comment">// 与真实的物理地址只有一个固定的偏移,因为存在较简单的转换关系，所以对申请的内存大小有限制，不能超过128KB。</span></span><br><span class="line">    <span class="comment">// GFP_KERNEL —— 正常分配内存；</span></span><br><span class="line">	sb-&gt;s_fs_info = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> binderfs_info), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// inode 保存的其实是实际的数据的一些信息，这些信息称为“元数据”(也就是对文件属性的描述)。</span></span><br><span class="line">    <span class="comment">// 例如：文件大小，设备标识符，用户标识符，用户组标识符，文件模式，扩展属性，文件读取或</span></span><br><span class="line">    <span class="comment">// 修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等等。</span></span><br><span class="line">	inode = <span class="built_in">new_inode</span>(sb);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此函数在@sb引用的binderfs中创建一个新的binderfs控制设备节点。</span></span><br><span class="line">	ret = <span class="built_in">binderfs_binder_ctl_create</span>(sb);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	name = binder_devices_param;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并创建所有binder设备，三种:&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line">    <span class="comment">// 1. binder</span></span><br><span class="line">    <span class="comment">// 2. hwbinder</span></span><br><span class="line">    <span class="comment">// 3. vndbinder</span></span><br><span class="line">	<span class="keyword">for</span> (len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>); len &gt; <span class="number">0</span>; len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">		<span class="built_in">strscpy</span>(device_info.name, name, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.4 创建对应binder设备</span></span><br><span class="line">		ret = <span class="built_in">binderfs_binder_device_create</span>(inode, <span class="literal">NULL</span>, &amp;device_info);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		name += len;</span><br><span class="line">		<span class="keyword">if</span> (*name == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">			name++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;mount_opts.stats_mode == STATS_GLOBAL)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">init_binder_logs</span>(sb);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-binderfs-c-binderfs-binder-device-create"><a href="#3-4-binderfs-c-binderfs-binder-device-create" class="headerlink" title="3.4 binderfs.c#binderfs_binder_device_create"></a>3.4 binderfs.c#binderfs_binder_device_create</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binderfs_binder_device_create</span><span class="params">(<span class="keyword">struct</span> inode *ref_inode,</span></span></span><br><span class="line"><span class="params"><span class="function">					 <span class="keyword">struct</span> binderfs_device __user *userp,</span></span></span><br><span class="line"><span class="params"><span class="function">					 <span class="keyword">struct</span> binderfs_device *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> minor, ret;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *dentry, *root;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_device</span> *device;</span><br><span class="line">	<span class="type">char</span> *name = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">size_t</span> name_len;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">super_block</span> *sb = ref_inode-&gt;i_sb;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info = sb-&gt;s_fs_info;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给binder_device分配内核内存空间</span></span><br><span class="line">	device = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*device), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!device)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 创建一个新的inode节点</span></span><br><span class="line">	inode = <span class="built_in">new_inode</span>(sb);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点,　这里将加载文件操作集－binder操作</span></span><br><span class="line">	inode-&gt;i_fop = &amp;binder_fops;</span><br><span class="line">	inode-&gt;i_uid = info-&gt;root_uid;</span><br><span class="line">	inode-&gt;i_gid = info-&gt;root_gid;</span><br><span class="line"></span><br><span class="line">	req-&gt;name[BINDERFS_MAX_NAME] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* NUL-terminate */</span></span><br><span class="line">	name_len = <span class="built_in">strlen</span>(req-&gt;name);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 分配一块长度为name_len + 1的内存（kmalloc+gfp）</span></span><br><span class="line">    <span class="comment">// 然后将req-&gt;name到(req-&gt;name + len)内存的内容copy到新分配的内存中</span></span><br><span class="line">    <span class="comment">// 最后后返回该内存的首地址</span></span><br><span class="line">	name = <span class="built_in">kmemdup</span>(req-&gt;name, name_len + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!name)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化binder_device的相关设置</span></span><br><span class="line">	<span class="built_in">refcount_set</span>(&amp;device-&gt;ref, <span class="number">1</span>);</span><br><span class="line">	device-&gt;binderfs_inode = inode;</span><br><span class="line">	device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">	device-&gt;context.name = name;</span><br><span class="line">	device-&gt;miscdev.name = name;<span class="comment">// 分别是binder, hwbinder, vndbinder</span></span><br><span class="line">	device-&gt;miscdev.minor = minor;</span><br><span class="line">	<span class="built_in">mutex_init</span>(&amp;device-&gt;context.context_mgr_node_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 将创建的binder_device保存在inode中</span></span><br><span class="line">	inode-&gt;i_private = device;</span><br><span class="line">	<span class="built_in">d_instantiate</span>(dentry, inode);</span><br><span class="line">	<span class="built_in">fsnotify_create</span>(root-&gt;d_inode, dentry);</span><br><span class="line">	<span class="built_in">inode_unlock</span>(<span class="built_in">d_inode</span>(root));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建binder_device的步骤分为:</p>
<ol>
<li>给binder_device分配内核内存空间</li>
<li>根据超级块创建一个新的inode节点</li>
<li>加载文件操作集－binder_fops 至inode中</li>
<li>初始化binder_device的相关设置</li>
<li>将创建的binder_device保存在inode中</li>
</ol>
<p>最重要的是关注步骤3,这里我们还要看看binder_fops的文件操作集具体指向的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android/kernel/msm-4.19/drivers/android/binder.c</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> binder_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哦偶, 终于看到ioctl了，这里先解释下文件操作集的含义及作用:</p>
<blockquote>
<p>Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用。<br>用户进程利用在对设备文件进行诸如read&#x2F;write操作的时候，系统调用通过设备文件的主设备号找到相应的设备<br>驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。</p>
</blockquote>
<p>其实驱动程序可以理解为一个被动服务，当有上层调用时，才会进入，内核调用的具体实现后续分析。</p>
<p>比如我们在应用进程中调用ioctl，通过syscall进入内核态，但此时进程上下文还是该应用进程的上下文，对应进程状态为S状态。</p>
<p>所以我们在上一篇文章中 ##1.6 IPCThreadState#talkWithDriver 里面调用ioctl最后是调用了binder_ioctl这个函数！</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>module_init解析及内核initcall的初始化顺序 <a href="https://www.cnblogs.com/chaozhu/p/6410271.html">https://www.cnblogs.com/chaozhu/p/6410271.html</a></li>
<li>各种initcall的执行先后顺序 <a href="https://blog.csdn.net/fenzhikeji/article/details/6860143">https://blog.csdn.net/fenzhikeji/article/details/6860143</a></li>
<li>binder 驱动的操作 <a href="https://blog.csdn.net/qq_15893929/article/details/103965668">https://blog.csdn.net/qq_15893929/article/details/103965668</a></li>
<li>Android的IPC机制Binder的各个部分 <a href="http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml">http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml</a></li>
<li>字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 <a href="https://blog.csdn.net/weixin_42314225/article/details/81112217">https://blog.csdn.net/weixin_42314225/article/details/81112217</a></li>
<li>linux文件系统 - 初始化(一) <a href="https://www.cnblogs.com/alantu2018/p/8447303.html">https://www.cnblogs.com/alantu2018/p/8447303.html</a></li>
<li>mount过程分析之五(mount_bdev-&gt;fill_super) <a href="https://blog.csdn.net/ZR_Lang/article/details/40115013">https://blog.csdn.net/ZR_Lang/article/details/40115013</a></li>
<li>VFS四大对象之一 struct super_block <a href="https://www.cnblogs.com/linhaostudy/p/7427027.html">https://www.cnblogs.com/linhaostudy/p/7427027.html</a></li>
<li>Linux字符设备驱动file_operations <a href="https://www.cnblogs.com/chen-farsight/p/6181341.html">https://www.cnblogs.com/chen-farsight/p/6181341.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Binder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder(5)--binder驱动响应ioctl</title>
    <url>/2022/04/04/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，我们现在了解了binder驱动的加载过程，回过头继续分析App使用Binder通信的过程。</p>
<p>先回顾下App使用binder通信的大致过程：</p>
<ol>
<li>创建AIDL文件，定义接口函数并在服务端app中实现,并注册进SystemServer</li>
<li>客户端app通过SystemServer获取服务端注册的Service所代表的IBinder(BpBinder)<ol>
<li>Client app &lt;–&gt; SystemServer &lt;–&gt; Server app</li>
<li>Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。</li>
</ol>
</li>
<li>客户端app通过该IBinder与服务端app直接通信。</li>
</ol>
<p>之前我们分析到最后一步是：IPCThreadState#talkWithDriver</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Finished read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面我们也了解了ioctl的用法，简单回顾下:</p>
<blockquote>
<p>int ioctl(int fd, unsigned long request, …);</p>
</blockquote>
<ol>
<li>fd 必须是打开文件描述符。</li>
<li>cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作</li>
<li>argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。</li>
</ol>
<p>这里我们还不知道此处的ioctl是怎么和binder驱动勾搭上的，是因为我们之前分析客户端app使用ioctl的时候忽略了IPCThreadState的初始化。</p>
<p>传入的参数mProcess-&gt;mDriverFD这个文件描述符是怎么获取的呢，接下来先看IPCThreadState的初始化。</p>
<h1 id="一-IPCThreadState的初始化"><a href="#一-IPCThreadState的初始化" class="headerlink" title="一. IPCThreadState的初始化"></a>一. IPCThreadState的初始化</h1><p>我们在调用transact的时候，会先调用self()函数，这个函数就是初始化用的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br></pre></td></tr></table></figure>

<h2 id="1-1-IPCThreadState-self"><a href="#1-1-IPCThreadState-self" class="headerlink" title="1.1 IPCThreadState::self"></a>1.1 IPCThreadState::self</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">gHaveTLS</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> gTLS = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; gShutdown = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; gDisableBackgroundScheduling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// gHaveTLS为true说明之前已经初始化过</span></span><br><span class="line">    <span class="comment">// 或者说pthread_key_create有被调用过，及本线程私有数据内存空间已开辟</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">        <span class="comment">// 取得本线程对应关键字gTLS所关联的私有数据空间首址</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="comment">// 如果不为null,直接返回, 当然如果是第一次进入肯定为null的。</span></span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">// 1.2 实例化IPCThreadState</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处于shutdown时直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (gShutdown.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// 创建关键字gTLS及其对应的内存释放函数threadDestructor</span></span><br><span class="line">        <span class="comment">// 关键字关联线程私有数据空间首址，初始化时是NULL</span></span><br><span class="line">        <span class="type">int</span> key_create_value = <span class="built_in">pthread_key_create</span>(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;</span>,</span><br><span class="line">                    <span class="built_in">strerror</span>(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表明线程私有数据内存空间已开辟</span></span><br><span class="line">        gHaveTLS.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="comment">// 回到restart中准备实例化IPCThreadState</span></span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Linux 中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone() 。<br>该系统copy 了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。<br>copy 后的进程和原先的进程共享了所有的变量，运行环境（clone的实现是可以指定新进程与老进程之间的共享关系，100%共享就表示创建了一个线程）。<br>这样，原先进程中的变量变动在copy 后的进程中便能体现出来。</p>
</blockquote>
<h2 id="1-2-IPCThreadState实例化"><a href="#1-2-IPCThreadState实例化" class="headerlink" title="1.2 IPCThreadState实例化"></a>1.2 IPCThreadState实例化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">    <span class="comment">// 1.2.1 创建ProcessState</span></span><br><span class="line">    : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),</span><br><span class="line">      <span class="built_in">mServingStackPointer</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">mWorkSource</span>(kUnsetWorkSource),</span><br><span class="line">      <span class="built_in">mPropagateWorkSource</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mStrictModePolicy</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLastTransactionBinderFlags</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mCallRestriction</span>(mProcess-&gt;mCallRestriction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自身存入关键字gTLS对应的线程私有数据空间中，缓存以备后续使用</span></span><br><span class="line">    <span class="built_in">pthread_setspecific</span>(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">clearCaller</span>();</span><br><span class="line">    mIn.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">    mOut.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-３-ProcessState-self"><a href="#1-３-ProcessState-self" class="headerlink" title="1.３ ProcessState::self"></a>1.３ ProcessState::self</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ANDROID_VNDK__</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* kDefaultDriver = <span class="string">&quot;/dev/vndbinder&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* kDefaultDriver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里假定kDefaultDriver为&quot;/dev/binder&quot;</span></span><br><span class="line">    gProcess = <span class="keyword">new</span> <span class="built_in">ProcessState</span>(kDefaultDriver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-４-ProcessState实例化"><a href="#1-４-ProcessState实例化" class="headerlink" title="1.４ ProcessState实例化"></a>1.４ ProcessState实例化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    <span class="comment">// 1.5 打开binder驱动，获取其文件描述符</span></span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))</span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mCallRestriction</span>(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-open-driver-打开binder驱动"><a href="#1-5-open-driver-打开binder驱动" class="headerlink" title="1.5 open_driver - 打开binder驱动"></a>1.5 open_driver - 打开binder驱动</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.5.1 打开/dev/binder驱动</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.5.2 ioctl通信!!!</span></span><br><span class="line">        <span class="type">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// #define DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line">        <span class="comment">// 默认最大binder线程数目是15个</span></span><br><span class="line">        <span class="type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">// 1.5.2 ioctl通信，设置当前进程的最大binder线程数为15</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先使用open函数打开对应目录的驱动文件，成功打开后调用ioctl函数获取Binder版本，最后还是通过ioctl设置最大binder线程。</p>
<p>我们常听闻在Linux中，一切皆文件，这里就体现出来了。回顾下binder驱动注册进文件系统时的操作函数集:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android/kernel/msm-4.19/drivers/android/binder.c</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> binder_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll,</span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-open函数-binder-open"><a href="#1-5-1-open函数-binder-open" class="headerlink" title="1.5.1 open函数-binder_open"></a>1.5.1 open函数-binder_open</h3><p>在app进程中通过open函数打开&#x2F;dev&#x2F;binder文件，就会调用到binder.c中的binder_open函数了。</p>
<p>我们来看看这个open的时候驱动里面具体做了什么吧，至于用户进程中调用open进而使用系统调用进入内核态调用到binder_open的方式我们后续分析。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// binder_proc代表一个进程</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_device</span> *binder_dev;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">dentry</span> *binder_binderfs_dir_entry_proc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">binder_debug</span>(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;%s: %d:%d\n&quot;</span>, __func__,</span><br><span class="line">		     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    <span class="comment">// 给binder_proc分配内核内存</span></span><br><span class="line">	proc = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">// 初始化自旋锁lock,其实是将自旋锁指针lock 指向SPIN_LOCK_UNLOCKED宏</span></span><br><span class="line">    <span class="comment">// 该宏的定义在内核文件spinlock_types.h中，它表示自旋锁的状态为未加锁</span></span><br><span class="line">	<span class="built_in">spin_lock_init</span>(&amp;proc-&gt;inner_lock);</span><br><span class="line">	<span class="built_in">spin_lock_init</span>(&amp;proc-&gt;outer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current是一个内核宏，它是当前进程的指针</span></span><br><span class="line">    <span class="comment">// get_task_struct的最终实现是将传入的task_struct的usage加1:</span></span><br><span class="line">    <span class="comment">//  #define get_task_struct(tsk) do &#123; atomic_inc(&amp;(tsk)-&gt;usage); &#125; while(0)</span></span><br><span class="line">    <span class="comment">// 这个宏的作用是标记传入的task_struct，当期有人在用。</span></span><br><span class="line">    <span class="comment">// usage的数量代表正在使用该task_struct的程序数量。</span></span><br><span class="line">	<span class="built_in">get_task_struct</span>(current-&gt;group_leader);</span><br><span class="line">    <span class="comment">// 将binder_proc的tsk标记为当前进程的主进程</span></span><br><span class="line">	proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    <span class="comment">// 加上互斥锁</span></span><br><span class="line">	<span class="built_in">mutex_init</span>(&amp;proc-&gt;files_lock);</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;todo);</span><br><span class="line">    <span class="comment">// 确定进程调度策略</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">binder_supported_policy</span>(current-&gt;policy)) &#123;</span><br><span class="line">		proc-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">		proc-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		proc-&gt;default_priority.sched_policy = SCHED_NORMAL;</span><br><span class="line">		proc-&gt;default_priority.prio = <span class="built_in">NICE_TO_PRIO</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断nodp是否是binder_device:</span></span><br><span class="line">    <span class="comment">//  inode-&gt;i_sb-&gt;s_magic == BINDERFS_SUPER_MAGIC</span></span><br><span class="line">    <span class="comment">// s_magic是在binderfs_fill_super也就是binder驱动挂载时赋值的</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">is_binderfs_device</span>(nodp)) &#123;</span><br><span class="line">        <span class="comment">// 如果是binder_device:</span></span><br><span class="line">        <span class="comment">// 回忆下上一篇文章3.4 binderfs.c#binderfs_binder_device_create</span></span><br><span class="line">        <span class="comment">// 我们将创建的binder_device存入了i_private数据中</span></span><br><span class="line">		binder_dev = nodp-&gt;i_private;</span><br><span class="line">		info = nodp-&gt;i_sb-&gt;s_fs_info;</span><br><span class="line">		binder_binderfs_dir_entry_proc = info-&gt;proc_log_dir;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		binder_dev = <span class="built_in">container_of</span>(filp-&gt;private_data,</span><br><span class="line">					  <span class="keyword">struct</span> binder_device, miscdev);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 标记binder_device的引用计数+1</span></span><br><span class="line">	<span class="built_in">refcount_inc</span>(&amp;binder_dev-&gt;ref);</span><br><span class="line">    <span class="comment">// binder_proc的上下文</span></span><br><span class="line">	proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">	<span class="built_in">binder_alloc_init</span>(&amp;proc-&gt;alloc);</span><br><span class="line">    <span class="comment">// binder_stats中BINDER_STAT_PROC类型的创建数加+1</span></span><br><span class="line">	<span class="built_in">binder_stats_created</span>(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">// binder_proc的pid为当前进程的主进程的pid</span></span><br><span class="line">	proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;delivered_death);</span><br><span class="line">	<span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;waiting_threads);</span><br><span class="line">	filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mutex_lock</span>(&amp;binder_procs_lock);</span><br><span class="line">    <span class="comment">// 将当前binder_proc的proc_node加入binder_procs列表中</span></span><br><span class="line">    <span class="comment">// binder_procs是binder驱动中存储一系列binder_proc的链表</span></span><br><span class="line">    <span class="comment">// 关于binder_proc是如何插入链表中的，我们后续分析，涉及‘传说中’的红黑树操作</span></span><br><span class="line">    <span class="comment">// 注意当前虽然是在应用进程中，但此时已经进入内核态了。</span></span><br><span class="line">	<span class="built_in">hlist_add_head</span>(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">	<span class="built_in">mutex_unlock</span>(&amp;binder_procs_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sys/kernel/debug/binder/proc目录存在时</span></span><br><span class="line">	<span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">		<span class="type">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">snprintf</span>(strbuf, <span class="built_in">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line">		<span class="comment">// proc调试条目是在上下文之间共享的</span></span><br><span class="line">        <span class="comment">// 创建当前binder_proc的目录，可以看到在sys/kernel/debug/binder/proc目录下有很多pid的目录</span></span><br><span class="line">		proc-&gt;debugfs_entry = <span class="built_in">debugfs_create_file</span>(strbuf, <span class="number">0444</span>,</span><br><span class="line">			binder_debugfs_dir_entry_proc,</span><br><span class="line">			(<span class="type">void</span> *)(<span class="type">unsigned</span> <span class="type">long</span>)proc-&gt;pid,</span><br><span class="line">			&amp;proc_fops);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是binderfs_fill_super中创建的一个目录：/dev/binderfs/binder_logs/proc</span></span><br><span class="line">	<span class="keyword">if</span> (binder_binderfs_dir_entry_proc) &#123;</span><br><span class="line">		<span class="type">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">dentry</span> *binderfs_entry;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">snprintf</span>(strbuf, <span class="built_in">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line">		<span class="comment">// 与debugfs类似，进程特定的日志文件在上下文之间共享。</span></span><br><span class="line">        <span class="comment">// 如果已经为进程创建了文件，如果同一进程的另一个上下文调用binder_open（）</span></span><br><span class="line">        <span class="comment">// 则以下binderfs_create_file（）调用将失败，错误代码为EEXIST。</span></span><br><span class="line">        <span class="comment">// 因为与debugfs相同，日志文件将包含给定PID的所有上下文的信息。</span></span><br><span class="line">		binderfs_entry = <span class="built_in">binderfs_create_file</span>(binder_binderfs_dir_entry_proc,</span><br><span class="line">			strbuf, &amp;proc_fops, (<span class="type">void</span> *)(<span class="type">unsigned</span> <span class="type">long</span>)proc-&gt;pid);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(binderfs_entry)) &#123;</span><br><span class="line">			proc-&gt;binderfs_entry = binderfs_entry;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">			error = <span class="built_in">PTR_ERR</span>(binderfs_entry);</span><br><span class="line">			<span class="keyword">if</span> (error != -EEXIST) &#123;</span><br><span class="line">				<span class="built_in">pr_warn</span>(<span class="string">&quot;Unable to create file %s in binderfs (error %d)\n&quot;</span>,</span><br><span class="line">					strbuf, error);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder_open的函数做的事情也不复杂：</p>
<ol>
<li>创建binder_proc, 其pid为当前进程的主进程pid</li>
<li>标记binder_device的引用计数+1</li>
<li>将当前binder_proc的proc_node加入binder_procs列表中</li>
<li>创建当前binder_proc的目录，目录名为: sys&#x2F;kernel&#x2F;debug&#x2F;binder&#x2F;proc&#x2F;pid</li>
<li>&#x2F;dev&#x2F;binderfs&#x2F;binder_logs&#x2F;proc存在时，也在这个目录下创建对应pid目录</li>
</ol>
<p>顺便说一下很多Linux内核宏都用 do { code; } while(0) 的形式,这个是确保code不会被打乱，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> demo do &#123; codeA; codeB; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (A) </span><br><span class="line"> demo; <span class="comment">//这里展开就不会因为宏内有多行代码而出现逻辑异常</span></span><br><span class="line">nextCodeLine;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-binder-ioctl-BINDER-VERSION-amp-BINDER-SET-CONTEXT-MGR-EXT"><a href="#1-5-2-binder-ioctl-BINDER-VERSION-amp-BINDER-SET-CONTEXT-MGR-EXT" class="headerlink" title="1.5.2 binder_ioctl - BINDER_VERSION &amp; BINDER_SET_CONTEXT_MGR_EXT"></a>1.5.2 binder_ioctl - BINDER_VERSION &amp; BINDER_SET_CONTEXT_MGR_EXT</h3><blockquote>
<p>status_t result &#x3D; ioctl(fd, BINDER_VERSION, &amp;vers);</p>
</blockquote>
<p>从参数名称可以看到，这里是获取binder版本号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_thread</span> *thread;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*pr_info(&quot;binder_ioctl: %d:%d %x %lx\n&quot;,</span></span><br><span class="line"><span class="comment">			proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配BUFFER_NUM buffers以覆盖所有页面对齐情况，然后以所有可能的顺序释放它们。</span></span><br><span class="line">    <span class="comment">// 检查页面是否正确分配，在释放缓冲区时放在lru上，在调用binder_alloc_free_page时释放。</span></span><br><span class="line">	<span class="built_in">binder_selftest_alloc</span>(&amp;proc-&gt;alloc);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">trace_binder_ioctl</span>(cmd, arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_stop_on_user_error是一个int变量，当出现binder_stop_on_user_error错误</span></span><br><span class="line">    <span class="comment">// 时为2, 这里的意思是只要这个不为2,使得cpu不休眠。</span></span><br><span class="line">	ret = <span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据binder_proc获取binder_thread, 后续分析</span></span><br><span class="line">	thread = <span class="built_in">binder_get_thread</span>(proc);</span><br><span class="line">	<span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> fbo;</span><br><span class="line">        <span class="comment">// 从用户空间拷贝ubuf内容至fbo中，其实就是15，单个进程的最大binder线程数</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;fbo, ubuf, <span class="built_in">sizeof</span>(fbo))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 设置单个进程的最大binder数目，默认是15个(app进程)</span></span><br><span class="line">		ret = <span class="built_in">binder_ioctl_set_ctx_mgr</span>(filp, &amp;fbo);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">binder_version</span> __user *ver = ubuf;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 从内核空间获取BINDER_CURRENT_PROTOCOL_VERSION拷贝到用户空间</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">put_user</span>(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">			     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy_from_user函数的目的是从用户空间拷贝数据到内核空间，<strong>失败返回没有被拷贝的字节数，成功返回0</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy_from_user(void *to, const void __user *from, unsigned long n)</span><br><span class="line">1. *to         将数据拷贝到内核的地址</span><br><span class="line">2. *from       需要拷贝数据的地址</span><br><span class="line">3. n           拷贝数据的长度（字节）</span><br><span class="line"></span><br><span class="line">也就是将from地址中的数据拷贝到to地址中去，拷贝长度是n</span><br></pre></td></tr></table></figure>

<h1 id="二-ioctl-BINDER-WRITE-READ"><a href="#二-ioctl-BINDER-WRITE-READ" class="headerlink" title="二. ioctl - BINDER_WRITE_READ"></a>二. ioctl - BINDER_WRITE_READ</h1><p>现在万事具备了，我们继续分析进程间的ioctl通信传输数据, 回到最开始：IPCThreadState#talkWithDriver</p>
<p>其实我们在open_driver - 打开binder驱动的过程中就有分析看到ioctl了。</p>
<p>从代码的角度理解为什么说binder跨进程通信只需要一次内存拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">    err = NO_ERROR;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-binder-ioctl-BINDER-WRITE-READ"><a href="#2-1-binder-ioctl-BINDER-WRITE-READ" class="headerlink" title="2.1 binder_ioctl - BINDER_WRITE_READ"></a>2.1 binder_ioctl - BINDER_WRITE_READ</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        <span class="comment">// thread是根据binder_proc获取的binder_thread</span></span><br><span class="line">        <span class="comment">// 这里的arg就是上面的ioctl的最后一个参数bwr的地址</span></span><br><span class="line">		ret = <span class="built_in">binder_ioctl_write_read</span>(filp, cmd, arg, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">if</span> (thread)</span><br><span class="line">		thread-&gt;looper_need_return = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line">		<span class="built_in">pr_info</span>(<span class="string">&quot;%d:%d ioctl %x %lx returned %d\n&quot;</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">	<span class="built_in">trace_binder_ioctl_done</span>(ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-binder-c-binder-ioctl-write-read"><a href="#2-2-binder-c-binder-ioctl-write-read" class="headerlink" title="2.2 binder.c:binder_ioctl_write_read"></a>2.2 binder.c:binder_ioctl_write_read</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="keyword">struct</span> binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">	<span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从用户空间拷贝ubuf内容至bwr中, 一次拷贝：从用户空间到内核空间</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">		     <span class="string">&quot;%d:%d write %lld at %016llx, read %lld at %016llx\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">		     (u64)bwr.write_size, (u64)bwr.write_buffer,</span><br><span class="line">		     (u64)bwr.read_size, (u64)bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还记得么，这个bwr是在IPCThreadState#talkWithDriver中填充的数据</span></span><br><span class="line">    <span class="comment">// write_size 代表 binder in parcel数据大小</span></span><br><span class="line">    <span class="comment">// read_size 代表 binder out parcel数据大小</span></span><br><span class="line">	<span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理用户进程传来的数据</span></span><br><span class="line">		ret = <span class="built_in">binder_thread_write</span>(proc, thread,</span><br><span class="line">					  bwr.write_buffer,</span><br><span class="line">					  bwr.write_size,</span><br><span class="line">					  &amp;bwr.write_consumed);</span><br><span class="line">		<span class="built_in">trace_binder_write_done</span>(ret);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理需要回传的数据</span></span><br><span class="line">		ret = <span class="built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer,</span><br><span class="line">					 bwr.read_size,</span><br><span class="line">					 &amp;bwr.read_consumed,</span><br><span class="line">					 filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">		<span class="built_in">trace_binder_read_done</span>(ret);</span><br><span class="line">		<span class="built_in">binder_inner_proc_lock</span>(proc);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))</span><br><span class="line">			<span class="built_in">binder_wakeup_proc_ilocked</span>(proc);</span><br><span class="line">		<span class="built_in">binder_inner_proc_unlock</span>(proc);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">		     <span class="string">&quot;%d:%d wrote %lld of %lld, read return %lld of %lld\n&quot;</span>,</span><br><span class="line">		     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">		     (u64)bwr.write_consumed, (u64)bwr.write_size,</span><br><span class="line">		     (u64)bwr.read_consumed, (u64)bwr.read_size);</span><br><span class="line">    <span class="comment">// 将从内核空间拷贝bwr内容至ubuf中, 一次拷贝：从内核空间到用户空间</span></span><br><span class="line">    <span class="comment">// 但是这里是新的数据了，不算是内容的重复拷贝，如果说不需要回传数据，oneway的方式，这个拷贝也不是必要的</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">		ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy_from_user函数的目的是从内核空间拷贝数据到用户空间，失败返回没有被拷贝的字节数，成功返回0.</p>
<p>unsigned long copy_to_user(void *to, const void *from, unsigned long n)</p>
<ol>
<li>*to            目标地址（用户空间）</li>
<li>*from          源地址（内核空间）</li>
<li>n              将要拷贝数据的字节数</li>
</ol>
<p>返回：成功返回0，失败返回没有拷贝成功的数据字节数</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到用户进程IPCThreadState的初始化之后会将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。<br>这里就拿到了binder的fd, 保存在用户进程的mDriverFD中, 现在就可以愉快的通信了。</p>
<p>鉴于 binder_thread_write 和 binder_thread_read 函数都特别大，接下来单开两篇分开论述。</p>
<p>之前看 <strong>红茶一杯话Binder（传输机制篇_中）</strong> 有一张图特别清晰的展现了这里的流程，在此贴出:</p>
<p><img src="/images/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/5_1_%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="图片"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>module_init解析及内核initcall的初始化顺序 <a href="https://www.cnblogs.com/chaozhu/p/6410271.html">https://www.cnblogs.com/chaozhu/p/6410271.html</a></li>
<li>各种initcall的执行先后顺序 <a href="https://blog.csdn.net/fenzhikeji/article/details/6860143">https://blog.csdn.net/fenzhikeji/article/details/6860143</a></li>
<li>binder 驱动的操作 <a href="https://blog.csdn.net/qq_15893929/article/details/103965668">https://blog.csdn.net/qq_15893929/article/details/103965668</a></li>
<li>Android的IPC机制Binder的各个部分 <a href="http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml">http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml</a></li>
<li>字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 <a href="https://blog.csdn.net/weixin_42314225/article/details/81112217">https://blog.csdn.net/weixin_42314225/article/details/81112217</a></li>
<li>linux文件系统 - 初始化(一) <a href="https://www.cnblogs.com/alantu2018/p/8447303.html">https://www.cnblogs.com/alantu2018/p/8447303.html</a></li>
<li>mount过程分析之五(mount_bdev-&gt;fill_super) <a href="https://blog.csdn.net/ZR_Lang/article/details/40115013">https://blog.csdn.net/ZR_Lang/article/details/40115013</a></li>
<li>VFS四大对象之一 struct super_block <a href="https://www.cnblogs.com/linhaostudy/p/7427027.html">https://www.cnblogs.com/linhaostudy/p/7427027.html</a></li>
<li>Linux字符设备驱动file_operations <a href="https://www.cnblogs.com/chen-farsight/p/6181341.html">https://www.cnblogs.com/chen-farsight/p/6181341.html</a></li>
<li>一种linux线程私有数据技术 <a href="http://blog.163.com/william_djj@126/blog/static/3516650120085111193035/">http://blog.163.com/william_djj@126/blog/static/3516650120085111193035/</a></li>
<li>pthread_key_t和pthread_key_create()详解 <a href="https://www.cnblogs.com/klcf0220/p/5807148.html">https://www.cnblogs.com/klcf0220/p/5807148.html</a></li>
<li>腾讯面试题——谈一谈Binder的原理和实现一次拷贝的流程 <a href="https://blog.csdn.net/AndroidStudyDay/article/details/93749470">https://blog.csdn.net/AndroidStudyDay/article/details/93749470</a></li>
<li>红茶一杯话Binder（传输机制篇_中） <a href="https://my.oschina.net/youranhongcha/blog/152963">https://my.oschina.net/youranhongcha/blog/152963</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Binder</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title>Looper-Android中的消息机制</title>
    <url>/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文详细分析android的消息机制Looper的底层原理。</p>
<span id="more"></span>

<p><strong>以下分析基于Android S.</strong></p>
<p>初学Android的时候, 比较容易遇到如下错误:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E AndroidRuntime: FATAL EXCEPTION: 非UI线程</span><br><span class="line">E AndroidRuntime: Process: com.android.demo, PID: 23939</span><br><span class="line">E AndroidRuntime: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br><span class="line">E AndroidRuntime: 	at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:9587)</span><br><span class="line">E AndroidRuntime: 	at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1894)</span><br><span class="line">......</span><br><span class="line">E AndroidRuntime: 	at java.lang.Thread.run(Thread.java:923)</span><br></pre></td></tr></table></figure>

<p>往往是我们在非UI线程更新UI组件导致的。解决的方案也很简单，将更新组件的操作移入UI线程执行即可。此时就需要用到Android中非常基础又非常重要的Handler、Looper、Message这三个类:</p>
<figure class="highlight kt"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uiHandler = UiHandler(Looper.getMainLooper())</span><br><span class="line"><span class="keyword">val</span> message = uiHandler.obtainMessage(MSG_UPDATE_UI)</span><br><span class="line">message.obj = <span class="string">&quot;我在UI线程中更新UI组件哦!&quot;</span></span><br><span class="line">uiHandler.sendMessage(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> MSG_UPDATE_UI = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">UiHandler</span></span>(looper: Looper) : Handler(looper) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">        <span class="keyword">when</span> (msg.what) &#123;</span><br><span class="line">            MSG_UPDATE_UI -&gt; &#123;</span><br><span class="line">                textview.text = msg.obj <span class="keyword">as</span> String</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，设置Handler的Looper为MainLooper，然后通过sendMessage将封装数据的Message发送到MainLooper代表的UI线程中处理，就这样切换了线程。接下来我们研究下其中的原理，为什么Looper有main looper, Handler的sendMessage是怎么找到对应线程，然后调用handleMessage的。</p>
<p>或者通过Looper prepare的方式， 其实也是获取主线程的Looper实现的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Keep</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MSG_A</span> <span class="operator">=</span> <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MSG_B</span> <span class="operator">=</span> <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        handler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MSG_A: &#123; <span class="comment">/* .... */</span> &#125; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MSG_B: &#123; <span class="comment">/* .... */</span> &#125; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们在需要的时候执行: handler.sendMessage(handler.obtain(MSG_A)) 即可以实现线程交换了, 除了sendMessage，还有如下方式:</p>
<p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Handler.png" alt="Handler"></p>
<p>Android系统中大量使用Message来进行跨线程通信，实现交互，设计四个类：Message、Handler、Looper和MessageQueue, 类图如下:</p>
<p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Looper.png" alt="Looper类图"></p>
<ol>
<li>Message: 消息，封装待传递的数据</li>
<li>Handler: 消息辅助类，向消息池(MessageQueue)中存入消息和接收消息进行处理</li>
<li>Looper:  如其名，封装一个不断循环的函数体，不停的从消息池(MessageQueue)中取出合适的消息交给Handler处理</li>
<li>MessageQueue: 消息池，维护了一个由消息组成的链表，该链表按照消息执行的时间顺序排列</li>
</ol>
<p>我们首先看看UI线程的Looper获取：Looper.getMainLooper()</p>
<h1 id="一-Main-Looper的创建"><a href="#一-Main-Looper的创建" class="headerlink" title="一. Main Looper的创建"></a>一. Main Looper的创建</h1><h2 id="1-1-Looper-getMainLooper"><a href="#1-1-Looper-getMainLooper" class="headerlink" title="1.1 Looper.getMainLooper"></a>1.1 Looper.getMainLooper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title function_">getMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> sMainLooper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的就是Looper中静态变量sMainLooper。那么该sMainLooper是何时创建的呢：</p>
<h2 id="1-2-sMainLooper"><a href="#1-2-sMainLooper" class="headerlink" title="1.2 sMainLooper"></a>1.2 sMainLooper</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.2.1 Looper准备工作</span></span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.2.3 myLooper拿的就是当前线程的Looper.</span></span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sMainLooper是在Looper.prepareMainLooper被<strong>第一次调用</strong>时赋值的。而prepareMainLooper是在ActivityThread.main函数中调用的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1.3 执行loop</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Zygote启动进程时，进程的入口函数是ActivityThread.main，也就是说三方进程启动后第一时间就会调用Looper.prepareMainLooper()设置sMainLooper。</p>
<h3 id="1-2-1-Looper-prepare"><a href="#1-2-1-Looper-prepare" class="headerlink" title="1.2.1 Looper.prepare"></a>1.2.1 Looper.prepare</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quitAllowed 这个参数表明该Looper是否允许退出</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2.2 注意这里创建了一个Looper, 并保存在sThreadLocal中</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>quitAllowed 这个参数表明该Looper是否允许退出，自然UI线程(主线程)是不允许退出的，除非被kill或者进程自杀。</p>
<p>这里稍微提一下，sThreadLocal是ThreadLocal类型，实现了线程本地存储区(Thread Local Storage, 简称TLS)。每个线程都有自己私有的存储区域，不同线程之间彼此不能访问对方的TSL区域。简单来说，可以将这里的 <strong>sThreadLocal 视为一个Map集合，其中key为Thread, value是Looper</strong>, <strong>每次set和get都是获取当前线程对应的Looper</strong></p>
<h3 id="1-2-2-Looper-的创建"><a href="#1-2-2-Looper-的创建" class="headerlink" title="1.2.2 Looper 的创建"></a>1.2.2 Looper 的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="comment">// 3.1 MessageQueue创建</span></span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的创建了一个MessageQueue,并保存创建该Looper的线程。</p>
<h3 id="1-2-3-Looper-myLooper"><a href="#1-2-3-Looper-myLooper" class="headerlink" title="1.2.3 Looper.myLooper"></a>1.2.3 Looper.myLooper</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过sThreadLocal获取当前线程对应的Looper.</p>
<h2 id="1-3-Looper-loop"><a href="#1-3-Looper-loop" class="headerlink" title="1.3 Looper.loop"></a>1.3 Looper.loop</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的Looper</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="comment">// Looper一定存在某个线程中，线程不一定拥有Looper</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="comment">// 用于修改记录Looper中的Message是否执行慢或者超时的时长</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有message分发超时，这个变量就会被标记为true</span></span><br><span class="line">    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是Loop名称的由来，一直循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop()函数很简单，就一直循环执行loopOnce就可</p>
<h2 id="1-4-Looper-loopOnce"><a href="#1-4-Looper-loopOnce" class="headerlink" title="1.4 Looper.loopOnce"></a>1.4 Looper.loopOnce</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="comment">// 5.1 通过MessageQueue获取下一个Message, 这里稍后分析</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next();</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取的下一个Message为null，说明该Looper将要退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mLogging是Printer的对象，可以通过: looper.setMessageLogging(printer)设置</span></span><br><span class="line">    <span class="comment">// 用于打印Looper日志，如下：</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span></span><br><span class="line">                + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> sObserver;</span><br><span class="line">    <span class="comment">// traceTag用于抓取systrace，通过looper.setTraceTag设置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">    <span class="comment">// mSlowDispatchThresholdMs和mSlowDeliveryThresholdMs默认都是0</span></span><br><span class="line">    <span class="comment">// 可以通过setSlowLogThresholdMs设置</span></span><br><span class="line">    <span class="comment">// 比如SystemServer主线程的looper就被分别设置为100ms，200ms</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line">    <span class="type">long</span> <span class="variable">slowDeliveryThresholdMs</span> <span class="operator">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class="line">    <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// thresholdOverride可以通过属性修改:setprop log.looper.1000.main.slow 1</span></span><br><span class="line">        slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">        slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDelivery</span> <span class="operator">=</span> (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDispatch</span> <span class="operator">=</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needStartTime</span> <span class="operator">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needEndTime</span> <span class="operator">=</span> logSlowDispatch;</span><br><span class="line">    <span class="comment">// 开始抓取trace</span></span><br><span class="line">    <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录Message分发开始的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">        token = observer.messageDispatchStarting();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.4.1 分发message， 这里的target就是Handler</span></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.messageDispatched(token, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录消息分发结束时间</span></span><br><span class="line">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">            Trace.traceEnd(traceTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">        <span class="comment">// mSlowDeliveryDetected 表明之前就有消息等待分发超时了</span></span><br><span class="line">        <span class="keyword">if</span> (me.mSlowDeliveryDetected) &#123;</span><br><span class="line">            <span class="comment">// message分发时间和该message需要执行的时间相差不超过10ms，说明Message分发及时</span></span><br><span class="line">            <span class="comment">// 去掉之前标记的消息分发超时</span></span><br><span class="line">            <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就是检测Message等待分发是否超过阈值</span></span><br><span class="line">            <span class="comment">// 打印的日志如： Looper: Slow delivery took 233ms android.ui h=com.XXX c=null m=31</span></span><br><span class="line">            <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                    msg)) &#123;</span><br><span class="line">                <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                me.mSlowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消息分发是否超时</span></span><br><span class="line">    <span class="comment">// 打印的日志如： Looper: Slow dispatch took 233ms android.ui h=com.XXX c=null m=31</span></span><br><span class="line">    <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 回收该Message</span></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loopOnce函数看起来也很简单，一直从MessageQueue中获取Message并执行Handler.handleMessage函数。除非拿到的message是null时返回false，否则永远返回true。<br>注意弄清 delivery 和 dispatch 的区别：</p>
<ol>
<li>delivery: 消息被拿出准备分发的时间与消息期望被执行的时间差</li>
<li>dispatch: 消息处理的总时间，即handle.dispatchMessage的执行时长</li>
</ol>
<p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Delivery_Dispatch.png" alt="Delivery_Dispatch"></p>
<h3 id="1-4-1-Handler-dispatchMessage"><a href="#1-4-1-Handler-dispatchMessage" class="headerlink" title="1.4.1 Handler.dispatchMessage"></a>1.4.1 Handler.dispatchMessage</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行我们重载的函数了</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道在Handler.handleMessage这里已经转到Handler对应Looper所在的线程了。这样看起来，线程切换的奥秘都被隐藏在MessageQueue中了。</p>
<h1 id="二-Message"><a href="#二-Message" class="headerlink" title="二. Message"></a>二. Message</h1><p>在分析MessageQueue之前，简单看一下Message的设计。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>what</td>
<td>int</td>
<td>标明消息类别</td>
</tr>
<tr>
<td>arg1</td>
<td>int</td>
<td>参数1</td>
</tr>
<tr>
<td>arg2</td>
<td>int</td>
<td>参数2</td>
</tr>
<tr>
<td>obj</td>
<td>Object</td>
<td>消息内容</td>
</tr>
<tr>
<td>when</td>
<td>long</td>
<td>消息期望触发时间</td>
</tr>
<tr>
<td>data</td>
<td>Bundle</td>
<td>消息附带内容</td>
</tr>
<tr>
<td>target</td>
<td>Handler</td>
<td>消息触发执行的Handler</td>
</tr>
<tr>
<td>callback</td>
<td>Runnable</td>
<td>消息执行的Runnable</td>
</tr>
<tr>
<td>next</td>
<td>Message</td>
<td>下一个消息, 消息链表结构基础</td>
</tr>
</tbody></table>
<h2 id="2-1-消息链表结构"><a href="#2-1-消息链表结构" class="headerlink" title="2.1 消息链表结构"></a>2.1 消息链表结构</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sPoolSync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sPoolSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过维护一个大小为50的Message缓冲池，来缓解Message频繁创建销毁带来的资源损耗，所以在开发过程中尽可能选择使用obtain来创建Message。</p>
<h1 id="三-MessageQueue"><a href="#三-MessageQueue" class="headerlink" title="三. MessageQueue"></a>三. MessageQueue</h1><p>既然Message自己就维护了一个链表结构，还需要MessageQueue做什么呢？</p>
<h2 id="3-1-MessageQueue"><a href="#3-1-MessageQueue" class="headerlink" title="3.1 MessageQueue"></a>3.1 MessageQueue</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">// 3.2 通过JNI进入native实例化</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置mQuitAllowed, 主线程的Looper不允许退出(调用quit，主动退出)。然后通过JNI进入native层初始化</p>
<h2 id="3-2-android-os-MessageQueue-nativeInit"><a href="#3-2-android-os-MessageQueue-nativeInit" class="headerlink" title="3.2 android_os_MessageQueue_nativeInit"></a>3.2 android_os_MessageQueue_nativeInit</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> <span class="built_in">NativeMessageQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;Unable to allocate native queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">incStrong</span>(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是创建了一个NativeMessageQueue的对象。</p>
<h2 id="3-3-NativeMessageQueue"><a href="#3-3-NativeMessageQueue" class="headerlink" title="3.3 NativeMessageQueue"></a>3.3 NativeMessageQueue</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NativeMessageQueue::<span class="built_in">NativeMessageQueue</span>() :</span><br><span class="line">        <span class="built_in">mPollEnv</span>(<span class="literal">NULL</span>), <span class="built_in">mPollObj</span>(<span class="literal">NULL</span>), <span class="built_in">mExceptionObj</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意这里是native层的Loop了, 同样的也是通过TLS方式存储的</span></span><br><span class="line">    mLooper = Looper::<span class="built_in">getForThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.4 创建Looper</span></span><br><span class="line">        mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 保存在当前线程的TLS中</span></span><br><span class="line">        Looper::<span class="built_in">setForThread</span>(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-Looper-cpp"><a href="#3-4-Looper-cpp" class="headerlink" title="3.4 Looper.cpp"></a>3.4 Looper.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks)</span><br><span class="line">    : <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks),</span><br><span class="line">      <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mPolling</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mEpollRebuildRequired</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mNextRequestSeq</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mResponseIndex</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    <span class="comment">// eventfd函数会创建一个eventfd, 这里保存在mWakeEventFd中</span></span><br><span class="line">    <span class="comment">// EFD_NONBLOCK: 设置FD对象为非阻塞状态</span></span><br><span class="line">    <span class="comment">// EFD_CLOEXEC: 调用exec后会自动关闭文件描述符，防止泄漏</span></span><br><span class="line">    mWakeEventFd.<span class="built_in">reset</span>(<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd.<span class="built_in">get</span>() &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">// 3.4.1 重建epoll</span></span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>eventfd 是 Linux 的一个系统调用，创建一个文件描述符用于事件通知，自 Linux 2.6.22 以后开始支持。该函数会创建一个 eventfd 对象，用户空间的应用程序可以用这个 eventfd 来实现事件的等待或通知机制，也可以用于内核通知新的事件到用户空间应用程序。</p>
</blockquote>
<p>看来初始化该Looper的线程是通过这个eventfd来实现被唤醒的。</p>
<h3 id="3-4-1-Looper-cpp-rebuildEpollLocked"><a href="#3-4-1-Looper-cpp-rebuildEpollLocked" class="headerlink" title="3.4.1 Looper.cpp:rebuildEpollLocked"></a>3.4.1 Looper.cpp:rebuildEpollLocked</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果原有fd存在，则关闭</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mEpollFd.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的epoll实例, 并获取该实例的fd标记</span></span><br><span class="line">    mEpollFd.<span class="built_in">reset</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event));</span><br><span class="line">    <span class="comment">// EPOLLIN 表明fd文件可读</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 在epoll实例上注册mWakeEventFd文件描述符，并将EPOLL_CTL_ADD事件关联到mWakeEventFd</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class="built_in">get</span>(), &amp;eventItem);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not add wake event fd to epoll instance: %s&quot;</span>,</span><br><span class="line">                        <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对所有mRequests的fd进行重定向, 均关联到新创建的epoll实例上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> Request&amp; request = mRequests.<span class="built_in">valueAt</span>(i);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">        request.<span class="built_in">initEventItem</span>(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epollResult = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Error adding epoll events for fd %d while rebuilding epoll set: %s&quot;</span>,</span><br><span class="line">                  request.fd, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是创建了一个epoll实例，并将该Looper的mWakeEventFd（即eventfd）关联到该epoll实例上。如果该Looper的mRequests存在Request时，也对所有mRequests的fd进行重定向, 均关联到新创建的epoll实例上。</p>
<p>所以MessageQueue的初始化就是在Native层创建了一个NativeMessageQueue的对象，该对象持有一个Native层的Looper对象。而Native层的Looper里有两个文件描述符: </p>
<ol>
<li>通过eventfd创建的mWakeEventFd; </li>
<li>通过epoll_create1创建的代表epoll实例的mEpollFd。</li>
</ol>
<h1 id="四-sendMessageAtTime发送消息"><a href="#四-sendMessageAtTime发送消息" class="headerlink" title="四. sendMessageAtTime发送消息"></a>四. sendMessageAtTime发送消息</h1><p>现在回到Handler发送消息，假设Handler中的Looper是MainLooper, 现在是在非UI线程，比如bg线程读取网络数据后更新到UI组件上：uiHandler.sendMessageAtTime </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 将Message的target设置为自己</span></span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mAsynchronous表明是否异步执行</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交给Handler的MessageQueue执行</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1-MessageQueue-enqueueMessage"><a href="#4-1-MessageQueue-enqueueMessage" class="headerlink" title="4.1 MessageQueue.enqueueMessage"></a>4.1 MessageQueue.enqueueMessage</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 标记该Message正在使用, 避免缓冲池重复使用该Message</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="comment">// 记录该Message期望执行的时间</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">// mMessages是一个Message对象，代表该MessageQueue队列的头节点</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 如果头节点是空的、传入的Message执行时间是0（立刻执行）</span></span><br><span class="line">            <span class="comment">// 或者执行时间在头节点消息执行之前，将该Message作为链表新的头节点</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            <span class="comment">// mBlocked为false代表Handler所在线程已经拿到合适的Message执行了</span></span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将Message插入到链表头节点之后</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 找到该Message的位置，即其执行时间在链表中的顺序排列位置</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否需要唤醒, 唤醒什么，当然是Handler的Looper对应线程了！</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            <span class="comment">// 进入JNI, 通过epoll唤醒线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以Handler.sendMessage仅仅是将Message插入MessageQueue中Message链表的合适位置，即保持mMessages链表中的Message期望执行时间从小到大排列，等待执行。</p>
<h2 id="4-2-android-os-MessageQueue-nativeWake"><a href="#4-2-android-os-MessageQueue-nativeWake" class="headerlink" title="4.2 android_os_MessageQueue_nativeWake"></a>4.2 android_os_MessageQueue_nativeWake</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转到native层的loop执行。</p>
<h2 id="4-3-Looper-cpp-wake"><a href="#4-3-Looper-cpp-wake" class="headerlink" title="4.3 Looper.cpp:wake"></a>4.3 Looper.cpp:wake</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通过write向该Looper的mWakeEventFd中写入1</span></span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;</span>,</span><br><span class="line">                             mWakeEventFd.<span class="built_in">get</span>(), nWrite, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，bg线程中uiHandler发送Message的流程就结束了。</p>
<h1 id="五-UI线程处理Message"><a href="#五-UI线程处理Message" class="headerlink" title="五. UI线程处理Message"></a>五. UI线程处理Message</h1><p>那么此时我们UI线程在做什么呢? 对了，就是一直在循环执行 Looper中的 loopOnce 函数！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="comment">// 5.1 通过MessageQueue获取下一个Message</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-MessageQueue-next"><a href="#5-1-MessageQueue-next" class="headerlink" title="5.1 MessageQueue.next"></a>5.1 MessageQueue.next</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 5.2 转到Native中执行，获取下一次poll的时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接转到native层执行pollOnce.</p>
<h2 id="5-2-android-os-MessageQueue-nativePollOnce"><a href="#5-2-android-os-MessageQueue-nativePollOnce" class="headerlink" title="5.2 android_os_MessageQueue_nativePollOnce"></a>5.2 android_os_MessageQueue_nativePollOnce</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">pollOnce</span>(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    <span class="comment">// 还是用到Native层的Looper</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">pollOnce</span>(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">Throw</span>(mExceptionObj);</span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-Looper-cpp-pollOnce"><a href="#5-3-Looper-cpp-pollOnce" class="headerlink" title="5.3 Looper.cpp:pollOnce"></a>5.3 Looper.cpp:pollOnce</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pollOnce</span>(timeoutMillis, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 当前mResponses还是空的，mResponseIndex为0</span></span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> Response&amp; response = mResponses.<span class="built_in">itemAt</span>(mResponseIndex++);</span><br><span class="line">            <span class="type">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="type">int</span> events = response.events;</span><br><span class="line">                <span class="type">void</span>* data = response.request.data;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = fd;</span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = events;</span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = data;</span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// result为0, 表明poll超时</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先执行这里</span></span><br><span class="line">        result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-Looper-cpp-pollInner"><a href="#5-4-Looper-cpp-pollInner" class="headerlink" title="5.4 Looper.cpp:pollInner"></a>5.4 Looper.cpp:pollInner</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="type">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.<span class="built_in">clear</span>();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标记正在poll</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EPOLL_MAX_EVENTS默认是16</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="comment">// 通过epoll_wait监听mEpollFd文件描述符等待被唤醒, 注意这里timeoutMillis是0</span></span><br><span class="line">    <span class="comment">// 也就是说当mEpollFd没有事件时，立刻返回超时 0</span></span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.<span class="built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// poll超时，在执行一次Looper.pollOnce的循环</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll中存在事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="comment">// 当epoll中事件描述符是当前Looper的mWakeEventFd时, 说明有线程通过write向该fd写入值</span></span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">// 5.5 执行被唤醒后的处理</span></span><br><span class="line">                <span class="built_in">awoken</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>
</blockquote>
<p>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误。</p>
<ol>
<li>epfd是 epoll的描述符。</li>
<li>events则是分配好的 epoll_event结构体数组，epoll将会把发生的事件复制到 events数组中</li>
<li>maxevents表示本次可以返回的最大事件数目，通常 maxevents参数与预分配的events数组的大小是相等的。</li>
<li>timeout表示在没有检测到事件发生时最多等待的时间（单位为毫秒），如果 timeout为0，则表示 epoll_wait在 rdllist链表中为空，立刻返回，不会等待。</li>
</ol>
<h2 id="5-5-Looper-cpp-awoken"><a href="#5-5-Looper-cpp-awoken" class="headerlink" title="5.5 Looper.cpp:awoken"></a>5.5 Looper.cpp:awoken</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::awoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> counter;</span><br><span class="line">    <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">read</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;counter, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取mWakeEventFd中的值，也就是之前bg线程通过write写入的1. 然后回到Looper.cpp:pollOnce返回1.</p>
<p>这样UI线程就从epoll_wait阻塞状态(或者一直执行Looper.cpp:pollOnce函数的状态)退出，之后回到java层的MessageQueue.next中继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 5.2 转到Native中执行，获取下一次poll的时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录当前系统时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 尝试找到抵达执行时间的Message</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 如果头节点Message的执行时间尚未到来，那么下一次epoll_wait的等待时间就是</span></span><br><span class="line">                    <span class="comment">// 该message执行时间和当前时间的差值</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 找到可执行的Message了</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 头节点标记为下一个</span></span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="comment">// 打破循环，返回该Message，回到Looper.loopOnce中</span></span><br><span class="line">                    <span class="comment">// 即执行 [1.4.1] Handler.dispatchMessage</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自此，Android的线程切换就结束了。</p>
<h1 id="六-小结"><a href="#六-小结" class="headerlink" title="六. 小结"></a>六. 小结</h1><p>通过上述分析，画一张图来展示一次Message的执行:</p>
<p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/MessageHandle.png" alt="Message Handle"></p>
<div style="page-break-after: always;"></div>


<h2 id="6-1-Epoll机制"><a href="#6-1-Epoll机制" class="headerlink" title="6.1 Epoll机制"></a>6.1 Epoll机制</h2><p>关于Eopll推荐大家阅读这篇文: <a href="https://zhuanlan.zhihu.com/p/63179839">Epoll本质</a> <a href="https://zhuanlan.zhihu.com/p/63179839">https://zhuanlan.zhihu.com/p/63179839</a></p>
<ol>
<li>cpu running</li>
</ol>
<img src="/images/Looper-Android中的消息机制/epoll_1.jpg" width="500">

<ol>
<li>Ui Thread: epoll_wait</li>
</ol>
<img src="/images/Looper-Android中的消息机制/epoll_2.jpg" width="500">

<ol start="3">
<li>Bg Thread: write fd</li>
</ol>
<img src="/images/Looper-Android中的消息机制/epoll_3.jpg" width="500">

<ol start="4">
<li>Ui Thread: read</li>
</ol>
<img src="/images/Looper-Android中的消息机制/epoll_4.jpg" width="500">]]></content>
      <categories>
        <category>Android</category>
        <category>Looper</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Looper</tag>
      </tags>
  </entry>
  <entry>
    <title>SurfaceFlinger(1)--SFEventThread</title>
    <url>/2022/04/04/SurfaceFlinger-1-SFEventThread/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<h1 id="一-SFEventThread"><a href="#一-SFEventThread" class="headerlink" title="一. SFEventThread"></a>一. SFEventThread</h1><ol>
<li>EventControlThread: 控制硬件vsync的开关</li>
<li>DispSyncThread: 软件产生vsync的线程</li>
<li>SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染</li>
<li>App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图</li>
</ol>
<p>从这4个线程，可以将vsync分为4种不同的类型</p>
<ol>
<li>HW vsync, 真实由硬件产生的vsync信号</li>
<li>SW vsync, 由DispSync产生的vsync信号</li>
<li>SF vsync,  SF接收到的vsync信号</li>
<li>App vsync, App接收到的vsync信号</li>
</ol>
<p>这里我们着重看看SF EventThread.</p>
<span id="more"></span>

<h2 id="1-1-BitTube"><a href="#1-1-BitTube" class="headerlink" title="1.1 BitTube"></a>1.1 BitTube</h2><p>先大致了解下BitTube，其实现是socketpairt套接字，用于传递消息。<br>Buffer大小是4KB。</p>
<h1 id="二-EventThread启动"><a href="#二-EventThread启动" class="headerlink" title="二. EventThread启动"></a>二. EventThread启动</h1><h2 id="2-1-SurfaceFlinger-init"><a href="#2-1-SurfaceFlinger-init" class="headerlink" title="2.1 SurfaceFlinger.init"></a>2.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    mEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,</span><br><span class="line">                                             <span class="literal">true</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">    mEventThread = std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                       [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                       impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>(),</span><br><span class="line">                                                       <span class="string">&quot;appEventThread&quot;</span>);</span><br><span class="line">    mSfEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,</span><br><span class="line">                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;sf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSFEventThread =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mSfEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                    mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                <span class="string">&quot;sfEventThread&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意传入的偏移是不同的。</p>
<ol>
<li>app EventThread : vsyncPhaseOffsetNs &#x3D; 2000000ns</li>
<li>sf EventThread : sfVsyncPhaseOffsetNs &#x3D; 6000000ns</li>
</ol>
<p>这个值是编译期间固定的，定义在BoardConfig.mk中</p>
<h2 id="2-2-EventThread初始化"><a href="#2-2-EventThread初始化" class="headerlink" title="2.2 EventThread初始化"></a>2.2 EventThread初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EventThread::<span class="built_in">EventThread</span>(VSyncSource* src, ResyncWithRateLimitCallback resyncWithRateLimitCallback,</span><br><span class="line">                         InterceptVSyncsCallback interceptVSyncsCallback, <span class="type">const</span> <span class="type">char</span>* threadName)</span><br><span class="line">      : <span class="built_in">mVSyncSource</span>(src),</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>(resyncWithRateLimitCallback),</span><br><span class="line">        <span class="built_in">mInterceptVSyncsCallback</span>(interceptVSyncsCallback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; event : mVSyncEvent) &#123;</span><br><span class="line">        event.header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        event.header.id = <span class="number">0</span>;</span><br><span class="line">        event.header.timestamp = <span class="number">0</span>;</span><br><span class="line">        event.vsync.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定thread函数</span></span><br><span class="line">    mThread = std::<span class="built_in">thread</span>(&amp;EventThread::threadMain, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置thread名称</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), threadName);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> EVENT_THREAD_PRIORITY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = EVENT_THREAD_PRIORITY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_setschedparam</span>(mThread.<span class="built_in">native_handle</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for EventThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-EventThread-threadMain"><a href="#2-3-EventThread-threadMain" class="headerlink" title="2.3 EventThread.threadMain"></a>2.3 EventThread.threadMain</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (mKeepRunning) &#123;</span><br><span class="line">        DisplayEventReceiver::Event event;</span><br><span class="line">        Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">        <span class="comment">// 2.4 阻塞等待事件</span></span><br><span class="line">        signalConnections = <span class="built_in">waitForEventLocked</span>(&amp;lock, &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分发事件给connection</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> count = signalConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="function"><span class="type">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line">            <span class="comment">// 2.5 分发事件</span></span><br><span class="line">            <span class="type">status_t</span> err = conn-&gt;<span class="built_in">postEvent</span>(event);</span><br><span class="line">            <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">                <span class="comment">// The destination doesn&#x27;t accept events anymore, it&#x27;s probably</span></span><br><span class="line">                <span class="comment">// full. For now, we just drop the events on the floor.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> Note that some events cannot be dropped and would have</span></span><br><span class="line">                <span class="comment">// to be re-sent later.</span></span><br><span class="line">                <span class="comment">// Right-now we don&#x27;t have the ability to do this.</span></span><br><span class="line">                <span class="comment">//ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;, event.header.type,</span></span><br><span class="line">                <span class="comment">//      conn.get());</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// handle any other error on the pipe as fatal. the only</span></span><br><span class="line">                <span class="comment">// reasonable thing to do is to clean-up this connection.</span></span><br><span class="line">                <span class="comment">// The most common error we&#x27;ll get here is -EPIPE.</span></span><br><span class="line">                <span class="built_in">removeDisplayEventConnectionLocked</span>(signalConnections[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-EventThread-waitForEventLocked"><a href="#2-4-EventThread-waitForEventLocked" class="headerlink" title="2.4 EventThread.waitForEventLocked"></a>2.4 EventThread.waitForEventLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This will return when (1) a vsync event has been received, and (2) there was</span></span><br><span class="line"><span class="comment">// at least one connection interested in receiving it when we started waiting.</span></span><br><span class="line">Vector&lt;sp&lt;EventThread::Connection&gt; &gt; EventThread::<span class="built_in">waitForEventLocked</span>(</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt;* lock, DisplayEventReceiver::Event* event) &#123;</span><br><span class="line">    Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (signalConnections.<span class="built_in">isEmpty</span>() &amp;&amp; mKeepRunning) &#123;</span><br><span class="line">        <span class="type">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// 当timestamp不为0时，说明有事件发生</span></span><br><span class="line">                <span class="keyword">if</span> (mInterceptVSyncsCallback) &#123;</span><br><span class="line">                    <span class="built_in">mInterceptVSyncsCallback</span>(timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                <span class="comment">// 置timestamp为0，标记为当前事件被消费</span></span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mDisplayEventConnections保存的是注册的Connection的,</span></span><br><span class="line">        <span class="comment">// SF EventThread线程里只有一个Connection, 而这个Connection主要是用来渲染</span></span><br><span class="line">        <span class="comment">// 而如果是APP EventThread, 这里会有多个connection</span></span><br><span class="line">        <span class="type">size_t</span> count = mDisplayEventConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; count) &#123;</span><br><span class="line">            <span class="comment">// 没有vsync事件， 来看下是否有其它pending的event, 这里主要是hotplug的事件</span></span><br><span class="line">            eventPending = !mPendingEvents.<span class="built_in">isEmpty</span>();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;</span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];</span><br><span class="line">                mPendingEvents.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count;) &#123;</span><br><span class="line">            <span class="function">sp&lt;Connection&gt; <span class="title">connection</span><span class="params">(mDisplayEventConnections[i].promote())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// Connection-&gt;count的值大小含义如下：</span></span><br><span class="line">                <span class="comment">// 1. &gt;=1:  表示持续接收Vsync信号</span></span><br><span class="line">                <span class="comment">// 2. ==0:  只接收一次Vsync信号</span></span><br><span class="line">                <span class="comment">// 3. ==-1: 不接收Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果有 connection-&gt;count &gt;= 0，说明需要Vsync信号</span></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123; <span class="comment">// 大于0.说明有事件</span></span><br><span class="line">                        <span class="comment">// 处理本次事件</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                   (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don&#x27;t have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn&#x27;t promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.<span class="built_in">removeAt</span>(i);</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 收到Vsync信号，但是没有Connection监听，所以关闭Vsync</span></span><br><span class="line">            <span class="built_in">disableVSyncLocked</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 有Connection监听，但是还没有Vsync信号，所以打开Vsync</span></span><br><span class="line">            <span class="built_in">enableVSyncLocked</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有事件发生</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123; <span class="comment">// 如果有connection监听，则需要等待Vsync事件</span></span><br><span class="line">                <span class="comment">// 以防止硬件Driver出问题，设置一个超时时间16ms</span></span><br><span class="line">                <span class="type">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line">                <span class="keyword">auto</span> timeout = softwareSync ? <span class="number">16</span>ms : <span class="number">1000</span>ms;</span><br><span class="line">                <span class="keyword">if</span> (mCondition.<span class="built_in">wait_for</span>(*lock, timeout) == std::cv_status::timeout) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        <span class="built_in">ALOGW</span>(<span class="string">&quot;Timed out waiting for hw vsync; faking it&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有connection监听，也没有收到事件，则一直等待</span></span><br><span class="line">                mCondition.<span class="built_in">wait</span>(*lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we&#x27;re guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we&#x27;ll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当EventThread初始化进入时，由于没有Connection，timestamp也为0，直接进入waitForEventLocked一直等待。</p>
<h2 id="2-5-EventThread-Connection-postEvent"><a href="#2-5-EventThread-Connection-postEvent" class="headerlink" title="2.5 EventThread.Connection.postEvent"></a>2.5 EventThread.Connection.postEvent</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">postEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过BitTube发送事件。</p>
<h1 id="三-SF-EventThread-添加Connection"><a href="#三-SF-EventThread-添加Connection" class="headerlink" title="三. SF EventThread 添加Connection"></a>三. SF EventThread 添加Connection</h1><h2 id="3-1-SurfaceFlinger-init"><a href="#3-1-SurfaceFlinger-init" class="headerlink" title="3.1 SurfaceFlinger.init"></a>3.1 SurfaceFlinger.init</h2><p>sfEventThread添加Connection是在这个线程启动后就添加的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// mEventQueue就是MessageQueue类的对象</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventThread</span>(mSFEventThread.<span class="built_in">get</span>());</span><br><span class="line">    mVsyncModulator.<span class="built_in">setEventThreads</span>(mSFEventThread.<span class="built_in">get</span>(), mEventThread.<span class="built_in">get</span>());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-MessageQueue-setEventThread"><a href="#3-2-MessageQueue-setEventThread" class="headerlink" title="3.2 MessageQueue.setEventThread"></a>3.2 MessageQueue.setEventThread</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(android::EventThread* eventThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventThread == eventThread) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    <span class="comment">// 3.3 创建Connection</span></span><br><span class="line">    mEvents = eventThread-&gt;<span class="built_in">createEventConnection</span>();</span><br><span class="line">    <span class="comment">// 3.4 建立BitTube连接</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 3.5 接受BitTube事件，调用cb_eventReceiver方法</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-EventThread-createEventConnection"><a href="#3-3-EventThread-createEventConnection" class="headerlink" title="3.3 EventThread.createEventConnection"></a>3.3 EventThread.createEventConnection</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;BnDisplayEventConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Connection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThread::Connection::<span class="built_in">Connection</span>(EventThread* eventThread)</span><br><span class="line">      <span class="comment">// 注意这里的count是被赋值为-1，也就是不接收Vsync事件</span></span><br><span class="line">      : <span class="built_in">count</span>(<span class="number">-1</span>), <span class="built_in">mEventThread</span>(eventThread), <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-EventThread-Connection-onFirstRef"><a href="#3-3-1-EventThread-Connection-onFirstRef" class="headerlink" title="3.3.1 EventThread.Connection.onFirstRef"></a>3.3.1 EventThread.Connection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> EventThread::Connection::<span class="built_in">onFirstRef</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Connection对象生成之后，就被注册到其对应的EventThread中</p>
<h3 id="3-3-2-EventThread-registerDisplayEventConnection"><a href="#3-3-2-EventThread-registerDisplayEventConnection" class="headerlink" title="3.3.2 EventThread.registerDisplayEventConnection"></a>3.3.2 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 添加到mDisplayEventConnections集合中</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">    <span class="comment">// waitForEventLocked 可以继续执行了。</span></span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册connection后，waitForEventLocked便可以开始继续执行了。但是由于只有这一个connection，而且这个connection.count 还是 -1，所以最后还是会在waitForEventLocked中一直等待Vsync事件</p>
<h2 id="3-4-EventThread-Connection-stealReceiveChannel"><a href="#3-4-EventThread-Connection-stealReceiveChannel" class="headerlink" title="3.4  EventThread.Connection.stealReceiveChannel"></a>3.4  EventThread.Connection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">stealReceiveChannel</span>(gui::BitTube* outChannel) &#123;</span><br><span class="line">    <span class="comment">// 将Connection的mChannel复制</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-SF-EventThread-connection开始监听Vsync信号"><a href="#3-5-SF-EventThread-connection开始监听Vsync信号" class="headerlink" title="3.5 SF EventThread connection开始监听Vsync信号"></a>3.5 SF EventThread connection开始监听Vsync信号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SurfaceFlinger::initializeDisplays</span><br><span class="line">    SurfaceFlinger::onInitializeDisplays</span><br><span class="line">        SurfaceFlinger::setTransactionState</span><br><span class="line">            SurfaceFlinger::setTransactionFlags</span><br><span class="line">                SurfaceFlinger::signalTransaction</span><br><span class="line">                    MessageQueue::invalidate</span><br><span class="line">                        EventThread::Connection::requestNextVsync</span><br><span class="line">                            EventThread::requestNextVsync</span><br></pre></td></tr></table></figure>
<p>也就是说当显示屏准备完毕，sfEventThread就可以开始监听Vsync信号了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResyncWithRateLimitCallback) &#123;</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>; <span class="comment">// 只接受一次Vsync信号</span></span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-6-MessageQueue-cb-eventReceiver-处理Vsync信号"><a href="#3-6-MessageQueue-cb-eventReceiver-处理Vsync信号" class="headerlink" title="3.6 MessageQueue.cb_eventReceiver 处理Vsync信号"></a>3.6 MessageQueue.cb_eventReceiver 处理Vsync信号</h2><p>当SF EventThread收到Vsync信号时，最终会通过BitTube发送给对应connection的receiver[2.5]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-1-MessageQueue-Handler-dispatchInvalidate"><a href="#3-6-1-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="3.6.1 MessageQueue.Handler.dispatchInvalidate"></a>3.6.1 MessageQueue.Handler.dispatchInvalidate</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转到SufaceFlinger主线程中处理了。</p>
<h1 id="四-开启硬件Vsync"><a href="#四-开启硬件Vsync" class="headerlink" title="四. 开启硬件Vsync"></a>四. 开启硬件Vsync</h1><h2 id="4-1-EventThread-enableVSyncLocked"><a href="#4-1-EventThread-enableVSyncLocked" class="headerlink" title="4.1 EventThread.enableVSyncLocked"></a>4.1 EventThread.enableVSyncLocked</h2><p>当显示屏准备完毕后，SF EventThread请求一次Vsync信号。那么走到waitForEventLocked中，会调用enableVSyncLocked方法开启硬件Vsync信号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::enableVSyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mUseSoftwareVSync) &#123; </span><br><span class="line">        <span class="comment">// mUseSoftwareVSync也就是显示屏power状态</span></span><br><span class="line">        <span class="comment">// 灭屏为true，亮屏置为false</span></span><br><span class="line">        <span class="keyword">if</span> (!mVsyncEnabled) &#123;</span><br><span class="line">            mVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setCallback</span>(<span class="keyword">this</span>);</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setVSyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mDebugVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-DispSyncSource-setVSyncEnabled"><a href="#4-2-DispSyncSource-setVSyncEnabled" class="headerlink" title="4.2 DispSyncSource.setVSyncEnabled"></a>4.2 DispSyncSource.setVSyncEnabled</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSyncSource::setVSyncEnabled</span><span class="params">(<span class="type">bool</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mVsyncMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">addEventListener</span>(mName, mPhaseOffset,</span><br><span class="line">                                                   <span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                   mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error registering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 1);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">removeEventListener</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                      &amp;mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error unregistering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启Vsync信号就是添加EventListener，关闭就是将这个listener移除</p>
<h2 id="4-3-DispSync-addEventListener"><a href="#4-3-DispSync-addEventListener" class="headerlink" title="4.3 DispSync.addEventListener"></a>4.3 DispSync.addEventListener</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DispSync::addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> mThread-&gt;<span class="built_in">addEventListener</span>(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是到了DispSync部分了。</p>
<p>大致流程如下：</p>
<p><img src="/images/SurfaceFlinger-1-SFEventThread/1_1.png" alt="图片"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>SurfaceFlinger</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
        <tag>SurfaceFlinger</tag>
      </tags>
  </entry>
  <entry>
    <title>SurfaceFlinger(2)--DispSync</title>
    <url>/2022/04/04/SurfaceFlinger-2-DispSync/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<h1 id="一-DispSync"><a href="#一-DispSync" class="headerlink" title="一. DispSync"></a>一. DispSync</h1><p>DispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。</p>
<p>接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。<br>我们先看DispSync线程的创建过程。</p>
<span id="more"></span>

<h1 id="二-DispSync初始化"><a href="#二-DispSync初始化" class="headerlink" title="二. DispSync初始化"></a>二. DispSync初始化</h1><h2 id="2-1-SurfaceFlinger"><a href="#2-1-SurfaceFlinger" class="headerlink" title="2.1 SurfaceFlinger"></a>2.1 SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFligner</span>(SurfaceFlinger::SkipInitializationTag)</span><br><span class="line">        :   <span class="built_in">BnSurfaceComposer</span>(),</span><br><span class="line">            <span class="built_in">mTransactionFlags</span>(<span class="number">0</span>),</span><br><span class="line">            ......</span><br><span class="line">            <span class="built_in">mPrimaryDispSync</span>(<span class="string">&quot;PrimaryDispSync&quot;</span>),</span><br><span class="line">            <span class="built_in">mPrimaryHWVsyncEnabled</span>(<span class="literal">false</span>),</span><br><span class="line">            ......</span><br><span class="line">            &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在SurfaceFlinger初始化的时候创建的。</p>
<h2 id="2-2-DispSync创建"><a href="#2-2-DispSync创建" class="headerlink" title="2.2 DispSync创建"></a>2.2 DispSync创建</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DispSync::<span class="built_in">DispSync</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">      : <span class="built_in">mName</span>(name), <span class="built_in">mRefreshSkipCount</span>(<span class="number">0</span>), <span class="built_in">mThread</span>(<span class="keyword">new</span> <span class="built_in">DispSyncThread</span>(name)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DispSyncThread</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function">        : mName(name),</span></span><br><span class="line"><span class="function">        mStop(false),</span></span><br><span class="line"><span class="function">        mPeriod(<span class="number">0</span>), // 注意这里的mPeriod初始化为<span class="number">0</span></span></span><br><span class="line"><span class="function">        mPhase(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mReferenceTime(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mWakeupLatency(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mFrameNumber(<span class="number">0</span>) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-SurfaceFlinger-SurfaceFlinger"><a href="#2-3-SurfaceFlinger-SurfaceFlinger" class="headerlink" title="2.3 SurfaceFlinger::SurfaceFlinger"></a>2.3 SurfaceFlinger::SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFlinger</span>() : <span class="built_in">SurfaceFlinger</span>(SkipInitialization) &#123;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;SurfaceFlinger is starting&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    mPrimaryDispSync.<span class="built_in">init</span>(SurfaceFlinger::hasSyncFramework, </span><br><span class="line">            SurfaceFlinger::dispSyncPresentTimeOffset);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-DispSync-init"><a href="#2-4-DispSync-init" class="headerlink" title="2.4 DispSync.init"></a>2.4 DispSync.init</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::init</span><span class="params">(<span class="type">bool</span> hasSyncFramework, <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> </span>&#123;</span><br><span class="line">    mIgnorePresentFences = !hasSyncFramework;</span><br><span class="line">    mPresentTimeOffset = dispSyncPresentTimeOffset;</span><br><span class="line">    <span class="comment">// 线程改名为 DispSync，调整线程优先级</span></span><br><span class="line">    mThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;DispSync&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set DispSync to SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sched_setscheduler</span>(mThread-&gt;<span class="built_in">getTid</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for DispSyncThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re not getting present fences then the ZeroPhaseTracer</span></span><br><span class="line">        <span class="comment">// would prevent HW vsync event from ever being turned off.</span></span><br><span class="line">        <span class="comment">// Even if we&#x27;re just ignoring the fences, the zero-phase tracing is</span></span><br><span class="line">        <span class="comment">// not needed because any time there is an event registered we will</span></span><br><span class="line">        <span class="comment">// turn on the HW vsync events.</span></span><br><span class="line">        <span class="keyword">if</span> (!mIgnorePresentFences &amp;&amp; kEnableZeroPhaseTracer) &#123;</span><br><span class="line">            mZeroPhaseTracer = std::<span class="built_in">make_unique</span>&lt;ZeroPhaseTracer&gt;();</span><br><span class="line">            <span class="built_in">addEventListener</span>(<span class="string">&quot;ZeroPhaseTracer&quot;</span>, <span class="number">0</span>, mZeroPhaseTracer.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-1-DispSyncThread-threadLoop"><a href="#2-4-1-DispSyncThread-threadLoop" class="headerlink" title="2.4.1 DispSyncThread.threadLoop"></a>2.4.1 DispSyncThread.threadLoop</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="comment">// 获取开机到现在的时长</span></span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于此时mPeriod为0，所以会进入该分支一直等待。</span></span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-enableVysncLocked后续"><a href="#三-enableVysncLocked后续" class="headerlink" title="三. enableVysncLocked后续"></a>三. enableVysncLocked后续</h1><p>SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked</p>
<h2 id="3-1-DispSync-addEventListener"><a href="#3-1-DispSync-addEventListener" class="headerlink" title="3.1 DispSync.addEventListener"></a>3.1 DispSync.addEventListener</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status_t DispSync::addEventListener(const char* name, nsecs_t phase, Callback* callback) &#123;</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    return mThread-&gt;addEventListener(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-DispSync-DispSyncThread-addEventListener"><a href="#3-2-DispSync-DispSyncThread-addEventListener" class="headerlink" title="3.2 DispSync.DispSyncThread.addEventListener"></a>3.2 DispSync.DispSyncThread.addEventListener</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, DispSync::Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEventListeners[i].mCallback == callback) &#123;</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventListener listener;</span><br><span class="line">    listener.mName = name;</span><br><span class="line">    listener.mPhase = phase;</span><br><span class="line">    listener.mCallback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to allow the firstmost future event to fire without</span></span><br><span class="line">    <span class="comment">// allowing any past events to fire</span></span><br><span class="line">    listener.mLastEventTime = <span class="built_in">systemTime</span>() - mPeriod / <span class="number">2</span> + mPhase - mWakeupLatency;</span><br><span class="line"></span><br><span class="line">    mEventListeners.<span class="built_in">push</span>(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threadLooper可以继续执行了</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里还是运行在SurfaceFlinger主线程，在mCond.signal之后，DispSync线程就可以继续执行了。<br>但是注意看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的continue意味着如果mPeriod为0，还是会一直等待。</p>
<h1 id="四-setPeriod"><a href="#四-setPeriod" class="headerlink" title="四. setPeriod"></a>四. setPeriod</h1><p>这样我们就需要看mPeriod是什么时候被更改的。<br>在SurfaceFlinger初始化Display后，会调用resyncToHardwareVsync跟硬件vsync进行同步。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initializeDisplays();</span><br><span class="line">    flinger-&gt;onInitializeDisplays();</span><br><span class="line">        setPowerModeInternal()</span><br><span class="line">            resyncToHardwareVsync(true);</span><br><span class="line">                repaintEverything();</span><br></pre></td></tr></table></figure>

<h2 id="4-1-SurfaceFlinger-resyncToHardwareVsync"><a href="#4-1-SurfaceFlinger-resyncToHardwareVsync" class="headerlink" title="4.1 SurfaceFlinger.resyncToHardwareVsync"></a>4.1 SurfaceFlinger.resyncToHardwareVsync</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">        <span class="comment">// mHWVsyncAvailable 表示 HW vsync 被 enable</span></span><br><span class="line">        mHWVsyncAvailable = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">        <span class="comment">// Hardware vsync is not currently available, so abort the resync</span></span><br><span class="line">        <span class="comment">// attempt for now</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得显示设备的刷新率，比如60HZ, 那么period就是16.6667ms,即每隔16.6667就会产生一个硬件vsync信号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; activeConfig = <span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">getActiveConfig</span>(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = activeConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是设置DispSync线程中的period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">// 4.2 设置period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mPrimaryHWVsyncEnabled表示当前的硬件vsync是否enable,</span></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        mPrimaryDispSync.<span class="built_in">beginResync</span>();</span><br><span class="line">        <span class="comment">// 如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC</span></span><br><span class="line">        <span class="comment">// 这个和DispSync的setVsyncEnabled是不一样的</span></span><br><span class="line">        <span class="comment">// 5.1 硬件Vsync控制</span></span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-DispSync-setPeriod"><a href="#4-2-DispSync-setPeriod" class="headerlink" title="4.2 DispSync.setPeriod"></a>4.2 DispSync.setPeriod</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::setPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = <span class="number">0</span>;</span><br><span class="line">    mReferenceTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Ignore recompute as mReferenceTime is zero.</span></span><br><span class="line">    <span class="comment">// mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mPeriod表示具体的硬件产生vsync的时间间隔。这样，之后的DispSync线程中的threadLoop就可以继续执行了。</p>
<h1 id="五-硬件Vsync的开关控制"><a href="#五-硬件Vsync的开关控制" class="headerlink" title="五. 硬件Vsync的开关控制"></a>五. 硬件Vsync的开关控制</h1><p>接上面 4.1，当设置DispSync的mPeriod之后，如果硬件Vsync开关是开启状态，则会通过EventControlThread打开HW Vsync<br>我们先看看EventControlThread线程的启动，其启动在SurfaceFlinger的初始化，EventThread启动之后，显示屏初始化之前。</p>
<h2 id="5-1-EventControlThread的启动"><a href="#5-1-EventControlThread的启动" class="headerlink" title="5.1 EventControlThread的启动"></a>5.1 EventControlThread的启动</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = std::<span class="built_in">make_unique</span>&lt;impl::EventControlThread&gt;(</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setVsyncEnabled</span>(HWC_DISPLAY_PRIMARY, enabled); &#125;);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里初始化时传入了函数 setVsyncEnabled。</p>
<p>注意EventControlThread中线程的初始化是在成员变量中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Must be last so that everything is initialized before the thread starts.</span></span><br><span class="line">std::thread mThread&#123;&amp;EventControlThread::threadMain, <span class="keyword">this</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>所以先调用threadMain，后调用构造函数。</p>
<h3 id="5-1-1-EventControlThread-threadMain"><a href="#5-1-1-EventControlThread-threadMain" class="headerlink" title="5.1.1 EventControlThread.threadMain"></a>5.1.1 EventControlThread.threadMain</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unfortunately std::unique_lock gives warnings with -Wthread-safety</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> keepRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> currentVsyncEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keepRunning) &#123;</span><br><span class="line">        <span class="comment">// 5.3 此时currentVsyncEnabled为false</span></span><br><span class="line">        <span class="built_in">mSetVSyncEnabled</span>(currentVsyncEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">// 在这里等待</span></span><br><span class="line">        mCondition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, currentVsyncEnabled, keepRunning]() NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">            <span class="keyword">return</span> currentVsyncEnabled != mVsyncEnabled || keepRunning != mKeepRunning;</span><br><span class="line">        &#125;);</span><br><span class="line">        currentVsyncEnabled = mVsyncEnabled;</span><br><span class="line">        keepRunning = mKeepRunning;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-EventControlThread初始化"><a href="#5-1-2-EventControlThread初始化" class="headerlink" title="5.1.2 EventControlThread初始化"></a>5.1.2 EventControlThread初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EventControlThread::<span class="built_in">EventControlThread</span>(EventControlThread::SetVSyncEnabledFunction function)</span><br><span class="line">      : <span class="built_in">mSetVSyncEnabled</span>(function) &#123;</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), <span class="string">&quot;EventControlThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, tid, ANDROID_PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数里面设置了线程名和优先级</p>
<h2 id="5-2-EventControlThread-setVsyncEnabled"><a href="#5-2-EventControlThread-setVsyncEnabled" class="headerlink" title="5.2 EventControlThread.setVsyncEnabled"></a>5.2 EventControlThread.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::setVsyncEnabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mVsyncEnabled = enabled;</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mVsyncEnabled设置为true, 表明开启硬件Vsync.<br>mCondition.notify_all() 则通知EventControlThread线程继续执行，回到5.1.1的循环内。<br>mSetVSyncEnabled是传入的函数SurfaceFlinger.setVsyncEnabled.</p>
<h2 id="5-3-SurfaceFlinger-setVsyncEnabled"><a href="#5-3-SurfaceFlinger-setVsyncEnabled" class="headerlink" title="5.3 SurfaceFlinger.setVsyncEnabled"></a>5.3 SurfaceFlinger.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">getHwComposer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">getBE</span>().mHwc; &#125;</span><br><span class="line"><span class="function">SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br></pre></td></tr></table></figure>
<p>这里的disp &#x3D; HWC_DISPLAY_PRIMARY</p>
<h2 id="5-4-HWComposer-setVsyncEnabled"><a href="#5-4-HWComposer-setVsyncEnabled" class="headerlink" title="5.4 HWComposer.setVsyncEnabled"></a>5.4 HWComposer.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::setVsyncEnabled</span><span class="params">(DisplayId displayId, HWC2::Vsync enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_INVALID_DISPLAY</span>(displayId);</span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayData.isVirtual) &#123;</span><br><span class="line">        <span class="built_in">LOG_DISPLAY_ERROR</span>(displayId, <span class="string">&quot;Invalid operation on virtual display&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we use our own internal lock here because we have to call</span></span><br><span class="line">    <span class="comment">// into the HWC with the lock held, and we want to make sure</span></span><br><span class="line">    <span class="comment">// that even if HWC blocks (which it shouldn&#x27;t), it won&#x27;t</span></span><br><span class="line">    <span class="comment">// affect other threads.</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(displayData.vsyncEnabledLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enabled == displayData.vsyncEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">auto</span> error = displayData.hwcDisplay-&gt;<span class="built_in">setVsyncEnabled</span>(enabled);</span><br><span class="line">    <span class="built_in">RETURN_IF_HWC_ERROR</span>(error, displayId);</span><br><span class="line"></span><br><span class="line">    displayData.vsyncEnabled = enabled;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> tag = <span class="string">&quot;HW_VSYNC_ON_&quot;</span> + <span class="built_in">to_string</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(tag.<span class="built_in">c_str</span>(), enabled == HWC2::Vsync::Enable ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六-硬件Vsync信号更新"><a href="#六-硬件Vsync信号更新" class="headerlink" title="六. 硬件Vsync信号更新"></a>六. 硬件Vsync信号更新</h1><p>经过HWComposer使能硬件Vsync信号后，只要有硬件Vsync信号产生，就可回调 hook_vsync函数。<br>hook_vsync函数在HWComposer的初始化的时候被注册的。</p>
<h2 id="6-1-HWC初始化"><a href="#6-1-HWC初始化" class="headerlink" title="6.1 HWC初始化"></a>6.1 HWC初始化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 获取硬件HWC</span><br><span class="line">    getBE().mHwc.reset(</span><br><span class="line">            new HWComposer(std::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));</span><br><span class="line">    // 注册回调</span><br><span class="line">    getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里这里先创建的是 Hwc2::impl::Composer,然后创建HWComposer</p>
<h3 id="6-1-1-ComposerHal-cpp-Composer"><a href="#6-1-1-ComposerHal-cpp-Composer" class="headerlink" title="6.1.1 ComposerHal.cpp:Composer"></a>6.1.1 ComposerHal.cpp:Composer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Composer::<span class="built_in">Composer</span>(<span class="type">const</span> std::string&amp; serviceName)</span><br><span class="line">    : <span class="built_in">mWriter</span>(kWriterInitialSize),</span><br><span class="line">      <span class="built_in">mIsUsingVrComposer</span>(serviceName == std::<span class="built_in">string</span>(<span class="string">&quot;vr&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    mComposer = V2_1::IComposer::<span class="built_in">getService</span>(serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mComposer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to get hwcomposer service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mComposer-&gt;<span class="built_in">createClient</span>(</span><br><span class="line">            [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="type">const</span> <span class="keyword">auto</span>&amp; tmpClient)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmpError == Error::NONE) &#123;</span><br><span class="line">                    mClient = tmpClient;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (mClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create composer client&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 support is optional</span></span><br><span class="line">    sp&lt;IComposer&gt; composer_2_2 = IComposer::<span class="built_in">castFrom</span>(mComposer);</span><br><span class="line">    <span class="keyword">if</span> (composer_2_2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mClient_2_2 = IComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mClient_2_2 == <span class="literal">nullptr</span>, <span class="string">&quot;IComposer 2.2 did not return IComposerClient 2.2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsUsingVrComposer) &#123;</span><br><span class="line">        sp&lt;IVrComposerClient&gt; vrClient = IVrComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="keyword">if</span> (vrClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create vr composer client&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取composer服务。</p>
<h3 id="6-1-2-HWComposer创建"><a href="#6-1-2-HWComposer创建" class="headerlink" title="6.1.2 HWComposer创建"></a>6.1.2 HWComposer创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HWComposer::<span class="built_in">HWComposer</span>(std::unique_ptr&lt;android::Hwc2::Composer&gt; composer)</span><br><span class="line">      : <span class="built_in">mHwcDevice</span>(std::<span class="built_in">make_unique</span>&lt;HWC2::Device&gt;(std::<span class="built_in">move</span>(composer))) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-注册回调HWComposer-registerCallback"><a href="#6-2-注册回调HWComposer-registerCallback" class="headerlink" title="6.2 注册回调HWComposer.registerCallback"></a>6.2 注册回调HWComposer.registerCallback</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::registerCallback</span><span class="params">(HWC2::ComposerCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    mHwcDevice-&gt;<span class="built_in">registerCallback</span>(callback, sequenceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Device::registerCallback</span><span class="params">(ComposerCallback* callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRegisteredCallback) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Callback already registered. Ignored extra registration &quot;</span></span><br><span class="line">                <span class="string">&quot;attempt.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRegisteredCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">sp&lt;ComposerCallbackBridge&gt; <span class="title">callbackBridge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> ComposerCallbackBridge(callback, sequenceId))</span></span>;</span><br><span class="line">    mComposer-&gt;<span class="built_in">registerCallback</span>(callbackBridge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Composer::registerCallback</span><span class="params">(<span class="type">const</span> sp&lt;IComposerCallback&gt;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mClient就是composer服务在SurfaceFlinger中的客户端</span></span><br><span class="line">    <span class="keyword">auto</span> ret = mClient-&gt;<span class="built_in">registerCallback</span>(callback);</span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">isOk</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to register IComposerCallback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ComposerCallbackBridge类就是实现onHotplug, onVsync等回调。<br>当HWC硬件产生vsync信号时，就会回调onVsync方法。</p>
<h2 id="6-3-Vsync信号更新"><a href="#6-3-Vsync信号更新" class="headerlink" title="6.3 Vsync信号更新"></a>6.3 Vsync信号更新</h2><h3 id="6-3-1-ComposerCallbackBridge-onVsync"><a href="#6-3-1-ComposerCallbackBridge-onVsync" class="headerlink" title="6.3.1 ComposerCallbackBridge.onVsync"></a>6.3.1 ComposerCallbackBridge.onVsync</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onVsync</span><span class="params">(Hwc2::Display display, <span class="type">int64_t</span> timestamp)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mCallback-&gt;<span class="built_in">onVsyncReceived</span>(mSequenceId, display, timestamp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mCallback就是SurfaceFlinger[6.1].</p>
<h3 id="6-3-2-SurfaceFlinger-onVsyncReceived"><a href="#6-3-2-SurfaceFlinger-onVsyncReceived" class="headerlink" title="6.3.2 SurfaceFlinger.onVsyncReceived"></a>6.3.2 SurfaceFlinger.onVsyncReceived</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onVsyncReceived</span><span class="params">(<span class="type">int32_t</span> sequenceId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">hwc2_display_t</span> displayId, <span class="type">int64_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="comment">// Ignore any vsyncs from a previous hardware composer.</span></span><br><span class="line">    <span class="keyword">if</span> (sequenceId != <span class="built_in">getBE</span>().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> type;</span><br><span class="line">    <span class="comment">// 按条件决定是否过滤，记录此次HWC接收到的硬件Vsync</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">onVsync</span>(displayId, timestamp, &amp;type)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="comment">// DISPLAY_PRIMARY为0，mPrimaryHWVsyncEnabled为true</span></span><br><span class="line">        <span class="keyword">if</span> (type == DisplayDevice::DISPLAY_PRIMARY &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.<span class="built_in">addResyncSample</span>(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        <span class="built_in">enableHardwareVsync</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">disableHardwareVsync</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-DispSync-addResyncSample"><a href="#6-3-3-DispSync-addResyncSample" class="headerlink" title="6.3.3 DispSync.addResyncSample"></a>6.3.3 DispSync.addResyncSample</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DispSync::addResyncSample</span><span class="params">(<span class="type">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample(%&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>, mName, <span class="built_in">ns2us</span>(timestamp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MAX_RESYNC_SAMPLES = 32，即最大只保存32次硬件vsync时间戳，用来计算SW vsync模型.</span></span><br><span class="line">    <span class="comment">// mNumResyncSamples 表示已经有多少个硬件vsync 样本了 ，最多记录MAX_RESYNC_SAMPLES</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    mResyncSamples[idx] = timestamp;</span><br><span class="line">    <span class="comment">// 第一次收到Vsync信号，直接更新</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples == <span class="number">0</span>) &#123;</span><br><span class="line">        mPhase = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 参考时间设置为第一个硬件vsync的时间戳</span></span><br><span class="line">        mReferenceTime = timestamp;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] First resync sample: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = 0, &quot;</span></span><br><span class="line">              <span class="string">&quot;mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">              mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">        <span class="comment">// 6.3.5 通知更新DispSync线程收到Vsync信号</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新 mNumResyncSamples 或 mFirstResyncSample的值</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">        mNumResyncSamples++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFirstResyncSample = (mFirstResyncSample + <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.3.4 开始计算更新SW vsync 模型</span></span><br><span class="line">    <span class="built_in">updateModelLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">        <span class="built_in">resetErrorLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIgnorePresentFences) &#123;</span><br><span class="line">        <span class="comment">// If we don&#x27;t have the sync framework we will never have</span></span><br><span class="line">        <span class="comment">// addPresentFence called.  This means we have no way to know whether</span></span><br><span class="line">        <span class="comment">// or not we&#x27;re synchronized with the HW vsyncs, so we just request</span></span><br><span class="line">        <span class="comment">// that the HW vsync events be turned on whenever we need to generate</span></span><br><span class="line">        <span class="comment">// SW vsync events.</span></span><br><span class="line">        <span class="keyword">return</span> mThread-&gt;<span class="built_in">hasAnyEventListeners</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against kErrorThreshold / 2 to add some hysteresis before having to</span></span><br><span class="line">    <span class="comment">// resync again</span></span><br><span class="line">    <span class="type">bool</span> modelLocked = mModelUpdated &amp;&amp; mError &lt; (kErrorThreshold / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample returning %s&quot;</span>, mName, modelLocked ? <span class="string">&quot;locked&quot;</span> : <span class="string">&quot;unlocked&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !modelLocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是收到硬件Vsync信号, 在SurfaceFlinger主线程执行，在经过误差更正后，通知DispSync线程处理分发事件。</p>
<h3 id="6-3-4-DispSync-updateModelLocked"><a href="#6-3-4-DispSync-updateModelLocked" class="headerlink" title="6.3.4 DispSync.updateModelLocked"></a>6.3.4 DispSync.updateModelLocked</h3><p>这一步是计算模型参数如偏移、硬件Vsync更新间隔等。在分析前，我们先了解下几个重要参数的含义：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>默认值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>mNumResyncSamples</td>
<td>-</td>
<td>当前保存的硬件Vsyc信号数量，最大值为32</td>
</tr>
<tr>
<td>MIN_RESYNC_SAMPLES_FOR_UPDATE</td>
<td>6</td>
<td>更新模型参数的最小硬件Vsync数量</td>
</tr>
<tr>
<td>mPeriod</td>
<td>-</td>
<td>硬件刷新率，根据保存的Vsync去掉最大和最小求得的平均值</td>
</tr>
<tr>
<td>mPhase</td>
<td>-</td>
<td>偏移时间，仅作为针对mPeriod的一个偏移</td>
</tr>
<tr>
<td>mReferenceTime</td>
<td>第一个硬件Vsync事件</td>
<td>每次计算sw vsync模型时的基准时间，以减少误差</td>
</tr>
<tr>
<td>mRefreshSkipCount</td>
<td>0</td>
<td>多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::updateModelLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);</span><br><span class="line">    <span class="comment">// MIN_RESYNC_SAMPLES_FOR_UPDATE = 6, 也就是收到6次硬件Vsync之后，开始计算sw vsync模型</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Computing...&quot;</span>, mName);</span><br><span class="line">        <span class="type">nsecs_t</span> durationSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> minDuration = INT64_MAX;</span><br><span class="line">        <span class="type">nsecs_t</span> maxDuration = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里计算总时长，以及拿到最长和最短的硬件vsync间隔</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">            durationSum += duration;</span><br><span class="line">            minDuration = <span class="built_in">min</span>(minDuration, duration);</span><br><span class="line">            maxDuration = <span class="built_in">max</span>(maxDuration, duration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算平均间隔，去掉一个最大和一个最小的间隔</span></span><br><span class="line">        durationSum -= minDuration + maxDuration;</span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPeriod = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPeriod));</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> sampleAvgX = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> sampleAvgY = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="built_in">double</span>(mPeriod);</span><br><span class="line">        <span class="comment">// 跳过第一个Vsync，因为第一个Vsync已经更新到DispSync中了。</span></span><br><span class="line">        <span class="comment">// mReferenceTime是第一个Vsync的时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;</span><br><span class="line">            <span class="type">double</span> samplePhase = <span class="built_in">double</span>(sample % mPeriod) * scale;</span><br><span class="line">            sampleAvgX += <span class="built_in">cos</span>(samplePhase);</span><br><span class="line">            sampleAvgY += <span class="built_in">sin</span>(samplePhase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sampleAvgX /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line">        sampleAvgY /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        mPhase = <span class="built_in">nsecs_t</span>(<span class="built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        <span class="comment">// 如果偏移值是负值，绝对值超过了mPeroid的一半</span></span><br><span class="line">        <span class="comment">// 则调整偏移值为对应正值</span></span><br><span class="line">        <span class="keyword">if</span> (mPhase &lt; -(mPeriod / <span class="number">2</span>)) &#123;</span><br><span class="line">            mPhase += mPeriod;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Period&quot;</span>, mPeriod);</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Phase&quot;</span>, mPhase + mPeriod / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mRefreshSkipCount表示多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</span></span><br><span class="line">        mPeriod += mPeriod * mRefreshSkipCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.3.5 更新sw model. 这个方法会唤醒DispSync线程</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">        mModelUpdated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里算偏移还用上了反三角函数。mPeriod的含义就是圆周长，最终算出来的 mPhase 就是弧BC的长度。<br>也就是基于mPeriod的偏移值，如下图：</p>
<p><img src="/images/SurfaceFlinger-2-DispSync/2_1.png" alt="图片"></p>
<p>这个偏移值有什么用处呢？</p>
<h3 id="6-3-5-DispSync-DispSyncThread-updateModel"><a href="#6-3-5-DispSync-DispSyncThread-updateModel" class="headerlink" title="6.3.5 DispSync.DispSyncThread.updateModel"></a>6.3.5 DispSync.DispSyncThread.updateModel</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateModel</span><span class="params">(<span class="type">nsecs_t</span> period, <span class="type">nsecs_t</span> phase, <span class="type">nsecs_t</span> referenceTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = phase;</span><br><span class="line">    mReferenceTime = referenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModel: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = %&quot;</span> PRId64</span><br><span class="line">          <span class="string">&quot; mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">          mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mPhase), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">    <span class="comment">// 这里通知正在等待的DispSync线程开始执行</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新mPeriod和时间戳。<br>mCond.signal 后转DispSyncThread线程[2.4.1]DispSyncThread.threadLoop继续执行</p>
<h1 id="七-SW-Vsync更新"><a href="#七-SW-Vsync更新" class="headerlink" title="七. SW Vsync更新"></a>七. SW Vsync更新</h1><p>硬件Vsync信号经过DispSync的简单加工，会将相应的值更新，然后唤醒DispSyncThread线程</p>
<h2 id="7-1-DispSync-DispSyncThread-threadLoop"><a href="#7-1-DispSync-DispSyncThread-threadLoop" class="headerlink" title="7.1 DispSync.DispSyncThread.threadLoop"></a>7.1 DispSync.DispSyncThread.threadLoop</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2 计算下一个SW Vsync时间点</span></span><br><span class="line">            targetTime = <span class="built_in">computeNextEventTimeLocked</span>(now);</span><br><span class="line">            <span class="type">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果计算出来的下一次vsync事件还没有到来，就等时间到了，才发送SW VSYNC信号</span></span><br><span class="line">            <span class="comment">// 可以看出 DispSyncThread的发送的vsync信号和真正硬件发生的vsync信号没有直接的关系，</span></span><br><span class="line">            <span class="comment">// 发送给app/sf的vsync信号都是由 DispSyncThread发送出去的.</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;DispSync waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetTime == INT64_MAX) &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting forever&quot;</span>, mName);</span><br><span class="line">                    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(targetTime));</span><br><span class="line">                    err = mCond.<span class="built_in">waitRelative</span>(mMutex, targetTime - now);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待超时，主动醒来，发送SW Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">                    isWakeup = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算wake up消耗的时间, 但是不能超过1.5 ms</span></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">nsecs_t</span> kMaxWakeupLatency = <span class="built_in">us2ns</span>(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">                <span class="comment">// 乍一看没明白为什么这么算。仔细想，每次wakeup时间是累加的，这个为了减小抖动？</span></span><br><span class="line">                mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) + (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">                mWakeupLatency = <span class="built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.3 搜集EventListener回调，一般就两个：SF和App EventThread</span></span><br><span class="line">            <span class="comment">// 并不是所有的wakeup都是等待了sw vsync的targetTime，如果SurfaceFlinger</span></span><br><span class="line">            <span class="comment">// 主线程收到硬件Vsync,也会唤醒此线程，此时isWakeup为false</span></span><br><span class="line">            <span class="comment">// 这里的callbackInvocations集合就为null，只有now&gt;=targetTime才不为null</span></span><br><span class="line">            callbackInvocations = <span class="built_in">gatherCallbackInvocationsLocked</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackInvocations.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fireCallbackInvocations</span>(callbackInvocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-DispSync-DispSyncThread-computeNextEventTimeLocked"><a href="#7-2-DispSync-DispSyncThread-computeNextEventTimeLocked" class="headerlink" title="7.2 DispSync.DispSyncThread.computeNextEventTimeLocked"></a>7.2 DispSync.DispSyncThread.computeNextEventTimeLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeNextEventTimeLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] computeNextEventTimeLocked&quot;</span>, mName);</span><br><span class="line">    <span class="type">nsecs_t</span> nextEventTime = INT64_MAX;</span><br><span class="line">    <span class="comment">// 对所有的EventListener进行分别计算，里面的mLastEventTime值不同</span></span><br><span class="line">    <span class="comment">// 找出一个最小的Vsync时间，即最近的时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], now);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; nextEventTime) &#123;</span><br><span class="line">            nextEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] nextEventTime = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(nextEventTime));</span><br><span class="line">    <span class="keyword">return</span> nextEventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的EventListeners里面只有两个，一个是SF EventThread，另一个就是App EventThread.</p>
<h3 id="7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked"><a href="#7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked" class="headerlink" title="7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked"></a>7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeListenerNextEventTimeLocked</span><span class="params">(<span class="type">const</span> EventListener&amp; listener, <span class="type">nsecs_t</span> baseTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listener.mLasteEventTime就是上次SW VSync的时间点，mWakeupLatency就是上次线程醒来的耗时</span></span><br><span class="line">    <span class="type">nsecs_t</span> lastEventTime = listener.mLastEventTime + mWakeupLatency;</span><br><span class="line">    <span class="comment">// 一般baseTime也就是nowTime, 是大于lasterEventTime，除了第一次进入   </span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; lastEventTime) &#123;</span><br><span class="line">        baseTime = lastEventTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// baseTime减去第一次硬件Vsync的时间，算duration时长</span></span><br><span class="line">    baseTime -= mReferenceTime;</span><br><span class="line">    <span class="comment">// 偏移就是SW Vsync本身的偏移值加上各EventThread本身的偏移</span></span><br><span class="line">    <span class="comment">// sf 使用的是 SF_VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="comment">// APP使用的VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="type">nsecs_t</span> phase = mPhase + listener.mPhase;</span><br><span class="line">    <span class="comment">// baseTime也减去偏移</span></span><br><span class="line">    baseTime -= phase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// baseTime小于0，只有第一次进入的时候才会发生。</span></span><br><span class="line">    <span class="comment">// 此时硬件Vsync已经发生了，所以设置baseTime为-mPeriod这样后面算的numPeriod为-1</span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        baseTime = -mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出下一个SW Vsync的时间点</span></span><br><span class="line">    <span class="comment">// 先得到baseTime对应第几个sw Vsync，也就是现在时间点发送了多少个sw Vsync</span></span><br><span class="line">    <span class="type">nsecs_t</span> numPeriods = baseTime / mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numberPeriods+1也就是下一个sw Vysnc，再加上偏移        </span></span><br><span class="line">    <span class="type">nsecs_t</span> t = (numPeriods + <span class="number">1</span>) * mPeriod + phase;</span><br><span class="line">    </span><br><span class="line">    t += mReferenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Absolute t = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个vsync距离上一个vsync时间小于3/5个mPeriod的话，</span></span><br><span class="line">    <span class="comment">// 为了避免连续的两个sw vsync, 那么这次sw vsync就放弃了，直接放到下一个周期里</span></span><br><span class="line">    <span class="keyword">if</span> (t - listener.mLastEventTime &lt; (<span class="number">3</span> * mPeriod / <span class="number">5</span>)) &#123;</span><br><span class="line">        t += mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出来的时间减掉wakeup累积时间，最大1.5ms</span></span><br><span class="line">    t -= mWakeupLatency;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="/images/SurfaceFlinger-2-DispSync/2_2.png" alt="图片"></p>
<p>看到这里就有一个疑问，sw vsync信号是在DispSyncThread收到第一个硬件Vsync更新sw model后就可以不依赖<br>硬件Vsync信号了，后续可以自己产生。那为什么google没有在这里disable硬件Vsync呢，因为sw vsync还是有误差<br>并不能与硬件Vsync完全保持一致，所以需要updateModelLocked持续消减误差。<br>重新梳理一下完整流程：</p>
<ol>
<li>SurfaceFlinger主线程收到硬件Vsync</li>
<li>DispSync.updateModelLocked及时更新sw model，并通知DispSyncThread线程</li>
<li>DispSyncThread线程更新mPeriod，mPhase等参数通过computeNextEventTimeLocked计算新的targetTime</li>
<li>继续等待直到新的targetTime，通知SF EventThread或者AppEventThread有sw vsync信号</li>
</ol>
<p>我们知道SF EventThread和App EventThread是有间隔的，并不同步，这里是如何实现的呢？<br>注意我们计算出来的targetTime是sf和app中最近的一次，那么继续看往下看。</p>
<h2 id="7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked"><a href="#7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked" class="headerlink" title="7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked"></a>7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked</h2><p>now是当前应该被触发的sw vsync时间点，可能是sf vsync也可能是app vsync。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为什么是拿一个vsync周期前的时间点呢？</span></span><br><span class="line">    <span class="type">nsecs_t</span> onePeriodAgo = now - mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算各个EventListener(也就是sf 和app EventThread)的对应的下一次vsync时间.</span></span><br><span class="line">    <span class="comment">// 因为对于时间点now来讲，sf 和 app的下一次vsync时间可能尚未到来。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], onePeriodAgo);</span><br><span class="line">        <span class="comment">// 如果下一次vsync时间尚未到达，这一次就不通知给对应EventListener</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;</span><br><span class="line">            CallbackInvocation ci;</span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">            ci.mEventTime = t;</span><br><span class="line">            callbackInvocations.<span class="built_in">push</span>(ci);</span><br><span class="line">            <span class="comment">// 记录本次sw Vsync时间点</span></span><br><span class="line">            mEventListeners.<span class="built_in">editItemAt</span>(i).mLastEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完这个方法，其实不难理解，DispSyncThread中的targetTime是变化的值，有可能是app EventThread的下一次sw vsync时间，也可能是sf的。如下图：</p>
<p><img src="/images/SurfaceFlinger-2-DispSync/2_3.png" alt="图片"></p>
<p>到这里，sw vsync的流程基本梳理完毕了。</p>
<p>接下来继续看EventThread.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li>
<li><a href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li>
<li><a href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>SurfaceFlinger</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
        <tag>SurfaceFlinger</tag>
      </tags>
  </entry>
  <entry>
    <title>SurfaceFlinger(3)--AppEventThread接受vsync信号</title>
    <url>/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p>前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。</p>
<span id="more"></span>

<p>一图以概之：</p>
<p><img src="/images/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/3_1.png" alt="图片"></p>
<p>我们知道android app绘制是离不开编舞者 Choreographer 的，关于 Choreographer 这里就不赘叙，详细可以参考这篇博文。<br>接下来重点分析一下应用app进程是如何与sw vsync信号同步的。</p>
<h1 id="二-App进程与AppEventThread建立通信过程"><a href="#二-App进程与AppEventThread建立通信过程" class="headerlink" title="二. App进程与AppEventThread建立通信过程"></a>二. App进程与AppEventThread建立通信过程</h1><p>回忆一下，我们知道当应用进程的第一个具有布局的Activity启动时，会初始化Choreographer.</p>
<h2 id="2-1-Choerographer初始化"><a href="#2-1-Choerographer初始化" class="headerlink" title="2.1 Choerographer初始化"></a>2.1 Choerographer初始化</h2><p>Choerographer是个单例，意味着一个应用进程中只会存在一个实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Thread local storage for the choreographer.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Choreographer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主线程中初始化，注意传入的第二个参数 VSYNC_SOURCE_APP</span></span><br><span class="line">        <span class="comment">// 这个值是DisplayEventReceiver.VSYNC_SOURCE_APP 也就是 0</span></span><br><span class="line">        <span class="comment">// 与ISurfaceComposer.h中的VsyncSource.eVsyncSourceApp值保持同步</span></span><br><span class="line">        <span class="comment">// 代表的就是 AppEventThread.</span></span><br><span class="line">        <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">    <span class="comment">// 初始化 DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// USE_VSYNC 值默认为true，读取属性debug.choreographer.vsync</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-FrameDisplayEventReceiver初始化"><a href="#2-2-FrameDisplayEventReceiver初始化" class="headerlink" title="2.2 FrameDisplayEventReceiver初始化"></a>2.2 FrameDisplayEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(looper, vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameDisplayEventReceiver类继承了DisplayEventReceiver类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 转到jni层</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意FrameDisplayEventReceiver类是DisplayEventReceiver的子类。</p>
<h2 id="2-3-android-view-DisplayEventReceiver-cpp-nativeInit"><a href="#2-3-android-view-DisplayEventReceiver-cpp-nativeInit" class="headerlink" title="2.3 android_view_DisplayEventReceiver.cpp:nativeInit"></a>2.3 android_view_DisplayEventReceiver.cpp:nativeInit</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject messageQueueObj, jint vsyncSource)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = <span class="built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;MessageQueue is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.4 根据传入的参数初始化NativeDisplayEventReceiver</span></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> <span class="built_in">NativeDisplayEventReceiver</span>(env,</span><br><span class="line">            receiverWeak, messageQueue, vsyncSource);</span><br><span class="line">    <span class="comment">// 2.8 连接BitTube通信信道</span></span><br><span class="line">    <span class="type">status_t</span> status = receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.<span class="built_in">appendFormat</span>(<span class="string">&quot;Failed to initialize display event receiver.  status=%d&quot;</span>, status);</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;<span class="built_in">incStrong</span>(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-NativeDisplayEventReceiver-初始化"><a href="#2-4-NativeDisplayEventReceiver-初始化" class="headerlink" title="2.4 NativeDisplayEventReceiver 初始化"></a>2.4 NativeDisplayEventReceiver 初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NativeDisplayEventReceiver::<span class="built_in">NativeDisplayEventReceiver</span>(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource) :</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="built_in">DisplayEventDispatcher</span>(messageQueue-&gt;<span class="built_in">getLooper</span>(),</span><br><span class="line">                <span class="comment">// 将传入的vsyncSource（0）强制转换为VsyncSource.eVsyncSourceApp</span></span><br><span class="line">                <span class="built_in">static_cast</span>&lt;ISurfaceComposer::VsyncSource&gt;(vsyncSource)),</span><br><span class="line">        <span class="built_in">mReceiverWeakGlobal</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(receiverWeak)),</span><br><span class="line">        <span class="built_in">mMessageQueue</span>(messageQueue) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Initializing display event receiver.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NativeDisplayEventReceiver 继承了 DisplayEventDispatcher。</p>
<h2 id="2-5-DisplayEventDispatcher-初始化"><a href="#2-5-DisplayEventDispatcher-初始化" class="headerlink" title="2.5 DisplayEventDispatcher 初始化"></a>2.5 DisplayEventDispatcher 初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DisplayEventDispatcher::<span class="built_in">DisplayEventDispatcher</span>(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper,</span><br><span class="line">        ISurfaceComposer::VsyncSource vsyncSource) :</span><br><span class="line">        <span class="comment">// 这里的looper是app主线程的looper，mReceiver是我们所寻找的纽带</span></span><br><span class="line">        <span class="built_in">mLooper</span>(looper), <span class="built_in">mReceiver</span>(vsyncSource), <span class="built_in">mWaitingForVsync</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Initializing display event dispatcher.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mReceiver是DisplayEventReceiver类型。</p>
<h2 id="2-6-DisplayEventReceiver初始化"><a href="#2-6-DisplayEventReceiver初始化" class="headerlink" title="2.6 DisplayEventReceiver初始化"></a>2.6 DisplayEventReceiver初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DisplayEventReceiver::<span class="built_in">DisplayEventReceiver</span>(ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// vsyncSource就是VsyncSource.eVsyncSourceApp</span></span><br><span class="line">        <span class="comment">// 2.6.1 通过binder通信，在surfaceFlinger中创建DisplayEventConnection</span></span><br><span class="line">        mEventConnection = sf-&gt;<span class="built_in">createDisplayEventConnection</span>(vsyncSource);</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.7 取出EventThread类中新创建的BitTube的Fd（文件描述符表索引）</span></span><br><span class="line">            mDataChannel = std::<span class="built_in">make_unique</span>&lt;gui::BitTube&gt;();</span><br><span class="line">            mEventConnection-&gt;<span class="built_in">stealReceiveChannel</span>(mDataChannel.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的博文中也分析了，这里的ComposerService就是获取的SurfaceFlinger服务。</p>
<h3 id="2-6-1-SurfaceFlinger-createDisplayEventConnection"><a href="#2-6-1-SurfaceFlinger-createDisplayEventConnection" class="headerlink" title="2.6.1 SurfaceFlinger.createDisplayEventConnection"></a>2.6.1 SurfaceFlinger.createDisplayEventConnection</h3><p>进入SurfaceFlinger主线程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ISurfaceComposer::VsyncSource vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> resyncCallback = mScheduler-&gt;<span class="built_in">makeResyncCallback</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">        Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里的handle为mAppConnectionHandle</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; handle =</span><br><span class="line">            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;</span><br><span class="line">    <span class="comment">// 2.6.2 创建连接</span></span><br><span class="line">    <span class="keyword">return</span> mScheduler-&gt;<span class="built_in">createDisplayEventConnection</span>(handle, std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-Scheduler-cpp-createDisplayEventConnection"><a href="#2-6-2-Scheduler-cpp-createDisplayEventConnection" class="headerlink" title="2.6.2 Scheduler.cpp:createDisplayEventConnection"></a>2.6.2 Scheduler.cpp:createDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">Scheduler::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;Scheduler::ConnectionHandle&gt;&amp; handle, ResyncCallback resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_VALUE_IF_INVALID</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// mConnections是map类型，key值表示对应的EventThread类型</span></span><br><span class="line">    <span class="comment">// 这个初始化就是在SurfaceFlinger.init方法内，创建EventThread时同步生成的</span></span><br><span class="line">    <span class="comment">// 最终mConnections[handle-&gt;id]-&gt;thread.get()拿到的就是AppEventThread</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">createConnectionInternal</span>(mConnections[handle-&gt;id]-&gt;thread.<span class="built_in">get</span>(),</span><br><span class="line">                                    std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里传入的eventThread就是appEventThread</span></span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里mConnections[handle-&gt;id]-&gt;thread.get()拿到的是handle对应的EventThread.</p>
<h3 id="2-6-3-EventThread-createEventConnection"><a href="#2-6-3-EventThread-createEventConnection" class="headerlink" title="2.6.3 EventThread.createEventConnection"></a>2.6.3 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建的BitTube管道</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>创建EventThreadConnection时新建了个BitTube管道，看来就是通信枢纽就是这个了。</p>
<p>注意到这个类有onFirstRef方法，在生成对象后，就会调用。</p>
<h3 id="2-6-4-EventThreadConnection-onFirstRef"><a href="#2-6-4-EventThreadConnection-onFirstRef" class="headerlink" title="2.6.4 EventThreadConnection.onFirstRef"></a>2.6.4 EventThreadConnection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThreadConnection::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-5-EventThread-registerDisplayEventConnection"><a href="#2-6-5-EventThread-registerDisplayEventConnection" class="headerlink" title="2.6.5 EventThread.registerDisplayEventConnection"></a>2.6.5 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should never happen</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(mDisplayEventConnections.<span class="built_in">cbegin</span>(),</span><br><span class="line">            mDisplayEventConnections.<span class="built_in">cend</span>(), connection);</span><br><span class="line">    <span class="keyword">if</span> (it != mDisplayEventConnections.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;DisplayEventConnection %p already exists&quot;</span>, connection.<span class="built_in">get</span>());</span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有新的连接了，就需要唤醒AppEventThread线程使能Vsync信号了。</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">push_back</span>(connection);</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在注意到我们仅仅是得到了一个BitTube，然而并没有用上这个管道。<br>接下来，回到[2.6 DisplayEventReceiver初始化] 创建DisplayEventReceiver的地方。</p>
<h2 id="2-7-EventThreadConnection-stealReceiveChannel"><a href="#2-7-EventThreadConnection-stealReceiveChannel" class="headerlink" title="2.7 EventThreadConnection.stealReceiveChannel"></a>2.7 EventThreadConnection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将新建的BitTube的Fd复制给outChannel, 也就是DisplayEventReceiver中的 mDataChannel.<br>虽然还是没有用上这个BitTube，不着急，继续看。</p>
<h2 id="2-8-BitTube信道连接过程"><a href="#2-8-BitTube信道连接过程" class="headerlink" title="2.8 BitTube信道连接过程"></a>2.8 BitTube信道连接过程</h2><h3 id="2-8-1-DisplayEventDispatcher-initialize"><a href="#2-8-1-DisplayEventDispatcher-initialize" class="headerlink" title="2.8.1 DisplayEventDispatcher.initialize"></a>2.8.1 DisplayEventDispatcher.initialize</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventDispatcher::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mReceiver 就是DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// 这一步就是确认BitTube创建无误</span></span><br><span class="line">    <span class="type">status_t</span> result = mReceiver.<span class="built_in">initCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to initialize display event receiver, status=%d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个mLooper就是应用app进程的主线程Looper，所以这一步就是将</span></span><br><span class="line">    <span class="comment">// 创建的BitTube信道Fd添加到Looper中</span></span><br><span class="line">    <span class="type">int</span> rc = mLooper-&gt;<span class="built_in">addFd</span>(mReceiver.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个DisplayEventDispatcher是继承了LooperCallback, 所以这里的this方法就是handleEvent。</p>
<p>到这里这里整个Vsync流程已经跑通：</p>
<ol>
<li>SurfaceFlinger主线程收到硬件Vsync, 经过误差修正, 通知给DispSyncThread线程</li>
<li>DispSyncThread线程计算各个EventThread的SW Vsync信号时间并及时发出</li>
<li>AppEventThread收到sw Vsync信号，遍历各个Connection，调用sendEvent向对应BitTube管道发送事件</li>
<li>App进程的主线程收到事件，并处理</li>
</ol>
<p>接下来我们就看app收到sw vsync信号的处理过程。</p>
<h1 id="三-App进程收到SW-VSYNC信号"><a href="#三-App进程收到SW-VSYNC信号" class="headerlink" title="三. App进程收到SW VSYNC信号"></a>三. App进程收到SW VSYNC信号</h1><h2 id="3-1-DisplayEventDispatcher-handleEvent"><a href="#3-1-DisplayEventDispatcher-handleEvent" class="headerlink" title="3.1 DisplayEventDispatcher.handleEvent"></a>3.1 DisplayEventDispatcher.handleEvent</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisplayEventDispatcher::handleEvent</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> events, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    PhysicalDisplayId vsyncDisplayId;</span><br><span class="line">    <span class="type">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="comment">// 3.1.1 读取BitTube管道中的数据，返回值为true表示读取到了数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">processPendingEvents</span>(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3.2 分发收到的sw vsync信号</span></span><br><span class="line">        <span class="built_in">dispatchVsync</span>(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1-DisplayEventDispatcher-processPendingEvents"><a href="#3-1-1-DisplayEventDispatcher-processPendingEvents" class="headerlink" title="3.1.1 DisplayEventDispatcher.processPendingEvents"></a>3.1.1 DisplayEventDispatcher.processPendingEvents</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DisplayEventDispatcher::processPendingEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span>* outTimestamp, PhysicalDisplayId* outDisplayId, <span class="type">uint32_t</span>* outCount)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="comment">// 读取管道中的所有数据</span></span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.<span class="built_in">getEvents</span>(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Read %d events.&quot;</span>, <span class="keyword">this</span>, <span class="built_in">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// 拿到最新的sw vsync信号时间</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outDisplayId = ev.header.displayId;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                <span class="built_in">dispatchHotplug</span>(ev.header.timestamp, ev.header.displayId, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_CONFIG_CHANGED:</span><br><span class="line">                <span class="built_in">dispatchConfigChanged</span>(ev.header.timestamp, ev.header.displayId, ev.config.configId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;dispatcher %p ~ ignoring unknown event type %#x&quot;</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to get events from display event dispatcher, status=%d&quot;</span>, <span class="built_in">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-NativeDisplayEventReceiver-dispatchVsync"><a href="#3-2-NativeDisplayEventReceiver-dispatchVsync" class="headerlink" title="3.2 NativeDisplayEventReceiver.dispatchVsync"></a>3.2 NativeDisplayEventReceiver.dispatchVsync</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="type">nsecs_t</span> timestamp, PhysicalDisplayId displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, jniGetReferent(env, mReceiverWeakGlobal))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Invoking vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, displayId, count);</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Returned from vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;dispatchVsync&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过JNI回调到java层的DisplayEventReceiver.dispatchVsync方法</p>
<h2 id="3-3-DisplayEventReceiver-dispatchVsync"><a href="#3-3-DisplayEventReceiver-dispatchVsync" class="headerlink" title="3.3 DisplayEventReceiver.dispatchVsync"></a>3.3 DisplayEventReceiver.dispatchVsync</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    onVsync(timestampNanos, physicalDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考2.2中，这里的DisplayEventReceiver 对象就是其子类FrameDisplayEventReceiver的对象。</p>
<h2 id="3-4-FrameDisplayEventReceiver-onVsync"><a href="#3-4-FrameDisplayEventReceiver-onVsync" class="headerlink" title="3.4 FrameDisplayEventReceiver.onVsync"></a>3.4 FrameDisplayEventReceiver.onVsync</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    <span class="comment">// mHandler就是mFrameHandler，传入runnable立刻执行，也就是执行run里面的</span></span><br><span class="line">    <span class="comment">// doFrame方法。</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 进入Choreographer的绘图，接下来就是measure,layout,draw的过程了、</span></span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的VSYNC流程图如下：</p>
<p><img src="/images/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/Vsync.jpg" alt="图片"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li>
<li><a href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li>
<li><a href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>SurfaceFlinger</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
        <tag>SurfaceFlinger</tag>
      </tags>
  </entry>
  <entry>
    <title>SurfaceFlinger(4)--Layer&amp;Surface</title>
    <url>/2022/04/04/SurfaceFlinger-4-Layer-Surface/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>Android Q</strong></p>
<p>前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。<br>接下来我们先看看SurfaceFlinger合成帧的部分。</p>
<span id="more"></span>

<h1 id="一-SF-EventThread接收vsync的准备"><a href="#一-SF-EventThread接收vsync的准备" class="headerlink" title="一. SF EventThread接收vsync的准备"></a>一. SF EventThread接收vsync的准备</h1><p>在SFEventThread一文中已经探明，当产生Vsync信号后，会通过BitTube发送事件(EventThreadConnection.postEvent):</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::postEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event&amp; event)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就需要知道 mChannel 是被谁监听了。</p>
<h2 id="1-1-SurfaceFlinger-init"><a href="#1-1-SurfaceFlinger-init" class="headerlink" title="1.1 SurfaceFlinger.init"></a>1.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.1.1 创建SfEventThread以及EventThreadConnection</span></span><br><span class="line">    mSfConnectionHandle = mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;sf&quot;</span>, mPhaseOffsets-&gt;<span class="built_in">getCurrentSfOffset</span>(),</span><br><span class="line">                                                    resyncCallback, [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                        mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 赋值 BitTube, 用来通信</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventConnection</span>(mScheduler-&gt;<span class="built_in">getEventConnection</span>(mSfConnectionHandle));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mEventQueue是在SurfaceFlinger.onFirstRef中初始化的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onFirstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    mEventQueue-&gt;<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::init</span><span class="params">(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">true</span>);</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="built_in">Handler</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Looper就是SurfaceFlinger主线程的Looper.</p>
<h3 id="1-1-1-Scheduler-createConnection"><a href="#1-1-1-Scheduler-createConnection" class="headerlink" title="1.1.1 Scheduler.createConnection"></a>1.1.1 Scheduler.createConnection</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;Scheduler::ConnectionHandle&gt; <span class="title">Scheduler::createConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* connectionName, <span class="type">int64_t</span> phaseOffsetNs, ResyncCallback resyncCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">        impl::EventThread::InterceptVSyncsCallback interceptCallback)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> id = sNextId++;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating a connection handle with ID: %&quot;</span> PRId64 <span class="string">&quot;\n&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 sfEventThread</span></span><br><span class="line">    std::unique_ptr&lt;EventThread&gt; eventThread =</span><br><span class="line">            <span class="built_in">makeEventThread</span>(connectionName, mPrimaryDispSync.<span class="built_in">get</span>(), phaseOffsetNs,</span><br><span class="line">                            std::<span class="built_in">move</span>(interceptCallback));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventThreadConnection</span></span><br><span class="line">    <span class="keyword">auto</span> eventThreadConnection =</span><br><span class="line">            <span class="built_in">createConnectionInternal</span>(eventThread.<span class="built_in">get</span>(), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">    <span class="comment">// 保存创建的connection</span></span><br><span class="line">    mConnections.<span class="built_in">emplace</span>(id,</span><br><span class="line">                         std::<span class="built_in">make_unique</span>&lt;Connection&gt;(<span class="keyword">new</span> <span class="built_in">ConnectionHandle</span>(id),</span><br><span class="line">                                                      eventThreadConnection,</span><br><span class="line">                                                      std::<span class="built_in">move</span>(eventThread)));</span><br><span class="line">    <span class="keyword">return</span> mConnections[id]-&gt;handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-EventThread-createEventConnection"><a href="#1-1-2-EventThread-createEventConnection" class="headerlink" title="1.1.2 EventThread.createEventConnection"></a>1.1.2 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建了 BitTube, 此时是在SurfaceFlinger主线程</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-MessageQueue-setEventConnection"><a href="#1-2-MessageQueue-setEventConnection" class="headerlink" title="1.2 MessageQueue.setEventConnection"></a>1.2 MessageQueue.setEventConnection</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEvents = connection;</span><br><span class="line">    <span class="comment">// 1.2.1 通过BitTube建立与SFEventThread的通信通道</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 有vsync事件会回调cb_eventReceiver事件</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mLooper就是SurfaceFlinger主线程的Looper.</p>
<h3 id="1-2-1-EventThreadConnection-stealReceiveChannel"><a href="#1-2-1-EventThreadConnection-stealReceiveChannel" class="headerlink" title="1.2.1 EventThreadConnection.stealReceiveChannel"></a>1.2.1 EventThreadConnection.stealReceiveChannel</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mChannel就是[1.1.2]中新建的BitTube</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-SF-EventThread接收vsync"><a href="#二-SF-EventThread接收vsync" class="headerlink" title="二. SF EventThread接收vsync"></a>二. SF EventThread接收vsync</h1><p>上面我们知道了，当SFEventThread发出Vsync信号时，会通过BitTube发送该消息至SurfaceFlinger主线程，并调用MessageQueue.cb_eventReceiver方法处理。</p>
<h2 id="2-1-MessageQueue-cb-eventReceiver"><a href="#2-1-MessageQueue-cb-eventReceiver" class="headerlink" title="2.1 MessageQueue.cb_eventReceiver"></a>2.1 MessageQueue.cb_eventReceiver</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 读取消息内容</span></span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 只关心VSYNC消息</span></span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="comment">// 2.2 触发composition</span></span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-MessageQueue-Handler-dispatchInvalidate"><a href="#2-2-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="2.2 MessageQueue.Handler.dispatchInvalidate"></a>2.2 MessageQueue.Handler.dispatchInvalidate</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里通过Looper发送INVALIDATE消息</span></span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            <span class="comment">// 处理INVALIDATE消息</span></span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-SurfaceFlinger-onMessageReceived"><a href="#2-3-SurfaceFlinger-onMessageReceived" class="headerlink" title="2.3 SurfaceFlinger.onMessageReceived"></a>2.3 SurfaceFlinger.onMessageReceived</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="type">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            <span class="comment">// 通过fence机制来判断是否掉帧 </span></span><br><span class="line">            <span class="type">bool</span> frameMissed = <span class="built_in">previousFrameMissed</span>();</span><br><span class="line">            <span class="type">bool</span> hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="type">bool</span> gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;FrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;HwcFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(hwcFrameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;GpuFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(gpuFrameMissed));</span><br><span class="line">            <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line">                mFrameMissedCount++;</span><br><span class="line">                mTimeStats-&gt;<span class="built_in">incrementMissedFrames</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hwcFrameMissed) &#123;</span><br><span class="line">                mHwcFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gpuFrameMissed) &#123;</span><br><span class="line">                mGpuFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行相关参数更新，比如Vsync切换</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">performSetActiveConfig</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果丢帧，则不处理此次VSYNC</span></span><br><span class="line">            <span class="keyword">if</span> (frameMissed &amp;&amp; mPropagateBackpressure) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) ||</span><br><span class="line">                    mPropagateBackpressureClientComposition) &#123;</span><br><span class="line">                    <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">// transaction主要针对Layer和Display的变化更新脏区域</span></span><br><span class="line">            <span class="comment">// 通过Layer的变化来计算脏区域，目的是需要更新我才刷新</span></span><br><span class="line">            <span class="type">bool</span> refreshNeeded = <span class="built_in">handleMessageTransaction</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 主要是调用handlePageFlip()函数，该函数在systrace图上对应latchBuffer及其所包含的方法。</span></span><br><span class="line">            <span class="comment">// 作用是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域</span></span><br><span class="line">            <span class="comment">// 并且把GraphicBuffer映射为OpenGL的texture</span></span><br><span class="line">            refreshNeeded |= <span class="built_in">handleMessageInvalidate</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">updateCursorAsync</span>();</span><br><span class="line">            <span class="built_in">updateInputFlinger</span>();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">// 发送刷新合成请求</span></span><br><span class="line">                <span class="built_in">signalRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDolphinFuncsEnabled) &#123;</span><br><span class="line">                <span class="built_in">mDolphinRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.6 SF 处理合成</span></span><br><span class="line">            <span class="built_in">handleMessageRefresh</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们先忽略Fence机制，先看看大致流程。</p>
<h2 id="2-4-SurfaceFlinger-handleMessageInvalidate"><a href="#2-4-SurfaceFlinger-handleMessageInvalidate" class="headerlink" title="2.4 SurfaceFlinger.handleMessageInvalidate"></a>2.4 SurfaceFlinger.handleMessageInvalidate</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="type">bool</span> refreshNeeded = <span class="built_in">handlePageFlip</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty) &#123;</span><br><span class="line">        <span class="built_in">computeLayerBounds</span>();</span><br><span class="line">        <span class="keyword">if</span> (mTracingEnabled) &#123;</span><br><span class="line">            mTracing.<span class="built_in">notify</span>(<span class="string">&quot;visibleRegionsDirty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh) &#123;</span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">        <span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRefresh.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-SurfaceFlinger-handlePageFlip"><a href="#2-5-SurfaceFlinger-handlePageFlip" class="headerlink" title="2.5 SurfaceFlinger.handlePageFlip"></a>2.5 SurfaceFlinger.handlePageFlip</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;handlePageFlip&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> latchTime = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储需要更新的图层集。 当缓冲区被锁存时，不得更改，因为可能导致死锁。</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">            frameQueued = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">nsecs_t</span> expectedPresentTime;</span><br><span class="line">            expectedPresentTime = mScheduler-&gt;<span class="built_in">expectedPresentTime</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">shouldPresentNow</span>(expectedPresentTime)) &#123;</span><br><span class="line">                <span class="comment">// mLayersWithQueuedFrames用于标记那些已经有Frame的Layer</span></span><br><span class="line">                mLayersWithQueuedFrames.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;!layer-&gt;shouldPresentNow()&quot;</span>);</span><br><span class="line">                layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mLayersWithQueuedFrames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// mStateLock is needed for latchBuffer as LayerRejecter::reject()</span></span><br><span class="line">        <span class="comment">// writes to Layer current state. See also b/119481871</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime)) &#123;</span><br><span class="line">                mLayersPendingRefresh.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;<span class="built_in">useSurfaceDamage</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">isBufferLatched</span>()) &#123;</span><br><span class="line">                newDataLatched = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line">    <span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line">    <span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line">    <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.<span class="built_in">empty</span>() || !newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enter boot animation on first buffer latch</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Enter boot animation&quot;</span>);</span><br><span class="line">        mBootStage = BootStage::BOOTANIMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line">    <span class="keyword">return</span> !mLayersWithQueuedFrames.<span class="built_in">empty</span>() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-SurfaceFlinger-handleMessageRefresh"><a href="#2-6-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="2.6 SurfaceFlinger.handleMessageRefresh"></a>2.6 SurfaceFlinger.handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建layer堆栈, 提取可见的Laye并计算可见区域，为合成准备好数据材料。</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hwcomposer的设定</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); <span class="comment">//正式的合成处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line">    <span class="comment">// 将图像传递到物理屏幕。但是在下一个vsync信号才被消费。</span></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再继续分析之前，我们需要先了解Layer的结构，以及他是如何被添加至SurfaceFlinger中的。</p>
<h1 id="三-Layer的产生"><a href="#三-Layer的产生" class="headerlink" title="三. Layer的产生"></a>三. Layer的产生</h1><p>Layer, 即图层。Layer是图像合成中最重要的单元。图层是Surface和SurfaceControl的组合。<br>说到底也就是每个Window都有对应Surface，也就对应一个Layer;SurfaceFlinger的合成就是将所有图层按照顺序和特定属性合成一帧画面。<br>每个图层都有一组属性，用于定义它与其他图层的交互方式。 </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Positional</td>
<td>定义图层在其显示屏上显示的位置。 包括诸如图层边缘的位置及其相对于其他图层的Z顺序的信息</td>
</tr>
<tr>
<td>Content</td>
<td>定义图层上显示的内容应如何在位置属性定义的边界内显示。 包括裁剪和变换等信息</td>
</tr>
<tr>
<td>Composition</td>
<td>定义图层应如何与其他图层合成。 包括混合模式和alpha合成的图层范围Alpha值等信息</td>
</tr>
<tr>
<td>Optimization</td>
<td>提供正确合成图层非必要的信息，但硬件编写器（HWC）设备可以使用该信息来优化其执行合成的方式。 包括诸如图层的可见区域以及自上一帧以来图层的哪个部分已更新的信息。</td>
</tr>
</tbody></table>
<p>在创建Window或者Window产生变化时就会更新对应的Surface所属的Layer.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">    WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">    WindowManagerService.createSurfaceControl(...) --[SystemServer进程]</span><br><span class="line">    WindowStateAnimator.createSurfaceLocked(...) --[SystemServer进程] 这里传入Surface的FLAG</span><br><span class="line">    WindowSurfaceController.new() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface(WindowContainer) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Builder.build() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.new() --[SystemServer进程]</span><br><span class="line">        android_view_SurfaceControl:nativeCreate() --[JNI][SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:getDefault() --[SystemServer进程]</span><br><span class="line">            DefaultComposerClient:getComposerClient() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:onFirstRef() --[SystemServer进程]通过Binder从SF获取SurfaceComposerClient</span><br><span class="line">                SurfaceFlinger:createConnection() --[SurfaceFlinger进程] 创建SurfaceComposerClient</span><br><span class="line">        SurfaceComposerClient:createSurfaceChecked(...) --[SystemServer进程]Binder调用</span><br><span class="line">        Client:createSurface(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlinger:createLayer(...) --[SurfaceFlinger进程] 这里假设创建一个默认Surface</span><br><span class="line">            SurfaceFlinger:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlingerFactory:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            BufferQueueLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">                BufferLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">        SurfaceControl:<span class="keyword">new</span>(...) --[SystemServer进程]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_1.png" alt="图片"></p>
<p>Surface FLAG一览</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HIDDEN</td>
<td>0x00000004</td>
<td>Surface是隐藏的</td>
</tr>
<tr>
<td>SECURE</td>
<td>0x00000080</td>
<td>包含安全内容，禁止内容被其他进程复制。而且屏幕截图和VNC服务器将被禁用，但可能不会采用硬件加速。Window带有FLAG_SECURE标签，或者该应用禁止截图就会带有这个FLAG</td>
</tr>
<tr>
<td>NON_PREMULTIPLIED</td>
<td>0x00000100</td>
<td>预乘透明度，创建一个Surface，其中颜色分量被Alpha通道解释为“非预乘”。对于没有alpha通道的Surface，这个标志是没有意义的。 默认情况下，Surface是预乘的，这意味着每个颜色分量已经乘以其alpha值。</td>
</tr>
<tr>
<td>OPAQUE</td>
<td>0x00000400</td>
<td>表示Surface必须为不透明，即使其像素格式包含Alpha通道。</td>
</tr>
<tr>
<td>PROTECTED_APP</td>
<td>0x00000800</td>
<td>应用程序需要通过外部显示接收器的硬件保护路径。 如果硬件保护路径不可用，则此表面将不会显示在外部接收器上。</td>
</tr>
<tr>
<td>CURSOR_WINDOW</td>
<td>0x00002000</td>
<td>窗口表示光标字形。</td>
</tr>
<tr>
<td>FX_SURFACE_NORMAL</td>
<td>0x00000000</td>
<td>创建一个默认Surface</td>
</tr>
<tr>
<td>FX_SURFACE_DIM</td>
<td>0x00020000</td>
<td>创建一个暗淡的Surface。 此Surface后面的所有内容都会被{@link #setAlpha}中指定的数量调暗。 锁定Dim Surface是错误的，因为它没有后备存储。</td>
</tr>
<tr>
<td>FX_SURFACE_CONTAINER</td>
<td>创建容器Surface。 此Surface将没有缓冲区，仅用作其他Surface或其InputInfo的容器。</td>
<td></td>
</tr>
<tr>
<td>SURFACE_HIDDEN</td>
<td>0x01</td>
<td>隐藏该Surface, 等同于调用Surface.hide()</td>
</tr>
<tr>
<td>SURFACE_OPAQUE</td>
<td>0x02</td>
<td>尽可能不混合的复合材料。 更新Surface创建期间设置的值（请参阅{@link #OPAQUE}）。</td>
</tr>
</tbody></table>
<h2 id="3-1-SurfaceFlinger-createLayer"><a href="#3-1-SurfaceFlinger-createLayer" class="headerlink" title="3.1 SurfaceFlinger:createLayer"></a>3.1 SurfaceFlinger:createLayer</h2><p>当上次Window变化时，或者会创建Layer，并保存在SurfaceFlinger中.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 假设创建默认的Surface</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">            result = <span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                            format, handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 检查是否有访问SurfaceFlinger的权限</span></span><br><span class="line">    <span class="type">bool</span> addToCurrentState = <span class="built_in">callingThreadHasUnscopedSurfaceFlingerAccess</span>();</span><br><span class="line">    <span class="comment">// 3.2 保存新建的Layer</span></span><br><span class="line">    result = <span class="built_in">addClientLayer</span>(client, *handle, *gbp, layer, parentHandle, parentLayer,</span><br><span class="line">                            addToCurrentState);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-SurfaceFlinger-createBufferQueueLayer"><a href="#3-1-1-SurfaceFlinger-createBufferQueueLayer" class="headerlink" title="3.1.1 SurfaceFlinger.createBufferQueueLayer"></a>3.1.1 SurfaceFlinger.createBufferQueueLayer</h3><p>中间细琐流程略过，最终是创建了一个Layer对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Layer::<span class="built_in">Layer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">      : <span class="built_in">mFlinger</span>(args.flinger),</span><br><span class="line">        <span class="built_in">mName</span>(args.name),</span><br><span class="line">        <span class="built_in">mClientRef</span>(args.client),</span><br><span class="line">        <span class="built_in">mWindowType</span>(args.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>)) &#123;</span><br><span class="line">    mCurrentCrop.<span class="built_in">makeInvalid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> layerFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eHidden) layerFlags |= <span class="type">layer_state_t</span>::eLayerHidden;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eOpaque) layerFlags |= <span class="type">layer_state_t</span>::eLayerOpaque;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eSecure) layerFlags |= <span class="type">layer_state_t</span>::eLayerSecure;</span><br><span class="line"></span><br><span class="line">    mTransactionName = <span class="built_in">String8</span>(<span class="string">&quot;TX - &quot;</span>) + mName;</span><br><span class="line"></span><br><span class="line">    mCurrentState.active_legacy.w = args.w;</span><br><span class="line">    mCurrentState.active_legacy.h = args.h;</span><br><span class="line">    mCurrentState.flags = layerFlags;</span><br><span class="line">    mCurrentState.active_legacy.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.crop_legacy.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.requestedCrop_legacy = mCurrentState.crop_legacy;</span><br><span class="line">    mCurrentState.z = <span class="number">0</span>; <span class="comment">// 这里就是layer在Z轴的位置</span></span><br><span class="line">    mCurrentState.color.a = <span class="number">1.0f</span>;</span><br><span class="line">    mCurrentState.layerStack = <span class="number">0</span>; <span class="comment">// layer所在layerStack</span></span><br><span class="line">    mCurrentState.sequence = <span class="number">0</span>; <span class="comment">// layer序号</span></span><br><span class="line">    mCurrentState.requested_legacy = mCurrentState.active_legacy;</span><br><span class="line">    mCurrentState.active.w = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.h = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.transform = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.transformToDisplayInverse = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.crop.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.acquireFence = <span class="keyword">new</span> <span class="built_in">Fence</span>(<span class="number">-1</span>);</span><br><span class="line">    mCurrentState.dataspace = ui::Dataspace::UNKNOWN;</span><br><span class="line">    mCurrentState.hdrMetadata.validTypes = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.surfaceDamageRegion.<span class="built_in">clear</span>();</span><br><span class="line">    mCurrentState.cornerRadius = <span class="number">0.0f</span>;</span><br><span class="line">    mCurrentState.api = <span class="number">-1</span>;</span><br><span class="line">    mCurrentState.hasColorTransform = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.colorSpaceAgnostic = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.metadata = args.metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drawing state &amp; current state are identical</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    CompositorTiming compositorTiming;</span><br><span class="line">    args.flinger-&gt;<span class="built_in">getCompositorTiming</span>(&amp;compositorTiming);</span><br><span class="line">    mFrameEventHistory.<span class="built_in">initializeCompositorTiming</span>(compositorTiming);</span><br><span class="line">    mFrameTracker.<span class="built_in">setDisplayRefreshPeriod</span>(compositorTiming.interval);</span><br><span class="line"></span><br><span class="line">    mSchedulerLayerHandle = mFlinger-&gt;mScheduler-&gt;<span class="built_in">registerLayer</span>(mName.<span class="built_in">c_str</span>(), mWindowType);</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;<span class="built_in">onLayerCreated</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注的是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>z-order，表示x,y,z轴的z轴上的顺序。数字越大，表示越在上面，数字越小，表示越在下面。</td>
</tr>
<tr>
<td>layerStack</td>
<td>layerStack是存储layer的容器,我们知道每个display只会有一个layerstack来存储他要显示的layer,但是不同的display可以使用同一个layerStack,也可以使用不同的layerStack。可以理解为组的含义。也就是说属于不同组的layer之间互不干扰。SurfaceFlinger中有一个DisplayDevice类，他表示用来显示的设备，譬如LCD或者是HDMI。DisplayDevice里也有一个成员变量mLayerStack，在进行composition的时候，只有和这个device的layerstack相同的layer才可能被显示在这个设备上。</td>
</tr>
<tr>
<td>sequence</td>
<td>sSequence是一个static的变量，所以递加的效果就是为每一个layer设置一个唯一且递增的序列号。</td>
</tr>
</tbody></table>
<h2 id="3-2-SurfaceFlinger-addClientLayer"><a href="#3-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2 SurfaceFlinger.addClientLayer"></a>3.2 SurfaceFlinger.addClientLayer</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">const</span> sp&lt;IBinder&gt;&amp; handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc, <span class="type">const</span> sp&lt;Layer&gt;&amp; lbc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer, <span class="type">bool</span> addToCurrentState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// add this layer to the current state list</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mStateLock);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToCurrentState) &#123;</span><br><span class="line">            <span class="comment">// 3.2.1 将新创建的Layer按照Z轴顺序存储至队列中</span></span><br><span class="line">            mCurrentState.layersSortedByZ.<span class="built_in">add</span>(lbc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gbc != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            mGraphicBufferProducerList.<span class="built_in">insert</span>(IInterface::<span class="built_in">asBinder</span>(gbc).<span class="built_in">get</span>());</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mGraphicBufferProducerList.<span class="built_in">size</span>() &gt;</span><br><span class="line">                                        mMaxGraphicBufferProducerListSize,</span><br><span class="line">                                <span class="string">&quot;Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers&quot;</span>,</span><br><span class="line">                                mGraphicBufferProducerList.<span class="built_in">size</span>(),</span><br><span class="line">                                mMaxGraphicBufferProducerListSize, mNumLayers);</span><br><span class="line">        &#125;</span><br><span class="line">        mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.2 将该Layer保存至mClient的mLayers中,键为IBinder,供后续使用</span></span><br><span class="line">    client-&gt;<span class="built_in">attachLayer</span>(handle, lbc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞清楚Layer的Z轴顺序，对与我们理解Layer合成过程有很大帮助。<br>Layer排序建议参考：<a href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></p>
<h3 id="3-2-1-LayerVector-add"><a href="#3-2-1-LayerVector-add" class="headerlink" title="3.2.1 LayerVector.add"></a>3.2.1 LayerVector.add</h3><p>将新创建的Layer按照Z轴顺序存储至队列中.<br>LayerVector继承了SortedVector,并且重载了函数 do_compare.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LayerVector::do_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* lhs, <span class="type">const</span> <span class="type">void</span>* rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先对LayerStack排序，然后是Z轴排序，最后是序号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; l = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(lhs);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; r = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(rhs);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; lState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? l-&gt;<span class="built_in">getCurrentState</span>() : l-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; rState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? r-&gt;<span class="built_in">getCurrentState</span>() : r-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> ls = lState.layerStack;</span><br><span class="line">    <span class="type">uint32_t</span> rs = rState.layerStack;</span><br><span class="line">    <span class="keyword">if</span> (ls != rs)</span><br><span class="line">        <span class="keyword">return</span> (ls &gt; rs) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> lz = lState.z;</span><br><span class="line">    <span class="type">int32_t</span> rz = rState.z;</span><br><span class="line">    <span class="keyword">if</span> (lz != rz)</span><br><span class="line">        <span class="keyword">return</span> (lz &gt; rz) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;sequence == r-&gt;sequence)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (l-&gt;sequence &gt; r-&gt;sequence) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先比较layerstack，不同的layerstack分开。然后再比较z，假设都相同，就比较唯一的layer序列号。<br>但是至今为止，layerStack和z都还只是初始化时的0，所以在创建layer的时候，只是把他根据序列号放进layersSortedByZ而已，其实他的顺序还是没有设置的。</p>
<h3 id="3-2-2-SurfaceFlinger-addClientLayer"><a href="#3-2-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2.2 SurfaceFlinger:addClientLayer"></a>3.2.2 SurfaceFlinger:addClientLayer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Client::attachLayer</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLayers.<span class="built_in">add</span>(handle, layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-Layer更新流程"><a href="#3-4-Layer更新流程" class="headerlink" title="3.4 Layer更新流程"></a>3.4 Layer更新流程</h2><p>当java层调用setLayer时就会确定对应Layer的Z-Order顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App进程]</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacement(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacementLoop() --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacement(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacementNoTrace(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">WindowManagerService.openSurfaceTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.openTransaction() --[SystemServer进程] 创建Transaction, 或者计数+<span class="number">1</span></span><br><span class="line">    android_view_SurfaceControl:nativeCreateTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">WindowManagerService.applySurfaceChangesTransaction(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.mergeToGlobalTransaction(Transaction) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.merge(Transaction) --[SystemServer进程]合并更新后的属性</span><br><span class="line">    android_view_SurfaceControl:nativeMergeTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:merge(Transaction) --[SystemServer进程]也就是保存新的属性</span><br><span class="line">WindowManagerService.closeSurfaceTransaction(String) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.closeTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.apply() --[SystemServer进程]</span><br><span class="line">    android_view_SurfaceControl:nativeApplyTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:apply(bool) --[SystemServer进程]</span><br><span class="line">    SurfaceFlinger:setTransactionState(...) --[SurfaceFlinger进程]传递更新后的属性到sf</span><br><span class="line">    SurfaceFlinger:applyTransactionState(...) --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:run() --[SurfaceFlinger进程]</span><br><span class="line">            TransactionCompletedThread:threadMain() --[SurfaceFlinger子线程]</span><br><span class="line">                mConditionVariable.wait(mMutex);<span class="comment">// 等待执行</span></span><br><span class="line">                TransactionCompletedListener:onTransactionCompleted(...)--[SurfaceFlinger子线程]</span><br><span class="line">        TransactionCompletedThread:addCallback() --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:sendCallbacks() --notify TransactionCompletedThread执行</span><br><span class="line">        SurfaceFlinger:setClientStateLocked(...) --[SurfaceFlinger进程]</span><br><span class="line">            Layer:setLayer(int32_t) --[SurfaceFlinger进程] 更新Layer所处Z轴的位置</span><br></pre></td></tr></table></figure>
<p>如图：<br><img src="/images/SurfaceFlinger-4-Layer-Surface/4_2.png" alt="图片"></p>
<p>到目前为止还只是创建了一个SurfaceControl，对应SurfaceFlinger中的BufferQueueLayer。<br>真正的Surface还没有被创建，那是什么时候创建的呢？</p>
<h1 id="四-Surface的生成"><a href="#四-Surface的生成" class="headerlink" title="四. Surface的生成"></a>四. Surface的生成</h1><p>一个ViewRootImpl对应一个Suface, 也就是一个Layer.<br>当我们创建了Layer之后，总要向其中填充数据内容，SurfaceFlinger才好做合成。<br>在RendererThread中，我们知道了Surface数据是通过渲染引擎OpenGL(android Q上是Vulkan)生成的。</p>
<h2 id="4-1-Suface的生成"><a href="#4-1-Suface的生成" class="headerlink" title="4.1 Suface的生成"></a>4.1 Suface的生成</h2><p>参阅：RenderThread深入分析(三)–绑定窗口对应的Surface到RenderThread的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewRootImpl.performTraversals(...) --[App UI进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App UI进程]</span><br><span class="line">    mSurface.copyFrom(mSurfaceControl) 注意这里会将赋值mSurface</span><br><span class="line">    android_view_Surface:nativeCreateFromSurfaceControl(...) --[App UI进程]</span><br><span class="line">    SurfaceControl:createSurface() --[App UI进程]</span><br><span class="line">        SurfaceControl:generateSurfaceLocked()</span><br><span class="line">        Surface:<span class="keyword">new</span>() 这里创建了<span class="keyword">native</span> Surface</span><br><span class="line">ThreadedRenderer.initializeIfNeeded(...) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.initialize(Surface) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    HardwareRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    android_view_ThreadedRenderer:setSurface(...) --[App UI进程]</span><br><span class="line">        android_view_Surface:getSurface(...) --[App UI进程] 这里返回上面创建的<span class="keyword">native</span> Surface</span><br><span class="line">    RenderProxy:setSurface(Surface) --[App UI进程] 接下来转进RenderThread线程处理</span><br><span class="line">        CanvasContext:setSurface(...) --[RenderThread线程]</span><br><span class="line">        SkiaVulkanPipeline:setSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager:createSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanSurface:Create(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager.mGetPhysicalDeviceSurfaceCapabilitiesKHR(...)</span><br><span class="line">            获取Vulkan引擎中的Surface</span><br></pre></td></tr></table></figure>
<p>大致流程如下图：<br><img src="/images/SurfaceFlinger-4-Layer-Surface/4_3.png" alt="图片"></p>
<p>现在我们已经获取了渲染引擎中的Surface，向其中填充数据的过程就是performDraw的流程；<br>这个部分在RenderThread中有分析，不在赘述。</p>
<p>那当我们的Surface中已经被填充了数据后，是如何传递给SurfaceFlinger做合成的呢？<br>这个部分我们稍后详细分析，目前仅从trace上也可以看出来：</p>
<p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_4_app.png" alt="图片"></p>
<p>上图中eglSwapBuffer最终就是通过binder通知到surfaceflinger中处理的：</p>
<p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_4_sf.png" alt="图片"></p>
<h1 id="五-Layer实例"><a href="#五-Layer实例" class="headerlink" title="五. Layer实例"></a>五. Layer实例</h1><p>以如下图为例，看看对应Layer：</p>
<img src="/.io//screenshot_phone.png" width="100" hegiht="200" align="center">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Display 19260235133379457 HWC layers:</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> Layer name</span><br><span class="line">           Z |  Window Type |  Comp Type |  Transform |   Disp Frame (LTRB) |          Source Crop (LTRB)</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">  rel      0 |            1 |     DEVICE |          0 |    0    0 1080 2340 |    0.0    0.0 1080.0 2340.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> PopupWindow:b04e24#0</span><br><span class="line">  rel      0 |         1002 |     DEVICE |          0 |  646   56 1080  656 |    0.0    0.0  434.0  600.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> StatusBar#0</span><br><span class="line">  rel      0 |         2000 |     DEVICE |          0 |    0    0 1080   80 |    0.0    0.0 1080.0   80.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> NavigationBar0#0</span><br><span class="line">  rel      0 |         2019 |     DEVICE |          0 |    0 2214 1080 2340 |    0.0    0.0 1080.0  126.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlay#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0    0 1080  240 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlayBottom#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0 2100 1080 2340 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (5fd44db PopupWindow:b04e24#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        2, pos=(646,56), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ ContainerLayer (AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Task=5#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Task=5#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Stack=2#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;taskId:5&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Stack=2#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        5, pos=(0,0), size=(   0,   0), crop=[  0,   0, 1080, 2340], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        1, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Display Root#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Display Root#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000002, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=none</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>示意图如下：</p>
<p><img src="/images/SurfaceFlinger-4-Layer-Surface/screenshot_phone_layer.png" alt="图片"></p>
<p>总的来说就是，树形结构+Z order排序。</p>
<h1 id="六-类图"><a href="#六-类图" class="headerlink" title="六. 类图"></a>六. 类图</h1><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_5_classmap.png" alt="图片"></p>
<p>现在我们Surface有了，也有渲染的内容了，那SurfaceFlinger是如何将这些Surface对应的Layer合成为一帧并显示出来的呢?</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[Android Synchronization Fences – An Introduction]<a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li>
<li>[Android中的GraphicBuffer同步机制-Fence]<a href="https://blog.csdn.net/jinzhuojun/article/details/39698317">https://blog.csdn.net/jinzhuojun/article/details/39698317</a></li>
<li>[深入浅出Android BufferQueue]<a href="https://blog.51cto.com/13591395/2380727">https://blog.51cto.com/13591395/2380727</a></li>
<li>[从systrace看app冷启动过程（三）-首帧的合成与送显]<a href="https://www.jianshu.com/p/3829158b4699">https://www.jianshu.com/p/3829158b4699</a></li>
<li>[Android显示Surface]<a href="https://www.jianshu.com/p/fc3c3d6f9bf7">https://www.jianshu.com/p/fc3c3d6f9bf7</a></li>
<li>[surfaceflinger中各个layer的排序]<a href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></li>
<li>[Android 4.0.3 显示系统深入理解]<a href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li>
<li>[Android窗口管理分析（3）：窗口分组及Z-order的确定]<a href="https://www.jianshu.com/p/90ede7b2a64a">https://www.jianshu.com/p/90ede7b2a64a</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>SurfaceFlinger</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
        <tag>SurfaceFlinger</tag>
      </tags>
  </entry>
  <entry>
    <title>SurfaceFlinger(5)--composer</title>
    <url>/2022/04/04/SurfaceFlinger-5-composer/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>Andorid Q</strong></p>
<p>接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。<br>前面我们也稍微分析了一下，直接看handleMessageRefresh方法：</p>
<p><img src="/images/SurfaceFlinger-5-composer/5_1_sf_onVsync.png" alt="图片"></p>
<p>从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。<br>如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。</p>
<p>这里重点分析handleMessageRefresh.</p>
<span id="more"></span>

<h1 id="一-handleMessageRefresh"><a href="#一-handleMessageRefresh" class="headerlink" title="一. handleMessageRefresh"></a>一. handleMessageRefresh</h1><h2 id="1-1-SurfaceFlinger-handleMessageRefresh"><a href="#1-1-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="1.1 SurfaceFlinger:handleMessageRefresh"></a>1.1 SurfaceFlinger:handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 1.2 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 重建layer堆栈, 提取可见的Laye并计算可见区域</span></span><br><span class="line">    <span class="comment">// 并将数据更新给对应的Display</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4 hwcomposer的设定，将Layer数据更新给HWC</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有Display，依次合成处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="comment">// 1.5 其实beginFrame和prepareFrame最终都是调用到FrameBufferSurface中，没有做特别的事情</span></span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="comment">// 1.6 正式的合成处理，简单来说就是申请GraphicBuffer，向其中填充帧数据</span></span><br><span class="line">        <span class="comment">// 最终给到硬件帧缓冲区</span></span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知composer,即HWC</span></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据状况决定是否更新Vsync Offset</span></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</span></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-SurfaceFlinger-perComposition"><a href="#1-2-SurfaceFlinger-perComposition" class="headerlink" title="1.2 SurfaceFlinger:perComposition"></a>1.2 SurfaceFlinger:perComposition</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;preComposition&quot;</span>);</span><br><span class="line">    <span class="comment">// 记录刷新时间</span></span><br><span class="line">    mRefreshStartTime = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.1 遍历所有layer, 处理处于Drawing状态的layer</span></span><br><span class="line">    <span class="comment">// 这里使用了lambda函数</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 1.2.3 判断Layer是否需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">            <span class="comment">// 如果有layer有frame更新，则标记该值为true，表示需要下一个vsync</span></span><br><span class="line">            <span class="comment">// 做合成</span></span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> SurfaceFlinger::State::<span class="built_in">traverseInZOrder</span>(<span class="type">const</span> LayerVector::Visitor&amp; visitor) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的mDrawingState里面的stateSet为StateSet::Drawing</span></span><br><span class="line">    layersSortedByZ.<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.h</span></span><br><span class="line">State mDrawingState&#123;LayerVector::StateSet::Drawing&#125;;</span><br></pre></td></tr></table></figure>
<p>layersSortedByZ中存储的layer都是SurfaceFlinger.addClientLayer过程中添加的。</p>
<h3 id="1-2-1-LayerVector-traverseInZOrder"><a href="#1-2-1-LayerVector-traverseInZOrder" class="headerlink" title="1.2.1 LayerVector:traverseInZOrder"></a>1.2.1 LayerVector:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerVector::traverseInZOrder</span><span class="params">(StateSet stateSet, <span class="type">const</span> Visitor&amp; visitor)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; layer = (*<span class="keyword">this</span>)[i];</span><br><span class="line">        <span class="comment">// 遍历所有layer，拿到合适State的Layer做处理</span></span><br><span class="line">        <span class="comment">// 这里是拿所有Drawing状态的Layer</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; state = (stateSet == StateSet::Current) ? layer-&gt;<span class="built_in">getCurrentState</span>()</span><br><span class="line">                                                      : layer-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">        <span class="comment">// zOrderRelativeOf中的layer是上层调用setRelativeLayer后添加的</span></span><br><span class="line">        <span class="comment">// 如果为非null，则表示此Surface的Z顺序相对于此进行解释</span></span><br><span class="line">        <span class="comment">// 默认是null的。</span></span><br><span class="line">        <span class="keyword">if</span> (state.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理Layer</span></span><br><span class="line">        layer-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-Layer-traverseInZOrder"><a href="#1-2-2-Layer-traverseInZOrder" class="headerlink" title="1.2.2 Layer:traverseInZOrder"></a>1.2.2 Layer:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::traverseInZOrder</span><span class="params">(LayerVector::StateSet stateSet, <span class="type">const</span> LayerVector::Visitor&amp; visitor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> skipRelativeZUsers = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.2.1 按顺序将当前Layer所有z轴相关的layer和子layer添加至列表</span></span><br><span class="line">    <span class="type">const</span> LayerVector list = <span class="built_in">makeTraversalList</span>(stateSet, &amp;skipRelativeZUsers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也就是说首先遍历Z轴相关的Layer</span></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意Layer的添加都是按照Z轴顺序插入排序的</span></span><br><span class="line">        <span class="comment">// 这里的意思就是首先要遍历并对所有z轴小于0的Layer调用onPreComposition方法</span></span><br><span class="line">        <span class="comment">// 所以需要理解z轴小于0的意义，什么时候z轴值才会小于0？</span></span><br><span class="line">        <span class="comment">// 因为P/Q上Layer组合的数据结构是：树形结构+Z轴排序。现在Z轴的大小一般为 [-2, 2]</span></span><br><span class="line">        <span class="comment">// Z轴小的在下面会被覆盖。现在可以理解了，这里为什么碰到z大于0就要退出循环了</span></span><br><span class="line">        <span class="keyword">if</span> (relative-&gt;<span class="built_in">getZ</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对本Layer做onPreComposition</span></span><br><span class="line">    <span class="built_in">visitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后对所有Z轴不小于0的Layer做onPreComposition</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>visitor这个就是lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.3 调用onPreComposition</span></span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>总的来说就是按顺序依次调用layer的onPreComposition方法，标记其mRefreshPending为false。</p>
<h4 id="1-2-2-1-Layer-makeTraversalList"><a href="#1-2-2-1-Layer-makeTraversalList" class="headerlink" title="1.2.2.1 Layer:makeTraversalList"></a>1.2.2.1 Layer:makeTraversalList</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __attribute__((no_sanitize(&quot;unsigned-integer-overflow&quot;)))的意思</span></span><br><span class="line"><span class="comment">// 是不进行无符号int溢出检测</span></span><br><span class="line">__attribute__((<span class="built_in">no_sanitize</span>(<span class="string">&quot;unsigned-integer-overflow&quot;</span>))) <span class="function">LayerVector <span class="title">Layer::makeTraversalList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        LayerVector::StateSet stateSet, <span class="type">bool</span>* outSkipRelativeZUsers)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(stateSet == LayerVector::StateSet::Invalid,</span><br><span class="line">                        <span class="string">&quot;makeTraversalList received invalid stateSet&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里useDrawing为true</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> useDrawing = stateSet == LayerVector::StateSet::Drawing;</span><br><span class="line">    <span class="type">const</span> LayerVector&amp; children = useDrawing ? mDrawingChildren : mCurrentChildren;</span><br><span class="line">    <span class="type">const</span> State&amp; state = useDrawing ? mDrawingState : mCurrentState;</span><br><span class="line">    <span class="comment">// 假设没有zOrderRelatives，所以直接返回children</span></span><br><span class="line">    <span class="keyword">if</span> (state.zOrderRelatives.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        *outSkipRelativeZUsers = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在，则将相关的layer按照Z轴顺序加入stateSet.Drawing中</span></span><br><span class="line">    <span class="function">LayerVector <span class="title">traverse</span><span class="params">(stateSet)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> wp&lt;Layer&gt;&amp; weakRelative : state.zOrderRelatives) &#123;</span><br><span class="line">        sp&lt;Layer&gt; strongRelative = weakRelative.<span class="built_in">promote</span>();</span><br><span class="line">        <span class="keyword">if</span> (strongRelative != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            traverse.<span class="built_in">add</span>(strongRelative);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有children，将children的相关Layer添加至traverse</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;Layer&gt;&amp; child : children) &#123;</span><br><span class="line">        <span class="type">const</span> State&amp; childState = useDrawing ? child-&gt;mDrawingState : child-&gt;mCurrentState;</span><br><span class="line">        <span class="keyword">if</span> (childState.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse.<span class="built_in">add</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到1.2.2中。</p>
<h3 id="1-2-3-Layer-BufferLayer-onPreComposition"><a href="#1-2-3-Layer-BufferLayer-onPreComposition" class="headerlink" title="1.2.3 Layer:BufferLayer::onPreComposition"></a>1.2.3 Layer:BufferLayer::onPreComposition</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="type">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        mFrameEventHistory.<span class="built_in">addPreComposition</span>(mCurrentFrameNumber, refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasReadyFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录开始刷新的时间，并返回该Layer是否具有可被合成的条件。</p>
<h4 id="1-2-3-1-Layer-BufferLayer-hasReadyFrame"><a href="#1-2-3-1-Layer-BufferLayer-hasReadyFrame" class="headerlink" title="1.2.3.1 Layer:BufferLayer::hasReadyFrame"></a>1.2.3.1 Layer:BufferLayer::hasReadyFrame</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::hasReadyFrame</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasFrameUpdate</span>() || <span class="built_in">getSidebandStreamChanged</span>() || <span class="built_in">getAutoRefresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-2-Layer-BufferLayer-BufferQueueLayer"><a href="#1-2-3-2-Layer-BufferLayer-BufferQueueLayer" class="headerlink" title="1.2.3.2 Layer:BufferLayer:BufferQueueLayer"></a>1.2.3.2 Layer:BufferLayer:BufferQueueLayer</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::hasFrameUpdate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否具有绘制完成的frame</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getAutoRefresh</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAutoRefresh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getSidebandStreamChanged</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSidebandStreamChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-SurfaceFlinger-rebuildLayerStacks"><a href="#1-3-SurfaceFlinger-rebuildLayerStacks" class="headerlink" title="1.3 SurfaceFlinger:rebuildLayerStacks"></a>1.3 SurfaceFlinger:rebuildLayerStacks</h2><p>这个方法比较长，慢慢看。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;rebuildLayerStacks&quot;</span>);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mDolphinStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个display重建其layer列表</span></span><br><span class="line">    <span class="comment">// mVisibleRegionsDirty的这个变量在如下条件会被置为true:</span></span><br><span class="line">    <span class="comment">// 1. 有layer的增删时</span></span><br><span class="line">    <span class="comment">// 2. layer可视化面积发生变化</span></span><br><span class="line">    <span class="comment">// 3. display显示设备变化</span></span><br><span class="line">    <span class="comment">// 4. set power mode on - 即亮屏时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;rebuildLayerStacks VR Dirty&quot;</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是将mGeometryInvalid置为true</span></span><br><span class="line">        <span class="comment">// 这个值影响后续是否需要hwc合成</span></span><br><span class="line">        <span class="built_in">invalidateHwcGeometry</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每一个Display做处理，适配多屏场景</span></span><br><span class="line">        <span class="comment">// mDisplays的类型是：std::map&lt;wp&lt;IBinder&gt;, sp&lt;DisplayDevice&gt;&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : mDisplays) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayDevice = pair.second;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            compositionengine::Output::OutputLayers layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            <span class="type">const</span> ui::Transform&amp; tr = displayState.transform;</span><br><span class="line">            <span class="type">const</span> Rect bounds = displayState.bounds;</span><br><span class="line">            <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">                <span class="comment">// 2.1 计算可视区域</span></span><br><span class="line">                <span class="built_in">computeVisibleRegions</span>(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 顺序遍历Z轴Layer</span></span><br><span class="line">                mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> compositionLayer = layer-&gt;<span class="built_in">getCompositionLayer</span>();</span><br><span class="line">                    <span class="keyword">if</span> (compositionLayer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> displayId = displayDevice-&gt;<span class="built_in">getId</span>();</span><br><span class="line">                    sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;<span class="built_in">getLayerFE</span>();</span><br><span class="line">                    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(layerFE.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">bool</span> needsOutputLayer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对属于给定图层堆栈上的layer, 将其可视区域与其所在Display相交</span></span><br><span class="line">                    <span class="comment">// 相交结果不为空，则说明其在或者其一部分在显示屏幕上</span></span><br><span class="line">                    <span class="comment">// needsOutputLayer标记为true</span></span><br><span class="line">                    <span class="keyword">if</span> (display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(),</span><br><span class="line">                                                 layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">                        Region <span class="built_in">drawRegion</span>(tr.<span class="built_in">transform</span>(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.<span class="built_in">andSelf</span>(bounds);</span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                            needsOutputLayer = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Layer有内容在屏幕上</span></span><br><span class="line">                    <span class="keyword">if</span> (needsOutputLayer) &#123;</span><br><span class="line">                        layersSortedByZ.<span class="built_in">emplace_back</span>(</span><br><span class="line">                                display-&gt;<span class="built_in">getOrCreateOutputLayer</span>(displayId, compositionLayer,</span><br><span class="line">                                                                layerFE));</span><br><span class="line">                        deprecated_layersSortedByZ.<span class="built_in">add</span>(layer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span>&amp; outputLayerState = layersSortedByZ.<span class="built_in">back</span>()-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                        outputLayerState.visibleRegion =</span><br><span class="line">                                tr.<span class="built_in">transform</span>(layer-&gt;visibleRegion.<span class="built_in">intersect</span>(displayState.viewport));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">                        <span class="comment">// 到这个分支里说明Layer之前有内容显示，但现在没有内容显示在屏幕上</span></span><br><span class="line">                        <span class="comment">// 此时我们需要清理该Layer对应的Fence，销毁HWC Layer</span></span><br><span class="line">                        <span class="type">bool</span> hasExistingOutputLayer =</span><br><span class="line">                                display-&gt;<span class="built_in">getOutputLayerForLayer</span>(compositionLayer.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// mLayersWithQueuedFrames 这个变量还记不，是在handlePageFlip方法中，顺序</span></span><br><span class="line">                        <span class="comment">// 遍历Z轴Layer时添加进入的。</span></span><br><span class="line">                        <span class="type">bool</span> hasQueuedFrames = std::<span class="built_in">find</span>(mLayersWithQueuedFrames.<span class="built_in">cbegin</span>(),</span><br><span class="line">                                                         mLayersWithQueuedFrames.<span class="built_in">cend</span>(),</span><br><span class="line">                                                         layer) != mLayersWithQueuedFrames.<span class="built_in">cend</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123;</span><br><span class="line">                            layersNeedingFences.<span class="built_in">add</span>(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据更新到Display中</span></span><br><span class="line">            display-&gt;<span class="built_in">setOutputLayersOrderedByZ</span>(std::<span class="built_in">move</span>(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">            displayDevice-&gt;<span class="built_in">setVisibleLayersSortedByZ</span>(deprecated_layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;<span class="built_in">setLayersNeedingFences</span>(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未定义的区域。也就是屏幕的大小减去屏幕的非透明区域opaqueRegion余下的部分。</span></span><br><span class="line">            Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">            undefinedRegion.<span class="built_in">subtractSelf</span>(tr.<span class="built_in">transform</span>(opaqueRegion));</span><br><span class="line"></span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().undefinedRegion = undefinedRegion;</span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">orSelf</span>(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，rebuildLayerStacks就是反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</p>
<h2 id="1-4-SurfaceFlinger-calculateWorkingSet"><a href="#1-4-SurfaceFlinger-calculateWorkingSet" class="headerlink" title="1.4 SurfaceFlinger::calculateWorkingSet"></a>1.4 SurfaceFlinger::calculateWorkingSet</h2><p>再看这个方法之前先瞄一眼各个Layer之前的关系：</p>
<p><img src="/images/SurfaceFlinger-5-composer/5_4_layer_list.png" alt="图片"></p>
<p>上图中标红的appId就是在此方法内的latchCompositionState方法中赋值的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::calculateWorkingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立HWC中的Layer列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mGeometryInvalid)) &#123;</span><br><span class="line">        mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 同样需要针对各个Display做处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> zOrder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;<span class="built_in">getOutputLayersOrderedByZ</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; compositionState = layer-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                compositionState.forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                    compositionState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Z轴顺序依次递增</span></span><br><span class="line">                compositionState.z = zOrder++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新与显示无关的合成状态，其实就是将Layer的状态信息放在CompositionState中了。</span></span><br><span class="line">                <span class="comment">// 也就是frontEnd（LayerFECompositionState）中</span></span><br><span class="line">                layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">latchCompositionState</span>(layer-&gt;<span class="built_in">getLayer</span>().<span class="built_in">editState</span>().frontEnd,</span><br><span class="line">                                                          <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新计算OutputLayer的几何状态</span></span><br><span class="line">                <span class="comment">// 比如根据显示屏全局矩阵调整该Layer的DisplayFrame、</span></span><br><span class="line">                <span class="comment">// 变换窗口裁剪以匹配缓冲区坐标系等等。</span></span><br><span class="line">                layer-&gt;<span class="built_in">updateCompositionState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将Layer更新完毕的几何状态写入HWC</span></span><br><span class="line">                layer-&gt;<span class="built_in">writeStateToHWC</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每帧的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="keyword">if</span> (!displayId) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDrawingState.colorMatrixChanged) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setColorTransform</span>(mDrawingState.colorMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        Dataspace targetDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (useColorManagement) &#123;</span><br><span class="line">            ColorMode colorMode;</span><br><span class="line">            RenderIntent renderIntent;</span><br><span class="line">            <span class="built_in">pickColorMode</span>(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent);</span><br><span class="line">            display-&gt;<span class="built_in">setColorMode</span>(colorMode, targetDataspace, renderIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">            layer-&gt;<span class="built_in">setPerFrameData</span>(displayDevice, displayState.transform, displayState.viewport,</span><br><span class="line">                                   displayDevice-&gt;<span class="built_in">getSupportedPerFrameMetadata</span>(),</span><br><span class="line">                                   <span class="built_in">isHdrColorMode</span>(displayState.colorMode) ? Dataspace::UNKNOWN</span><br><span class="line">                                                                          : targetDataspace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; layerState = layer-&gt;<span class="built_in">getCompositionLayer</span>()-&gt;<span class="built_in">editState</span>().frontEnd;</span><br><span class="line">            layerState.compositionType = <span class="built_in">static_cast</span>&lt;Hwc2::IComposerClient::Composition&gt;(</span><br><span class="line">                    layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里建立HWC中的Layer列表： </p>
<ol>
<li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li>
<li>将Layer的mActiveBuffer设置到HWComposer中</li>
</ol>
<h2 id="1-5-SurfaceFlinger-beginFrame"><a href="#1-5-SurfaceFlinger-beginFrame" class="headerlink" title="1.5 SurfaceFlinger::beginFrame"></a>1.5 SurfaceFlinger::beginFrame</h2><p>开始合成前的准备。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::beginFrame</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有待更新的区域</span></span><br><span class="line">    <span class="type">bool</span> dirty = !display-&gt;<span class="built_in">getDirtyRegion</span>(<span class="literal">false</span>).<span class="built_in">isEmpty</span>();</span><br><span class="line">    <span class="comment">// 可见Layer数量是否为0</span></span><br><span class="line">    <span class="type">bool</span> empty = displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>().<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上次合成是否有可见Layer</span></span><br><span class="line">    <span class="type">bool</span> wasEmpty = !displayState.lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有变化时或者有变化但此时没有可见Layer且上次合成时也没有就跳过</span></span><br><span class="line">    <span class="type">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> flagPrefix[] = &#123;<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(flagPrefix);</span><br><span class="line">    <span class="built_in">ALOGV_IF</span>(displayDevice-&gt;<span class="built_in">isVirtual</span>(), <span class="string">&quot;%s: %s composition for %s (%cdirty %cempty %cwasEmpty)&quot;</span>,</span><br><span class="line">             __FUNCTION__, mustRecompose ? <span class="string">&quot;doing&quot;</span> : <span class="string">&quot;skipping&quot;</span>,</span><br><span class="line">             displayDevice-&gt;<span class="built_in">getDebugName</span>().<span class="built_in">c_str</span>(), flagPrefix[dirty], flagPrefix[empty],</span><br><span class="line">             flagPrefix[wasEmpty]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里面其实没有做什么特殊的操作，我们看一下DisplayDevice相关的类</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">beginFrame</span>(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/SurfaceFlinger-5-composer/5_5_DisplayDevice.png" alt="图片"></p>
<p>这个DiplayDevice是怎么初始化的呢，后续再看。</p>
<h2 id="1-6-SurfaceFlinger-doComposition"><a href="#1-6-SurfaceFlinger-doComposition" class="headerlink" title="1.6 SurfaceFlinger::doComposition"></a>1.6 SurfaceFlinger::doComposition</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice, <span class="type">bool</span> repaintEverything)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="comment">// 将脏区转换为该屏幕的坐标空间</span></span><br><span class="line">        <span class="type">const</span> Region dirtyRegion = display-&gt;<span class="built_in">getDirtyRegion</span>(repaintEverything);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.6.1 请求buffer,做合成操作</span></span><br><span class="line">        <span class="built_in">doDisplayComposition</span>(displayDevice, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">        display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">flip</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fence同步相关处理，暂时忽略</span></span><br><span class="line">    <span class="built_in">postFramebuffer</span>(displayDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-1-SurfaceFlinger-doDisplayComposition"><a href="#1-6-1-SurfaceFlinger-doDisplayComposition" class="headerlink" title="1.6.1 SurfaceFlinger::doDisplayComposition"></a>1.6.1 SurfaceFlinger::doDisplayComposition</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Region&amp; inDirtyRegion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅在以下情况下才需要实际构成显示：</span></span><br><span class="line">    <span class="comment">// 1）由HWC处理，它可能需要此操作以使其虚拟显示状态机保持同步</span></span><br><span class="line">    <span class="comment">// 2）有工作要做（脏区不为空）</span></span><br><span class="line">    <span class="keyword">if</span> (!displayDevice-&gt;<span class="built_in">getId</span>() &amp;&amp; inDirtyRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doDisplayComposition&quot;</span>);</span><br><span class="line">    base::unique_fd readyFence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.6.2 合成Surface</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">doComposeSurfaces</span>(displayDevice, Region::INVALID_REGION, &amp;readyFence)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲区，buffer已经被填充了合成所有Layer后的帧数据。</span></span><br><span class="line">    <span class="comment">// 将FrameBuffer发送给HWC, 也就是将内容渲染到硬件帧缓冲区中去</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">queueBuffer</span>(std::<span class="built_in">move</span>(readyFence));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-2-SurfaceFlinger-doComposeSurfaces"><a href="#1-6-2-SurfaceFlinger-doComposeSurfaces" class="headerlink" title="1.6.2 SurfaceFlinger::doComposeSurfaces"></a>1.6.2 SurfaceFlinger::doComposeSurfaces</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> Region&amp; debugRegion, base::unique_fd* readyFence)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposeSurfaces&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; renderEngine = <span class="built_in">getRenderEngine</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> supportProtectedContent = renderEngine.<span class="built_in">supportsProtectedContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Region <span class="title">bounds</span><span class="params">(displayState.bounds)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> DisplayRenderArea <span class="title">renderArea</span><span class="params">(displayDevice)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> hasClientComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;hasClientComposition&quot;</span>, hasClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> applyColorMatrix = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    renderengine::DisplaySettings clientCompositionDisplay;</span><br><span class="line">    std::vector&lt;renderengine::LayerSettings&gt; clientCompositionLayers;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    base::unique_fd fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;hasClientComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求GraphicBuffer, 通过ANativeWindow向GPU申请</span></span><br><span class="line">        buf = display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">dequeueBuffer</span>(&amp;fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Dequeuing buffer for display [%s] failed, bailing out of &quot;</span></span><br><span class="line">                  <span class="string">&quot;client composition for this frame&quot;</span>,</span><br><span class="line">                  displayDevice-&gt;<span class="built_in">getDisplayName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将DisplayState相关信息赋值给clientCompositionDisplay，以供HWC使用</span></span><br><span class="line">        clientCompositionDisplay.physicalDisplay = displayState.scissor;</span><br><span class="line">        clientCompositionDisplay.clip = displayState.scissor;</span><br><span class="line">        <span class="type">const</span> ui::Transform&amp; displayTransform = displayState.transform;</span><br><span class="line">        clientCompositionDisplay.globalTransform = displayTransform.<span class="built_in">asMatrix4</span>();</span><br><span class="line">        clientCompositionDisplay.orientation = displayState.orientation;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line">        Dataspace outputDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (profile-&gt;<span class="built_in">hasWideColorGamut</span>()) &#123;</span><br><span class="line">            outputDataspace = displayState.dataspace;</span><br><span class="line">        &#125;</span><br><span class="line">        clientCompositionDisplay.outputDataspace = outputDataspace;</span><br><span class="line">        clientCompositionDisplay.maxLuminance =</span><br><span class="line">                profile-&gt;<span class="built_in">getHdrCapabilities</span>().<span class="built_in">getDesiredMaxLuminance</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> hasDeviceComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> skipClientColorTransform =</span><br><span class="line">                <span class="built_in">getHwComposer</span>()</span><br><span class="line">                        .<span class="built_in">hasDisplayCapability</span>(displayId,</span><br><span class="line">                                              HWC2::DisplayCapability::SkipClientColorTransform);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the global color transform matrix.</span></span><br><span class="line">        applyColorMatrix = !hasDeviceComposition &amp;&amp; !skipClientColorTransform;</span><br><span class="line">        <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">            clientCompositionDisplay.colorTransform = displayState.colorTransformMat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 现在渲染以帧缓冲区为目标的图层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Rendering client layers&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> firstLayer = <span class="literal">true</span>;</span><br><span class="line">    Region clearRegion = Region::INVALID_REGION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可见Layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">viewportRegion</span><span class="params">(displayState.viewport)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">clip</span><span class="params">(viewportRegion.intersect(layer-&gt;visibleRegion))</span></span>;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Layer: %s&quot;</span>, layer-&gt;<span class="built_in">getName</span>().<span class="built_in">string</span>());</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;  Composition type: %s&quot;</span>, <span class="built_in">toString</span>(layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (!clip.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CLIENT: &#123;</span><br><span class="line">                    renderengine::LayerSettings layerSettings;</span><br><span class="line">                    <span class="comment">// 根据相关配置设置Layer状态：渲染区域、alpha通道、颜色变换等等</span></span><br><span class="line">                    <span class="type">bool</span> prepared =</span><br><span class="line">                            layer-&gt;<span class="built_in">prepareClientLayer</span>(renderArea, clip, clearRegion,</span><br><span class="line">                                                      supportProtectedContent, layerSettings);</span><br><span class="line">                    <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                        <span class="comment">// 放入clientCompositionLayers中备用</span></span><br><span class="line">                        clientCompositionLayers.<span class="built_in">push_back</span>(layerSettings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;  Skipping for empty clip&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        firstLayer = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasClientComposition为true说明使用GPU合成</span></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        clientCompositionDisplay.clearRegion = clearRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里提高GPU频率，因为会进行色彩空间转换，比较耗时。 </span></span><br><span class="line">        <span class="comment">// 提高了GPU频率，以便GPU合成可以及时完成。</span></span><br><span class="line">        <span class="comment">// 之后必须重新设置GPU频率，因为高频率会消耗额外的电池。</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> expensiveRenderingExpected =</span><br><span class="line">                clientCompositionDisplay.outputDataspace == Dataspace::DISPLAY_P3;</span><br><span class="line">        <span class="keyword">if</span> (expensiveRenderingExpected &amp;&amp; displayId) &#123;</span><br><span class="line">            mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用渲染引擎（renderengine/gl/GLESRenderEngine.cpp）合成所有Layer</span></span><br><span class="line">        renderEngine.<span class="built_in">drawLayers</span>(clientCompositionDisplay, clientCompositionLayers,</span><br><span class="line">                                buf-&gt;<span class="built_in">getNativeBuffer</span>(), <span class="comment">/*useFramebufferCache=*/</span><span class="literal">true</span>, std::<span class="built_in">move</span>(fd),</span><br><span class="line">                                readyFence);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">        mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先请求GraphicBuffer，然后通过GLESRenderEngine合成所有Layer.</p>
<h1 id="二-计算Layer可视区域"><a href="#二-计算Layer可视区域" class="headerlink" title="二. 计算Layer可视区域"></a>二. 计算Layer可视区域</h1><p>一般来讲，我们手机App Layer如下：<br><img src="/images/SurfaceFlinger-5-composer/5_2_appZ.png" alt="图片"></p>
<p>计算可视区域的时候，从Z轴大的开始遍历计算。这样做的好处是，如果计算到某一层Layer时，完全不透明的可视化区域已经占满整个屏幕，那么这之下的Layer可视化区域就可以不用计算了。</p>
<p>在开始阅读代码之前，还是有必要理清楚：</p>
<ol>
<li>可见区域（Visible Region）</li>
<li>透明区域（Transparent Region）</li>
<li>半透明区域（Translucent Region）</li>
<li>完全不透明区域（Opaque Region）</li>
<li>被覆盖区域（Covered Region）</li>
</ol>
<p>如下图:</p>
<p><img src="/images/SurfaceFlinger-5-composer/5_3_visiableregion.png" alt="图片"></p>
<p>如果A1为W2中半透明区域，A2在W1中全透明，W2中不透明，A3为W1中完全不透明区域。<br>则对于Surface W2而言，可见区域为W2-A1-A3.</p>
<h2 id="2-1-SurfaceFlinger-computeVisibleRegions"><a href="#2-1-SurfaceFlinger-computeVisibleRegions" class="headerlink" title="2.1 SurfaceFlinger:computeVisibleRegions"></a>2.1 SurfaceFlinger:computeVisibleRegions</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;computeVisibleRegions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    outDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先找到“感兴趣的”Layer，也就是这个layer是属于SecureDisplay的</span></span><br><span class="line">    <span class="comment">// 暂时没有找到相关的说明，忽略好了</span></span><br><span class="line">    Layer* layerOfInterest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> bIgnoreLayer = <span class="literal">false</span>;</span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">isSecureDisplay</span>()) &#123;</span><br><span class="line">            bIgnoreLayer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (displayDevice-&gt;<span class="built_in">isPrimary</span>()) &#123;</span><br><span class="line">                layerOfInterest = layer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向遍历Z轴计算可视化区域</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 获取当前绘制中的Surface</span></span><br><span class="line">        <span class="type">const</span> Layer::State&amp; <span class="built_in">s</span>(layer-&gt;<span class="built_in">getDrawingState</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只考虑给定图层堆栈上的layer</span></span><br><span class="line">        <span class="keyword">if</span> (!display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略SecureDisplay中的layer</span></span><br><span class="line">        <span class="keyword">if</span> (bIgnoreLayer &amp;&amp; layerOfInterest != layer) &#123;</span><br><span class="line">            Region visibleNonTransRegion;</span><br><span class="line">            visibleNonTransRegion.<span class="built_in">set</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(visibleNonTransRegion);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全不透明的Surface区域</span></span><br><span class="line">        Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕上可见且不完全透明的Surface区域。 </span></span><br><span class="line">        <span class="comment">// 这实际上是该层的足迹减去其上方的不透明区域。</span></span><br><span class="line">        <span class="comment">// 半透明Surface覆盖的区域被认为是可见的。</span></span><br><span class="line">        Region visibleRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被其上方所有可见区域覆盖的Surface区域（包括半透明区域）。</span></span><br><span class="line">        Region coveredRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暗示完全透明的表面区域。 这仅用于告诉图层何时没有可见的非透明区域，可以将其从图层列表中删除。 </span></span><br><span class="line">        <span class="comment">// 它不会影响此层或它下面的任何层的visibleRegion。 </span></span><br><span class="line">        <span class="comment">// 如果应用程序不遵守SurfaceView限制（不幸的是，有些不遵守），则提示可能不正确。</span></span><br><span class="line">        Region transparentRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理不可见或者被隐藏的Surface的方式就是将其可视化的区域设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_LIKELY</span>(layer-&gt;<span class="built_in">isVisible</span>())) &#123;</span><br><span class="line">            <span class="comment">// 如果该Surface不是完全不透明的，则视为半透明</span></span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> translucent = !layer-&gt;<span class="built_in">isOpaque</span>(s);</span><br><span class="line">            Rect <span class="built_in">bounds</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前Surface的可视区域默认为屏幕大小或者Surface在屏幕中的大小</span></span><br><span class="line">            visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            ui::Transform tr = layer-&gt;<span class="built_in">getTransform</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Region为空则说明没有可视区域</span></span><br><span class="line">            <span class="comment">// 注意 Region 是一个矩形（Rect）集合</span></span><br><span class="line">            <span class="keyword">if</span> (!visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="comment">// 首先从可见区域移除透明区域</span></span><br><span class="line">                <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">                    <span class="comment">// 函数preserveRects的返回值为false</span></span><br><span class="line">                    <span class="comment">// 说明需要忽略掉当前正在处理的应用程序窗口的透明区域</span></span><br><span class="line">                    <span class="keyword">if</span> (tr.<span class="built_in">preserveRects</span>()) &#123;</span><br><span class="line">                        <span class="comment">// 标记透明区域，这个透明区域就是transparentRegionHint遍历</span></span><br><span class="line">                        <span class="comment">// 在 SurfaceFlinger.setClientStateLocked过程中设置的</span></span><br><span class="line">                        transparentRegion = tr.<span class="built_in">transform</span>(layer-&gt;<span class="built_in">getActiveTransparentRegion</span>(s));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 转换太复杂，无法进行透明区域优化。</span></span><br><span class="line">                        transparentRegion.<span class="built_in">clear</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算不透明区域</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> layerOrientation = tr.<span class="built_in">getOrientation</span>();</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;<span class="built_in">getAlpha</span>() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                        layer-&gt;<span class="built_in">getRoundedCornerState</span>().radius == <span class="number">0.0f</span> &amp;&amp;</span><br><span class="line">                        ((layerOrientation &amp; ui::Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时</span></span><br><span class="line">                    <span class="comment">// 那么它的完全不透明区域opaqueRegion就等于计算所得到的可见区域visibleRegion</span></span><br><span class="line">                    opaqueRegion = visibleRegion;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Surface没有可视区域，则清空相关变量，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">clearVisibilityRegions</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将覆盖区域裁剪到可见区域</span></span><br><span class="line">        <span class="comment">// aboveCoveredLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的可见区域</span></span><br><span class="line">        <span class="comment">// 将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相交，就可以得到当前正在处理的应用程序窗口的被覆盖区域coveredRegion</span></span><br><span class="line">        <span class="comment">// 而将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相或一下，就可以得到下一个应用程序窗口的所有上层应用程序窗口所组成的可见区域aboveCoveredLayers。</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.<span class="built_in">intersect</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aboveOpaqueLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的完全不透明区域</span></span><br><span class="line">        aboveCoveredLayers.<span class="built_in">orSelf</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个区域从当前正在处理的应用程序窗口的可见区域visibleRegion减去后，就可以得到当前正在处理的应用程序窗口的最终可见区域visibleRegion。</span></span><br><span class="line">        visibleRegion.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算Layer的脏区域，所谓脏区域就是需要重新执行渲染操作的</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">            <span class="comment">// 成员变量contentDirty的值为true，则说明当前正在处理的Layer上一次的状态还未来得及处理</span></span><br><span class="line">            <span class="comment">// 即它当前的内容是脏的。在这个状况下，只需要将此次的可见区域与上一次的可见区域合并即可</span></span><br><span class="line">            dirty = visibleRegion;</span><br><span class="line">            <span class="comment">// as well, as the old visible region</span></span><br><span class="line">            dirty.<span class="built_in">orSelf</span>(layer-&gt;visibleRegion);</span><br><span class="line">            layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当上一次状态已经处理了，也就是显示内容没有更新,则无需重新渲染所有区域。</span></span><br><span class="line">            <span class="comment">// 现在只需要处理一下两种情况：</span></span><br><span class="line">            <span class="comment">// 1. 之前是被覆盖的区域，但现在不被覆盖了</span></span><br><span class="line">            <span class="comment">// 2. 由于窗口大小变化而引发的新增不被覆盖区域</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第一种情况:</span></span><br><span class="line">            <span class="comment">// 将当前可见区域visibleRegion与它的上一次被覆盖区域oldCoveredRegion相交</span></span><br><span class="line">            <span class="comment">// 就可以得到之前是被覆盖的而现在不被覆盖了的区域，即可以得到第一部分需要重新渲染的区域</span></span><br><span class="line">            <span class="comment">// 上一次可见区域和被覆盖区域分别oldVisibleRegion, oldCoveredRegion</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第二种情况:</span></span><br><span class="line">            <span class="comment">// 由于将一个应用程序窗口的当前可见区域减去被覆盖区域即为它的当前不被覆盖的区域newExposed</span></span><br><span class="line">            <span class="comment">// 同理上一次不被覆盖的区域oldExposed就是上一次可见区域减去上一次被覆盖区域</span></span><br><span class="line">            <span class="comment">// 那么将一个应用程序窗口的当前不被覆盖的区域newExposed减去它的上一次不被覆盖的区域oldExposed，就可以得到新增的不被覆盖区域</span></span><br><span class="line">            <span class="type">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">            <span class="type">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将第一部分和第二部分需要重新渲染的区域组合起来，就可以得到当前Layer的脏区域dirty。</span></span><br><span class="line">            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从该脏区域dirty减去上层的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 因为后者的渲染不需要当前Layer参与</span></span><br><span class="line">        dirty.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新的脏区域dirty累计到输出参数dirtyRegion中.</span></span><br><span class="line">        outDirtyRegion.<span class="built_in">orSelf</span>(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新计算到目前为止所得到的Layer的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 这个是方便下一层Layer的计算</span></span><br><span class="line">        aboveOpaqueLayers.<span class="built_in">orSelf</span>(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前正在处理的Layer的可见区域和被覆盖区域以及可见非透明区域.</span></span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleRegion</span>(visibleRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setCoveredRegion</span>(coveredRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(</span><br><span class="line">                visibleRegion.<span class="built_in">subtract</span>(transparentRegion));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前面所有的Layer组成的完全不透明区域aboveOpaqueLayers保存在输出参数opaqueRegion中</span></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>handleMessageRefresh – SF合成所有Layer大概步骤如下：</p>
<ol>
<li>preComposition<br>合成前遍历所有layer, 处理处于Drawing状态的Layer是否被更新了</li>
<li>rebuildLayerStacks<br>反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</li>
<li>calculateWorkingSet<br>这里建立HWC中的Layer列表： </li>
<li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li>
<li>将Layer的mActiveBuffer设置到HWComposer中</li>
<li>doComposition<br>正式的合成处理，使用渲染引擎合成所有layer，然后就是申请GraphicBuffer，向其中填充帧数据, 最终给到硬件帧缓冲区</li>
<li>postComposition &amp;&amp; clear mLayersWithQueuedFrames<br>回调每个layer的onPostComposition并清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</li>
</ol>
<p>大概流程搞清楚了，接下来细细分析比如GraphicBuffer和Fence机制的工作原理, 等等，HWC好像还没有了解，先看看这个是怎么工作的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[Android Synchronization Fences – An Introduction]<a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li>
<li>[Android 4.0.3 显示系统深入理解]<a href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li>
<li>[Clang 10 documentation ATTRIBUTES IN CLANG]<a href="https://clang.llvm.org/docs/AttributeReference.html">https://clang.llvm.org/docs/AttributeReference.html</a></li>
<li>[「Android」SurfaceFlinger分析]<a href="https://www.cnblogs.com/1996swg/p/9790209.html">https://www.cnblogs.com/1996swg/p/9790209.html</a></li>
<li>[显示系统：第005课_Vsync机制:第007节_rebuildLayerStacks源码分析]<a href="http://www.pianshen.com/article/8541345041/">http://www.pianshen.com/article/8541345041/</a></li>
<li>[Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析]<a href="https://blog.csdn.net/luoshengyang/article/details/8079456">https://blog.csdn.net/luoshengyang/article/details/8079456</a></li>
<li>[Android Region代码分析]<a href="https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t">https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t</a></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>SurfaceFlinger</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
        <tag>SurfaceFlinger</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(1)-环境配置</title>
    <url>/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是介绍如何在 ubuntu 机器上安装并编译Vulkan程序。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://vulkan.lunarg.com/doc/sdk/1.2.170.0/linux/getting_started.html">https://vulkan.lunarg.com/doc/sdk/1.2.170.0/linux/getting_started.html</a></li>
<li><a href="https://github.com/google/glog">https://github.com/google/glog</a></li>
<li>[pkg-config的用法]<a href="https://www.cnblogs.com/chris-cp/p/3580002.html">https://www.cnblogs.com/chris-cp/p/3580002.html</a></li>
<li>[解决&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libglog.so.0: error adding symbols: DSO missing from command line]<a href="https://blog.csdn.net/u010987458/article/details/72235408">https://blog.csdn.net/u010987458/article/details/72235408</a></li>
<li><a href="https://www.glfw.org/docs/3.3/build_guide.html#build_link_cmake_package">https://www.glfw.org/docs/3.3/build_guide.html#build_link_cmake_package</a></li>
<li>[GLFW]<a href="https://www.glfw.org/">https://www.glfw.org/</a></li>
<li>[GLM]<a href="https://github.com/g-truc/glm">https://github.com/g-truc/glm</a></li>
</ol>
<h1 id="一-准备环境"><a href="#一-准备环境" class="headerlink" title="一. 准备环境"></a>一. 准备环境</h1><h2 id="1-1-开发环境"><a href="#1-1-开发环境" class="headerlink" title="1.1 开发环境"></a>1.1 开发环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get dist-upgrade</span><br><span class="line">sudo apt-get install libglm-dev cmake libxcb-dri3-0 libxcb-present0 libpciaccess0 libpng-dev libxcb-keysyms1-dev libxcb-dri3-dev libx11-dev  libmirclient-dev libwayland-dev libxrandr-dev libxcb-ewmh-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install git libpython2.7</span><br></pre></td></tr></table></figure>

<h2 id="1-2-下载-SDK"><a href="#1-2-下载-SDK" class="headerlink" title="1.2 下载 SDK"></a>1.2 下载 SDK</h2><p>官方网站：<a href="https://vulkan.lunarg.com/">https://vulkan.lunarg.com/</a> 下载SDK包：vulkan-sdk.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/Program</span><br><span class="line">mkdir vulkan</span><br><span class="line">cd vulkan</span><br><span class="line">tar zxf $HOME/Downloads/vulkan-sdk.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压后的文件目录如下：</p>
<table>
<thead>
<tr>
<th>文件夹</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x86_64&#x2F;bin</td>
<td>Vulkan工具和命令</td>
</tr>
<tr>
<td>x86_64&#x2F;include&#x2F;vulkan</td>
<td>编译链接头文件</td>
</tr>
<tr>
<td>x86_64&#x2F;lib</td>
<td>Vulkan加载程序库和layer运行时库</td>
</tr>
<tr>
<td>x86_64&#x2F;etc&#x2F;explicit_layer.d</td>
<td>.json 用于Vulkan验证层的清单文件</td>
</tr>
<tr>
<td>config</td>
<td>样本层设置文件，系统配置说明</td>
</tr>
<tr>
<td>doc</td>
<td>Khronos SPIRV，Vulkan，Loader和WSI规范</td>
</tr>
<tr>
<td>examples</td>
<td>Vulkan程序示例</td>
</tr>
<tr>
<td>samples</td>
<td>Vulkan的示例代码</td>
</tr>
<tr>
<td>source</td>
<td>glslang和所选Vulkan组件的源和调试库</td>
</tr>
</tbody></table>
<h2 id="1-3-安装SDK"><a href="#1-3-安装SDK" class="headerlink" title="1.3 安装SDK"></a>1.3 安装SDK</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/Program/vulkan/1.2.170.0/setup-env.sh</span><br><span class="line"></span><br><span class="line">export VULKAN_SDK=~/vulkan/1.2.170.0/x86_64</span><br><span class="line">export PATH=$VULKAN_SDK/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$VULKAN_SDK/lib:$LD_LIBRARY_PATH</span><br><span class="line">export VK_LAYER_PATH=$VULKAN_SDK/etc/explicit_layer.d</span><br></pre></td></tr></table></figure>

<p>大功告成，检查一下：输入vulkaninfo<br><a href="mailto:&#117;&#98;&#117;&#110;&#x74;&#117;&#64;&#49;&#x38;&#46;&#48;&#x34;&#x4c;">&#117;&#98;&#117;&#110;&#x74;&#117;&#64;&#49;&#x38;&#46;&#48;&#x34;&#x4c;</a> ~  vulkaninfo<br>Cannot create Vulkan instance.<br>&#x2F;home&#x2F;lunarg&#x2F;sdk-build&#x2F;Vulkan-Tools&#x2F;vulkaninfo&#x2F;vulkaninfo.c:921: failed with VK_ERROR_INCOMPATIBLE_DRIVER</p>
<p>wtf, 发生了什么？等等，貌似我们没有检查是否安装了驱动。。。</p>
<h2 id="1-4-安装驱动"><a href="#1-4-安装驱动" class="headerlink" title="1.4 安装驱动"></a>1.4 安装驱动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:oibaf/graphics-drivers</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">apt install libvulkan1 mesa-vulkan-drivers vulkan-utils</span><br><span class="line"></span><br><span class="line">// 或者试试：</span><br><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install nvidia-graphics-drivers-396 nvidia-settings vulkan vulkan-utils</span><br></pre></td></tr></table></figure>
<p>检查一下：输入vulkaninfo</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_1.png" alt="图片"></p>
<p>或者：vulkaninfo –html , 在当前目录生成 vulkaninfo.html 文件，用浏览器打开，可以看到更多信息</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_2.png" alt="图片"></p>
<h2 id="1-5-运行示例程序"><a href="#1-5-运行示例程序" class="headerlink" title="1.5. 运行示例程序"></a>1.5. 运行示例程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Program/vulkan/1.1.160.0/examples</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>make成功后会在当前目录生成：</p>
<p><img src="/./images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_3.png" alt="图片"></p>
<p>运行示例程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./vkcube</span><br></pre></td></tr></table></figure>

<p><img src="/./images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_4.png" alt="图片"></p>
<p>一个旋转的立方体～</p>
<h1 id="二-GLFW-安装"><a href="#二-GLFW-安装" class="headerlink" title="二. GLFW 安装"></a>二. GLFW 安装</h1><p>Vulkan本身是一个与平台无关的API，不包括用于创建显示渲染结果的窗口的工具。 为了从Vulkan的跨平台优势中受益并避免X11的限制，我们将使用GLFW库来创建一个支持Windows，Linux和MacOS的窗口。<br>还有其他可用于此目的的库，如SDL，但GLFW的优势在于它除了窗口创建之外，还抽象了Vulkan中一些其他特定于平台的东西。<br>我们将从源代码安装GLFW而不是使用软件包，因为Vulkan支持需要最新版本。 可以在官方网站上找到这些来源。<br>将源代码解压缩到一个方便的目录，并使用CMakeLists.txt等文件打开目录中的终端。</p>
<p>github地址：<a href="https://github.com/glfw/glfw">https://github.com/glfw/glfw</a><br>解压后进入其主目录：cmake .<br>有报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- Looking <span class="keyword">for</span> shmat - found</span><br><span class="line">-- Found X11: /usr/lib/x86_64-linux-gnu/libX11.so</span><br><span class="line">CMake Error at CMakeLists.txt:<span class="number">220</span> (message):</span><br><span class="line">  The Xinerama headers were not found</span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also <span class="string">&quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeOutput.log&quot;</span>.</span><br><span class="line">See also <span class="string">&quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeError.log&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>缺少环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ~/Program/vulkan/glfw-master  sudo apt-get install libsdl2-dev</span><br></pre></td></tr></table></figure>

<p>然后重新: cmake .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">🦄  ~/Program/vulkan/glfw-master  cmake .</span><br><span class="line">-- Could NOT find <span class="title function_">Doxygen</span> <span class="params">(missing: DOXYGEN_EXECUTABLE)</span> </span><br><span class="line">-- Using X11 <span class="keyword">for</span> window creation</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/jh/Program/vulkan/glfw-master</span><br></pre></td></tr></table></figure>
<p>濡染没有报错，但这个也是没有成功的：缺少Doxygen<br>sudo apt-get install doxygen</p>
<p>重新: cmake .<br>最后: make<br>成功后：sudo make install</p>
<h1 id="三-GLM-安装"><a href="#三-GLM-安装" class="headerlink" title="三. GLM 安装"></a>三. GLM 安装</h1><p>与DirectX 12不同，Vulkan不包含用于线性代数运算的库，因此我们必须下载一个。<br>GLM是一个很好的库，设计用于图形API，也常用于OpenGL。<br>它是一个只有头的库，可以从libglm-dev包安装：</p>
<p>sudo apt install libglm-dev</p>
<h1 id="四-手动编译示例代码"><a href="#四-手动编译示例代码" class="headerlink" title="四. 手动编译示例代码"></a>四. 手动编译示例代码</h1><h2 id="4-1-在编译示例代码的时候老是报错，找不到vulkan头文件。"><a href="#4-1-在编译示例代码的时候老是报错，找不到vulkan头文件。" class="headerlink" title="4.1 在编译示例代码的时候老是报错，找不到vulkan头文件。"></a>4.1 在编译示例代码的时候老是报错，找不到vulkan头文件。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.cpp -lglfw3</span><br><span class="line">In file included from main.cpp:2:</span><br><span class="line">/usr/local/include/GLFW/glfw3.h:215:12: fatal error: vulkan/vulkan.h: 没有那个文件或目录</span><br><span class="line">   #include &lt;vulkan/vulkan.h&gt;</span><br><span class="line">            ^~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>

<p>当然是环境设置的问题：需要将头文件等拷贝到对应system文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Program/vulkan/1.2.170.0/x86_64</span><br><span class="line">sudo cp -r include/vulkan/ /usr/local/include/</span><br><span class="line">sudo cp -P lib/libvulkan.so* /usr/local/lib/</span><br><span class="line">sudo cp lib/libVkLayer_*.so /usr/local/lib/</span><br><span class="line">sudo mkdir -p /usr/local/share/vulkan/explicit_layer.d</span><br><span class="line">sudo cp etc/explicit_layer.d/VkLayer_*.json /usr/local/share/vulkan/explicit_layer.d    </span><br><span class="line"></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<h2 id="4-2-error-adding-symbols-DSO-missing-from-command-line"><a href="#4-2-error-adding-symbols-DSO-missing-from-command-line" class="headerlink" title="4.2 error adding symbols: DSO missing from command line"></a>4.2 error adding symbols: DSO missing from command line</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">g++ -std=c++17 -I/home/jh/Program/vulkan/1.1.160.0/x86_64/include -o VulkanTest main.cpp -L/home/jh/Program/vulkan/1.1.160.0/x86_64/lib -lvulkan -lglfw3</span><br><span class="line">/usr/bin/ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol &#x27;dlclose@@GLIBC_2.2.5&#x27;</span><br><span class="line">/usr/bin/ld: //lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command line</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [Makefile:8：VulkanTest] 错误 1</span><br></pre></td></tr></table></figure>

<p>cd &#x2F;usr&#x2F;lib&#x2F;<br>ll |grep -iE “liblog”<br>没有文件</p>
<p><a href="https://github.com/google/glog">https://github.com/google/glog</a><br>下载解压, 进入解压后的主目录，执行：<br>.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install</p>
<p>如果报错：autogen.sh: 5: autogen.sh: autoreconf: not found<br>sudo apt-get install autoconf<br>sudo apt-get install automake<br>sudo apt-get install libtool</p>
<p>重新执行：.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install<br>可能还有权限问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Up-to-date: /usr/local/include/GLFW</span><br><span class="line">CMake Error at cmake_install.cmake:41 (file):</span><br><span class="line">  file INSTALL cannot set permissions on &quot;/usr/local/include/GLFW&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make: *** [Makefile:118：install] 错误 1</span><br></pre></td></tr></table></figure>
<p>执行：<br>cd ..<br>chmod a+x glog-master -R<br>cd glog-master<br>make &amp;&amp; make install</p>
<p>okay,现在可以在Makefile文件中添加：-lglog</p>
<p>重新 make 还是会存在这个问题，笔者查阅各种资料，大部分指明在Makefile中加入 -ldl 即可，尝试后失败。<br>最后发现是 Makefile 文件写的有问题，改成如[#5.2]即可.</p>
<h2 id="4-3-运行示例"><a href="#4-3-运行示例" class="headerlink" title="4.3 运行示例"></a>4.3 运行示例</h2><p>make 成功后，会在当前目录生成 VulkanTest 可执行文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./VulkanTest</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="/./images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_5.png" alt="图片"></p>
<h1 id="五-主要代码"><a href="#五-主要代码" class="headerlink" title="五. 主要代码"></a>五. 主要代码</h1><h2 id="5-1-main-cpp"><a href="#5-1-main-cpp" class="headerlink" title="5.1 main.cpp"></a>5.1 main.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_RADIANS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_DEPTH_ZERO_TO_ONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/vec4.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/mat4x4.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Vulkan window&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> extensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; extensionCount &lt;&lt; <span class="string">&quot; extensions supported&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    glm::mat4 matrix;</span><br><span class="line">    glm::vec4 vec;</span><br><span class="line">    <span class="keyword">auto</span> test = matrix * vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Makefile"><a href="#5-2-Makefile" class="headerlink" title="5.2 Makefile"></a>5.2 Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64</span><br><span class="line"></span><br><span class="line">CFLAGS = -std=c++17 -I<span class="variable">$(VULKAN_SDK_PATH)</span>/<span class="keyword">include</span></span><br><span class="line">LDFLAGS = -L<span class="variable">$(VULKAN_SDK_PATH)</span>/lib -lvulkan `pkg-config --static --libs glfw3`</span><br><span class="line">LDFLAGS += -ldl</span><br><span class="line"></span><br><span class="line"><span class="section">VulkanTest: main.cpp</span></span><br><span class="line">	g++ <span class="variable">$(CFLAGS)</span> -o VulkanTest main.cpp <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: VulkanTest</span></span><br><span class="line">    LD_LIBRARY_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/lib</span><br><span class="line">        VK_LAYER_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/etc/explicit_layer.d ./VulkanTest</span><br><span class="line"></span><br><span class="line"><span class="section">clean:rm -f VulkanTest</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(10)-重建交换链</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-10-%E9%87%8D%E5%BB%BA%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在上一篇里，我们已经成功绘制了一个颜色渐变的三角形，并将其显示在窗口上了。但是窗口Surface可能会发生变化，从而使交换链不再与之兼容，比如是窗口大小的变化。所以我们必须捕获这些事件并重新创建交换链。</p>
<span id="more"></span>

<h1 id="一-重建交换链"><a href="#一-重建交换链" class="headerlink" title="一. 重建交换链"></a>一. 重建交换链</h1><p>创建一个新的recreateSwapChain函数，该函数调用createSwapChain和所有依赖于交换链或窗口大小的对象的创建函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待队列中所有操作完成</span></span><br><span class="line">    <span class="built_in">vkDeviceWaitIdle</span>(device);</span><br><span class="line">    <span class="comment">// 先清理后创建</span></span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createSwapChain</span>();</span><br><span class="line">    <span class="built_in">createImageViews</span>();</span><br><span class="line">    <span class="built_in">createRenderPass</span>();</span><br><span class="line">    <span class="built_in">createGraphicsPipeline</span>();</span><br><span class="line">    <span class="built_in">createFramebuffers</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用vkDeviceWaitIdle，确保不触及可能仍在使用的资源。显然，我们必须做的第一件事是重新创建交换链本身。</p>
<p>需要重新创建图像视图，因为它们直接基于交换链图像。渲染通道需要重新创建，因为它取决于交换链图像的格式。交换链的图像格式很少在窗口调整等操作期间发生改变，但它仍然应该被处理。视口和剪刀矩形大小是在图形管道创建时指定的，因此管道也需要重新构建。可以通过使用动态状态的视图和剪刀矩形来避免这种情况。最后，帧缓冲区和命令缓冲区也直接依赖于交换链图像。</p>
<p>为了确保这些对象的旧版本在重新创建它们之前得到清理，我们应该将一些清理代码移到一个单独的函数中，我们可以从recreateSwapChain函数调用这个函数cleanupSwapChain。</p>
<h2 id="1-1-cleanupSwapChain"><a href="#1-1-cleanupSwapChain" class="headerlink" title="1.1 cleanupSwapChain"></a>1.1 cleanupSwapChain</h2><p>将所有和交换链相关的资源从cleanup函数中移到此函数内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放所有的帧缓冲区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> framebuffer : swapChainFramebuffers) &#123;</span><br><span class="line">        <span class="built_in">vkDestroyFramebuffer</span>(device, framebuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放指令缓冲区</span></span><br><span class="line">    <span class="comment">// 可以从头重新创建命令池，但相当浪费。所以选择使用vkFreeCommandBuffers函数清理现有的命令缓冲区。</span></span><br><span class="line">    <span class="comment">// 这样可以重用现有的池来分配新的命令缓冲区。</span></span><br><span class="line">    <span class="built_in">vkFreeCommandBuffers</span>(device, commandPool,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(commandBuffers.<span class="built_in">size</span>()), commandBuffers.<span class="built_in">data</span>());</span><br><span class="line">    <span class="comment">// 销毁图形管道</span></span><br><span class="line">    <span class="built_in">vkDestroyPipeline</span>(device, graphicsPipeline, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 释放管道布局</span></span><br><span class="line">    <span class="built_in">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 释放渲染通道</span></span><br><span class="line">    <span class="built_in">vkDestroyRenderPass</span>(device, renderPass, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 释放交换链对应的图像视图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> imageView : swapChainImageViews) &#123;</span><br><span class="line">        <span class="built_in">vkDestroyImageView</span>(device, imageView, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放交换链</span></span><br><span class="line">    <span class="built_in">vkDestroySwapchainKHR</span>(device, swapChain, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从头重新创建命令池，但相当浪费。所以选择使用vkFreeCommandBuffers函数清理现有的命令缓冲区, 这样可以重用现有的池来分配新的命令缓冲区。</p>
<h2 id="1-2-获取窗口最新大小"><a href="#1-2-获取窗口最新大小" class="headerlink" title="1.2 获取窗口最新大小"></a>1.2 获取窗口最新大小</h2><p>为了正确地处理窗口的大小，我们还需要查询framebuffer的当前大小，以确保交换链图像具有(新的)正确的大小。为了做到这一点，改变chooseSwapExtent函数来考虑实际的大小:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择交换链分辨率</span></span><br><span class="line"><span class="function">VkExtent2D <span class="title">chooseSwapExtent</span><span class="params">(<span class="type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> capabilities.currentExtent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> width, height;</span><br><span class="line">        <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line"></span><br><span class="line">        VkExtent2D actualExtent = &#123;</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(width),</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(height)&#125;;</span><br><span class="line">        actualExtent.width = std::<span class="built_in">max</span>(capabilities.minImageExtent.width, std::<span class="built_in">min</span>(capabilities.maxImageExtent.width, actualExtent.width));</span><br><span class="line">        actualExtent.height = std::<span class="built_in">max</span>(capabilities.minImageExtent.height, std::<span class="built_in">min</span>(capabilities.maxImageExtent.height, actualExtent.height));</span><br><span class="line">        <span class="keyword">return</span> actualExtent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过glfwGetFramebufferSize函数来获取当前窗口大小。</p>
<p>这就是重建交换链所需要的全部!然而，这种方法的缺点是:需要在创建新的交换链之前停止所有的呈现。当从旧的交换链在图像上绘制命令时，可以创建一个新的交换链。需要将之前的交换链传递给VkSwapchainCreateInfoKHR结构中的oldswarechain字段，并在使用完旧的交换链后立即销毁它。</p>
<h2 id="1-3-次优或过时的交换链"><a href="#1-3-次优或过时的交换链" class="headerlink" title="1.3 次优或过时的交换链"></a>1.3 次优或过时的交换链</h2><p>现在，我们只需要确定何时需要重新创建交换链，并调用新的recreateSwapChain函数。幸运的是，Vulkan通常会告诉我们交换链在显示过程中不再足够。vkAcquireNextImageKHR和vkQueuePresentKHR函数可以返回以下特殊值来表示这一点:</p>
<ol>
<li>VK_ERROR_OUT_OF_DATE_KHR: 交换链已经变得与表面不兼容，不能再用于渲染。通常发生在窗口大小调整之后。</li>
<li>VK_SUBOPTIMAL_KHR:交换链仍然可以成功地呈现到表面，但是表面的属性不再完全匹配。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkResult result = <span class="built_in">vkAcquireNextImageKHR</span>(device, swapChain,</span><br><span class="line">        std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>(),</span><br><span class="line">        imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);</span><br><span class="line"><span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR) &#123;</span><br><span class="line">    <span class="built_in">recreateSwapChain</span>();</span><br><span class="line">    <span class="comment">// 已经获得了一个映像。VK_SUCCESS和VK_SUBOPTIMAL_KHR都被认为是“成功”返回码, 也可以去掉return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to acquire swap chain image!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果交换链在试图获取映像时已经过期，那么就不可能再向其呈现。因此，应该立即重新创建交换链，并在下一个drawFrame调用中再次尝试。然而，如果在这中止绘图，那么栅栏将永远不会通过vkqueuessubmit提交，当我们稍后尝试等待它时，它将处于一个意想不到的状态。我们可以重建fence作为交换链重建的一部分，但是移动vkResetFences调用更容易:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkResetFences</span>(device, <span class="number">1</span>, &amp;inFlightFences[currentFrame]);</span><br><span class="line"><span class="comment">// VkQueue是Vulkan中应用程序向GPU提交命令的唯一途径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把fence放在vkQueueSubmit之前，而不是在vkWaitForFences后立刻调用。这是什么原理呢？</p>
<h3 id="1-3-1-fence"><a href="#1-3-1-fence" class="headerlink" title="1.3.1 fence"></a>1.3.1 fence</h3><p>fence是一种同步原语，可用于将依赖项从队列插入到主机。fence有两种状态——有信号的和没有信号的, fence可以作为队列提交命令执行的一部分发出信号。</p>
<p>使用vkResetFences可以将fence置为unsignal状态。主机可以通过vkWaitForFences命令来等待fence，并且可以通过vkGetFenceStatus来查询当前的状态。</p>
<p>如果vkWaitForFences被调用时条件被满足，那么vkWaitForFences会立即返回。如果在vkWaitForFences被调用的时候条件没有被满足，那么vkWaitForFences将会阻塞并等待到超时纳秒，直到条件被满足。这里的条件就是fence状态是不是signal状态。vkQueueSubmit会将fence置为signal状态，那么vkWaitForFences就会通过。</p>
<p>所以，当vkWaitForFences之后立刻调用vkResetFences，那么当vkAcquireNextImageKHR发生异常导致返回时，下次在进入drawFrame调用vkWaitForFences就永远处于等待状态了。</p>
<h3 id="1-3-2-vkQueuePresentKHR"><a href="#1-3-2-vkQueuePresentKHR" class="headerlink" title="1.3.2 vkQueuePresentKHR"></a>1.3.2 vkQueuePresentKHR</h3><p>如果交换链不是最优的，也可以继续呈现，因为我们已经获得了一个映像。VK_SUCCESS和VK_SUBOPTIMAL_KHR都被认为是“成功”返回码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line"><span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) &#123;</span><br><span class="line">    <span class="built_in">recreateSwapChain</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (result != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to present swap chain image!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vkQueuePresentKHR函数返回具有相同含义的相同值。 在这种情况下，如果交换链不是次优的，为获得最好的结果，最好重新创建交换链。</p>
<h2 id="1-4-主动处理窗口变化"><a href="#1-4-主动处理窗口变化" class="headerlink" title="1.4 主动处理窗口变化"></a>1.4 主动处理窗口变化</h2><p>尽管许多驱动程序和平台在调整窗口大小后会自动触发VK_ERROR_OUT_OF_DATE_KHR，但不能保证一定会发生这种情况。所以最好通过监听窗口变化来主动重建交换链。</p>
<p>添加一个新的成员变量，该变量指示已调整大小：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> framebufferResized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    result = <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line">    <span class="keyword">if</span> (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) &#123;</span><br><span class="line">        framebufferResized = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">recreateSwapChain</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-1-监听窗口变化"><a href="#1-4-1-监听窗口变化" class="headerlink" title="1.4.1 监听窗口变化"></a>1.4.1 监听窗口变化</h3><p>要实际检测窗口大小调整，可以使用GLFW框架中的glfwSetFramebufferSizeCallback函数来设置回调：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line"></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, <span class="string">&quot;Vulkan&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glfwSetWindowUserPointer</span>(window, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">glfwSetFramebufferSizeCallback</span>(window, framebufferResizeCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">framebufferResizeCallback</span><span class="params">(GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> app = </span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(<span class="built_in">glfwGetWindowUserPointer</span>(window));</span><br><span class="line">    app-&gt;framebufferResized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为glfw回调只能通过静态函数实现，所以通过glfwSetWindowUserPointer保存当前实例指针。</p>
<h2 id="1-5-窗口最小化"><a href="#1-5-窗口最小化" class="headerlink" title="1.5 窗口最小化"></a>1.5 窗口最小化</h2><p>还有一种特殊状态是，当最小化窗口时，拿到的窗口大小是0, 这样创建出来的帧缓冲区大小也应该是0，根本不需要渲染。所以这里做一个简单的等待处理:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> width = <span class="number">0</span>, height = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">        <span class="built_in">glfwWaitEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vkDeviceWaitIdle</span>(device);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>突然有点好奇这个绘制的刷新率，通过在drawFrame里嵌入函数computeRefreshRate来计算刷新率:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">computeRefreshRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> fps = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int64_t</span> lastCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> lastTimestamp = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> now = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    now = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">float</span> duration = std::chrono::duration_cast&lt;std::chrono::duration&lt;<span class="type">float</span>&gt;&gt;(now-lastTimestamp).<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">if</span> (duration &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        lastTimestamp = now;</span><br><span class="line">        fps = (count - lastCount)/duration;</span><br><span class="line">        lastCount = count;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;computeRefreshRate: fps=&quot;</span>&lt;&lt;fps&lt;&lt;<span class="string">&quot;, count=&quot;</span>&lt;&lt;count&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算出来高达4k，看起来这个fence也并没有同步gpu显示，只是不停的提交。</p>
<p>那么如果我们想吧这个实时刷新率显示在我们程序的左上角，该怎么做呢? </p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(11)-顶点输入描述及顶点缓冲的创建</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>接下来，我们将用内存中的顶点缓冲区替换顶点着色器中的硬编码顶点数据。我们将从创建CPU可见缓冲区的最简单方法开始，并使用memcpy将顶点数据直接复制到其中，然后我们将看到如何使用分段缓冲区将顶点数据复制到高性能内存。</p>
<span id="more"></span>

<p>首先修改顶点着色器不再包含顶点数据在着色器代码本身， 顶点着色器使用in关键字从顶点缓冲区获取输入。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为fragColor</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inPosition和inColor变量是顶点属性。 它们是在顶点缓冲区中为每个顶点指定的属性，就像我们使用两个数组为每个顶点手动指定位置和颜色一样。 更改后记得重新编译顶点着色器！</p>
<p>像fragColor一样，layout（location &#x3D; x）批注为输入分配索引，我们之后可以使用索引来引用它们。 重要的是要知道某些类型（例如dvec3 64位向量）使用多个插槽。 这意味着之后的索引必须至少高2倍（这里没搞懂, 需要学习一下GLSL的语法:<a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)%EF%BC%89%EF%BC%9A">https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)）：</a></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">dvec3</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br></pre></td></tr></table></figure>

<h1 id="一-顶点数据"><a href="#一-顶点数据" class="headerlink" title="一. 顶点数据"></a>一. 顶点数据</h1><p>将顶点数据从着色器代码移动到程序代码中的数组中。需要引入GLM库，它为我们提供了与线性代数相关的类型，如向量和矩阵, 有与着色器语言中使用的向量类型完全匹配的c++类型。我们将使用这些类型来指定位置和颜色向量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">0.0f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建一个名为Vertex的新结构，内有两个属性，我们将在其内部的顶点着色器中使用. 使用顶点结构来指定顶点数据的数组。我们使用和之前完全相同的位置和颜色值，但现在它们被组合到一个顶点数组中, 这就是所谓的交错顶点(interleaving vertex)属性。</p>
<p>接下来是告诉Vulkan，一旦数据格式被上传到GPU内存，如何将其传递到顶点着色器。而传达这个信息需要有两种类型的结构: VkVertexInputBindingDescription和VkVertexInputAttributeDescription.</p>
<h2 id="1-1-绑定描述"><a href="#1-1-绑定描述" class="headerlink" title="1.1 绑定描述"></a>1.1 绑定描述</h2><p>第一个结构是VkVertexInputBindingDescription，我们将向顶点结构添加一个成员函数，用正确的数据填充它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> bindingDescription;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-1-VkVertexInputBindingDescription"><a href="#1-1-1-VkVertexInputBindingDescription" class="headerlink" title="1.1.1 VkVertexInputBindingDescription"></a>1.1.1 VkVertexInputBindingDescription</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputBindingDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>             binding;</span><br><span class="line">    <span class="type">uint32_t</span>             stride;</span><br><span class="line">    VkVertexInputRate    inputRate;</span><br><span class="line">&#125; VkVertexInputBindingDescription;</span><br></pre></td></tr></table></figure>
<ol>
<li>binding: 该结构描述的绑定号</li>
<li>stride : 是缓冲区中两个连续元素之间的距离(以字节为单位)</li>
<li>inputRate: 是一个VkVertexInputRate值，指定顶点属性寻址是顶点索引还是实例索引的函数<ol>
<li>VK_VERTEX_INPUT_RATE_VERTEX: 指定顶点属性寻址是顶点索引的函数，即移动到每个顶点后的下一个数据项</li>
<li>VK_VERTEX_INPUT_RATE_INSTANCE: 指定顶点属性寻址是实例索引的函数，即移到每个实例之后的下一个数据项</li>
</ol>
</li>
</ol>
<p>顶点绑定描述在所有顶点中从内存加载数据的速率。它指定数据条目之间的字节数，以及是在每个顶点之后还是在每个实例之后移动到下一个数据条目。</p>
<h3 id="1-1-2-绑定"><a href="#1-1-2-绑定" class="headerlink" title="1.1.2 绑定"></a>1.1.2 绑定</h3><p>所有的顶点数据都打包在一个数组中，所以我们只需要一个绑定:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">    bindingDescription.binding = <span class="number">0</span>;</span><br><span class="line">    bindingDescription.stride = <span class="built_in">sizeof</span>(Vertex);</span><br><span class="line">    bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bindingDescription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-属性描述"><a href="#1-2-属性描述" class="headerlink" title="1.2 属性描述"></a>1.2 属性描述</h2><p>第二个描述如何处理顶点输入的结构是VkVertexInputAttributeDescription。我们将添加另一个辅助函数到顶点来填充这些结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> bindingDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="title">getAttributeDescriptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> attributeDescriptions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正如函数原型所表明的，有两个VkVertexInputAttributeDescription,分别代表位置和颜色。</p>
<p>属性描述结构描述如何从源自绑定描述的顶点数据块中提取顶点属性。</p>
<h3 id="1-2-1-VkVertexInputAttributeDescription"><a href="#1-2-1-VkVertexInputAttributeDescription" class="headerlink" title="1.2.1 VkVertexInputAttributeDescription"></a>1.2.1 VkVertexInputAttributeDescription</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputAttributeDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>    location;</span><br><span class="line">    <span class="type">uint32_t</span>    binding;</span><br><span class="line">    VkFormat    format;</span><br><span class="line">    <span class="type">uint32_t</span>    offset;</span><br><span class="line">&#125; VkVertexInputAttributeDescription;</span><br></pre></td></tr></table></figure>
<ol>
<li>location: 属性的着色器绑定位置号</li>
<li>binding: 该属性获取其数据的绑定号</li>
<li>format: 指顶点属性数据的大小和类型, 应使用颜色通道数量与着色器数据类型中的组件数量相匹配的格式<ol>
<li>float: VK_FORMAT_R32_SFLOAT</li>
<li>vec2: VK_FORMAT_R32G32_SFLOAT</li>
<li>vec3: VK_FORMAT_R32G32B32_SFLOAT</li>
<li>vec4: VK_FORMAT_R32G32B32A32_SFLOAT</li>
</ol>
</li>
<li>offset: 该属性相对于顶点输入绑定中元素开始的字节偏移量</li>
</ol>
<h3 id="1-2-2-绑定"><a href="#1-2-2-绑定" class="headerlink" title="1.2.2 绑定"></a>1.2.2 绑定</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="title">getAttributeDescriptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position</span></span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].binding = <span class="number">0</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].location = <span class="number">0</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;</span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].offset = <span class="built_in">offsetof</span>(Vertex, pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// color</span></span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].binding = <span class="number">0</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].location = <span class="number">1</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;</span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].offset = <span class="built_in">offsetof</span>(Vertex, color);</span><br><span class="line">    <span class="keyword">return</span> attributeDescriptions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里offsetof函数是用来获取偏移量的。</p>
<h2 id="1-3-管道输入顶点"><a href="#1-3-管道输入顶点" class="headerlink" title="1.3 管道输入顶点"></a>1.3 管道输入顶点</h2><p>现在需要通过引用createGraphicsPipeline中的结构来设置图形管道以接受这种格式的顶点数据。找到vertexInputInfo结构体并修改它以引用以下两种描述:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> bindingDescription = Vertex::<span class="built_in">getBindingDescription</span>();</span><br><span class="line"><span class="keyword">auto</span> attributeDescriptions = Vertex::<span class="built_in">getAttributeDescriptions</span>();</span><br><span class="line">vertexInputInfo.vertexBindingDescriptionCount = <span class="number">1</span>;</span><br><span class="line">vertexInputInfo.vertexAttributeDescriptionCount =</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(attributeDescriptions.<span class="built_in">size</span>());</span><br><span class="line">vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;</span><br><span class="line">vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>
<p>管道现在已经准备好接受顶点容器格式的顶点数据，并将其传递给顶点着色器。</p>
<p>如果在启用验证层的情况下运行程序，将报出没有顶点缓冲区绑定到绑定。下一步是创建一个顶点缓冲区，并将顶点数据移动到其中，以便GPU能够访问它。</p>
<h1 id="二-顶点缓冲区"><a href="#二-顶点缓冲区" class="headerlink" title="二. 顶点缓冲区"></a>二. 顶点缓冲区</h1><p>Vulkan中的缓冲区是用于存储任意数据的内存区域，这些数据可以被显卡读取，通过描述符集或特定命令将它们绑定到图形或计算管道，或者直接将它们指定为特定命令的参数。它们可以用来存储顶点数据，但也可以用于许多其他目的，以后中探讨。</p>
<p>与我们目前处理的Vulkan对象不同，缓冲区不会自动为自己分配内存， Vulkan API让程序员控制了几乎所有的事情，内存管理就是其中之一。</p>
<h2 id="2-1-创建缓冲区"><a href="#2-1-创建缓冲区" class="headerlink" title="2.1 创建缓冲区"></a>2.1 创建缓冲区</h2><p>创建一个新的函数createVertexBuffer，并在createCommandBuffers之前从initVulkan调用它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createCommandPool</span>();</span><br><span class="line">    <span class="comment">// 有可能使用指令，所以需要在指令池创建之后创建</span></span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">    <span class="built_in">createSyncObjects</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建顶点缓冲区需要填充VkBufferCreateInfo结构。</p>
<h3 id="2-1-1-VkBufferCreateInfo"><a href="#2-1-1-VkBufferCreateInfo" class="headerlink" title="2.1.1 VkBufferCreateInfo"></a>2.1.1 VkBufferCreateInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkBufferCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*            pNext;</span><br><span class="line">    VkBufferCreateFlags    flags;</span><br><span class="line">    VkDeviceSize           size;</span><br><span class="line">    VkBufferUsageFlags     usage;</span><br><span class="line">    VkSharingMode          sharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>               queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*        pQueueFamilyIndices;</span><br><span class="line">&#125; VkBufferCreateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 结构体类型, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>flags: VkBufferCreateFlagBits的位掩码，指定缓冲区的附加参数, 用于配置稀疏缓冲区内存</li>
<li>size:  是要创建的缓冲区的大小(以字节为单位)</li>
<li>usage: VkBufferUsageFlagBits的位掩码，指定缓冲区允许的用法</li>
<li>sharingMode: VkSharingMode值，指定当多个队列族访问缓冲区时，缓冲区的共享模式<ol>
<li>VK_SHARING_MODE_EXCLUSIVE:  指定对对象的任何范围或图像子资源的访问一次只能由单个队列族独占</li>
<li>VK_SHARING_MODE_CONCURRENT: 指定支持对来自多个队列族的对象的任何范围或映像子资源的并发访问</li>
</ol>
</li>
<li>queueFamilyIndexCount: 是pQueueFamilyIndices数组中的数量</li>
<li>pQueueFamilyIndices: 将访问这个缓冲区的队列族列表(如果shareingmode不是VK_SHARING_MODE_CONCURRENT则忽略)</li>
</ol>
<h3 id="2-1-2-vkCreateBuffer"><a href="#2-1-2-vkCreateBuffer" class="headerlink" title="2.1.2 vkCreateBuffer"></a>2.1.2 vkCreateBuffer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferCreateInfo*                   pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer*                                   pBuffer)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建缓冲区对象的逻辑设备</li>
<li>pCreateInfo: 指向VkBufferCreateInfo结构的指针，该结构包含影响缓冲区创建的参数</li>
<li>pAllocator: 控制主机内存分配</li>
<li>pBuffer: 指向VkBuffer句柄的指针，在该句柄中返回结果缓冲区对象</li>
</ol>
<p>VkBuffer缓冲区表示用于各种目的的数据的线性数组，通过描述符集或特定命令将它们绑定到图形或计算管道，或者直接将它们指定为特定命令的参数。</p>
<p>缓冲区由VkBuffer句柄表示：</p>
<h3 id="2-1-3-createVertexBuffer"><a href="#2-1-3-createVertexBuffer" class="headerlink" title="2.1.3 createVertexBuffer"></a>2.1.3 createVertexBuffer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkBuffer vertexBuffer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkBufferCreateInfo bufferInfo = &#123;&#125;;</span><br><span class="line">    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;</span><br><span class="line">    bufferInfo.size = <span class="built_in">sizeof</span>(vertices[<span class="number">0</span>]) * vertices.<span class="built_in">size</span>();</span><br><span class="line">    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;</span><br><span class="line">    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="literal">nullptr</span>, &amp;vertexBuffer) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create vertex buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建后不需要时应该手动销毁:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, vertexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-给顶点缓冲区分配内存"><a href="#2-2-给顶点缓冲区分配内存" class="headerlink" title="2.2 给顶点缓冲区分配内存"></a>2.2 给顶点缓冲区分配内存</h2><p>缓冲区已创建，但实际上尚未分配任何内存。为缓冲区分配内存的第一步是使用vkGetBufferMemoryRequirements函数查询其内存需求.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkMemoryRequirements memRequirements;</span><br><span class="line"><span class="built_in">vkGetBufferMemoryRequirements</span>(device, vertexBuffer, &amp;memRequirements);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-vkGetBufferMemoryRequirements"><a href="#2-2-1-vkGetBufferMemoryRequirements" class="headerlink" title="2.2.1 vkGetBufferMemoryRequirements"></a>2.2.1 vkGetBufferMemoryRequirements</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkGetBufferMemoryRequirements</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkMemoryRequirements*                       pMemoryRequirements)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建缓冲区对象的逻辑设备</li>
<li>buffer: 待请求所需内存大小的缓冲区</li>
<li>pMemoryRequirements: 指向VkMemoryRequirements结构的指针，在该结构中返回缓冲区对象的内存需求</li>
</ol>
<h3 id="2-2-2-VkMemoryRequirements"><a href="#2-2-2-VkMemoryRequirements" class="headerlink" title="2.2.2 VkMemoryRequirements"></a>2.2.2 VkMemoryRequirements</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryRequirements</span> &#123;</span><br><span class="line">    VkDeviceSize    size;</span><br><span class="line">    VkDeviceSize    alignment;</span><br><span class="line">    <span class="type">uint32_t</span>        memoryTypeBits;</span><br><span class="line">&#125; VkMemoryRequirements;</span><br></pre></td></tr></table></figure>
<ol>
<li>size: 资源所需的内存分配的大小（以字节为单位）</li>
<li>alignment: 资源所需的分配内偏移量的对齐（以字节为单位）,即缓冲区在分配的内存区域中开始的偏移量</li>
<li>memoryTypeBits: 适合缓冲区的内存类型的位字段</li>
</ol>
<h3 id="2-2-3-findMemoryType"><a href="#2-2-3-findMemoryType" class="headerlink" title="2.2.3 findMemoryType"></a>2.2.3 findMemoryType</h3><p>图形显卡可以提供不同类型的内存进行分配。每种类型的内存在允许的操作和性能特性方面都有所不同。</p>
<p>我们需要结合缓冲区的需求和我们自己的应用程序需求来找到合适的内存类型。为此，我们创建一个新函数findMemoryType:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">findMemoryType</span><span class="params">(<span class="type">uint32_t</span> typeFilter, VkMemoryPropertyFlags properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先获取物理显卡支持的内存类型</span></span><br><span class="line">    VkPhysicalDeviceMemoryProperties memProperties;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceMemoryProperties</span>(physicalDevice, &amp;memProperties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; memProperties.memoryTypeCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeFilter &amp; (<span class="number">1</span> &lt;&lt; i) &amp;&amp;</span><br><span class="line">                <span class="comment">// 可能有多个属性</span></span><br><span class="line">                (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to find suitable memory type!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>typeFilter参数用于指定适合的内存类型的位字段。</p>
<h4 id="2-2-3-1-VkPhysicalDeviceMemoryProperties"><a href="#2-2-3-1-VkPhysicalDeviceMemoryProperties" class="headerlink" title="2.2.3.1 VkPhysicalDeviceMemoryProperties"></a>2.2.3.1 VkPhysicalDeviceMemoryProperties</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPhysicalDeviceMemoryProperties</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>        memoryTypeCount;</span><br><span class="line">    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];</span><br><span class="line">    <span class="type">uint32_t</span>        memoryHeapCount;</span><br><span class="line">    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];</span><br><span class="line">&#125; VkPhysicalDeviceMemoryProperties;</span><br></pre></td></tr></table></figure>
<ol>
<li>memoryTypeCount: memoryTypes数组中的有效元素数。</li>
<li>memoryTypes: VK_MAX_MEMORY_TYPES_Vk MemoryType结构数组，描述可用于访问从memoryHeaps指定的堆中分配的内存的内存类型。</li>
<li>memoryHeapCount: memoryHeaps数组中的有效元素数。</li>
<li>memoryHeaps: VK_MAX_MEMORY_HEAPS VkMemoryHeap结构的数组，描述可以从中分配内存的内存堆。</li>
</ol>
<p>VkPhysicalDeviceMemoryProperties结构描述了许多内存堆以及一些内存类型，这些内存类型可用于访问这些堆中分配的内存。每个堆描述特定大小的内存资源，每个内存类型描述一组内存属性（例如，主机缓存与未缓存），这些属性可以与给定内存堆一起使用。使用特定内存类型的分配将消耗该内存类型的堆索引指示的堆中的资源。多个内存类型可以共享每个堆，堆和内存类型提供了一种机制，以宣告物理内存资源的精确大小，同时允许将内存与各种不同的属性一起使用。</p>
<h3 id="2-2-4-分配内存"><a href="#2-2-4-分配内存" class="headerlink" title="2.2.4 分配内存"></a>2.2.4 分配内存</h3><p>通过findMemoryType, 现在可以获取正确的内存类型，接下来就是给VkBuffer分配内存了。</p>
<p>不同类型的内存具有不同的属性。一些类型的内存可以被CPU访问，一些不可以。一些类型可以在GPU和CPU间保持数据一致性、一些类型可以被CPU缓存使用等等。可以通过查询物理设备获取这些信息。我们可以根据需要使用不同的内存类型，比如对于暂存资源，我们需要使用可以被CPU访问的内存类型。对于用于渲染的图像、顶点数据，我们通常为其分配GPU内存。</p>
<p>内存分配现在只需指定大小和类型就可以了，这两种类型都来自于顶点缓冲区的内存需求和所需的属性。创建一个类成员来将句柄存储到内存中，并用vkallocatemory分配它。</p>
<h4 id="2-2-4-1-VkMemoryAllocateInfo"><a href="#2-2-4-1-VkMemoryAllocateInfo" class="headerlink" title="2.2.4.1 VkMemoryAllocateInfo"></a>2.2.4.1 VkMemoryAllocateInfo</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*        pNext;</span><br><span class="line">    VkDeviceSize       allocationSize;</span><br><span class="line">    <span class="type">uint32_t</span>           memoryTypeIndex;</span><br><span class="line">&#125; VkMemoryAllocateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 结构体类型, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>allocationSize: 内存分配大小，以字节为单位</li>
<li>memoryTypeIndex: 内存类型的索引，VkPhysicalDeviceMemoryProperties结构的memoryTypes数组中的数据</li>
</ol>
<h4 id="2-2-4-2-内存分配"><a href="#2-2-4-2-内存分配" class="headerlink" title="2.2.4.2 内存分配"></a>2.2.4.2 内存分配</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex = <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits,</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;vertexBufferMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate vertex buffer memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存对象对设备内存中的数据进行操作可以使用vkAllocateMemory函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkMemoryAllocateInfo*                 pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory*                             pMemory)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 是拥有内存的逻辑设备</li>
<li>pAllocateInfo: 指向描述分配参数的VkMemoryAllocateInfo结构的指针。成功返回的分配必须使用请求的参数 - 实现不允许替换。</li>
<li>pAllocator: 控制内存分配</li>
<li>pMemory: 指向VkDeviceMemory句柄的指针，在该句柄中返回有关已分配内存的信息</li>
</ol>
<p>vkallocatemory返回的分配保证满足实现的任何对齐要求。例如，如果一个实现需要128字节的图像对齐和64字节的缓冲区对齐，那么通过这个机制返回的设备内存将是128字节对齐的。这确保了应用程序可以在同一内存对象中正确地子分配不同类型的对象（具有可能不同的对齐要求）。</p>
<h4 id="2-2-4-3-内存与缓冲区关联"><a href="#2-2-4-3-内存与缓冲区关联" class="headerlink" title="2.2.4.3 内存与缓冲区关联"></a>2.2.4.3 内存与缓冲区关联</h4><p>如果内存分配成功，那么可以使用vkBindBufferMemory将此内存与缓冲区关联：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkBindBufferMemory</span>(device, vertexBuffer, vertexBufferMemory, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>要将内存附加到缓冲区对象可以调用vkBindBufferMemory函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkBindBufferMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                memoryOffset)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 是拥有内存的逻辑设备</li>
<li>buffer: 要附加到内存的缓冲区</li>
<li>memory: 描述要附加的设备内存的VkDeviceMemory对象</li>
<li>memoryOffset: 要绑定到缓冲区的内存区域的起始偏移量。因为这个内存被专门分配给这个顶点缓冲区，所以偏移量是0。如果偏移量不为零，则要求它可以被整除内存memRequirements.alignment.</li>
</ol>
<p>一旦缓冲区不再使用，绑定到缓冲区对象的内存可能会被释放，因此让我们在缓冲区被销毁后释放它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 vulkan 中推荐在创建的资源不需要后主动释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理交换链关联资源</span></span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="comment">// 清理顶点缓冲区</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, vertexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, vertexBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-填充顶点缓冲区"><a href="#2-3-填充顶点缓冲区" class="headerlink" title="2.3 填充顶点缓冲区"></a>2.3 填充顶点缓冲区</h2><p>现在是时候将顶点数据复制到缓冲区了。可以通过使用vkMapMemory将缓冲内存映射到CPU可访问内存来实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkMapMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                size,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkMemoryMapFlags                            flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>**                                      ppData)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 拥有内存的逻辑设备</li>
<li>memory: 要映射的VkDeviceMemory对象</li>
<li>offset: 从内存对象开始的以零为基础的字节偏移量</li>
<li>size:  映射的内存范围的大小，或者是要从偏移量映射到分配末尾的VK_WHOLE_SIZE大小</li>
<li>flags: 保留供将来使用</li>
<li>ppData: 指向void*变量的指针，指向映射内存的指针的输出。在该变量中返回指向映射范围开头的主机可访问指针。此指针减去偏移量必须至少与VkPhysicalDeviceLimits:：minMemoryMapAlignment对齐</li>
</ol>
<p>此函数允许我们访问由偏移量和大小定义的指定内存资源区域:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* data;</span><br><span class="line"><span class="comment">// 将缓冲内存映射到CPU可访问内存</span></span><br><span class="line"><span class="built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="number">0</span>, bufferInfo.size, <span class="number">0</span>, &amp;data);</span><br><span class="line"><span class="comment">// 将顶点数据拷贝到映射内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferInfo.size);</span><br><span class="line"><span class="comment">// 使用vkUnmapMemory再次取消映射</span></span><br><span class="line"><span class="built_in">vkUnmapMemory</span>(device, vertexBufferMemory);</span><br></pre></td></tr></table></figure>

<p>填充顶点数据到缓冲区内存的方式就是先映射然后拷贝，最后解映射。</p>
<p>但是驱动程序可能不会立即将数据复制到缓冲区内存中，例如因为缓存(Cache)机制。有两种方法可以解决这个问题：</p>
<ol>
<li>缓存的内存类型使用主机相关的内存堆，用VK_MEMORY_PROPERTY_HOST_COHERENT_BIT表示</li>
<li>在写入映射内存后调用vkFlushMappedMemoryRanges以及在从映射内存读取之前调用vkInvalidateMappedMemoryRanges</li>
</ol>
<p>对于CPU可以访问的内存类型，可以使用vkMapMemory&#x2F;vkUnmapMemory函数对其进行映射。这一映射是持久化的，只要进行了正确的同步，可以在GPU使用这一内存区域时访问它。</p>
<p>vkMapMemory函数返回的指针可以被保存使用，只要进行了正确的同步，甚至可以在GPU使用这一内存区域时对其进行写入操作，同步规则可以保证CPU不会写入数据到GPU正在使用的那部分内存。</p>
<p>这里我们采用第一个方式实现，确保映射内存始终与分配内存的内容匹配。</p>
<p>刷新内存范围或使用一致的内存堆意味着驱动程序将知道我们对缓冲区的写入，但这并不意味着它们在GPU上实际上是可见的。将数据传输到GPU是一个在后台发生的操作，规范简单地告诉我们，它保证在下一次调用vkQueueSubmit时完成。</p>
<h2 id="2-4-绑定顶点缓冲区"><a href="#2-4-绑定顶点缓冲区" class="headerlink" title="2.4 绑定顶点缓冲区"></a>2.4 绑定顶点缓冲区</h2><p>现在我们有了顶点缓冲区，也分配了内存并填充了顶点数据，就剩下在渲染操作期间绑定顶点缓冲区。</p>
<p>通过扩展createCommandBuffers函数来实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindPipeline</span>(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);</span><br><span class="line"></span><br><span class="line">VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;</span><br><span class="line">VkDeviceSize offsets[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vkCmdBindVertexBuffers</span>(commandBuffers[i], <span class="number">0</span>, <span class="number">1</span>, vertexBuffers, offsets);</span><br><span class="line"><span class="built_in">vkCmdDraw</span>(commandBuffers[i], <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(vertices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkCmdEndRenderPass</span>(commandBuffers[i]);</span><br></pre></td></tr></table></figure>

<p>将顶点缓冲区绑定到命令缓冲区，以便在后续绘制命令中使用，需要使用vkCmdBindVertexBuffers:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindVertexBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstBinding,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    bindingCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBuffer*                             pBuffers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDeviceSize*                         pOffsets)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer: 记录命令的命令缓冲区。</li>
<li>firstBinding: 第一个顶点输入绑定的索引，其状态由命令更新。</li>
<li>bindingCount: 状态由命令更新的顶点输入绑定数</li>
<li>pBuffers: 指向缓冲区句柄数组的指针。</li>
<li>pOffsets: 指向缓冲区偏移量数组的指针。</li>
</ol>
<p>从pBuffers和poffset的元素i获取的值替换了顶点输入绑定firstBinding+i的当前状态，即[0，bindingCount]中的i。顶点输入绑定将更新为从缓冲区pBuffers[i]开始的由pOffsets[i]指示的偏移处开始。所有使用这些绑定的顶点输入属性都将在后续绘制命令的地址计算中使用这些更新的地址。</p>
<h1 id="三-根据鼠标移动变化颜色"><a href="#三-根据鼠标移动变化颜色" class="headerlink" title="三. 根据鼠标移动变化颜色"></a>三. 根据鼠标移动变化颜色</h1><p>现在我们完成了从硬编码的顶点输入转为程序内的顶点数据输入， 更改vertices就可以看到颜色有变化，比如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">0.0f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的图形就是: </p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/Vulkan_11_1.png" alt="图形"></p>
<p>现在我们动手做根据鼠标移动动态变化颜色:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="built_in">initGlfwInput</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initGlfwInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册鼠标位置监听</span></span><br><span class="line">    <span class="built_in">glfwSetCursorPosCallback</span>(window, cursor_position_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cursor_position_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> app = <span class="built_in">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(<span class="built_in">glfwGetWindowUserPointer</span>(window));</span><br><span class="line">    <span class="keyword">if</span> (app-&gt;widthOfWindow != <span class="number">0</span> &amp;&amp; app-&gt;heightOfWindow != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> xP = xpos/app-&gt;widthOfWindow;</span><br><span class="line">        <span class="type">float</span> yP = ypos/app-&gt;heightOfWindow;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> x = xP * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="type">float</span> y = yP * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        app-&gt;vertices = &#123;</span><br><span class="line">            &#123;&#123;x, y&#125;, &#123;xP, xP, xP&#125;&#125;,</span><br><span class="line">            &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;yP, yP, yP&#125;&#125;,</span><br><span class="line">            &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 顶点数据变化后，重新拷贝至内存中</span></span><br><span class="line">        app-&gt;<span class="built_in">reMemcpyVertexBuffer</span>(<span class="built_in">sizeof</span>(app-&gt;vertices[<span class="number">0</span>]) * app-&gt;vertices.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reMemcpyVertexBuffer</span><span class="params">(VkDeviceSize size)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="number">0</span>, size, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) size);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, vertexBufferMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的结果:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/Vulkan_11_2.png" alt="图片"></p>
<p>哈哈，有那么回事了，第一个顶点会跟随鼠标移动而移动，并且三角形也会变幻颜色, 不过这里只是简单的处理，甚至没有考虑同步问题。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(12)-暂存缓冲和索引缓冲</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>虽然现在我们创建的顶点缓冲区工作正常，但是从CPU访问它的内存类型可能不是图形显卡本身读取的最佳内存类型，最理想的内存具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT位标志，并且通常不可由专用图形显卡上的CPU访问。而且我们上一篇最后实现的随鼠标移动的功能也没有考虑同步，简单一点，考虑读写分离。</p>
<p>现在创建两个顶点缓冲区：CPU可访问内存中的一个暂存缓冲区用于从顶点数组上传数据，最终顶点缓冲区位于设备本地内存中。然后我们将使用一个缓冲区复制命令将数据从暂存缓冲区移动到实际的顶点缓冲区。简单来说就是暂存缓冲区用于cpu写入，顶点缓冲区用于GPU读取数据。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>Vulkan coordinate system <a href="http://vulkano.rs/guide/vertex-input">http://vulkano.rs/guide/vertex-input</a></li>
</ol>
<h1 id="一-传输队列"><a href="#一-传输队列" class="headerlink" title="一. 传输队列"></a>一. 传输队列</h1><p>buffer copy命令需要支持传输操作的队列族，使用VK_QUEUE_TRANSFER_BIT表示。不过任何具有VK_QUEUE_GRAPHICS_BIT或VK_QUEUE_COMPUTE_BIT功能的队列家族都已经隐式支持VK_QUEUE_TRANSFER_BIT操作。在这些情况下，不需要实现在queueFlags中显式地列出它。</p>
<p>但可以尝试使用专门用于传输操作的不同队列族， 可以如下操作:</p>
<ol>
<li>修改QueueFamilyIndices和findQueueFamilies来显式地查找具有VK_QUEUE_TRANSFER位的队列族，而不是VK_QUEUE_GRAPHICS_BIT位</li>
<li>修改createLogicalDevice以请求传输队列的句柄</li>
<li>为传输队列系列上提交的命令缓冲区创建第二个命令池</li>
<li>修改资源的共享模式为VK_SHARING_MODE_CONCURRENT，并指定图形和传输队列族</li>
<li>提交传输命令，如vkCmdCopyBuffer到传输队列，而不是图形队列</li>
</ol>
<h1 id="二-暂存缓冲区"><a href="#二-暂存缓冲区" class="headerlink" title="二. 暂存缓冲区"></a>二. 暂存缓冲区</h1><p>因为我们要创建多个VkBuffer，所以最好把共有的部分抽出，以避免代码累赘:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入必要参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBuffer</span><span class="params">(VkDeviceSize size, VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkMemoryPropertyFlags properties, VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDeviceMemory&amp; bufferMemory, VkSharingMode mode)</span> </span>&#123;</span><br><span class="line">    VkBufferCreateInfo bufferInfo = &#123;&#125;;</span><br><span class="line">    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;</span><br><span class="line">    bufferInfo.size = size;</span><br><span class="line">    bufferInfo.usage = usage;</span><br><span class="line">    bufferInfo.sharingMode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="literal">nullptr</span>, &amp;buffer) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create vertex buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkMemoryRequirements memRequirements;</span><br><span class="line">    <span class="built_in">vkGetBufferMemoryRequirements</span>(device, buffer, &amp;memRequirements);</span><br><span class="line"></span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex = <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;bufferMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate vertex buffer memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vkBindBufferMemory</span>(device, buffer, bufferMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(vertices[<span class="number">0</span>]) * vertices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的MEMORY_PROPERTY是VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT！</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |</span><br><span class="line">            VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            vertexBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们需要使用传输队列，所以注意stagingBuffer的usage是用的VK_BUFFER_USAGE_TRANSFER_SRC_BIT，而vertexBuffer现在用的是VK_BUFFER_USAGE_TRANSFER_DST_BIT！</p>
<p>vertexBuffer现在从设备本地的内存类型分配，这意味着我们不能使用vkMapMemory。但是，我们可以将数据从stagingBuffer复制到vertexBuffer。我们必须通过指定stagingBuffer的传输源标志和vertexBuffer的传输目标标志以及顶点缓冲区使用标志来表明我们打算这样做。</p>
<h2 id="2-1-VkBufferUsageFlagBits"><a href="#2-1-VkBufferUsageFlagBits" class="headerlink" title="2.1 VkBufferUsageFlagBits"></a>2.1 VkBufferUsageFlagBits</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkBufferUsageFlagBits</span> &#123;</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFER_DST_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = <span class="number">0x00020000</span>,</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,</span><br><span class="line">    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,</span><br><span class="line">    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkBufferUsageFlagBits;</span><br></pre></td></tr></table></figure>
<p>VkBufferUsageFlagBits设置的位可以指定缓冲区的使用行为：</p>
<ol>
<li>VK_BUFFER_USAGE_TRANSFER_SRC_BIT指定缓冲区可以用作传输命令的源(请参阅VK_PIPELINE_STAGE_TRANSFER_BIT的定义)。</li>
<li>VK_BUFFER_USAGE_TRANSFER_DST_BIT指定缓冲区可以用作传输命令的目的地。</li>
<li>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT缓冲区可用于创建一个VkBufferView，该视图适合占用VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER类型的VkDescriptorSet槽位。</li>
<li>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT指定该缓冲区可以用来创建一个VkBufferView，该视图适合于占用VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的VkDescriptorSet槽位。</li>
<li>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT缓冲区可以用于VkDescriptorBufferInfo中，该缓冲区适合于占用VkDescriptorSet类型的VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC槽位。</li>
<li>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT指定该缓冲区可用于VkDescriptorBufferInfo中，该缓冲区适合于占用VkDescriptorSet类型的VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC槽位。</li>
<li>VK_BUFFER_USAGE_INDEX_BUFFER_BIT指定该缓冲区适合作为buffer参数传递给vkCmdBindIndexBuffer。</li>
<li>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT指定缓冲区适合作为pBuffers数组的元素传递给vkCmdBindVertexBuffers。</li>
<li>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT缓冲区适合作为buffer参数传递给vkCmdDrawIndirect、vkCmdDrawIndexedIndirect、vkCmdDrawMeshTasksIndirectNV、vkCmdDrawMeshTasksIndirectCountNV或vkCmdDispatchIndirect。它也适合作为VkIndirectCommandsTokenNVX的缓冲区成员，或VkCmdProcessCommandsInfoNVX的sequencesCountBuffer或sequencesIndexBuffer成员传递</li>
<li>VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT指定缓冲区适合作为buffer参数传递给vkCmdBeginConditionalRenderingEXT。</li>
<li>VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT指定该缓冲区适合使用for binding作为vkCmdBindTransformFeedbackBuffersEXT的转换反馈缓冲区。</li>
<li>VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT指定该缓冲区适合与vkCmdBeginTransformFeedbackEXT和vkCmdEndTransformFeedbackEXT一起用作计数器缓冲区。</li>
<li>VK_BUFFER_USAGE_RAY_TRACING_BIT_NV指定缓冲区适用于vkCmdTraceRaysNV和vkCmdBuildAccelerationStructureNV。</li>
<li>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT指定缓冲区可以通过vkGetBufferDeviceAddress来检索缓冲区设备地址，并使用该地址从着色器访问缓冲区的内存。</li>
</ol>
<h2 id="2-2-VkMemoryPropertyFlags"><a href="#2-2-VkMemoryPropertyFlags" class="headerlink" title="2.2 VkMemoryPropertyFlags"></a>2.2 VkMemoryPropertyFlags</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkMemoryPropertyFlagBits</span> &#123;</span><br><span class="line">    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_PROTECTED_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkMemoryPropertyFlagBits;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: 指定使用这种类型分配的内存对于设备访问是最有效的。当且仅当内存类型属于设置了VK_MEMORY_HEAP_DEVICE_LOCAL_BIT的堆时，才会设置此属性。</li>
<li>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: 指定使用这种类型分配的内存可以通过vkMapMemory映射给主机访问。</li>
<li>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: 指定主机缓存管理命令vkFlushMappedMemoryRanges和vkInvalidateMappedMemoryRanges分别用于刷新主机对设备的写操作，或者使设备的写操作对主机可见。</li>
<li>VK_MEMORY_PROPERTY_HOST_CACHED_BIT: 指定用这种类型分配的内存缓存在主机上。主机内存对非缓存内存的访问比对缓存内存的访问慢，但是非缓存内存总是与主机一致的。</li>
<li>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: 指定内存类型仅允许设备访问内存。内存类型不能同时设置VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT。另外，对象的后备内存可以由在惰性分配内存中指定的lazy实现提供。</li>
<li>VK_MEMORY_PROPERTY_PROTECTED_BIT: 指定内存类型仅允许设备访问内存，并允许受保护的队列操作访问内存。内存类型不能设置VK_MEMORY_PROPERTY_PROTECTED_BIT和任何VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT、VK_MEMORY_PROPERTY_HOST_COHERENT_BIT或VK_MEMORY_PROPERTY_HOST_CACHED_BIT。</li>
<li>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: 指定对这种内存类型分配的设备访问将自动变为可用和可见的。</li>
<li>VK_MEMORY_PROPERTY_DEVICE_UNCACHHED_BIT_AMD: 指定用这种类型分配的内存不会缓存到设备上。非缓存设备内存总是设备一致的。</li>
</ol>
<h2 id="2-3-缓冲区拷贝函数"><a href="#2-3-缓冲区拷贝函数" class="headerlink" title="2.3 缓冲区拷贝函数"></a>2.3 缓冲区拷贝函数</h2><p>内存传输操作使用命令缓冲区执行，就像绘制命令一样。因此，首先分配一个临时的命令缓冲区。您可能希望为这些短期缓冲区创建一个单独的命令池，因为实现可能能够应用内存分配优化。在这种情况下，您应该在生成命令池期间使用VK_COMMAND_POOL_CREATE_TRANSIENT_BIT标志。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyBuffer</span><span class="params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;</span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandPool = commandPool;</span><br><span class="line">    allocInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer;</span><br><span class="line">    <span class="built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);</span><br><span class="line">    <span class="comment">// 开始记录指令</span></span><br><span class="line">    VkCommandBufferBeginInfo beginInfo = &#123;&#125;;</span><br><span class="line">    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">    <span class="comment">// 只使用一次命令缓冲区，并等待函数返回，直到复制操作完成执行</span></span><br><span class="line">    <span class="comment">// 所以使用VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT标志</span></span><br><span class="line">    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</span><br><span class="line">    <span class="built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲拷贝指令</span></span><br><span class="line">    VkBufferCopy copyRegion = &#123;&#125;;</span><br><span class="line">    copyRegion.srcOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.dstOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.size = size;</span><br><span class="line">    <span class="comment">// 缓冲区的内容使用vkCmdCopyBuffer命令传输。</span></span><br><span class="line">    <span class="comment">// 源和目标缓冲区以及要复制的区域数组作为参数。copyRegion由源缓冲区偏移量、目标缓冲区偏移量和大小组成</span></span><br><span class="line">    <span class="built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="number">1</span>, &amp;copyRegion);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkEndCommandBuffer</span>(commandBuffer);</span><br><span class="line">    VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line">    <span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);</span><br><span class="line">    <span class="built_in">vkQueueWaitIdle</span>(graphicsQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="number">1</span>, &amp;commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝缓冲指令的一般流程是:</p>
<ol>
<li>vkAllocateCommandBuffers 创建指令缓冲，分配内存</li>
<li>vkBeginCommandBuffer     开始指令记录</li>
<li>vkCmdCopyBuffer          执行具体指令</li>
<li>vkEndCommandBuffer       结束指令记录</li>
<li>vkQueueSubmit            将指令提交到管道</li>
<li>vkQueueWaitIdle          等待管道执行指令,也可以通过fence机制</li>
<li>vkFreeCommandBuffers     释放指令缓冲区</li>
</ol>
<h3 id="2-2-1-vkCmdCopyBuffer-拷贝缓冲区"><a href="#2-2-1-vkCmdCopyBuffer-拷贝缓冲区" class="headerlink" title="2.2.1 vkCmdCopyBuffer 拷贝缓冲区"></a>2.2.1 vkCmdCopyBuffer 拷贝缓冲区</h3><p>在缓冲区对象之间复制数据，调用:vkCmdCopyBuffer</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdCopyBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    srcBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    dstBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    regionCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferCopy*                         pRegions)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是命令将被记录到的命令缓冲区。</li>
<li>srcBuffer是源缓冲区。</li>
<li>dstBuffer是目标缓冲区。</li>
<li>regionCount是要复制的区域数。</li>
<li>pRegions是一个指向VkBufferCopy结构体数组的指针，该数组指定了要复制的区域。</li>
</ol>
<h2 id="2-3-缓冲区拷贝"><a href="#2-3-缓冲区拷贝" class="headerlink" title="2.3 缓冲区拷贝"></a>2.3 缓冲区拷贝</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(vertices[<span class="number">0</span>]) * vertices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的MEMORY_PROPERTY是VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT！</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |</span><br><span class="line">            VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            vertexBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将暂存缓冲区的数据内容拷贝到顶点缓冲区</span></span><br><span class="line">    <span class="built_in">copyBuffer</span>(stagingBuffer, vertexBuffer, bufferSize);</span><br><span class="line">    <span class="comment">// 销毁暂存缓冲区，释放内存</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里思考一下，为什么要使用一个暂存缓冲区替换原来的直接使用memcpy呢，而且使用暂存缓冲还额外多了一个创建缓冲区的操作？</p>
<p>因为图形管道使用顶点数据缓冲区时，如果需要更改顶点数据内容，还需要等待memcpy,如果使用暂存缓冲区，可以将更改顶点数据内容的操作放在另一个线程执行，等到写完之后，再使用vkCmdCopyBuffer指令拷贝内存数据，这样图形管道最多等待这个指令拷贝的时间。当然这一点现在看不出来优势，等我们的顶点数据多而且绘制内容复杂的时候就可以体现出来了。</p>
<p>让我们更近一步，考虑到每次拷贝都需要执行vkAllocateCommandBuffers分配内存，不如一开始就请求一块合适的内存区域，毕竟这个函数开销还是很大的。通过使用我们在许多函数中看到的偏移参数，在许多不同的对象之间分割单个分配或回收。可以自己实现也可以使用GPUOpen倡议提供的VulkanMemoryAllocator库。</p>
<h1 id="三-索引缓冲区"><a href="#三-索引缓冲区" class="headerlink" title="三. 索引缓冲区"></a>三. 索引缓冲区</h1><p>在真实世界的应用程序中渲染的3D网格经常会在多个三角形之间共享顶点。比如画一个矩形:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_1.png" alt="12_1"></p>
<p>绘制一个矩形需要两个三角形(基本绘制单元只有点、线和三角形，所以矩形是两个三角形之和)，这意味着需要有6个顶点的顶点缓冲区。问题是两个顶点的部分数据重复，会产生50%的冗余。在更复杂的网格中，只会变得更糟，因为顶点会在平均3个三角形中重复使用。解决这个问题的方法是使用索引缓冲区。</p>
<p>索引缓冲区本质上是一个指向顶点缓冲区的指针数组。它允许重新排序顶点数据，并为多个顶点重用现有数据。上面的插图演示了一个顶点缓冲区包含四个不同的顶点，其索引缓冲区会是什么样子的。前三个索引定义了右上角的三角形，后三个索引定义了左下角三角形的顶点(顺时钟)。</p>
<h2 id="3-1-创建索引缓冲区"><a href="#3-1-创建索引缓冲区" class="headerlink" title="3.1 创建索引缓冲区"></a>3.1 创建索引缓冲区</h2><p>接下来将修改顶点数据并添加索引数据来绘制一个矩形，像上图中一样。修改顶点数据以表示四个角:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>左上角是红色的，右上方是绿色的，右下角是蓝色的，左下角是白色的。现在添加一个新的数组索引来表示索引缓冲区的内容，匹配图中的索引来绘制右上三角形和左下三角形。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用uint16_t或uint32_t作为索引缓冲区，这取决于顶点中条目的数量。我们可以坚持uint16_t现在，因为我们使用少于65535唯一顶点。</p>
<p>就像顶点数据一样，索引需要上传到VkBuffer中，GPU才能访问它们。定义两个新的类成员来保存索引缓冲区的资源:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkBuffer indexBuffer;</span><br><span class="line">VkDeviceMemory indexBufferMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    <span class="built_in">createIndexBuffer</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createIndexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(indices[<span class="number">0</span>]) * indices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, indices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><br><span class="line">            | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            indexBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="comment">// 将暂存缓冲区的数据内容拷贝到顶点缓冲区</span></span><br><span class="line">    <span class="built_in">copyBuffer</span>(stagingBuffer, indexBuffer, bufferSize);</span><br><span class="line">    <span class="comment">// 销毁暂存缓冲区，释放内存</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 createIndexBuffer 几乎和 createVertexBuffer 一样，只有bufferSize和VkBufferUsageFlags不同而已，毕竟都是只是缓冲区。</p>
<p>索引缓冲同样也需要显示销毁： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, indexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, indexBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, vertexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, vertexBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-使用顶点缓冲"><a href="#3-2-使用顶点缓冲" class="headerlink" title="3.2 使用顶点缓冲"></a>3.2 使用顶点缓冲</h2><p>使用索引缓冲区绘制涉及createCommandBuffers的两个更改。我们首先需要绑定索引缓冲区，就像我们对顶点缓冲区所做的那样。但是索引缓冲区只能有一个。而且，不可能对每个顶点属性使用不同的索引，所以即使只有一个属性发生变化，仍然需要完全复制顶点数据。</p>
<p>索引缓冲区与vkCmdBindIndexBuffer绑定，vkCmdBindIndexBuffer包含索引缓冲区、其中的字节偏移量和索引数据类型作为参数。如前所述，可能的类型是VK_INDEX_TYPE_UINT16和VK_INDEX_TYPE_UINT32。</p>
<p>仅仅绑定索引缓冲区还不能改变任何东西，我们还需要更改绘图命令来告诉Vulkan使用索引缓冲区。移除vkCmdDraw，并用vkCmdDrawIndexed替换:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;</span><br><span class="line">VkDeviceSize offsets[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vkCmdBindVertexBuffers</span>(commandBuffers[i], <span class="number">0</span>, <span class="number">1</span>, vertexBuffers, offsets);</span><br><span class="line"><span class="comment">// VK_INDEX_TYPE_UINT16 是因为我们索引用的就是uint16_t</span></span><br><span class="line"><span class="built_in">vkCmdBindIndexBuffer</span>(commandBuffers[i], indexBuffer, <span class="number">0</span>, VK_INDEX_TYPE_UINT16);</span><br><span class="line"><span class="comment">// 使用vkCmdDrawIndexed替换vkCmdDraw</span></span><br><span class="line"><span class="comment">// vkCmdDraw(commandBuffers[i], static_cast&lt;uint32_t&gt;(vertices.size()), 1, 0, 0);</span></span><br><span class="line"><span class="built_in">vkCmdDrawIndexed</span>(commandBuffers[i], <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(indices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vkCmdEndRenderPass</span>(commandBuffers[i]);</span><br></pre></td></tr></table></figure>

<p>对vkCmdDrawIndexed函数的调用非常类似于vkCmdDraw。前两个参数指定索引的数量和实例的数量。我们没有使用实例，所以只指定一个实例。索引的数量表示将被传递到顶点缓冲区的顶点的数量。下一个参数指定到索引缓冲区的偏移量，使用值1将导致显卡从第二个索引开始读取。倒数第二个参数指定要添加到索引缓冲区中的索引的偏移量。最后一个参数指定了实例化的偏移量。</p>
<h1 id="四-绘制命令概述"><a href="#四-绘制命令概述" class="headerlink" title="四. 绘制命令概述"></a>四. 绘制命令概述</h1><p>绘制命令大致分为两类:非索引绘图命令和索引绘图命令。</p>
<h2 id="4-1-非索引绘图命令"><a href="#4-1-非索引绘图命令" class="headerlink" title="4.1 非索引绘图命令"></a>4.1 非索引绘图命令</h2><p>非索引绘图命令为顶点着色器提供一个连续的vertexIndex。顺序索引是由设备自动生成的，这些命令有:</p>
<ol>
<li>vkCmdDraw</li>
<li>vkCmdDrawIndirect</li>
<li>vkCmdDrawIndirectCount</li>
<li>vkCmdDrawIndirectCountKHR</li>
<li>vkCmdDrawIndirectCountAMD</li>
</ol>
<h3 id="4-1-1-vkCmdDraw"><a href="#4-1-1-vkCmdDraw" class="headerlink" title="4.1.1 vkCmdDraw"></a>4.1.1 vkCmdDraw</h3><p>vkCmdDraw可以记录一个非索引的绘制，其原型如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDraw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    vertexCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    instanceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstVertex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstInstance)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是命令记录到的命令缓冲区</li>
<li>vertexCount是要绘制的顶点数</li>
<li>instanceCount是要绘制的实例数量</li>
<li>firstVertex是绘制的第一个顶点的索引</li>
<li>firstInstance是绘制的第一个实例的实例ID</li>
</ol>
<p>执行该命令时，将使用当前基本体拓扑和顶点计数连续顶点索引（第一个顶点索引值等于第一个顶点）组装基本体。原语绘制实例数量为instanceCount，instanceIndex从firstInstance开始，每个实例依次递增。<strong>组装原语的执行要绑定到图形管道</strong>。</p>
<h3 id="4-1-2-vkCmdDrawIndirect"><a href="#4-1-2-vkCmdDrawIndirect" class="headerlink" title="4.1.2 vkCmdDrawIndirect"></a>4.1.2 vkCmdDrawIndirect</h3><p>vkCmdDrawIndirect用于记录非索引的间接绘制，其原型如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    drawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是记录命令的命令缓冲区</li>
<li>buffer是包含绘图参数的缓冲区</li>
<li>offset是参数开始的缓冲区中的字节偏移量</li>
<li>drawCount是要执行的绘制数，可以为零</li>
<li>stride是连续绘图参数集之间的字节步幅</li>
</ol>
<p>vkCmdDrawIndirect的行为与vkCmdDraw类似，不同的是参数是在执行过程中由设备从缓冲区读取的。drawCount绘制由命令执行，参数从缓冲区的偏移量开始，每次绘制时按步长字节递增。每次绘制的参数都编码在一个VkDrawIndirectCommand结构数组中。如果drawCount小于或等于1，则忽略stride。</p>
<h3 id="4-1-3-vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD"><a href="#4-1-3-vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD" class="headerlink" title="4.1.3 vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD"></a>4.1.3 vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD</h3><p>记录来自缓冲区的draw调用计数的非索引绘制调用,可以使用vkCmdDrawIndirectCount，vkCmdDrawIndirectCountKHR或者vkCmdDrawIndirectCountAMD, 这三个指令几乎等效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirectCount</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirectCountKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirectCountAMD</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是记录命令的命令缓冲区</li>
<li>buffer是包含绘图参数的缓冲区</li>
<li>offset是参数开始的缓冲区中的字节偏移量</li>
<li>countBuffer是包含绘图计数的缓冲区</li>
<li>countBufferOffset是开始绘制计数的字节偏移到countBuffer中</li>
<li>maxDrawCount指定将执行的最大绘制数。实际执行的绘制调用数是countBuffer和maxDrawCount中指定的最小计数</li>
<li>stride是连续绘图参数集之间的字节步幅</li>
</ol>
<p>vkCmdDrawIndirectCount的行为与vkCmdDrawIndirectCount类似，只是在执行期间设备从缓冲区读取绘制计数。该命令将从位于countBufferOffset的countBuffer中读取一个无符号32位整数，并将其用作绘图计数。</p>
<h2 id="4-2-索引绘图命令"><a href="#4-2-索引绘图命令" class="headerlink" title="4.2 索引绘图命令"></a>4.2 索引绘图命令</h2><p>索引图形命令从索引缓冲区读取索引值，并使用此命令计算顶点着色器的vertexIndex值。这些命令有：</p>
<ol>
<li>vkCmdDrawIndexed</li>
<li>vkCmdDrawIndexedIndirect</li>
<li>vkCmdDrawIndexedIndirectCount</li>
<li>vkCmdDrawIndexedIndirectCountKHR</li>
<li>vkCmdDrawIndexedIndirectCountAMD</li>
</ol>
<h3 id="4-2-1-vkCmdDrawIndexed"><a href="#4-2-1-vkCmdDrawIndexed" class="headerlink" title="4.2.1 vkCmdDrawIndexed"></a>4.2.1 vkCmdDrawIndexed</h3><p>vkCmdDrawIndexed可以记录一个索引的绘制，其原型如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    indexCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    instanceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span>                                     vertexOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstInstance)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是命令记录到的命令缓冲区</li>
<li>indexCount是要绘制的顶点数</li>
<li>instanceCount是要绘制的实例数</li>
<li>firstIndex是索引缓冲区中的基索引</li>
<li>vertexOffset是在索引到顶点缓冲区之前添加到顶点索引的值</li>
<li>firstInstance是要绘制的第一个实例的实例ID</li>
</ol>
<p>在执行该命令时，使用当前基元拓扑和indexCount顶点组装基元，这些顶点的索引是从索引缓冲区检索的。索引缓冲区被视为一个紧凑封装的大小无符号整数数组，该整数由vkCmdBindIndexBuffer::indexType形参定义，该形参与该缓冲区绑定。</p>
<p>第一个顶点索引位于绑定索引缓冲区中的firstIndex * indexSize + offset的偏移量，其中offset是由vkCmdBindIndexBuffer指定的偏移量，indexSize是由indexType指定的类型的字节大小。从索引缓冲区中连续的位置检索后续的索引值。索引首先与原始的重启值比较，然后0扩展到32位(如果indexType是VK_INDEX_TYPE_UINT8_EXT或VK_INDEX_TYPE_UINT16)，并添加vertexOffset，然后再作为vertexIndex值提供。</p>
<p>这些原语是用从firstInstance开始的instanceIndex绘制instanceCount次数，并按顺序增加每个实例。<strong>组装的原语执行应绑定图形管道</strong>。</p>
<h3 id="4-2-2-vkCmdDrawIndexedIndirect"><a href="#4-2-2-vkCmdDrawIndexedIndirect" class="headerlink" title="4.2.2 vkCmdDrawIndexedIndirect"></a>4.2.2 vkCmdDrawIndexedIndirect</h3><p>vkCmdDrawIndexedIndirect用于记录索引的间接绘制，其原型如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    drawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是记录命令的命令缓冲区</li>
<li>buffer是包含绘图参数的缓冲区</li>
<li>offset是参数开始的缓冲区中的字节偏移量</li>
<li>drawCount是要执行的绘制数，可以为零</li>
<li>stride是连续绘图参数集之间的字节步幅</li>
</ol>
<p>vkCmdDrawIndexedIndirect的行为与vkcmddrawindex类似，不同的是参数是在执行过程中由设备从缓冲区中读取的。drawCount绘制由命令执行，参数从缓冲区的偏移量开始，每次绘制时按步长字节递增。每次绘制的参数都编码在vkdrawindexdindirectcommand结构的数组中。如果drawCount小于或等于1，则忽略stride。</p>
<h3 id="4-2-3-vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD"><a href="#4-2-3-vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD" class="headerlink" title="4.2.3 vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD"></a>4.2.3 vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD</h3><p>同样的，记录来自缓冲区的draw调用计数的索引绘制调用,可以使用, 这三个指令几乎等效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirectCount</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirectCountKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirectCountAMD</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是记录命令的命令缓冲区</li>
<li>buffer是包含绘图参数的缓冲区</li>
<li>offset是参数开始的缓冲区中的字节偏移量</li>
<li>countBuffer是包含绘制计数的缓冲区</li>
<li>countBufferOffset是进入countBuffer的字节偏移量，在这里开始绘制计数</li>
<li>maxDrawCount指定将执行的最大绘制数。实际执行的draw调用数是countBuffer和maxDrawCount中指定的最小计数</li>
<li>stride是连续绘图参数集之间的字节步幅</li>
</ol>
<p>vkCmdDrawIndexedIndirectCount的行为与vkCmdDrawIndexedIndirect类似，只是在执行期间设备从缓冲区读取绘制计数。该命令将从位于countBufferOffset的countBuffer中读取一个无符号32位整数，并将其用作绘图计数。</p>
<h1 id="五-小结"><a href="#五-小结" class="headerlink" title="五. 小结"></a>五. 小结</h1><p>在上一篇文章中，我们使用顶点描述符VkVertexInputBindingDescription和VkVertexInputAttributeDescription替换了硬编码顶点，并且使用VkBuffer存储了顶点数据，好处是可随时更改顶点信息。在本文中，我们又使用了暂存缓冲优化了顶点缓冲每次都需要memcpy的弊端，还介绍了顶点索引，使得我们的程序可以画出更多的图形。</p>
<p>使用暂存缓冲是因为图形管道使用顶点数据缓冲区时，如果需要更改顶点数据内容，还需要等待memcpy,如果使用暂存缓冲区，可以将更改顶点数据内容的操作放在另一个线程执行，等到写完之后，再使用vkCmdCopyBuffer指令拷贝内存数据，这样图形管道最多等待这个指令拷贝的时间。当顶点数据多而且绘制内容复杂的时候就可以体现出来了。</p>
<p>而使用顶点索引缓冲是和顶点缓冲几乎一样的流程，只是VkBuffer创建时的VkBufferUsageFlags和size(对应的数据不同嘛)不同。</p>
<p>不过这里还是很好奇，顶点索引和顶点的关系，比如如果我们顶点坐标不变，顶点索引改成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的图形就变成了:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_2.png" alt="图形"></p>
<p>但是当顶点索引改成:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应的图形就变成了:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_3.png" alt="图形"></p>
<p>这个顶点索引和最终图像的生成到底是什么个关系呢，参考:<a href="https://zhuanlan.zhihu.com/p/97496535">https://zhuanlan.zhihu.com/p/97496535</a></p>
<p>Vulkan中的坐标系使用的右手坐标系，相比OpenGL是用的左手坐标系：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_4.png" alt="坐标系"></p>
<p>其中原点(0,0,0)在屏幕中央, 所以当我们想画一个三棱锥可以使用如下顶点及索引:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line">std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-0.25f</span>, <span class="number">-0.01f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.01f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.25f</span>, <span class="number">0.01f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.01f</span>, <span class="number">0.15f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_5.png" alt="三棱锥"></p>
<p>接下来，让我们再接再厉，学习使用资源描述符来加载3D图形。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(13)-描述符布局及缓存</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。</p>
<span id="more"></span>

<p>在Vulkan中解决这个问题的正确方法是使用资源描述符（resource descriptor）。描述符是着色器自由访问缓冲区和图像等资源的一种方式。我们将设置一个包含变换矩阵的缓冲区，并让顶点着色器通过描述符访问它们。描述符的使用包括三个部分：</p>
<ol>
<li>在管道创建期间指定描述符布局</li>
<li>从描述符池分配描述符集</li>
<li>渲染期间绑定描述符集</li>
</ol>
<p>描述符是表示着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。描述符被组织成描述符集，这些描述符集在命令记录期间被绑定，以便在后续的绘制命令中使用。每个描述符集中内容的安排由描述符集布局决定，该布局决定了可以在其中存储哪些描述符。管道可使用的描述符集布局序列在管道布局中指定。每个管道对象最多可以使用maxBoundDescriptorSets(参见限制)描述符集。</p>
<p>描述符布局指定管道要访问的资源类型，就像渲染过程指定要访问的附件类型一样。描述符集指定将绑定到描述符的实际缓冲区或图像资源，就像帧缓冲区指定要绑定到渲染过程附件的实际图像视图一样。然后为绘图命令绑定描述符集，就像顶点缓冲区和帧缓冲区一样。</p>
<p>着色器通过装饰有描述符集和绑定数的变量访问资源，这些变量将它们连接到描述符集中的描述符。着色器接口到绑定描述符集的映射在着色器资源接口部分描述。着色器也可以通过64位地址使用物理存储缓冲区访问，而不需要通过描述符来访问缓冲区。</p>
<p>描述符有很多种类型，这里使用统一缓冲区对象(UBO)。如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UniformBufferObject</span> &#123;</span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    glm::mat4 view;</span><br><span class="line">    glm::mat4 proj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用GLM中的数据类型精确匹配着色器中的定义。矩阵中的数据与着色器期望的方式是二进制兼容的，因此我们可以稍后将UniformBufferObject的memcpy转换为VkBuffer。</p>
<p>需要更改顶点着色器:</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> UniformBufferObject &#123;</span><br><span class="line">    <span class="type">mat4</span> model;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">    <span class="type">mat4</span> proj;</span><br><span class="line">&#125; ubo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定指令类似于属性的位置指令。 我们将在描述符布局中引用此绑定。 更改了带有gl_Position的行，以使用转换来计算剪辑坐标中的最终位置。 与2D三角形不同，剪辑坐标的最后一个分量可能不是1，这在转换为屏幕上的最终归一化设备坐标时将导致除法。 这在透视投影中用作透视划分，对于使较近的对象看起来比较远的对象看起来更大，这是必不可少的。</p>
<h1 id="一-描述符集布局"><a href="#一-描述符集布局" class="headerlink" title="一. 描述符集布局"></a>一. 描述符集布局</h1><p>我们需要提供着色器中用于管道创建的每个描述符绑定的详细信息，就像我们必须为每个顶点属性及其位置索引所做的那样。我们将设置一个新函数来定义所有这些信息，称为createDescriptorSetLayout。在创建管道之前应该调用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorSetLayout</span>();</span><br><span class="line">    <span class="built_in">createGraphicsPipeline</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个绑定都需要通过VkDescriptorSetLayoutBinding结构来描述。前两个字段指定在着色器中使用的绑定和描述符的类型，该描述符是一个统一的缓冲区对象。着色器变量可能表示一个统一缓冲区对象的数组，而描述符计数指定该数组中值的数量。 例如，这可用于为骨骼动画指定骨骼中每个骨骼的变换。 我们的MVP转换位于单个统一缓冲区对象中，因此我们使用的描述符数为1。</p>
<h2 id="1-1-VkDescriptorSetLayoutBinding"><a href="#1-1-VkDescriptorSetLayoutBinding" class="headerlink" title="1.1 VkDescriptorSetLayoutBinding"></a>1.1 VkDescriptorSetLayoutBinding</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutBinding</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>              binding;</span><br><span class="line">    VkDescriptorType      descriptorType;</span><br><span class="line">    <span class="type">uint32_t</span>              descriptorCount;</span><br><span class="line">    VkShaderStageFlags    stageFlags;</span><br><span class="line">    <span class="type">const</span> VkSampler*      pImmutableSamplers;</span><br><span class="line">&#125; VkDescriptorSetLayoutBinding;</span><br></pre></td></tr></table></figure>
<ol>
<li>binding是此条目的绑定号，并且与着色器阶段中具有相同绑定号的资源相对应。</li>
<li>descriptorType是VkDescriptorType，它指定用于此绑定的资源描述符的类型。</li>
<li>descriptorCount是绑定中包含的描述符数量，在着色器中以数组形式访问，除非描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，在这种情况下，描述符计数是嵌入式统一块的字节大小。如果描述符计数为零，则此绑定条目被保留，并且不得使用设置的布局在任何管道内通过任何绑定从任何阶段访问资源。</li>
<li>stageFlags成员是VkShaderStageFlagBits的位掩码，用于指定哪些管道着色器阶段可以访问此绑定的资源。 VK_SHADER_STAGE_ALL是一种简写形式，用于指定所有定义的着色器阶段，包括扩展定义的任何其他阶段，都可以访问该资源。如果stageFlags中未包含着色器阶段，则不得使用设置的布局在任何管道中通过此绑定从该阶段访问资源。除了限于片段着色器的输入附件之外，对于阶段的哪些组合可以使用描述符绑定没有任何限制，特别是图形阶段和计算阶段都可以使用绑定。</li>
<li>pImmutableSamplers影响采样器的初始化。如果描述符类型指定VK_DESCRIPTOR_TYPE_SAMPLER或VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型描述符，则可以使用pImmutableSamplers初始化一组不可变的采样器。不可变的采样器永久绑定到设置的布局中，不得更改。不允许使用不可变采样器更新VK_DESCRIPTOR_TYPE_SAMPLER描述符，并且使用不可变采样器更新VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER描述符不会修改采样器（将更新图像视图，但会忽略采样器更新）。如果pImmutableSamplers不为NULL，则它指向一个采样器句柄数组，该数组将被复制到set布局中并用于相应的绑定。仅采样器句柄被复制；在最终使用集合布局以及使用它创建的任何描述符池和集合之前，不得破坏采样器对象。如果pImmutableSamplers为NULL，则采样器插槽是动态的，必须使用此布局将采样器句柄绑定到描述符集中。如果描述符类型不是这些描述符类型之一，则将忽略pImmutableSamplers。</li>
</ol>
<h3 id="1-1-1-VkDescriptorType"><a href="#1-1-1-VkDescriptorType" class="headerlink" title="1.1.1 VkDescriptorType"></a>1.1.1 VkDescriptorType</h3><p>其中描述符的类型VkDescriptorType有如下取值:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkDescriptorType</span> &#123;</span><br><span class="line">    VK_DESCRIPTOR_TYPE_SAMPLER = <span class="number">0</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = <span class="number">1</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = <span class="number">2</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = <span class="number">3</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = <span class="number">4</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = <span class="number">5</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = <span class="number">6</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = <span class="number">7</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = <span class="number">8</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = <span class="number">9</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = <span class="number">10</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = <span class="number">1000138000</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = <span class="number">1000165000</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkDescriptorType;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_DESCRIPTOR_TYPE_SAMPLER: 指定采样器描述符</li>
<li>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: 指定组合图像采样器描述符</li>
<li>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: 指定采样图像描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: 指定存储映像描述符</li>
<li>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: 指定统一纹理像素缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: 指定存储纹理元素缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: 统一缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: 指定存储缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: 指定动态统一缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: 指定动态存储缓冲区描述符</li>
<li>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: 指定输入附件描述符</li>
<li>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: 指定内联统一块</li>
</ol>
<h3 id="1-1-2-VkShaderStageFlags"><a href="#1-1-2-VkShaderStageFlags" class="headerlink" title="1.1.2 VkShaderStageFlags"></a>1.1.2 VkShaderStageFlags</h3><p>需要指定一个或多个着色器阶段的命令和结构使用位对应于阶段的位掩码来指定。可以设置为指定着色器阶段的位有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkShaderStageFlagBits</span> &#123;</span><br><span class="line">    VK_SHADER_STAGE_VERTEX_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_SHADER_STAGE_GEOMETRY_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_SHADER_STAGE_FRAGMENT_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_SHADER_STAGE_COMPUTE_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL_GRAPHICS = <span class="number">0x0000001F</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL = <span class="number">0x7FFFFFFF</span>,</span><br><span class="line">    VK_SHADER_STAGE_RAYGEN_BIT_NV = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_SHADER_STAGE_ANY_HIT_BIT_NV = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_SHADER_STAGE_MISS_BIT_NV = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_SHADER_STAGE_INTERSECTION_BIT_NV = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_SHADER_STAGE_CALLABLE_BIT_NV = <span class="number">0x00002000</span>,</span><br><span class="line">    VK_SHADER_STAGE_TASK_BIT_NV = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_SHADER_STAGE_MESH_BIT_NV = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkShaderStageFlagBits;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_SHADER_STAGE_VERTEX_BIT: 顶点阶段</li>
<li>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: 细分控制阶段</li>
<li>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: 细分评估阶段</li>
<li>VK_SHADER_STAGE_GEOMETRY_BIT: 几何图形阶段</li>
<li>VK_SHADER_STAGE_FRAGMENT_BIT: 片段阶段</li>
<li>VK_SHADER_STAGE_COMPUTE_BIT: 计算阶段</li>
<li>VK_SHADER_STAGE_ALL_GRAPHICS: 用作速记的位的组合，用于指定上面定义的所有图形阶段（计算阶段除外）</li>
<li>VK_SHADER_STAGE_ALL: 用作简写的位的组合，用于指定设备支持的所有着色器阶段，包括扩展引入的所有其他阶段</li>
<li>VK_SHADER_STAGE_TASK_BIT_NV: 任务阶段</li>
<li>VK_SHADER_STAGE_MESH_BIT_NV: 网格阶段</li>
<li>VK_SHADER_STAGE_RAYGEN_BIT_NV: 射线生成阶段</li>
<li>VK_SHADER_STAGE_ANY_HIT_BIT_NV: 任何命中阶段</li>
<li>VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: 最接近的命中阶段</li>
<li>VK_SHADER_STAGE_MISS_BIT_NV: 未命中阶段</li>
<li>VK_SHADER_STAGE_INTERSECTION_BIT_NV: 相交阶段</li>
<li>VK_SHADER_STAGE_CALLABLE_BIT_NV: 可调用阶段</li>
</ol>
<h2 id="1-2-创建VkDescriptorSetLayout"><a href="#1-2-创建VkDescriptorSetLayout" class="headerlink" title="1.2 创建VkDescriptorSetLayout"></a>1.2 创建VkDescriptorSetLayout</h2><p>所有描述符绑定都合并到一个vkDescriptorSetLayout对象中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkDescriptorSetLayout descriptorSetLayout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;;</span><br><span class="line">    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;</span><br><span class="line">    layoutInfo.bindingCount = <span class="number">1</span>;</span><br><span class="line">    layoutInfo.pBindings = &amp;uboLayoutBinding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建描述符集布局</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorSetLayout</span>(device, &amp;layoutInfo, <span class="literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor set layout!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-VkDescriptorSetLayoutCreateInfo"><a href="#1-2-1-VkDescriptorSetLayoutCreateInfo" class="headerlink" title="1.2.1 VkDescriptorSetLayoutCreateInfo"></a>1.2.1 VkDescriptorSetLayoutCreateInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                            pNext;</span><br><span class="line">    VkDescriptorSetLayoutCreateFlags       flags;</span><br><span class="line">    <span class="type">uint32_t</span>                               bindingCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayoutBinding*    pBindings;</span><br><span class="line">&#125; VkDescriptorSetLayoutCreateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType就是这种结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</li>
<li>pNext为NULL或指向特定于扩展的结构的指针</li>
<li>flags是VkDescriptorSetLayoutCreateFlagBits的位掩码，用于指定描述符集布局创建的选项</li>
<li>bindingCount是pBindings中的元素数</li>
<li>pBindings是指向VkDescriptorSetLayoutBinding结构数组的指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkDescriptorSetLayoutCreateFlagBits</span> &#123;</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkDescriptorSetLayoutCreateFlagBits;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: 指定不得使用此布局分配描述符集，而是由vkCmdPushDescriptorSetKHR推送描述符</li>
<li>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: 指定描述符集使用此布局必须从创建一个描述符池分配VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT位集。描述符集布局创建这部分设置有备用限制描述符的最大数量每级和per-pipeline布局。non-UpdateAfterBind限制仅计数在没有此标志的情况下创建的集合中的描述符。UpdateAfterBind限制计算所有描述符，但是限制可能高于非UpdateAfterBind限制。</li>
</ol>
<h3 id="1-2-2-vkCreateDescriptorSetLayout"><a href="#1-2-2-vkCreateDescriptorSetLayout" class="headerlink" title="1.2.2 vkCreateDescriptorSetLayout"></a>1.2.2 vkCreateDescriptorSetLayout</h3><p>描述符集布局对象由零个或多个描述符绑定的数组定义。每个单独的描述符绑定由描述符类型、绑定中描述符数量的计数（数组大小）、可以访问绑定的一组着色器阶段以及（如果使用不可变采样器）采样器描述符数组指定。</p>
<p>创建描述符集布局可以使用函数: vkCreateDescriptorSetLayout</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorSetLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSetLayout*                      pSetLayout)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建描述符集布局的逻辑设备</li>
<li>pCreateInfo: 指向VkDescriptorSetLayoutCreateInfo结构的指针，它指定了描述符集布局对象的状态</li>
<li>pAllocator: 控制主机内存分配</li>
<li>pSetLayout: 指向VkDescriptorSetLayout句柄的指针，在这个句柄中返回结果描述符集布局对象</li>
</ol>
<p>当然通过vkCreate*创建的对象或资源，一般需要显示销毁:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="built_in">vkDestroyDescriptorSetLayout</span>(device, descriptorSetLayout, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-管道指定描述符集布局"><a href="#1-3-管道指定描述符集布局" class="headerlink" title="1.3 管道指定描述符集布局"></a>1.3 管道指定描述符集布局</h2><p>我们需要在管道创建期间指定描述符集布局，以告诉Vulkan着色器将使用哪些描述符。描述符集布局在管道布局对象中指定。修改VkPipelineLayoutCreateInfo以引用布局对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;;</span><br><span class="line">pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;</span><br><span class="line">pipelineLayoutInfo.setLayoutCount = <span class="number">1</span>;</span><br><span class="line">pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout;</span><br></pre></td></tr></table></figure>
<p>这里留个悬念，为什么可以指定多个描述符集布局。</p>
<h2 id="1-4-统一缓存"><a href="#1-4-统一缓存" class="headerlink" title="1.4 统一缓存"></a>1.4 统一缓存</h2><p>我们将指定包含着色器的UBO数据的缓冲区，但是我们需要首先创建这个缓冲区。我们将在每一帧将新数据复制到统一缓冲区，因此使用暂存缓冲区实际上没有任何意义。在这种情况下，它只会增加额外的开销，而且可能会降低性能。</p>
<p>我们应该有多个缓冲区，因为多个帧可能在同一时间绘制，我们不想更新缓冲区，准备下一帧，而前一帧仍在读取它！我们可以为每个帧或每个交换链图像提供统一的缓冲区。然而，由于我们需要从每个交换链映像所拥有的命令缓冲区引用统一缓冲区，因此最好也为每个交换链映像创建一个统一缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkBuffer indexBuffer;</span><br><span class="line">VkDeviceMemory indexBufferMemory;</span><br><span class="line"></span><br><span class="line">std::vector&lt;VkBuffer&gt; uniformBuffers;</span><br><span class="line">std::vector&lt;VkDeviceMemory&gt; uniformBuffersMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    <span class="built_in">createIndexBuffer</span>();</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createUniformBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br><span class="line">    uniformBuffers.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    uniformBuffersMemory.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImages.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">                VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">                uniformBuffers[i], uniformBuffersMemory[i],</span><br><span class="line">                VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将编写一个单独的函数，在每一帧用一个新的转换来更新统一缓冲区，所以这里没有vkMapMemory。</p>
<p>统一数据将被用于所有的draw调用，所以包含它的缓冲区只有在我们停止渲染时才会被销毁。因为它也取决于交换链图像的数量，这可能会在重新创建后改变，所以在cleanupSwapChain中清理它:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; uniformBuffers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">vkDestroyBuffer</span>(device, uniformBuffers[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">vkFreeMemory</span>(device, uniformBuffersMemory[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createFramebuffers</span>();</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-更新统一缓存数据"><a href="#1-5-更新统一缓存数据" class="headerlink" title="1.5 更新统一缓存数据"></a>1.5 更新统一缓存数据</h2><p>在绘制更新交换链帧的时候更新统一缓存数据：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">updateUniformBuffer</span>(imageIndex);</span><br><span class="line"></span><br><span class="line">    VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUniformBuffer</span><span class="params">(<span class="type">uint32_t</span> currentImage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>updateUniformBuffer函数将在每帧生成一个新的变换，以使几何体旋转。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保glm::rotate之类的函数使用弧度作为参数是必要的，以避免任何可能的混淆</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_RADIANS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// chrono标准库标头公开了执行精确计时的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUniformBuffer</span><span class="params">(<span class="type">uint32_t</span> currentImage)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> currentTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 计算时长</span></span><br><span class="line">    <span class="type">float</span> time = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">float</span>, std::chrono::seconds::period&gt;(currentTime - startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    UniformBufferObject ubo = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 在统一缓冲区对象中定义模型，视图和投影转换。 使用时间变量，模型旋转将是围绕Z轴的简单旋转</span></span><br><span class="line">    <span class="comment">// 意思是每秒旋转90度</span></span><br><span class="line">    ubo.model = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), time * glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="comment">// 设置视图角度，从上方以45度角查看几何图形。 glm :: lookAt函数将眼睛位置，中心位置和上轴作为参数。</span></span><br><span class="line">    ubo.view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用具有45度垂直视场的透视投影。</span></span><br><span class="line">    <span class="comment">// 其他参数是长宽比，近视平面和远视平面。 重要的是使用当前交换链范围来计算纵横比，以考虑调整大小后窗口的新宽度和高度。</span></span><br><span class="line">    ubo.proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), swapChainExtent.width / (<span class="type">float</span>) swapChainExtent.height, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLM最初是为OpenGL(左手坐标系)设计的，将其中坐标的Y坐标反转。 最简单的补偿方法是在投影矩阵中翻转Y轴缩放比例上的符号。 </span></span><br><span class="line">    <span class="comment">// 如果不这样做，那么图像将被倒置呈现。</span></span><br><span class="line">    ubo.proj[<span class="number">1</span>][<span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将统一缓冲区对象中的数据复制到当前的统一缓冲区中。 与使用顶点缓冲区的方式完全相同，只是不需要暂存缓冲区（因为每帧都要更新）：</span></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, uniformBuffersMemory[currentImage], <span class="number">0</span>, <span class="built_in">sizeof</span>(ubo), <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;ubo, <span class="built_in">sizeof</span>(ubo));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, uniformBuffersMemory[currentImage]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然此时编译运行程序是不成功的，因为我们仅仅是更新数据，但是没有将描述符集绑定到图形管道中。</p>
<h1 id="二-描述符"><a href="#二-描述符" class="headerlink" title="二. 描述符"></a>二. 描述符</h1><p>前面我们创建了描述符集布局，描述了可以绑定的描述符的类型，现在我们给统一缓冲区的每个缓冲创建一个描述符集，然后将其绑定到统一缓冲区描述符中。</p>
<h2 id="2-1-描述符池"><a href="#2-1-描述符池" class="headerlink" title="2.1 描述符池"></a>2.1 描述符池</h2><p>描述符集无法直接创建，它们必须从命令缓冲区之类的池中分配。描述符集又称为描述符池。 我们将编写一个新函数createDescriptorPool进行设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorPoolSize poolSize = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 我们创建的是统一缓冲的描述符</span></span><br><span class="line">    poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    poolSize.descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;;</span><br><span class="line">    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;</span><br><span class="line">    poolInfo.poolSizeCount = <span class="number">1</span>;</span><br><span class="line">    poolInfo.pPoolSizes = &amp;poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了可用的单个描述符的最大数量外，还需要指定可以分配的最大描述符集数量：与交换链图像数量一致</span></span><br><span class="line">    poolInfo.maxSets = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 创建描述符池</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorPool</span>(device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要使用VkDescriptorPoolSize结构来描述我们的描述符集将包含哪些描述符类型以及其中有多少个描述符类型。</p>
<h3 id="2-1-1-VkDescriptorPoolSize"><a href="#2-1-1-VkDescriptorPoolSize" class="headerlink" title="2.1.1 VkDescriptorPoolSize"></a>2.1.1 VkDescriptorPoolSize</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolSize</span> &#123;</span><br><span class="line">    VkDescriptorType    type;</span><br><span class="line">    <span class="type">uint32_t</span>            descriptorCount;</span><br><span class="line">&#125; VkDescriptorPoolSize;</span><br></pre></td></tr></table></figure>
<ol>
<li>type是描述符的类型</li>
<li>descriptorCount是要分配的该类型的描述符数。如果类型是VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则descriptorCount是要为此类型的描述符分配的字节数</li>
</ol>
<h3 id="2-1-2-VkDescriptorPoolCreateInfo"><a href="#2-1-2-VkDescriptorPoolCreateInfo" class="headerlink" title="2.1.2 VkDescriptorPoolCreateInfo"></a>2.1.2 VkDescriptorPoolCreateInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                    pNext;</span><br><span class="line">    VkDescriptorPoolCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                       maxSets;</span><br><span class="line">    <span class="type">uint32_t</span>                       poolSizeCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorPoolSize*    pPoolSizes;</span><br><span class="line">&#125; VkDescriptorPoolCreateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType是此结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>flags是VkDescriptorPoolCreateFlagBits的位掩码，用于指定池中某些受支持的操作</li>
<li>maxSets是可以从池中分配的描述符集的最大数量</li>
<li>poolSizeCount是pPoolSizes中的元素数</li>
<li>pPoolSizes是一个指向VkDescriptorPoolSize结构数组的指针，每个结构都包含一个描述符类型和要在池中分配的该类型的描述符数量</li>
</ol>
<h3 id="2-1-3-vkCreateDescriptorPool"><a href="#2-1-3-vkCreateDescriptorPool" class="headerlink" title="2.1.3 vkCreateDescriptorPool"></a>2.1.3 vkCreateDescriptorPool</h3><p>描述符池维护着一个描述符池，从中分配描述符集。 描述符池是外部同步的，这意味着应用程序不得同时从多个线程中的同一池中分配和&#x2F;或释放描述符集。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorPoolCreateInfo*           pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorPool*                           pDescriptorPool)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建描述符池的逻辑设备</li>
<li>pCreateInfo: 指向VkDescriptorPoolCreateInfo结构的指针，该结构指定描述符池对象的状态</li>
<li>pAllocator: 内存分配</li>
<li>pDescriptorPool: 指向VkDescriptorPool句柄的指针，在该句柄中返回生成的描述符池对象</li>
</ol>
<p>别忘了手动清理描述符池：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">vkDestroyDescriptorPool</span>(device, descriptorPool, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-描述符集"><a href="#2-2-描述符集" class="headerlink" title="2.2 描述符集"></a>2.2 描述符集</h2><p>有了描述符池就可以分配描述符集了。为此添加createDescriptorSets函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkDescriptorPool descriptorPool;</span><br><span class="line">std::vector&lt;VkDescriptorSet&gt; descriptorSets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createDescriptorSets</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createDescriptorSets</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;VkDescriptorSetLayout&gt; <span class="title">layouts</span><span class="params">(swapChainImages.size(), descriptorSetLayout)</span></span>;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.descriptorPool = descriptorPool;</span><br><span class="line">    allocInfo.descriptorSetCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    allocInfo.pSetLayouts = layouts.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 重置大小</span></span><br><span class="line">    descriptorSets.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 内存分配描述符集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateDescriptorSets</span>(device, &amp;allocInfo, descriptorSets.<span class="built_in">data</span>()) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate descriptor sets!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; descriptorSets.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 引用缓冲区的描述符（例如我们的统一缓冲区描述符）使用VkDescriptorBufferInfo结构进行配置</span></span><br><span class="line">        <span class="comment">// 指定缓冲区以及其中包含描述符数据的区域。</span></span><br><span class="line">        VkDescriptorBufferInfo bufferInfo = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 绑定缓冲区</span></span><br><span class="line">        bufferInfo.buffer = uniformBuffers[i];</span><br><span class="line">        bufferInfo.offset = <span class="number">0</span>;</span><br><span class="line">        bufferInfo.range = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br><span class="line"></span><br><span class="line">        VkWriteDescriptorSet descriptorWrite = &#123;&#125;;</span><br><span class="line">        descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">        descriptorWrite.dstSet = descriptorSets[i];</span><br><span class="line">        descriptorWrite.dstBinding = <span class="number">0</span>;</span><br><span class="line">        descriptorWrite.dstArrayElement = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">        descriptorWrite.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        descriptorWrite.pBufferInfo = &amp;bufferInfo;</span><br><span class="line">        descriptorWrite.pImageInfo = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">        descriptorWrite.pTexelBufferView = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用描述符集更新</span></span><br><span class="line">        <span class="built_in">vkUpdateDescriptorSets</span>(device, <span class="number">1</span>, &amp;descriptorWrite, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>描述符集分配用VkDescriptorSetAllocateInfo结构描述。需要指定要从中分配的描述符池、要分配的描述符集的数量以及基于它们的描述符布局。</p>
<h3 id="2-2-1-VkDescriptorSetAllocateInfo"><a href="#2-2-1-VkDescriptorSetAllocateInfo" class="headerlink" title="2.2.1 VkDescriptorSetAllocateInfo"></a>2.2.1 VkDescriptorSetAllocateInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType                 sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                     pNext;</span><br><span class="line">    VkDescriptorPool                descriptorPool;</span><br><span class="line">    <span class="type">uint32_t</span>                        descriptorSetCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayout*    pSetLayouts;</span><br><span class="line">&#125; VkDescriptorSetAllocateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType是此结构的类型</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>descriptorPool是从中分配集合的池</li>
<li>descriptorSetCount确定要从池中分配的描述符集的数量</li>
<li>pSetLayouts是一个指向描述符集布局数组的指针，每个成员指定如何分配相应的描述符集</li>
</ol>
<h3 id="2-2-2-vkAllocateDescriptorSets"><a href="#2-2-2-vkAllocateDescriptorSets" class="headerlink" title="2.2.2 vkAllocateDescriptorSets"></a>2.2.2 vkAllocateDescriptorSets</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetAllocateInfo*          pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSet*                            pDescriptorSets)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 拥有描述符池的逻辑设备</li>
<li>pAllocateInfo: 指向VkDescriptorSetAllocateInfo结构的指针，该结构描述分配参数</li>
<li>pDescriptorSets: 指向VkDescriptorSet句柄数组的指针，在该数组中返回生成的描述符集对象</li>
</ol>
<p>无需手动清理描述符集，因为在销毁描述符池时，会自动释放描述符集。 对vkAllocateDescriptorSets的调用将分配描述符集，每个描述符集具有一个统一的缓冲区描述符。</p>
<h3 id="2-2-3-VkDescriptorBufferInfo"><a href="#2-2-3-VkDescriptorBufferInfo" class="headerlink" title="2.2.3 VkDescriptorBufferInfo"></a>2.2.3 VkDescriptorBufferInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorBufferInfo</span> &#123;</span><br><span class="line">    VkBuffer        buffer;</span><br><span class="line">    VkDeviceSize    offset;</span><br><span class="line">    VkDeviceSize    range;</span><br><span class="line">&#125; VkDescriptorBufferInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>buffer是缓冲区资源</li>
<li>offset是从缓冲区开始的偏移量（以字节为单位）。 通过此描述符访问缓冲存储器将使用相对于此起始偏移量的寻址</li>
<li>range是用于此描述符更新的大小（以字节为单位），或者是VK_WHOLE_SIZE以使用从偏移量到缓冲区末尾的范围</li>
</ol>
<h3 id="2-2-4-VkWriteDescriptorSet"><a href="#2-2-4-VkWriteDescriptorSet" class="headerlink" title="2.2.4 VkWriteDescriptorSet"></a>2.2.4 VkWriteDescriptorSet</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkWriteDescriptorSet</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkDescriptorSet                  dstSet;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstBinding;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstArrayElement;</span><br><span class="line">    <span class="type">uint32_t</span>                         descriptorCount;</span><br><span class="line">    VkDescriptorType                 descriptorType;</span><br><span class="line">    <span class="type">const</span> VkDescriptorImageInfo*     pImageInfo;</span><br><span class="line">    <span class="type">const</span> VkDescriptorBufferInfo*    pBufferInfo;</span><br><span class="line">    <span class="type">const</span> VkBufferView*              pTexelBufferView;</span><br><span class="line">&#125; VkWriteDescriptorSet;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType是此结构的类型, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>dstSet是要更新的目标描述符集</li>
<li>dstBinding是该集合内的描述符绑定</li>
<li>dstArrayElement是该数组中的起始元素。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则dstArrayElement指定绑定内的起始字节偏移量</li>
<li>descriptorCount是要更新的描述符的数量（pImageInfo，pBufferInfo或pTexelBufferView中的元素数量，或者与pNext链中的VkWriteDescriptorSetInlineUniformBlockEXT结构的dataSize成员匹配的值，或者与pNext中的VkWriteDescriptorSetAccelerationStructureNV结构的AccelerationStructureCount匹配的值。链 ）。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则描述符计数指定要更新的字节数</li>
<li>descriptorType是VkDescriptorType，用于指定pImageInfo，pBufferInfo或pTexelBufferView中每个描述符的类型，如下所述。它必须与在dstBinding中为dstSet的VkDescriptorSetLayoutBinding中指定的类型相同。描述符的类型还控制描述符从哪个数组获取</li>
<li>pImageInfo是指向VkDescriptorImageInfo结构数组的指针</li>
<li>pBufferInfo是指向VkDescriptorBufferInfo结构数组的指针</li>
<li>pTexelBufferView是指向VkBufferView句柄数组的指针</li>
</ol>
<h3 id="2-2-5-vkUpdateDescriptorSets"><a href="#2-2-5-vkUpdateDescriptorSets" class="headerlink" title="2.2.5 vkUpdateDescriptorSets"></a>2.2.5 vkUpdateDescriptorSets</h3><p>内存分配后，描述符集可以使用写和复制操作的组合进行更新。 要更新描述符集，调用：vkUpdateDescriptorSets</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkUpdateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorWriteCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkWriteDescriptorSet*                 pDescriptorWrites,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorCopyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCopyDescriptorSet*                  pDescriptorCopies)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device是更新描述符集的逻辑设备</li>
<li>descriptorWriteCount是pDescriptorWrites数组中元素的数量</li>
<li>pDescriptorWrites是指向VkWriteDescriptorSet结构数组的指针，该结构描述了要写入的描述符集</li>
<li>descriptorCopyCount是pDescriptorCopies数组中元素的数量</li>
<li>pDescriptorCopies是指向VkCopyDescriptorSet结构数组的指针，该结构描述了要在其间复制的描述符集</li>
</ol>
<h2 id="2-3-使用描述符集"><a href="#2-3-使用描述符集" class="headerlink" title="2.3 使用描述符集"></a>2.3 使用描述符集</h2><p>现在，我们需要更新createCommandBuffers函数，以将每个交换链图像的正确描述符集实际绑定到具有cmdBindDescriptorSets的着色器中的描述符。 </p>
<p>需要在vkCmdDrawIndexed调用之前完成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindDescriptorSets</span>(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;descriptorSets[i], <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkCmdDrawIndexed</span>(commandBuffers[i], <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(indices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>与顶点和索引缓冲区不同，描述符集不是图形管线所独有的。因此，我们需要指定是否要将描述符集绑定到图形或计算管道–vkCmdBindDescriptorSets。</p>
<p>现在运行程序，是看不到任何内容的。问题在于，由于我们在投影矩阵中进行了Y翻转，因此现在以顺时针顺序而不是逆时针顺序绘制了顶点。这将导致背面剔除，并阻止绘制任何几何图形。</p>
<p>在createGraphicsPipeline函数中VkPipelineRasterizationStateCreateInfo中修改frontFace来更正此问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;</span><br><span class="line">rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;</span><br></pre></td></tr></table></figure>

<p>frontFace是VkFrontFace结构体内的类型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkFrontFace</span> &#123;</span><br><span class="line">    VK_FRONT_FACE_COUNTER_CLOCKWISE = <span class="number">0</span>,</span><br><span class="line">    VK_FRONT_FACE_CLOCKWISE = <span class="number">1</span>,</span><br><span class="line">    VK_FRONT_FACE_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkFrontFace;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_FRONT_FACE_COUNTER_CLOCKWISE 指定具有正面积的三角形被认为是朝前的</li>
<li>VK_FRONT_FACE_CLOCKWISE 指定具有负面积的三角形被认为是朝前的</li>
</ol>
<p>如何计算面积的正负，后续研究。现在运行程序可以看到我们的图像在沿着逆时针旋转~</p>
<h3 id="2-3-1-vkCmdBindDescriptorSets"><a href="#2-3-1-vkCmdBindDescriptorSets" class="headerlink" title="2.3.1 vkCmdBindDescriptorSets"></a>2.3.1 vkCmdBindDescriptorSets</h3><p>绑定描述符集调用 vkCmdBindDescriptorSets:<br>一个参数是描述符所基于的布局。接下来的三个参数指定第一个描述符集的索引，要绑定的集的数量以及要绑定的集的数组。我们待会儿再讲这个。最后两个参数指定用于动态描述符的偏移量数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineBindPoint                         pipelineBindPoint,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout                            layout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstSet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorSetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSet*                      pDescriptorSets,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    dynamicOffsetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint32_t</span>*                             pDynamicOffsets)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer是描述符集将绑定到的命令缓冲区</li>
<li>pipelineBindPoint是一个VkPipelineBindPoint，它指示描述符是由图形管线还是由计算管线使用。 每个图形和计算都有一组单独的绑定点，因此绑定一个不会干扰另一个</li>
<li>layout是一个VkPipelineLayout对象，用于对绑定进行编程</li>
<li>firstSet是要绑定的第一个描述符集的集号</li>
<li>descriptorSetCount是pDescriptorSets数组中元素的数量</li>
<li>pDescriptorSets是指向VkDescriptorSet对象的句柄数组的指针，该对象描述了要写入的描述符集</li>
<li>dynamicOffsetCount是pDynamicOffsets数组中的动态偏移量</li>
<li>pDynamicOffsets是指向指定动态偏移量的uint32_t值数组的指针</li>
</ol>
<p>vkCmdBindDescriptorSets导致编号为[firstSet..firstSet + descriptorSetCount-1]的集合使用存储在pDescriptorSets [0..descriptorSetCount-1]中的绑定用于后续渲染命令（根据pipelineBindPoint计算或图形）。以前通过这些集合应用的任何绑定都不再有效。</p>
<p>绑定后，描述符集会影响命令缓冲区中后续图形或计算命令的渲染，直到将不同的集绑定到相同的集编号，或者直到该集受到干扰（如管线布局兼容性中所述）为止。</p>
<p>在记录绘制或分派命令以使用该管道执行时，必须为管道中任何着色器访问的所有设定编号绑定一个兼容的描述符集。但是，如果管道中的所有着色器都不静态使用具有特定集合号的任何绑定，则即使该管道编号包括该集合号的非平凡描述符集合布局，也不需要为该集合号绑定任何描述符集。</p>
<p>如果要绑定的任何集合包括动态统一缓冲区或存储缓冲区，则pDynamicOffsets会为每个集合中每个动态描述符类型绑定中的每个数组元素包含一个元素。从pDynamicOffsets中获取值的顺序是：集合N的所有条目都在集合N + 1之前；在一个集合中，条目按描述符集合布局中的绑定号排序；在绑定数组中，元素是有序的。 dynamicOffsetCount必须等于要绑定的集合中动态描述符的总数。</p>
<p>用于动态统一和存储缓冲区绑定的有效偏移量是从pDynamicOffsets获取的相对偏移量与缓冲区的基地址加描述符集中的基本偏移量之和。动态统一和存储缓冲区绑定的范围是描述符集中指定的缓冲区范围。</p>
<p>每个pDescriptorSet都必须与layout指定的管道布局兼容。用于编程绑定的布局还必须与后续图形或计算命令中使用的管线兼容，如“管线布局兼容性”部分中所定义。</p>
<p>调用vkCmdBindDescriptorSets绑定的描述符集内容可能在以下时间使用：</p>
<ol>
<li>对于使用VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT位置1创建的描述符绑定，在将命令缓冲区提交到队列时，在着色器执行结果绘制和调度时或在两者之间的任何时间，内容都可能被消耗。</li>
<li>在命令的主机执行期间，或在着色器执行结果绘制和派发期间，或之间的任何时间。</li>
</ol>
<p>因此，在描述符集合绑定的内容可能被消耗的第一个时间点和该命令在队列上完成执行之间，不得更改（由更新命令覆盖或释放）描述符集绑定的内容。</p>
<p>在执行vkCmdBindDescriptorSets时，pDynamicOffsets的内容将立即消耗。一旦所有待定用途都已完成，就可以更新和重用描述符集。</p>
<h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><p>描述符的使用包括三个部分：</p>
<ol>
<li>在管道创建期间指定描述符布局</li>
<li>从描述符池分配描述符集</li>
<li>渲染期间绑定描述符集</li>
</ol>
<p>所谓描述符，就是用来描述着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。</p>
<p>接下来，我们尝试一些更让人激动的东西–贴图。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(14)-VkImage图像的创建</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在之前我们使用顶点着色器以及描述符来实现绘制有颜色的几何体，还实现了旋转动画。接下来我们学习一下纹理贴图，这个将是我们实现加载绘制基本3D模型的基础。</p>
<span id="more"></span>

<p>添加纹理的基本步骤有:</p>
<ol>
<li>创建由设备内存支持的图像对象</li>
<li>用图像文件中的像素填充创建的图像对象</li>
<li>创建图像采样器</li>
<li>添加一个组合的图像采样器描述符来从纹理中采样颜色</li>
</ol>
<p>我们以前已经使用过图像对象，但是这些对象是由swap chain扩展自动创建的。这次需要手动创建，创建图像并填充数据类似于创建顶点缓冲区。我们将通过创建一个暂存资源和填充它与像素数据，然后我们复制这到我们将用于渲染的最终图像对象。</p>
<p>可以创建一个暂存图像，不过Vulkan允许将像素从VkBuffer复制到image中，而且这个API在某些硬件上实际上更快。我们将首先创建这个缓冲区并填充像素值，然后我们将创建一个图像复制像素到。创建image与创建缓冲区并没有太大的不同。它包括查询内存需求、分配设备内存并绑定它，就像我们之前看到的那样。</p>
<p>图像可以有不同的布局，影响像素在内存中的存储方式。例如，由于图形硬件的工作方式，简单地逐行存储像素可能不会带来最好的性能。当对图像执行任何操作时，确保它们具有在该操作中使用的最佳布局。比如指定渲染通道时其中一些布局有:</p>
<ol>
<li>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 适合呈现（present）</li>
<li>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:片段着色器中写入颜色的最佳附件</li>
<li>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: 作为传输操作的最佳源，如vkCmdCopyImageToBuffer</li>
<li>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 作为传输操作的最佳目的地，如vkCmdCopyBufferToImage</li>
<li>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: 适合着色器采样</li>
</ol>
<p>转换图像布局的最常见方法之一是管道屏障（pipeline barrier）。管道屏障主要用于同步对资源的访问，例如确保在读取图像之前将其写入。后面我们将了解如何将管道壁垒用于转换布局。</p>
<p>使用VK_SHARING_MODE_EXCLUSIVE时，可以另外使用屏障来转移队列系列的所有权。</p>
<h1 id="一-纹理贴图"><a href="#一-纹理贴图" class="headerlink" title="一. 纹理贴图"></a>一. 纹理贴图</h1><h2 id="1-1-图像库"><a href="#1-1-图像库" class="headerlink" title="1.1 图像库"></a>1.1 图像库</h2><p>有许多库可用于加载图像，您甚至可以编写自己的代码来加载BMP和PPM等简单格式。 这里我们将使用stb集合中的stb_image库。 这样做的好处是所有代码都在一个文件中，因此不需要任何棘手的构建配置。 下载stb_image.h并将其存储在方便的位置，例如保存GLFW和GLM的目录。 将位置添加到您的包含路径。</p>
<p>stb_image库地址: <a href="https://github.com/nothings/stb">https://github.com/nothings/stb</a></p>
<p>下载后解压，放在指定目录，然后修改我们的Makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.2.170.0/x86_64</span><br><span class="line">STB_IMAGE_PATH = /home/jh/Program/stb-image</span><br><span class="line"></span><br><span class="line">CFLAGS = -std=c++17 -I<span class="variable">$(VULKAN_SDK_PATH)</span>/<span class="keyword">include</span> -I<span class="variable">$(STB_IMAGE_PATH)</span></span><br></pre></td></tr></table></figure>

<h2 id="1-1-读取图片"><a href="#1-1-读取图片" class="headerlink" title="1.1 读取图片"></a>1.1 读取图片</h2><p>在shaders目录旁边创建一个新的目录textures来存储纹理图像：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/texture.jpg" alt="texture"></p>
<p>首先添加头文件:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stb_image.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>默认情况下，头文件只定义函数的原型。一个代码文件需要包含STB_IMAGE_IMPLEMENTATION定义的头文件来包含函数体，否则会有链接错误。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createCommandPool</span>();</span><br><span class="line">    <span class="comment">// 因为需要使用指令缓冲，所以在创建指令池之后调用</span></span><br><span class="line">    <span class="built_in">createTextureImage</span>();</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> texWidth, texHeight, texChannels;</span><br><span class="line">    <span class="comment">// 加载texture.jpg图像</span></span><br><span class="line">    stbi_uc* pixels = <span class="built_in">stbi_load</span>(<span class="string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);</span><br><span class="line">    <span class="comment">// 每个像素4个字节</span></span><br><span class="line">    VkDeviceSize imageSize = texWidth * texHeight * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pixels) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to load texture image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stbi_load函数将文件路径和要加载的通道数量作为参数。STBI_rgb_alpha值会强制为图像加载Alpha通道，即使它没有通道也是如此, 与其他纹理保持一致性。中间的三个参数是输出图像中通道的宽度、高度和实际数量。返回的指针是像素值数组中的第一个元素。在STBI_rgba_alpha中，像素逐行排列，每个像素4个字节，总共texWidth * texHeight * 4个值。</p>
<h2 id="1-2-缓存读取的图片"><a href="#1-2-缓存读取的图片" class="headerlink" title="1.2 缓存读取的图片"></a>1.2 缓存读取的图片</h2><p>现在，我们将在主机可见内存中创建一个缓冲区，以便我们可以使用vkMapMemory并将像素复制到其中。 将此临时缓冲区的变量添加到createTextureImage函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> texWidth, texHeight, texChannels;</span><br><span class="line">    <span class="comment">// 加载texture.jpg图像</span></span><br><span class="line">    stbi_uc* pixels = <span class="built_in">stbi_load</span>(<span class="string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);</span><br><span class="line">    <span class="comment">// 每个像素4个字节</span></span><br><span class="line">    VkDeviceSize imageSize = texWidth * texHeight * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pixels) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to load texture image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="comment">// 缓冲区应该在主机可见内存中，以便我们可以映射它，并且它应该可用作传输源，以便我们以后可以复制</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            stagingBufferMemory);</span><br><span class="line">    <span class="comment">// 内存映射</span></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, imageSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, pixels, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(imageSize));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line">    <span class="comment">// 最后释放原始像素数据</span></span><br><span class="line">    <span class="built_in">stbi_image_free</span>(pixels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-纹理图像-Texture-Image"><a href="#1-3-纹理图像-Texture-Image" class="headerlink" title="1.3 纹理图像(Texture Image)"></a>1.3 纹理图像(Texture Image)</h2><p>尽管我们可以设置着色器来访问缓冲区中的像素值，但为此目的最好使用Vulkan中的图像对象-VkImage。 通过使用2D坐标，图像对象将使检索颜色更加容易和快捷。 图像对象中的像素称为纹理像素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkImage textureImage;</span><br><span class="line">VkDeviceMemory textureImageMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    VkImageCreateInfo imageInfo = &#123;&#125;;</span><br><span class="line">    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;</span><br><span class="line">    imageInfo.imageType = VK_IMAGE_TYPE_2D; <span class="comment">//二维图像</span></span><br><span class="line">    imageInfo.extent.width = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texWidth);</span><br><span class="line">    imageInfo.extent.height = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texHeight);</span><br><span class="line">    imageInfo.extent.depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像的最小采样的细节级别</span></span><br><span class="line">    imageInfo.mipLevels = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像中的层数</span></span><br><span class="line">    imageInfo.arrayLayers = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定图像格式，对于像素像素，使用与缓冲区中像素相同的格式，否则复制操作将失败</span></span><br><span class="line">    imageInfo.format = VK_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line">    <span class="comment">// 图像平铺模式,这里指定图像像素最佳内存拼接布局</span></span><br><span class="line">    <span class="comment">// 与图像的布局不同，平铺模式不能在以后更改。如果希望能够直接访问图像内存中的texel，则必须使用VK_IMAGE_TILING_OPTIMAL</span></span><br><span class="line">    imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图像的initialLayout只有两个可能的值：VK_IMAGE_LAYOUT_UNDEFINED || VK_IMAGE_LAYOUT_PREINITIALIZED</span></span><br><span class="line">    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line"></span><br><span class="line">    imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;</span><br><span class="line">    <span class="comment">// 图像将仅由一个队列族使用, 因此独占模式</span></span><br><span class="line">    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">    <span class="comment">// 图像采样</span></span><br><span class="line">    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">    imageInfo.flags = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    <span class="comment">// 创建图像</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="literal">nullptr</span>, &amp;textureImage) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的，需要给Image分配内存空间</span></span><br><span class="line">    VkMemoryRequirements memRequirements;</span><br><span class="line">    <span class="built_in">vkGetImageMemoryRequirements</span>(device, textureImage, &amp;memRequirements);</span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex =</span><br><span class="line">            <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;textureImageMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate image memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定图像和内存</span></span><br><span class="line">    <span class="built_in">vkBindImageMemory</span>(device, textureImage, textureImageMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于initialLayout，很少有情况需要在第一次过渡期间保留纹理像素，但是如果想将图像与VK_IMAGE_TILING_LINEAR布局结合使用作为缓存图像。 在这种情况下，将纹理像素数据上传到其中，然后将图像转换为传输源而又不丢失数据。但是，我们首先将图像转换为传输目标，然后从缓冲区对象将纹理像素数据复制到该图像，因此使用VK_IMAGE_LAYOUT_UNDEFINED。</p>
<p>对于usage, 与缓冲区创建期间的含义相同。 该图像将用作缓冲区副本的目的地，因此应将其设置为传输目的地。 我们还希望能够从着色器访问图像来为网格着色，因此用法应包括VK_IMAGE_USAGE_SAMPLED_BIT。</p>
<p>采样标志与多重采样有关。 这仅与将用作附件的图像有关，这里使用一个样本。 对于与稀疏图像有关的图像，有一些可选的标志。 稀疏图像是其中实际上仅某些区域由内存支持的图像。 例如，如果将3D纹理用于体素地形，则可以使用它来避免分配内存来存储大量的“空”值，这里我们设置为0。</p>
<h3 id="1-3-1-VkImageCreateInfo"><a href="#1-3-1-VkImageCreateInfo" class="headerlink" title="1.3.1 VkImageCreateInfo"></a>1.3.1 VkImageCreateInfo</h3><p>创建图像的一系列参数是在VkImageCreateInfo中指明的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*              pNext;</span><br><span class="line">    VkImageCreateFlags       flags;</span><br><span class="line">    VkImageType              imageType;</span><br><span class="line">    VkFormat                 format;</span><br><span class="line">    VkExtent3D               extent;</span><br><span class="line">    <span class="type">uint32_t</span>                 mipLevels;</span><br><span class="line">    <span class="type">uint32_t</span>                 arrayLayers;</span><br><span class="line">    VkSampleCountFlagBits    samples;</span><br><span class="line">    VkImageTiling            tiling;</span><br><span class="line">    VkImageUsageFlags        usage;</span><br><span class="line">    VkSharingMode            sharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>                 queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*          pQueueFamilyIndices;</span><br><span class="line">    VkImageLayout            initialLayout;</span><br><span class="line">&#125; VkImageCreateInfo;</span><br></pre></td></tr></table></figure>

<ol>
<li>sType是此结构的类型,VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>flag是VkImageCreateFlagBits的位掩码，用于描述图像的其他参数</li>
<li>imageType是VkImageType值，用于指定图像的基本尺寸。就图像类型而言，阵列纹理中的图层不算作尺寸<ol>
<li>VK_IMAGE_TYPE_1D指定一维图像</li>
<li>VK_IMAGE_TYPE_2D指定二维图像</li>
<li>VK_IMAGE_TYPE_3D指定三维图像</li>
</ol>
</li>
<li>format是一种VkFormat，它描述了将包含在图像中的texel块的格式和类型</li>
<li>extent是一个VkExtent3D，它描述基本级别的每个维度中的数据元素数量</li>
<li>mipLevels描述可用于图像的最小采样的细节级别的数量</li>
<li>arrayLayers是图像中的层数</li>
<li>samples是VkSampleCountFlagBits，用于指定每个纹理像素的样本数</li>
<li>tiling是一个VkImageTiling值，它指定内存中纹理元素块的平铺模式<ol>
<li>VK_IMAGE_TILING_LINEAR: 以主要行顺序排列像素</li>
<li>VK_IMAGE_TILING_OPTIMAL: 指定最佳平铺（纹理像素以实现相关的安排进行布局，以实现更好的内存访问）</li>
<li>VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: 表示图片的拼贴是由Linux DRM格式修饰符定义的</li>
</ol>
</li>
<li>usage是VkImageUsageFlagBits的位掩码，用于描述图像的预期用法</li>
<li>SharingMode是VkSharingMode值，用于指定多个队列系列将访问图像时的图像共享模式</li>
<li>queueFamilyIndexCount是pQueueFamilyIndi​​ces数组中的条目数</li>
<li>pQueueFamilyIndi​​ces是将访问此图像的队列系列的列表（如果sharedMode不是VK_SHARING_MODE_CONCURRENT，则将被忽略）</li>
<li>initialLayout是一个VkImageLayout值，它指定图像的所有图像子资源的初始VkImageLayout。请参阅图像布局<ol>
<li>VK_IMAGE_LAYOUT_UNDEFINED: GPU不可用，第一次转换将丢弃纹理像素</li>
<li>VK_IMAGE_LAYOUT_PREINITIALIZED:GPU无法使用，但第一个过渡将保留纹理像素</li>
</ol>
</li>
</ol>
<h3 id="1-3-2-vkCreateImage"><a href="#1-3-2-vkCreateImage" class="headerlink" title="1.3.2 vkCreateImage"></a>1.3.2 vkCreateImage</h3><p>图像表示多维（最多3个）数据数组，可用于各种目的（例如附件、纹理），通过描述符集将其绑定到图形或计算管道，或直接将其指定为特定命令的参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkImageCreateInfo*                    pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage*                                    pImage)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>device是创建Image的逻辑设备</li>
<li>pCreateInfo是指向VkImageCreateInfo结构的指针，该结构包含用于创建图像的参数</li>
<li>pAllocator如“内存分配”一章中所述控制主机内存分配</li>
<li>pImage是指向VkImage句柄的指针，在该句柄中返回生成的图像对象</li>
</ol>
<h3 id="1-3-3-createImage"><a href="#1-3-3-createImage" class="headerlink" title="1.3.3 createImage"></a>1.3.3 createImage</h3><p>现在我们重构下createTextureImage, 将创建VkImage的部分单独做个函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createImage</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkImageTiling tiling, VkImageUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkMemoryPropertyFlags properties, VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDeviceMemory&amp; imageMemory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VkImageCreateInfo imageInfo = &#123;&#125;;</span><br><span class="line">    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;</span><br><span class="line">    imageInfo.imageType = VK_IMAGE_TYPE_2D; <span class="comment">//二维图像</span></span><br><span class="line">    imageInfo.extent.width = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(width);</span><br><span class="line">    imageInfo.extent.height = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(height);</span><br><span class="line">    imageInfo.extent.depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像的最小采样的细节级别</span></span><br><span class="line">    imageInfo.mipLevels = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像中的层数</span></span><br><span class="line">    imageInfo.arrayLayers = <span class="number">1</span>;</span><br><span class="line">    imageInfo.format = format;</span><br><span class="line">    <span class="comment">// 图像平铺模式,这里指定图像像素最佳内存拼接布局</span></span><br><span class="line">    <span class="comment">// 与图像的布局不同，平铺模式不能在以后更改。如果希望能够直接访问图像内存中的texel，则必须使用VK_IMAGE_TILING_OPTIMAL</span></span><br><span class="line">    imageInfo.tiling = tiling;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图像的initialLayout只有两个可能的值：VK_IMAGE_LAYOUT_UNDEFINED || VK_IMAGE_LAYOUT_PREINITIALIZED</span></span><br><span class="line">    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line"></span><br><span class="line">    imageInfo.usage = usage;</span><br><span class="line">    <span class="comment">// 图像将仅由一个队列族使用, 因此独占模式</span></span><br><span class="line">    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">    <span class="comment">// 图像采样</span></span><br><span class="line">    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">    imageInfo.flags = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    <span class="comment">// 创建图像</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="literal">nullptr</span>, &amp;image) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的，需要给Image分配内存空间</span></span><br><span class="line">    VkMemoryRequirements memRequirements;</span><br><span class="line">    <span class="built_in">vkGetImageMemoryRequirements</span>(device, image, &amp;memRequirements);</span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex =</span><br><span class="line">            <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;imageMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate image memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定图像和内存</span></span><br><span class="line">    <span class="built_in">vkBindImageMemory</span>(device, image, imageMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> texWidth, texHeight, texChannels;</span><br><span class="line">    <span class="comment">// 加载texture.jpg图像</span></span><br><span class="line">    stbi_uc* pixels = <span class="built_in">stbi_load</span>(<span class="string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);</span><br><span class="line">    <span class="comment">// 每个像素4个字节</span></span><br><span class="line">    VkDeviceSize imageSize = texWidth * texHeight * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pixels) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to load texture image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="comment">// 缓冲区应该在主机可见内存中，以便我们可以映射它，并且它应该可用作传输源，以便我们以后可以复制</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="comment">// 内存映射</span></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, imageSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, pixels, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(imageSize));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line">    <span class="comment">// 最后释放原始像素数据</span></span><br><span class="line">    <span class="built_in">stbi_image_free</span>(pixels);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL,</span><br><span class="line">            VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-布局转换"><a href="#1-4-布局转换" class="headerlink" title="1.4 布局转换"></a>1.4 布局转换</h2><p>我们需要再次记录和执行一个命令缓冲区以完成布局转换功能，所以最好是将执行指令缓冲区的部分逻辑抽离:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkCommandBuffer <span class="title">beginSingleTimeCommands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandPool = commandPool;</span><br><span class="line">    allocInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer;</span><br><span class="line">    <span class="built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);</span><br><span class="line"></span><br><span class="line">    VkCommandBufferBeginInfo beginInfo = &#123;&#125;;</span><br><span class="line">    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</span><br><span class="line">    <span class="built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);</span><br><span class="line">    <span class="keyword">return</span> commandBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">endSingleTimeCommands</span><span class="params">(VkCommandBuffer commandBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vkEndCommandBuffer</span>(commandBuffer);</span><br><span class="line"></span><br><span class="line">    VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);</span><br><span class="line">    <span class="built_in">vkQueueWaitIdle</span>(graphicsQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="number">1</span>, &amp;commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在有了beginSingleTimeCommands和endSingleTimeCommands函数，可以对执行单条指令缓冲区的函数进行优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyBuffer</span><span class="params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;</span><br><span class="line">    VkCommandBuffer commandBuffer= <span class="built_in">beginSingleTimeCommands</span>();</span><br><span class="line">    <span class="comment">// 缓冲拷贝指令</span></span><br><span class="line">    VkBufferCopy copyRegion = &#123;&#125;;</span><br><span class="line">    copyRegion.srcOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.dstOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.size = size;</span><br><span class="line">    <span class="comment">// std::cout&lt;&lt;&quot;copyBuffer vkCmdCopyBuffer&quot;&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="comment">// 缓冲区的内容使用vkCmdCopyBuffer命令传输。</span></span><br><span class="line">    <span class="comment">// 源和目标缓冲区以及要复制的区域数组作为参数。copyRegion由源缓冲区偏移量、目标缓冲区偏移量和大小组成</span></span><br><span class="line">    <span class="built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="number">1</span>, &amp;copyRegion);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">endSingleTimeCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们仍然使用缓冲区，那么我们现在可以编写一个函数来记录并执行vkCmdCopyBufferToImage，但是这个命令要求首先将Image置于正确的布局中。</p>
<p>创建一个新函数来处理布局转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transitionImageLayout</span><span class="params">(VkImage image, VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkImageLayout oldLayout, VkImageLayout newLayout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer = <span class="built_in">beginSingleTimeCommands</span>();</span><br><span class="line">    <span class="comment">// 使用图像内存屏障,用于同步资源访问</span></span><br><span class="line">    VkImageMemoryBarrier barrier = &#123;&#125;;</span><br><span class="line">    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;</span><br><span class="line">    <span class="comment">// 指定布局转换。如果不关心图像的现有内容，可以将VK_IMAGE_LAYOUT_UNDEFINED用作oldLayout</span></span><br><span class="line">    barrier.oldLayout = oldLayout;</span><br><span class="line">    barrier.newLayout = newLayout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用屏障来传递队列族的所有权，那么这两个字段应该是队列族的索引</span></span><br><span class="line">    <span class="comment">// 如果不这样做，则必须将它们设置为VK_QUEUE_FAMILY_IGNORED</span></span><br><span class="line">    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    <span class="comment">// image和subresourceRange指定受影响的图像以及图像的特定部分</span></span><br><span class="line">    barrier.image = image;</span><br><span class="line">    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    <span class="comment">// 我们的图像不是数组，也没有mipmapping级别，因此只指定了一个级别和层</span></span><br><span class="line">    barrier.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    barrier.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 屏障主要用于同步目的，因此必须指定哪些涉及资源的操作类型必须在屏障之前发生，哪些涉及资源的操作必须在屏障上等待</span></span><br><span class="line">    barrier.srcAccessMask = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line">    barrier.dstAccessMask = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在管道上执行barrier指令, 所有类型的管道屏障都使用相同的函数提交</span></span><br><span class="line">    <span class="built_in">vkCmdPipelineBarrier</span>(commandBuffer,</span><br><span class="line">        <span class="number">0</span> <span class="comment">/* TODO */</span>, <span class="number">0</span> <span class="comment">/* TODO */</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">1</span>, &amp;barrier</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">endSingleTimeCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行布局转换的最常见方法之一是使用图像内存屏障。像这样的管道屏障通常用于同步对资源的访问，例如确保在从缓冲区读取之前完成对缓冲区的写入，但是当使用VK_SHARING_MODE_EXCLUSIVE时，它也可以用于转换映像布局和传输队列族所有权。对于缓冲区，有一个等效的缓冲存储器屏障来实现这一点。</p>
<h3 id="1-4-1-VkImageMemoryBarrier"><a href="#1-4-1-VkImageMemoryBarrier" class="headerlink" title="1.4.1 VkImageMemoryBarrier"></a>1.4.1 VkImageMemoryBarrier</h3><p>图像存储器屏障仅适用于涉及特定图像子资源范围的存储器访问。也就是说，从图像存储器屏障形成的存储器依赖被限定为通过指定的图像子资源范围进行访问。图像内存屏障还可用于定义指定图像子资源范围的图像布局转换或队列族所有权转移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageMemoryBarrier</span> &#123;</span><br><span class="line">    VkStructureType            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                pNext;</span><br><span class="line">    VkAccessFlags              srcAccessMask;</span><br><span class="line">    VkAccessFlags              dstAccessMask;</span><br><span class="line">    VkImageLayout              oldLayout;</span><br><span class="line">    VkImageLayout              newLayout;</span><br><span class="line">    <span class="type">uint32_t</span>                   srcQueueFamilyIndex;</span><br><span class="line">    <span class="type">uint32_t</span>                   dstQueueFamilyIndex;</span><br><span class="line">    VkImage                    image;</span><br><span class="line">    VkImageSubresourceRange    subresourceRange;</span><br><span class="line">&#125; VkImageMemoryBarrier;</span><br></pre></td></tr></table></figure>

<ol>
<li>sType就是这种结构的类型, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER</li>
<li>pNext为NULL或指向特定于扩展的结构的指针</li>
<li>srccessmask是指定源访问掩码的VkAccessFlagBits的位掩码, 指定在哪个管道阶段发生操作，这些操作应该在屏障之前发生</li>
<li>dstAccessMask是指定目标访问掩码的VkAccessFlagBits位掩码, 指定操作将在其中等待屏障的管道阶段</li>
<li>oldLayout是图像布局转换中的旧布局</li>
<li>newLayout是图像布局转换中的新布局</li>
<li>srcQueueFamilyIndex是队列系列所有权转移的源队列系列</li>
<li>dstQueueFamilyIndex是队列系列所有权转移的目标队列系列</li>
<li>image是受此屏障影响的图像</li>
<li>subresourceRange描述图像中受此屏障影响的图像子资源范围</li>
</ol>
<h3 id="1-4-2-vkCmdPipelineBarrier"><a href="#1-4-2-vkCmdPipelineBarrier" class="headerlink" title="1.4.2 vkCmdPipelineBarrier"></a>1.4.2 vkCmdPipelineBarrier</h3><p>vkCmdPipelineBarrier是一个同步命令，它在提交到同一队列的命令之间或同一子类中的命令之间插入依赖关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdPipelineBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineStageFlags                        srcStageMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineStageFlags                        dstStageMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDependencyFlags                           dependencyFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    memoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkMemoryBarrier*                      pMemoryBarriers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    bufferMemoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferMemoryBarrier*                pBufferMemoryBarriers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    imageMemoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkImageMemoryBarrier*                 pImageMemoryBarriers)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>commandBuffer是将命令记录到的命令缓冲区</li>
<li>srcStageMask是一个指定源级掩码的VkPipelineStageFlagBits的位掩码</li>
<li>dstStageMask是指定目标阶段掩码的VkPipelineStageFlagBits的位掩码</li>
<li>dependencyFlags是VkdePendencyFlags的位掩码，指定如何形成执行和内存依赖关系</li>
<li>memoryBarrierCount是pMemoryBarriers数组的长度</li>
<li>pMemoryBarriers是指向VKMemorySbarrier结构数组的指针</li>
<li>bufferMemoryBarrierCount是pBufferMemoryBarriers数组的长度</li>
<li>pBufferMemoryBarriers是指向VkBufferMemoryBarrier结构数组的指针</li>
<li>imageMemoryBarrierCount是pImageMemoryBarriers数组的长度</li>
<li>pImageMemoryBarriers是指向VkimAgemoryBarrier结构数组的指针</li>
</ol>
<p>当vkCmdPipelineBarrier提交到队列时，它定义了在它之前提交的命令和在它之后提交的命令之间的内存依赖关系。</p>
<p>如果vkCmdPipelineBarrier是在渲染过程实例外部录制的，则第一个同步作用域将包括按提交顺序较早出现的所有命令。如果vkCmdPipelineBarrier记录在渲染过程实例中，则第一个同步作用域仅包括在同一子过程中以提交顺序较早出现的命令。在这两种情况下，第一个同步作用域仅限于由srcStageMask指定的源阶段掩码确定的管道阶段上的操作。</p>
<p>如果vkCmdPipelineBarrier是在渲染过程实例外部录制的，则第二个同步作用域将包括以后按提交顺序执行的所有命令。如果vkCmdPipelineBarrier记录在渲染过程实例中，则第二个同步作用域仅包括稍后在同一子过程中按提交顺序出现的命令。在任何一种情况下，第二同步作用域都限于由dstStageMask指定的目的级掩码确定的管道级上的操作。</p>
<p>第一个访问范围被限制为在由srcStageMask指定的源阶段掩码确定的管道阶段中进行访问。其中，第一访问作用域仅包括由pMemoryBarriers、pBufferMemoryBarriers和pImageMemoryBarriers数组的元素定义的第一访问作用域，每个元素定义一组内存屏障。如果未指定内存屏障，则第一个访问作用域不包括任何访问。</p>
<p>第二访问范围被限制为在由dstStageMask指定的目标阶段掩码确定的管道阶段中的访问。其中，第二访问作用域仅包括由pMemoryBarriers、pBufferMemoryBarriers和pImageMemoryBarriers数组的元素定义的第二访问作用域，它们各自定义了一组内存屏障。如果未指定内存屏障，则第二访问作用域不包括任何访问。</p>
<h2 id="1-5-拷贝缓存数据至Image"><a href="#1-5-拷贝缓存数据至Image" class="headerlink" title="1.5 拷贝缓存数据至Image"></a>1.5 拷贝缓存数据至Image</h2><p>就像缓冲区复制一样，需要指定缓冲区的哪个部分将被复制到图像的哪个部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyBufferToImage</span><span class="params">(VkBuffer buffer, VkImage image, <span class="type">uint32_t</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer = <span class="built_in">beginSingleTimeCommands</span>();</span><br><span class="line">    <span class="comment">// 使用VkBufferImageCopy指定缓冲区复制行为</span></span><br><span class="line">    VkBufferImageCopy region = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定缓冲区中像素值开始的字节偏移量</span></span><br><span class="line">    region.bufferOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 指定像素在内存中的布局方式, 指定0表示像素紧密打包</span></span><br><span class="line">    region.bufferRowLength = <span class="number">0</span>;</span><br><span class="line">    region.bufferImageHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示要将像素复制到图像的哪个部分</span></span><br><span class="line">    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    region.imageSubresource.mipLevel = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.layerCount = <span class="number">1</span>;</span><br><span class="line">    region.imageOffset = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    region.imageExtent = &#123;width, height, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用vkCmdCopyBufferToImage函数将缓冲区到图像的复制操作排队</span></span><br><span class="line">    <span class="comment">// 第四个参数指示图像当前使用的布局</span></span><br><span class="line">    <span class="built_in">vkCmdCopyBufferToImage</span>(commandBuffer, buffer, image,</span><br><span class="line">            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">            <span class="number">1</span>, &amp;region);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">endSingleTimeCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-VkBufferImageCopy"><a href="#1-5-1-VkBufferImageCopy" class="headerlink" title="1.5.1 VkBufferImageCopy"></a>1.5.1 VkBufferImageCopy</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkBufferImageCopy</span> &#123;</span><br><span class="line">    VkDeviceSize                bufferOffset;</span><br><span class="line">    <span class="type">uint32_t</span>                    bufferRowLength;</span><br><span class="line">    <span class="type">uint32_t</span>                    bufferImageHeight;</span><br><span class="line">    VkImageSubresourceLayers    imageSubresource;</span><br><span class="line">    VkOffset3D                  imageOffset;</span><br><span class="line">    VkExtent3D                  imageExtent;</span><br><span class="line">&#125; VkBufferImageCopy;</span><br></pre></td></tr></table></figure>

<ol>
<li>bufferOffset是从复制图像数据的缓冲区对象的起始处开始的以字节为单位的偏移量</li>
<li>bufferRowLength和bufferImageHeight以texel为单位指定缓冲存储器中较大的二维或三维图像的子区域，并控制寻址计算。如果这些值中的任何一个为零，则根据imageExtent，缓冲存储器的这一方面被认为是紧密压缩的</li>
<li>imageSubresource是一个VkImageSubresourceLayers，用于指定用于源或目标图像数据的图像的特定图像子资源</li>
<li>imageOffset选择源或目标图像数据子区域的初始x、y、z偏移（以texel为单位）</li>
<li>imageExtent是要在宽度、高度和深度上复制的图像的大小（以texel为单位）</li>
</ol>
<p>当复制到或从深度或模具方面时，缓冲区内存中的数据使用的布局是深度或模具数据的(大部分)紧密封装的表示形式。具体地说:</p>
<ol>
<li>复制到或从任何深度&#x2F;模板格式的模板方面的数据都用每个texel的VK_FORMAT_S8_UINT值紧密打包</li>
<li>复制到或从VK_FORMAT_D16_UNORM或VK_FORMAT_D16_UNORM_S8_UINT格式的深度方面的数据使用每个texel的VK_FORMAT_D16_UNORM值紧密打包</li>
<li>复制到或从VK_FORMAT_D32_SFLOAT或VK_FORMAT_D32_SFLOAT_S8_UINT格式的深度方面的数据使用每个texel的一个VK_FORMAT_D32_SFLOAT值紧密打包</li>
<li>复制到或从VK_FORMAT_X8_D24_UNORM_PACK32或VK_FORMAT_D24_UNORM_S8_UINT格式的深度方面的数据被打包为每个texel一个32位单词，每个单词的lsb中有D24值，8个msb中有未定义的值</li>
</ol>
<p>由于图像副本的深度或模板方面缓冲区在某些实现上可能需要格式转换，因此不支持图形的队列不支持格式转换。<br>当复制到深度方面时，并且没有启用VK_EXT_depth_range_unrestricted扩展名，缓冲区内存中的数据必须在[0,1]范围内，否则结果值是未定义的。<br>复制从imageSubresource的图像图层baseArrayLayer成员开始一层一层地进行。layerCount层从源图像或目标图像复制。</p>
<h3 id="1-5-2-vkCmdCopyBufferToImage"><a href="#1-5-2-vkCmdCopyBufferToImage" class="headerlink" title="1.5.2 vkCmdCopyBufferToImage"></a>1.5.2 vkCmdCopyBufferToImage</h3><p>在缓冲区和图像之间复制数据, 从buffer对象复制数据到image对象, 调用vkCmdCopyBufferToImage:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdCopyBufferToImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    srcBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage                                     dstImage,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImageLayout                               dstImageLayout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    regionCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferImageCopy*                    pRegions)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>commandBuffer是命令将被记录到的命令缓冲区</li>
<li>srcBuffer是源缓冲区</li>
<li>dstImage是目标图像</li>
<li>dstImageLayout是复制的目标图像子资源的布局</li>
<li>regionCount是要复制的区域数</li>
<li>pRegions是一个指向VkBufferImageCopy结构数组的指针，该结构数组指定要复制的区域</li>
</ol>
<p>区域中的每个区域从源缓冲区的指定区域复制到目标图像的指定区域。</p>
<p>如果dstImage的格式是一个多平面的图像格式)，必须使用VkBufferImageCopy结构的pRegions成员单独指定作为拷贝目标的每个平面的区域。在本例中，imageSubresource的aspectMask必须为VK_IMAGE_ASPECT_PLANE_0_BIT、VK_IMAGE_ASPECT_PLANE_1_BIT或VK_IMAGE_ASPECT_PLANE_2_BIT。对于vkCmdCopyBufferToImage来说，多平面图像的每个平面都被视为具有由相应子资源的aspectMask标识的平面的多平面格式的兼容平面格式中列出的格式。这既适用于VkFormat，也适用于复制中使用的坐标，它对应于平面中的texel，而不是这些texel如何映射到整个图像中的坐标。</p>
<h2 id="1-6-准备纹理图像"><a href="#1-6-准备纹理图像" class="headerlink" title="1.6 准备纹理图像"></a>1.6 准备纹理图像</h2><p>回到createTextureImage函数。我们在那里做的最后一件事是创建纹理图像。下一步是将暂存缓冲区复制到纹理图像。这包括两个步骤:</p>
<ol>
<li>转换纹理图像到VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</li>
<li>执行缓冲区到图像复制操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该图像是使用VK_IMAGE_LAYOUT_UNDEFINED布局创建的，因此在转换textureImage时应将oldLayout指定为VK_IMAGE_LAYOUT_UNDEFINED</span></span><br><span class="line"><span class="comment">// 在执行复制操作之前，不关心图像内容，所以可以这样做</span></span><br><span class="line"><span class="built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">        VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝stagingBuffer中缓存的图像数据至Image（GPU可见内存）</span></span><br><span class="line"><span class="built_in">copyBufferToImage</span>(stagingBuffer, textureImage,</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texWidth), <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texHeight));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了能够从着色器中的纹理图像开始采样，我们需要最后一个过渡来准备着色器访问(用于同步对资源的访问)：</span></span><br><span class="line"><span class="built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-7-转换屏障的含义-VkAccessFlags"><a href="#1-7-转换屏障的含义-VkAccessFlags" class="headerlink" title="1.7 转换屏障的含义 VkAccessFlags"></a>1.7 转换屏障的含义 VkAccessFlags</h2><p>现在在启用验证层的情况下运行应用程序，那么将看到transitionImageLayout中的访问掩码和管道阶段无效。</p>
<p>我们需要根据过渡中的布局来设置它们，拷贝前后的两种转换都需要设置：</p>
<ol>
<li>VK_IMAGE_LAYOUT_UNDEFINED-&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 不需要等待任何内容的传输写入</li>
<li>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL-&gt; VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: shader reads应该等待Transfer writes，特别是shader在片段着色器中读取，因为这就是我们要使用纹理的地方</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineStageFlags sourceStage;</span><br><span class="line">VkPipelineStageFlags destinationStage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED</span><br><span class="line">        &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123;</span><br><span class="line">    barrier.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Image或缓冲区在清除或复制操作中的写访问</span></span><br><span class="line">    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line">    <span class="comment">// 指定队列最初接收到任何命令的管道阶段</span></span><br><span class="line">    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;</span><br><span class="line">    <span class="comment">// 指定所有复制命令和清除命令管道阶段</span></span><br><span class="line">    destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</span><br><span class="line">        &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123;</span><br><span class="line">    <span class="comment">// Image或缓冲区在清除或复制操作中的写访问</span></span><br><span class="line">    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line">    <span class="comment">// 指定对存储缓冲区、物理存储缓冲区、统一texel缓冲区、存储texel缓冲区、采样图像或存储图像的读访问</span></span><br><span class="line">    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</span><br><span class="line">    <span class="comment">// 指定所有复制命令和清除命令管道阶段</span></span><br><span class="line">    sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">    <span class="comment">// 指定片段着色器阶段</span></span><br><span class="line">    destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;unsupported layout transition!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkCmdPipelineBarrier</span>(commandBuffer, sourceStage, destinationStage,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">1</span>, &amp;barrier);</span><br></pre></td></tr></table></figure>

<p>传输写入必须在管道传输阶段进行。因为写操作不需要等待任何东西，所以您可以为预barrier操作指定一个空的访问掩码和尽可能早的管道阶段VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT。需要注意的是，VK_PIPELINE_STAGE_TRANSFER_BIT并不是图形和计算管道中的一个真正的阶段。它更多的是一个发生转移的伪阶段。</p>
<p>图像将在相同的管道阶段被写入，然后被片段着色器读取，这就是为什么我们在片段着色器管道阶段指定着色器读取访问。需要注意的一点是，命令缓冲区提交在开始时会导致隐式的VK_ACCESS_HOST_WRITE_BIT同步。由于transitionImageLayout函数只使用一个命令来执行一个命令缓冲区，所以如果在布局转换中需要VK_ACCESS_HOST_WRITE_BIT依赖项，您可以使用这个隐式同步并将srcAccessMask设置为0。</p>
<p>实际上，有一种特殊的图像布局类型可以支持所有操作–VK_IMAGE_LAYOUT_GENERAL。当然，它的问题在于，它不一定能为任何操作提供最佳性能。在某些特殊情况下，例如使用图像作为输入和输出，或者在离开预初始化的布局后读取图像。到目前为止，所有提交命令的帮助程序功能都已设置为通过等待队列变为空闲状态而同步执行。对于实际应用，建议将这些操作组合在单个命令缓冲区中，并异步执行它们以提高吞吐量，尤其是createTextureImage函数中的过渡和复制。通过创建一个helper函数将命令记录到其中的setupCommandBuffer并尝试添加一个flushSetupCommands来执行到目前为止已记录的命令，来尝试进行此操作。最好在纹理贴图工作后执行此操作，以检查纹理资源是否仍正确设置。</p>
<h3 id="1-7-1-VkAccessFlagBits"><a href="#1-7-1-VkAccessFlagBits" class="headerlink" title="1.7.1 VkAccessFlagBits"></a>1.7.1 VkAccessFlagBits</h3><p>Vulkan中的内存可以通过shader调用和管道中的一些固定函数来访问。访问类型是所使用的描述符类型的函数，或者固定函数阶段如何访问内存。每个访问类型对应于VkAccessFlagBits中的一个位标志。</p>
<p>一些同步命令以访问类型集作为参数来定义内存依赖项的访问范围。如果同步命令包含源访问掩码，则其第一个访问作用域仅包括通过该掩码中指定的访问类型进行的访问。类似地，如果同步命令包含目标访问掩码，则其第二个访问作用域仅包括通过该掩码中指定的访问类型进行的访问。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkAccessFlagBits</span> &#123;</span><br><span class="line">    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_ACCESS_INDEX_READ_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_ACCESS_UNIFORM_READ_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_ACCESS_SHADER_READ_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_ACCESS_SHADER_WRITE_BIT = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_ACCESS_TRANSFER_READ_BIT = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_ACCESS_TRANSFER_WRITE_BIT = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_ACCESS_HOST_READ_BIT = <span class="number">0x00002000</span>,</span><br><span class="line">    VK_ACCESS_HOST_WRITE_BIT = <span class="number">0x00004000</span>,</span><br><span class="line">    VK_ACCESS_MEMORY_READ_BIT = <span class="number">0x00008000</span>,</span><br><span class="line">    VK_ACCESS_MEMORY_WRITE_BIT = <span class="number">0x00010000</span>,</span><br><span class="line">    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = <span class="number">0x02000000</span>,</span><br><span class="line">    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = <span class="number">0x04000000</span>,</span><br><span class="line">    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = <span class="number">0x08000000</span>,</span><br><span class="line">    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = <span class="number">0x00100000</span>,</span><br><span class="line">    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = <span class="number">0x00020000</span>,</span><br><span class="line">    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = <span class="number">0x00040000</span>,</span><br><span class="line">    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = <span class="number">0x00080000</span>,</span><br><span class="line">    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = <span class="number">0x00800000</span>,</span><br><span class="line">    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = <span class="number">0x00200000</span>,</span><br><span class="line">    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = <span class="number">0x00400000</span>,</span><br><span class="line">    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = <span class="number">0x01000000</span>,</span><br><span class="line">    VK_ACCESS_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkAccessFlagBits;</span><br></pre></td></tr></table></figure>

<ol>
<li>VK_ACCESS_INDIRECT_COMMAND_READ_BIT指定对作为间接绘图或调度命令一部分的间接命令数据的读访问</li>
<li>VK_ACCESS_INDEX_READ_BIT指定对索引缓冲区的读访问，作为索引绘图命令的一部分，由vkCmdBindIndexBuffer绑定</li>
<li>VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT指定对顶点缓冲区的读访问，作为绘图命令的一部分，由vkCmdBindVertexBuffers绑定</li>
<li>VK_ACCESS_UNIFORM_READ_BIT统一缓冲区读访问权限</li>
<li>VK_ACCESS_INPUT_ATTACHMENT_READ_BIT指定在片段着色期间渲染通道内对输入附件的读访问</li>
<li>VK_ACCESS_SHADER_READ_BIT指定对存储缓冲区、物理存储缓冲区、统一texel缓冲区、存储texel缓冲区、采样图像或存储图像的读访问</li>
<li>VK_ACCESS_SHADER_WRITE_BIT存储缓冲区、物理存储缓冲区、存储texel缓冲区或存储映像的写访问</li>
<li>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT指定对颜色附件的读访问，例如通过混合、逻辑操作或通过某些subpass加载操作。它不包括高级混合操作</li>
<li>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT指定在渲染通道期间或通过某些子通道加载和存储操作对颜色、解析或深度&#x2F;模板解析附件的写访问</li>
<li>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT指定对深度&#x2F;模板附件的读访问，通过深度或模板操作，或通过某些子传递加载操作</li>
<li>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT指定对深度&#x2F;模板附件的写访问，通过深度或模板操作，或者通过某些子传递加载和存储操作</li>
<li>VK_ACCESS_TRANSFER_READ_BIT拷贝操作中对镜像或缓冲区的读访问</li>
<li>VK_ACCESS_TRANSFER_WRITE_BIT映像或缓冲区在清除或复制操作中的写访问</li>
<li>VK_ACCESS_HOST_READ_BIT主机操作读访问。这种类型的访问不是通过资源执行的，而是直接在内存上执行的</li>
<li>VK_ACCESS_HOST_WRITE_BIT主机操作写访问。这种类型的访问不是通过资源执行的，而是直接在内存上执行的</li>
<li>VK_ACCESS_MEMORY_READ_BIT所有读访问。它在任何访问掩码中都是有效的，并被视为等同于设置所有在使用它时有效的读访问标志</li>
<li>VK_ACCESS_MEMORY_WRITE_BIT所有写访问。它在任何访问掩码中都是有效的，并被视为等同于设置所有在使用它时有效的写访问标志</li>
<li>VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT指定对谓词的读访问，作为条件呈现的一部分</li>
<li>VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT指定在转换反馈激活时对转换反馈缓冲区的写访问</li>
<li>VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT指定对转换反馈计数器缓冲区的读访问，当vkCmdBeginTransformFeedbackEXT执行时读取该缓冲区</li>
<li>VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT指定对转换反馈计数器缓冲区的写访问，该缓冲区在vkCmdEndTransformFeedbackEXT执行时写入</li>
<li>VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX指定从VkBuffer输入读取vkCmdProcessCommandsNVX</li>
<li>VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX指定写到vkCmdProcessCommandsNVX的目标命令缓冲区</li>
<li>VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT类似于VK_ACCESS_COLOR_ATTACHMENT_READ_BIT，但是也包括高级的混合操作</li>
<li>VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV指定对着色率图像的读取访问，作为绘图命令的一部分，由vkcmdbindshadingraemimagenv绑定</li>
<li>VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV指定对加速结构的读访问，作为跟踪或构建命令的一部分</li>
<li>VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV指定对加速结构的写访问，作为构建命令的一部分</li>
<li>VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT动态碎片密度图操作时对碎片密度图附件的读访问</li>
</ol>
<h3 id="1-7-2-VkPipelineStageFlags-管道阶段"><a href="#1-7-2-VkPipelineStageFlags-管道阶段" class="headerlink" title="1.7.2 VkPipelineStageFlags 管道阶段"></a>1.7.2 VkPipelineStageFlags 管道阶段</h3><p>操作或同步命令执行的工作由多个操作组成，这些操作作为逻辑上独立的步骤序列执行，称为管道阶段。执行的确切管道阶段取决于所使用的特定命令，以及记录命令时的当前命令缓冲区状态。绘制命令、分派命令、复制命令、清除命令和同步命令都在管道阶段的不同集合中执行。同步命令不会在已定义的管道中执行，但会执行VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT和VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT。</p>
<p>注意同步命令执行的操作(例如可用性和可见性操作)不是由定义的管道阶段执行的。但是，其他命令仍然可以通过VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT和VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT管道阶段与它们同步。</p>
<p>跨管道阶段执行操作必须遵循隐式排序保证，特别是包括管道阶段顺序。否则，与其他阶段相比，跨管道阶段的执行可能会重叠或无序执行，除非执行依赖项强制执行。</p>
<p>一些同步命令包括管道阶段参数，将该命令的同步范围限制在这些阶段。这允许对精确的执行依赖关系和操作命令执行的访问进行细粒度的控制。实现应该使用这些管道阶段来避免不必要的停顿或缓存刷新。</p>
<p>可以设置指定管道阶段通过VkPipelineStageFlags:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkPipelineStageFlagBits</span> &#123;</span><br><span class="line">    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TRANSFER_BIT = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = <span class="number">0x00002000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_HOST_BIT = <span class="number">0x00004000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = <span class="number">0x00008000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = <span class="number">0x00010000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = <span class="number">0x01000000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = <span class="number">0x00040000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = <span class="number">0x00020000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = <span class="number">0x00400000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = <span class="number">0x00200000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = <span class="number">0x02000000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = <span class="number">0x00080000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = <span class="number">0x00100000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = <span class="number">0x00800000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkPipelineStageFlagBits;</span><br></pre></td></tr></table></figure>

<ol>
<li>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT指定队列最初接收到任何命令的管道阶段</li>
<li>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT指定使用Draw&#x2F;DispatchIndirect数据结构的管道阶段。这个阶段还包括读取vkCmdProcessCommandsNVX写的命令</li>
<li>VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV指定任务着色器阶段</li>
<li>VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV指定网格着色器阶段</li>
<li>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT指定消耗顶点和索引缓冲区的流水线阶段</li>
<li>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT指定顶点着色器阶段</li>
<li>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT指定镶嵌控制着色器阶段</li>
<li>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT指定镶嵌评估着色器阶段</li>
<li>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT指定几何着色器阶段</li>
<li>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT指定片段着色器阶段</li>
<li>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT指定执行早期片段测试（片段着色之前的深度和模板测试）的管道阶段。此阶段还包括针对具有深度&#x2F;模板格式的帧缓冲区附件的子传递加载操作</li>
<li>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT指定执行后期片段测试（片段着色后的深度和模板测试）的管道阶段。此阶段还包括用于具有深度&#x2F;模板格式的帧缓冲区附件的子传递存储操作</li>
<li>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT指定混合后管道的阶段，从管道输出最终颜色值。此阶段还包括子通道加载和存储操作以及具有颜色或深度&#x2F;模板格式的帧缓冲区附件的多样本解析操作</li>
<li>VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT指定执行计算着色器</li>
<li>VK_PIPELINE_STAGE_TRANSFER_BIT指定以下命令：<ol>
<li>所有复制命令，包括vkCmdCopyQueryPoolResults，vkCmdBlitImage，vkCmdResolveImage</li>
<li>所有清除命令，但vkCmdClearAttachments除外</li>
</ol>
</li>
<li>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT指定管道中由所有命令生成的操作完成执行的最后阶段</li>
<li>VK_PIPELINE_STAGE_HOST_BIT指定一个伪阶段，指示在主机上执行设备存储器的读&#x2F;写操作。记录在命令缓冲区中的任何命令都不会调用此阶段</li>
<li>VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV指定光线跟踪着色器阶段的执行</li>
<li>VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV指定vkCmdBuildAccelerationStructureNV，vkCmdCopyAccelerationStructureNV和vkCmdWriteAccelerationStructuresPropertiesNV的执行</li>
<li>VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT指定所有图形管线阶段的执行，并且等效于：<ol>
<li>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</li>
<li>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT</li>
<li>VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</li>
<li>VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</li>
<li>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</li>
<li>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</li>
<li>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</li>
<li>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</li>
<li>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</li>
<li>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</li>
<li>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</li>
<li>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</li>
<li>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</li>
<li>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</li>
<li>VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT</li>
<li>VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT</li>
<li>VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV</li>
<li>VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT</li>
</ol>
</li>
<li>VK_PIPELINE_STAGE_ALL_COMMANDS_BIT等效于与其一起使用的队列上支持的所有其他管道阶段标志的逻辑或</li>
<li>VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT指定使用条件渲染谓词的管道阶段</li>
<li>VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT指定将顶点属性输出值写入转换反馈缓冲区的管线阶段</li>
<li>VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX指定了处理通过vkCmdProcessCommandsNVX在设备端生成命令的管道阶段</li>
<li>VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV指定管道的阶段，在该阶段中读取阴影率图像，以确定栅格化图元各部分的阴影率</li>
<li>VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT指定读取片段密度图以生成片段区域的管线阶段</li>
</ol>
<h2 id="1-8-清理"><a href="#1-8-清理" class="headerlink" title="1.8 清理"></a>1.8 清理</h2><p>创建纹理贴图后，不能忘记在必要的时候将内存释放出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过清除过渡缓冲区及其末尾的内存来完成createTextureImage函数：</span></span><br><span class="line">    <span class="built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyImage</span>(device, textureImage, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, textureImageMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-总结"><a href="#1-9-总结" class="headerlink" title="1.9 总结"></a>1.9 总结</h2><p>到目前为止，我们从设备物理存储上读取了图片内容，将其转成临时缓存后又将其存储在对应GPU可见的内存中以及生成对应VkImage纹理贴图对象，接下来需要将其显示在屏幕上还需要把这个对象放入图形管道中。</p>
<p>在回顾下本章中的读取图像的步骤:</p>
<ol>
<li>首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存</li>
<li>通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象</li>
<li>用VkBuffer图像文件中的像素填充创建的VkImage图像对象<ol>
<li>填充图像对象需要使用VkImageMemoryBarrier</li>
<li>使用vkCmdPipelineBarrier使得图像填充Barrier生效</li>
<li>通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充)</li>
<li>再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样</li>
</ol>
</li>
<li>创建图像视图和图像采样器(后续下一章开始处理)</li>
<li>添加一个组合的图像采样器描述符来从纹理中采样颜色</li>
</ol>
<p>上面步骤中，4和5是下一章的内容。</p>
<h2 id="1-10-Windows上的CMakefileLists-txt写法"><a href="#1-10-Windows上的CMakefileLists-txt写法" class="headerlink" title="1.10 Windows上的CMakefileLists.txt写法"></a>1.10 Windows上的CMakefileLists.txt写法</h2><p>windows平台上编译当前项目，可以使用cmake, CMakefileLists.txt文件如下(注意先安装Vulkan sdk)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION 3.7) #最低要求的CMake版本</span><br><span class="line">project(MyVulkan) # 项目名称</span><br><span class="line">set(VERSION 0.0.1)</span><br><span class="line">set(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -g -Wall -Wno-unused-variable -pthread&quot;)</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;This is &quot; $&#123;PROJECT_NAME&#125; &quot; version &quot; $&#123;VERSION&#125;)</span><br><span class="line">message(STATUS &quot;This is for windows platform&quot;)</span><br><span class="line">message(&quot;Build Type:&quot; $&#123;CMAKE_BUILD_TYPE&#125; $&#123;CMAKE_CXX_FLAGS&#125;)</span><br><span class="line"></span><br><span class="line"># Use FindVulkan module added with CMAKE 3.7</span><br><span class="line">if (NOT CMAKE_VERSION VERSION_LESS 3.7.0)</span><br><span class="line">    message(STATUS &quot;Using module to find Vulkan&quot;)</span><br><span class="line">    find_package(Vulkan)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">find_library(Vulkan_LIBRARY NAMES vulkan-1 vulkan PATHS $&#123;CMAKE_SOURCE_DIR&#125;/libs/vulkan)</span><br><span class="line">IF (Vulkan_LIBRARY)</span><br><span class="line">    set(Vulkan_FOUND ON)</span><br><span class="line">    MESSAGE(&quot;Using bundled Vulkan library version&quot;)</span><br><span class="line">ENDIF()</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;Using Vulkan lib: &quot; $&#123;Vulkan_LIBRARY&#125;)</span><br><span class="line"></span><br><span class="line"># CMAKE_SOURCE_DIR 代表工程根目录CMakeLists.txt文件所在目录</span><br><span class="line">set(ROOT_DIR $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">### GLFW3</span><br><span class="line">set(GLFW_LIB_DIR $&#123;ROOT_DIR&#125;/lib/glfw3)</span><br><span class="line">set(GLFW_LIBS $&#123;GLFW_LIB_DIR&#125;/glfw3dll.lib)</span><br><span class="line">### GLM</span><br><span class="line">set(GLM_INCLUDE_DIRS  $&#123;ROOT_DIR&#125;/include/glm)</span><br><span class="line">### stb-image</span><br><span class="line">set(STB_IMAGE_DIRS  $&#123;ROOT_DIR&#125;/include/stb-image)</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;Lib path: &quot;)</span><br><span class="line">message(STATUS &quot;  GLFW3: &quot; $&#123;GLFW_LIBS&#125;)</span><br><span class="line">message(STATUS &quot;  GLM  : &quot; $&#123;GLM_INCLUDE_DIRS&#125;)</span><br><span class="line">message(STATUS &quot;  STB_IMAGE: &quot; $&#123;STB_IMAGE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 定义头文件搜索路径</span><br><span class="line">include_directories($&#123;ROOT_DIR&#125;/inlcude</span><br><span class="line">                    $&#123;GLM_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">#aux_source_directory(./ SOURCE_DIR)</span><br><span class="line">aux_source_directory($&#123;ROOT_DIR&#125;/inlcude SOURCE_DIR)</span><br><span class="line">aux_source_directory($&#123;ROOT_DIR&#125;/src SOURCE_DIR)</span><br><span class="line"></span><br><span class="line"># Target</span><br><span class="line">add_executable(MyVulkan $&#123;SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">####Vulkan</span><br><span class="line">find_package(Vulkan REQUIRED)</span><br><span class="line"># GLFW3 is dynamic link</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; Vulkan::Vulkan $&#123;GLFW_LIBS&#125;)</span><br></pre></td></tr></table></figure>

<p>项目文件目录:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/Vulkan_14_1.png" alt="图像14-1"></p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(15)-图像视图和采样器</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>回顾上一篇章中的读取图像的步骤:</p>
<ol>
<li>首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存</li>
<li>通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象</li>
<li>用VkBuffer图像文件中的像素填充创建的VkImage图像对象<ol>
<li>填充图像对象需要使用VkImageMemoryBarrier</li>
<li>使用vkCmdPipelineBarrier使得图像填充Barrier生效</li>
<li>通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充)</li>
<li>再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样</li>
</ol>
</li>
<li>创建图像视图和图像采样器</li>
<li>添加一个组合的图像采样器描述符来从纹理中采样颜色</li>
</ol>
<p>在图像采样器创建之前，我们首先看看纹理图像视图，这个是在我们创建交换链的时候见过:</p>
<span id="more"></span>

<h1 id="一-纹理图像视图-Texture-Image-View"><a href="#一-纹理图像视图-Texture-Image-View" class="headerlink" title="一. 纹理图像视图 Texture Image View"></a>一. 纹理图像视图 Texture Image View</h1><p>通过VkImageView类来存储纹理图像视图, 它描述了如何访问图像以及要访问的图像部分，创建VkImageView的方式也是通过一个结构体：VkImageViewCreateInfo, 来指明细节. 这部分我们在之前的交换链创建图像视图中有过接触，如果忘记了的话可以回顾一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkImageView textureImageView;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createTextureImage</span>();</span><br><span class="line">    <span class="built_in">createTextureImageView</span>();</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VkImageView <span class="title">createImageView</span><span class="params">(VkImage image, VkFormat format)</span> </span>&#123;</span><br><span class="line">    VkImageView imageView;</span><br><span class="line">    VkImageViewCreateInfo viewInfo = &#123;&#125;;</span><br><span class="line">    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;</span><br><span class="line">    viewInfo.image = image; <span class="comment">// 绑定 VkImage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// viewType和format字段指定应如何解释图像数据</span></span><br><span class="line">    <span class="comment">// viewType参数指定图像为一维纹理，二维纹理，三维纹理或立方体贴图</span></span><br><span class="line">    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;</span><br><span class="line">    <span class="comment">// 图像格式</span></span><br><span class="line">    viewInfo.format = format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subresourceRange字段描述了图像的目的是什么以及应该访问图像的哪个部分。</span></span><br><span class="line">    <span class="comment">// 这里图像将用作颜色目标，没有任何mipmapping级别或多个层。</span></span><br><span class="line">    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    viewInfo.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    viewInfo.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    viewInfo.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    viewInfo.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意，通过vkCreateXXX创建的对象，不需要时要主动去释放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateImageView</span>(device, &amp;viewInfo, <span class="literal">nullptr</span>, &amp;imageView) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create image views!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createImageViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置集合大小</span></span><br><span class="line">    swapChainImageViews.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImageViews.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        swapChainImageViews[i] = <span class="built_in">createImageView</span>(swapChainImages[i],</span><br><span class="line">                                        swapChainImageFormat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImageView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    textureImageView = <span class="built_in">createImageView</span>(textureImage,</span><br><span class="line">                                VK_FORMAT_R8G8B8A8_UNORM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 vulkan 中推荐在创建的资源不需要后主动释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理交换链关联资源</span></span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="comment">// 清理纹理贴图</span></span><br><span class="line">    <span class="built_in">vkDestroyImageView</span>(device, textureImageView, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyImage</span>(device, textureImage, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, textureImageMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，纹理图像的视图创建成功了，很简单。接下来就是采样器的创建了。</p>
<h1 id="二-采样器"><a href="#二-采样器" class="headerlink" title="二. 采样器"></a>二. 采样器</h1><p>着色器可以直接从图像读取纹理像素，但是当将其用作纹理时，一般不会直接读取。 通常通过采样器访问纹理，采样器将应用过滤和转换以计算最终获取的颜色。</p>
<p>这些过滤器有助于处理过采样等问题。 考虑一个映射到几何图形的纹理，该纹理的碎片多于纹理像素。</p>
<p>如果只是在每个片段中使用最接近的纹理像素作为纹理坐标，那么将获得下图左边图像的结果：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_1.png" alt="图像15-1"></p>
<p>而通过线性插值法将4个最接近的纹理像素组合在一起，那么将获得如上右图所示的更平滑的结果。 当然，您的应用程序可能具有更适合左侧风格的艺术风格要求（比如Minecraft，哈哈），但是在常规图形应用程序中，右侧风格是首选，图像越精细越好。 从纹理读取颜色时，采样器对象会自动为您应用此过滤。</p>
<p>抽样不足(欠采样)则是相反的问题，比如纹理像素多于片段。这将导致在以锐角采样高频图案(如棋盘纹理)时产生伪影:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_2.png" alt="图像15-2"></p>
<p>如左图所示，纹理在远处变得模糊混乱。解决这个问题的方法是各向异性滤波，它也可以由采样器自动应用。</p>
<p>除了这些过滤器，采样器还可以处理转换。它决定当你试图通过它的寻址模式读取图像外的texel时会发生什么。下面的图片显示了一些可能性:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_3.png" alt="图像15-3"></p>
<h2 id="2-1-createTextureSampler"><a href="#2-1-createTextureSampler" class="headerlink" title="2.1 createTextureSampler"></a>2.1 createTextureSampler</h2><p>现在创建一个函数createTextureSampler来设置这样的采样对象。稍后我们将在着色器中使用采样器从纹理中读取颜色:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkImageView textureImageView;</span><br><span class="line">VkSampler textureSampler;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createTextureImage</span>();</span><br><span class="line">    <span class="built_in">createTextureImageView</span>();</span><br><span class="line">    <span class="built_in">createTextureSampler</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureSampler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 采样器通过VkSamplerCreateInfo结构进行配置，该结构指定了应应用的所有过滤器和转换。 </span></span><br><span class="line">    VkSamplerCreateInfo samplerInfo = &#123;&#125;;</span><br><span class="line">    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;</span><br><span class="line">    <span class="comment">// magFilter和minFilter字段指定如何对放大或缩小的纹理像素进行插值。</span></span><br><span class="line">    <span class="comment">// 放大倍数与上面描述的过采样问题有关，而缩小倍数与欠采样有关。</span></span><br><span class="line">    <span class="comment">// 指定要应用于查找的放大滤镜为线性过滤</span></span><br><span class="line">    samplerInfo.magFilter = VK_FILTER_LINEAR;</span><br><span class="line">    <span class="comment">// 指定要应用于查找的缩小过滤器为线性过滤</span></span><br><span class="line">    samplerInfo.minFilter = VK_FILTER_LINEAR;</span><br><span class="line">    <span class="comment">// 指定U、V、W坐标的[0..1]范围之外的寻址模式, 指定当超出图像尺寸时，重复纹理</span></span><br><span class="line">    <span class="comment">// 注意，轴称为U，V和W，而不是X，Y和Z。这是纹理空间坐标的约定</span></span><br><span class="line">    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line">    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line">    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anisotropyEnable为true, 采样器使用使用各向异性过滤</span></span><br><span class="line">    samplerInfo.anisotropyEnable = VK_TRUE;</span><br><span class="line">    samplerInfo.maxAnisotropy = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// borderColor字段指定在使用边界寻址模式对图像进行采样以外时返回的颜色。 </span></span><br><span class="line">    <span class="comment">// 可以以float或int格式返回黑色，白色或透明。</span></span><br><span class="line">    samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;</span><br><span class="line">    <span class="comment">// 指定要用于处理图像中纹理像素的坐标系</span></span><br><span class="line">    <span class="comment">// 为VK_FALSE，则将使用所有轴上的[0，1）范围对纹理像素进行寻址</span></span><br><span class="line">    samplerInfo.unnormalizedCoordinates = VK_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果启用了比较功能，则将首先将纹理像素与一个值进行比较，并且该比较的结果将用于过滤操作中。 主要用于阴影贴图上的百分比封闭器过滤。</span></span><br><span class="line">    samplerInfo.compareEnable = VK_FALSE;</span><br><span class="line">    samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有这些字段都适用于mipmapping。以后讨论mipmapping</span></span><br><span class="line">    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;</span><br><span class="line">    samplerInfo.mipLodBias = <span class="number">0.0f</span>;</span><br><span class="line">    samplerInfo.minLod = <span class="number">0.0f</span>;</span><br><span class="line">    samplerInfo.maxLod = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建采样器，注意清理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateSampler</span>(device, &amp;samplerInfo, <span class="literal">nullptr</span>, &amp;textureSampler) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create texture sampler!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="comment">// 清理采样器</span></span><br><span class="line">    <span class="built_in">vkDestroySampler</span>(device, textureSampler, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>samplerInfo中的anisotropyEnable和maxAnisotropy这两个字段指定是否应该使用各向异性过滤。最大各向异性字段限制了可以用来计算最终颜色的texel样本的数量。数值越低，性能越好，但质量越低。目前没有任何图形硬件可以使用超过16个样本，因为超过这个值的差异就可以忽略不计了。</p>
<p>unnormalizedCoordinates字段指定要用于处理图像中纹理像素的坐标系。 如果此字段为VK_TRUE，则可以简单地使用[0，texWidth）和[0，texHeight）范围内的坐标。 如果为VK_FALSE，则将使用所有轴上的[0，1）范围对纹理像素进行寻址。 实际应用中几乎总是使用归一化的坐标，因为这样一来，便可以使用分辨率完全相同的不同分辨率的纹理。</p>
<p>请注意，采样器未在任何地方引用VkImage。 采样器是一个独特的对象，它提供了一个接口来从纹理中提取颜色。 它可以应用于所需的任何图像，无论是1D，2D还是3D。 这与许多较早的API不同，后者将纹理图像和过滤合并为一个状态。</p>
<h2 id="2-2-VkSamplerCreateInfo"><a href="#2-2-VkSamplerCreateInfo" class="headerlink" title="2.2 VkSamplerCreateInfo"></a>2.2 VkSamplerCreateInfo</h2><p>VkSamplerCreateInfo结构体指定了采样器对象的状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSamplerCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType         sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*             pNext;</span><br><span class="line">    VkSamplerCreateFlags    flags;</span><br><span class="line">    VkFilter                magFilter;</span><br><span class="line">    VkFilter                minFilter;</span><br><span class="line">    VkSamplerMipmapMode     mipmapMode;</span><br><span class="line">    VkSamplerAddressMode    addressModeU;</span><br><span class="line">    VkSamplerAddressMode    addressModeV;</span><br><span class="line">    VkSamplerAddressMode    addressModeW;</span><br><span class="line">    <span class="type">float</span>                   mipLodBias;</span><br><span class="line">    VkBool32                anisotropyEnable;</span><br><span class="line">    <span class="type">float</span>                   maxAnisotropy;</span><br><span class="line">    VkBool32                compareEnable;</span><br><span class="line">    VkCompareOp             compareOp;</span><br><span class="line">    <span class="type">float</span>                   minLod;</span><br><span class="line">    <span class="type">float</span>                   maxLod;</span><br><span class="line">    VkBorderColor           borderColor;</span><br><span class="line">    VkBool32                unnormalizedCoordinates;</span><br><span class="line">&#125; VkSamplerCreateInfo;</span><br></pre></td></tr></table></figure>

<ol>
<li>sType是此结构的类型， VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</li>
<li>pNext是NULL或指向扩展特定结构的指针</li>
<li>flag是VkSamplerCreateFlagBits的位掩码，描述了采样器的其他参数</li>
<li>magFilter是VkFilter值，用于指定要应用于查找的放大滤镜<ol>
<li>VK_FILTER_NEAREST 指定最近的过滤</li>
<li>VK_FILTER_LINEAR 指定线性过滤</li>
<li>VK_FILTER_CUBIC_EXT 指定三次过滤</li>
<li>VK_FILTER_CUBIC_IMG 指定三次过滤，同VK_FILTER_CUBIC_EXT</li>
</ol>
</li>
<li>minFilter是一个VkFilter值，用于指定要应用于查找的缩小过滤器</li>
<li>mipmapMode是VkSamplerMipmapMode值，指定要应用于查找的mipmap过滤器</li>
<li>addressModeU是VkSamplerAddressMode值，用于为U坐标指定[0..1]范围之外的寻址模式<ol>
<li>VK_SAMPLER_ADDRESS_MODE_REPEAT 当超出图像尺寸时，重复纹理</li>
<li>VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT 类似于重复，但是当超出尺寸时会反转坐标以镜像图像</li>
<li>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 在图像尺寸之外，获取最靠近坐标的边缘的颜色</li>
<li>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER 当采样超出图像尺寸时，返回纯色</li>
<li>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE 类似CLAMP_TO_EDGE，但使用与最近边缘相反的边缘,仅在启用samplerMirrorClampToEdge或启用[VK_KHR_sampler_mirror_clamp_to_edge]扩展名后才有效</li>
</ol>
</li>
<li>addressModeV是VkSamplerAddressMode值，用于指定V坐标的[0..1]范围之外的寻址模式</li>
<li>addressModeW是VkSamplerAddressMode值，它为W坐标指定[0..1]范围之外的寻址模式</li>
<li>mipLodBias是要添加到mipmap LOD（详细程度）计算中的偏差，以及由SPIR-V中的图像采样功能提供的偏差</li>
<li>anisotropyEnable为VK_TRUE以启用各向异性过滤，如“ Texel各向异性过滤”部分所述，否则为VK_FALSE</li>
<li>maxAnisotropy是anisotropyEnable为VK_TRUE时采样器使用的各向异性值钳位。如果anisotropyEnable为VK_FALSE，则maxAnisotropy被忽略</li>
<li>compareEnable为VK_TRUE，以允许在查找过程中与参考值进行比较，否则为VK_FALSE<ol>
<li>注意：如果此成员不匹配，则某些实现将默认为着色器状态</li>
</ol>
</li>
<li>compareOp是一个VkCompareOp值，它指定比较功能，以按“深度比较操作”部分所述在过滤之前将其应用于获取的数据</li>
<li>minLod和maxLod是用于钳位计算的LOD值的值</li>
<li>borderColor是VkBorderColor值，用于指定要使用的预定义边框颜色</li>
<li>unnormalizedCoordinates指定要用于处理图像中纹理像素的坐标系。设置为VK_TRUE时，用于查找纹理像素的图像坐标的范围在0到x，y和z的图像尺寸的范围内。设置为VK_FALSE时，图像坐标范围为零到一。<ol>
<li>当unnormalizedCoordinates为VK_TRUE时，在着色器中使用采样器的图像具有以下要求：<ol>
<li>viewType必须为VK_IMAGE_VIEW_TYPE_1D或VK_IMAGE_VIEW_TYPE_2D</li>
<li>图像视图必须具有单个图层和单个mip级别</li>
</ol>
</li>
<li>当unnormalizedCoordinates为VK_TRUE时，使用采样器的着色器中的图像内置函数具有以下要求：<ol>
<li>这些功能不得使用投影</li>
<li>这些函数不得使用偏移量</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="2-3-vkCreateSampler"><a href="#2-3-vkCreateSampler" class="headerlink" title="2.3 vkCreateSampler"></a>2.3 vkCreateSampler</h2><p>VkSampler对象表示图像采样器的状态，实现可使用该对象读取图像数据并为着色器应用过滤和其他转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateSampler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSamplerCreateInfo*                  pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSampler*                                  pSampler)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>device是创建采样器的逻辑设备</li>
<li>pCreateInfo是指向VkSamplerCreateInfo结构的指针，该结构指定采样器对象的状态</li>
<li>pAllocator控制主机内存分配</li>
<li>pSampler是指向VkSampler句柄的指针，在该句柄中返回生成的采样器对象</li>
</ol>
<h2 id="2-4-设备功能之各向异性过滤"><a href="#2-4-设备功能之各向异性过滤" class="headerlink" title="2.4 设备功能之各向异性过滤"></a>2.4 设备功能之各向异性过滤</h2><p>如果现在运行程序，则会看到如下所示的验证层消息：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_4.png" alt="图片15-4"></p>
<p>这是因为各向异性过滤实际上是一个可选的设备特性。我们需要更新createLogicalDevice函数来请求它:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;;</span><br><span class="line">deviceFeatures.samplerAnisotropy = VK_TRUE;</span><br></pre></td></tr></table></figure>

<p>即使现在的显卡不支持它的可能性很小，我们也应该更新isDeviceSuitable来检查它是否可用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    VkPhysicalDeviceFeatures supportedFeatures;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceFeatures</span>(device, &amp;supportedFeatures);</span><br><span class="line">    <span class="keyword">return</span> indices.<span class="built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp;</span><br><span class="line">            swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vkGetPhysicalDeviceFeatures重新调整VkPhysicalDeviceFeatures结构的用途，通过设置布尔值来指示支持哪些功能，而不是请求哪些功能。</p>
<p>除了强制各向异性过滤的可用性，也可以通过条件设置不使用它:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">samplerInfo.anisotropyEnable = VK_FALSE;</span><br><span class="line">samplerInfo.maxAnisotropy = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>现在图像有了，接下来，我们将向着色器公开图像和采样器对象，以便将纹理绘制到正方形上并呈现出来。</p>
<h1 id="三-组合图像采样器"><a href="#三-组合图像采样器" class="headerlink" title="三. 组合图像采样器"></a>三. 组合图像采样器</h1><p>我们在统一缓冲区部分中了解了描述符。 现在我们看一种新型的描述符：组合图像采样器。 该描述符使着色器可以通过采样器对象访问图像资源。</p>
<p>我们将从修改描述符布局，描述符池和描述符集开始，以包括此类组合的图像采样器描述符。 之后，我们将向顶点添加纹理坐标，并修改片段着色器以从纹理读取颜色，而不仅仅是插入顶点颜色。</p>
<h2 id="3-1-更新描述符"><a href="#3-1-更新描述符" class="headerlink" title="3.1 更新描述符"></a>3.1 更新描述符</h2><p>回到createDescriptorSetLayout函数，为组合的图像采样器描述符添加VkDescriptorSetLayoutBinding。 将其放在统一缓冲区之后的绑定中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建采样器描述符</span></span><br><span class="line">    VkDescriptorSetLayoutBinding samplerLayoutBinding = &#123;&#125;;</span><br><span class="line">    samplerLayoutBinding.binding = <span class="number">1</span>;</span><br><span class="line">    samplerLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">    samplerLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 指明片段着色器阶段可以使用组合的图像采样器描述符, 那就是片段颜色确定的地方。</span></span><br><span class="line">    <span class="comment">// 可以在顶点着色器中使用纹理采样，例如通过高度图使顶点网格动态变形。</span></span><br><span class="line">    samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;</span><br><span class="line"></span><br><span class="line">    std::array&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings = &#123;uboLayoutBinding, samplerLayoutBinding&#125;;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;;</span><br><span class="line">    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;</span><br><span class="line">    layoutInfo.bindingCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(bindings.<span class="built_in">size</span>());</span><br><span class="line">    layoutInfo.pBindings = bindings.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建描述符集布局</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorSetLayout</span>(device, &amp;layoutInfo, <span class="literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor set layout!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您现在运行带有验证层的应用程序，那么会发现描述符池无法使用此布局分配描述符集，因为它没有任何组合的图像采样器描述符。</p>
<p>转到createDescriptorPool函数并对其进行修改，以包括此描述符的VkDescriptorPoolSize：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorPoolSize poolSize = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 我们创建的是统一缓冲的描述符</span></span><br><span class="line">    poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    poolSize.descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 第一个是统一缓冲区描述符</span></span><br><span class="line">    poolSizes[<span class="number">0</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    poolSizes[<span class="number">0</span>].descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 第二个是纹理图像采样器描述符</span></span><br><span class="line">    poolSizes[<span class="number">1</span>].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">    poolSizes[<span class="number">1</span>].descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;;</span><br><span class="line">    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;</span><br><span class="line">    poolInfo.poolSizeCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(poolSizes.<span class="built_in">size</span>());</span><br><span class="line">    poolInfo.pPoolSizes = poolSizes.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了可用的单个描述符的最大数量外，还需要指定可以分配的最大描述符集数量：与交换链图像数量一致</span></span><br><span class="line">    poolInfo.maxSets = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 创建描述符池</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorPool</span>(device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步是将实际图像和采样器资源绑定到描述符集中的描述符。 转到createDescriptorSets函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; descriptorSets.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定图像视图和采样器到描述符中</span></span><br><span class="line">        VkDescriptorImageInfo imageInfo = &#123;&#125;;</span><br><span class="line">        imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须在VkDescriptorImageInfo结构中指定用于组合图像采样器结构的资源</span></span><br><span class="line">        imageInfo.imageView = textureImageView;</span><br><span class="line">        imageInfo.sampler = textureSampler;</span><br><span class="line"></span><br><span class="line">        std::array&lt;VkWriteDescriptorSet, 2&gt; descriptorWrites = &#123;&#125;;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].dstSet = descriptorSets[i];</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].dstBinding = <span class="number">0</span>;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].dstArrayElement = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 绑定统一缓冲区至描述符</span></span><br><span class="line">        descriptorWrites[<span class="number">0</span>].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].descriptorCount = <span class="number">1</span>;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].pBufferInfo = &amp;bufferInfo;</span><br><span class="line"></span><br><span class="line">        descriptorWrites[<span class="number">1</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].dstSet = descriptorSets[i];</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].dstBinding = <span class="number">1</span>;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].dstArrayElement = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 绑定图像视图和相应的采样器至描述符</span></span><br><span class="line">        descriptorWrites[<span class="number">1</span>].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].descriptorCount = <span class="number">1</span>;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].pImageInfo = &amp;imageInfo;</span><br><span class="line">        <span class="comment">// 应用描述符集更新</span></span><br><span class="line">        <span class="built_in">vkUpdateDescriptorSets</span>(device,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(descriptorWrites.<span class="built_in">size</span>()),</span><br><span class="line">            descriptorWrites.<span class="built_in">data</span>(), <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>必须在VkDescriptorImageInfo结构中指定用于组合图像采样器结构的资源，就像在VkDescriptorBufferInfo结构中指定用于统一缓冲区描述符的缓冲区资源一样。</p>
<h2 id="3-2-纹理坐标"><a href="#3-2-纹理坐标" class="headerlink" title="3.2 纹理坐标"></a>3.2 纹理坐标</h2><p>纹理映射还有一个重要要素就是每个顶点的实际坐标。 坐标决定了图像如何实际映射到几何体:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line">    glm::vec2 texCoord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">        bindingDescription.binding = <span class="number">0</span>;</span><br><span class="line">        bindingDescription.stride = <span class="built_in">sizeof</span>(Vertex);</span><br><span class="line">        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;</span><br><span class="line">        <span class="keyword">return</span> bindingDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::array&lt;VkVertexInputAttributeDescription, 3&gt; <span class="title">getAttributeDescriptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions = &#123;&#125;;</span><br><span class="line">        <span class="comment">// position 顶点输入位置属性描述符</span></span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].location = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].offset = <span class="built_in">offsetof</span>(Vertex, pos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// color 顶点输入颜色属性描述符</span></span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].location = <span class="number">1</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].offset = <span class="built_in">offsetof</span>(Vertex, color);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// coordinates 顶点输入坐标属性描述符</span></span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].location = <span class="number">2</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].format = VK_FORMAT_R32G32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].offset = <span class="built_in">offsetof</span>(Vertex, texCoord);</span><br><span class="line">        <span class="keyword">return</span> attributeDescriptions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改“顶点”结构，使其包含用于纹理坐标的vec2（texCoord）。 确保还添加了VkVertexInputAttributeDescription，以便我们可以将访问纹理坐标用作顶点着色器中的输入。 要将它们传递到片段着色器以便在正方形表面上进行插值，这是必要的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>先使用从左上角的0、0到右下角的1、1的坐标简单地用纹理填充正方形。 随意尝试使用不同的坐标。 稍后我们看看低于0或高于1的坐标下的实际的寻址模式！</p>
<h2 id="3-3-着色器"><a href="#3-3-着色器" class="headerlink" title="3.3 着色器"></a>3.3 着色器</h2><p>最后一步是修改着色器，以从纹理中采样颜色。 我们首先需要修改顶点着色器，以将纹理坐标传递到片段着色器：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> inTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec2</span> fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">    fragTexCoord = inTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像每个顶点的颜色一样，栅格化器会将fragTexCoord值平滑地插入到正方形区域中。 我们可以通过使片段着色器将纹理坐标输出为颜色来形象化：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> outColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    outColor = <span class="type">vec4</span>(fragTexCoord, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们编译下着色器，然后运行下程序:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_5.png" alt="图片15-5"></p>
<h3 id="3-3-1-片段着色器中的图像采样器描述符"><a href="#3-3-1-片段着色器中的图像采样器描述符" class="headerlink" title="3.3.1 片段着色器中的图像采样器描述符"></a>3.3.1 片段着色器中的图像采样器描述符</h3><p>组合的图像采样器描述符在GLSL中由采样器统一表示。 在片段着色器中添加对它的引用：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 对于其他类型的图像，存在等效的sampler1D和sampler3D类型。 确保在此处使用正确的绑定。 </span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> texSampler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    outColor = <span class="built_in">texture</span>(texSampler, fragTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译一下shader然后运行程序:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_6.png" alt="图像15-6"></p>
<p>哒哒，一个旋转的贴图出现了！</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(2)-创建Vulkan示例及验证层</title>
    <url>/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-2-%E5%88%9B%E5%BB%BAVulkan%E7%A4%BA%E4%BE%8B%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%B1%82/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是实现Vulkan Tutorial.pdf文档中的Base Code, Instance和Validation Layers部分。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://github.com/KhronosGroup/Vulkan-Docs">https://github.com/KhronosGroup/Vulkan-Docs</a></li>
<li><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateInstance">https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateInstance</a></li>
<li><a href="https://github.com/SaschaWillems/Vulkan/blob/master/base/vulkanexamplebase.h">https://github.com/SaschaWillems/Vulkan/blob/master/base/vulkanexamplebase.h</a></li>
</ol>
<h1 id="一-创建-vulkan-实例"><a href="#一-创建-vulkan-实例" class="headerlink" title="一. 创建 vulkan 实例"></a>一. 创建 vulkan 实例</h1><h2 id="1-1-创建-Window-实例"><a href="#1-1-创建-Window-实例" class="headerlink" title="1.1 创建 Window 实例"></a>1.1 创建 Window 实例</h2><p>先创建个 window 窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步一定是先初始化GLFW库.</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为GLFW最初是为创建OpenGL上下文而设计的，</span></span><br><span class="line">    <span class="comment">// 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GLFW_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    <span class="comment">// GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, WINDOW_TITLE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-创建-Vulkan-实例"><a href="#1-2-创建-Vulkan-实例" class="headerlink" title="1.2 创建 Vulkan 实例"></a>1.2 创建 Vulkan 实例</h2><ol>
<li>创建 VkApplicationInfo 结构体变量，参数可选</li>
<li>创建 VkInstanceCreateInfo 结构体变量，必须指明<ol>
<li>使用 GLFW (glfwGetRequiredInstanceExtensions) 创建 glfwExtensions, 以便为GLFW窗口创建Vulkan surface</li>
</ol>
</li>
<li>调用 vkCreateInstance, 创建 vulkan 实例</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo</span></span><br><span class="line">    <span class="comment">// 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化</span></span><br><span class="line">    VkApplicationInfo appInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vulkan中的许多结构要求在sType成员中明确指定类型。 </span></span><br><span class="line">    <span class="comment">// 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。</span></span><br><span class="line">    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;</span><br><span class="line"></span><br><span class="line">    appInfo.pApplicationName = <span class="string">&quot;Hello Triangle&quot;</span>;</span><br><span class="line">    appInfo.applicationVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    appInfo.pEngineName = <span class="string">&quot;No Engine&quot;</span>;</span><br><span class="line">    appInfo.engineVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    appInfo.apiVersion = VK_API_VERSION_1_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vulkan中的很多信息都是通过结构而不是函数参数传递的，</span></span><br><span class="line">    <span class="comment">// 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。</span></span><br><span class="line">    <span class="comment">// VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 </span></span><br><span class="line">    VkInstanceCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span><br><span class="line">    createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    createInfo.pApplicationInfo = &amp;appInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前两个参数很简单。 </span></span><br><span class="line">    <span class="comment">// Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。</span></span><br><span class="line">    <span class="comment">// GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo</span></span><br><span class="line">    <span class="type">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** glfwExtensions;</span><br><span class="line">    <span class="comment">// 返回GLFW所需的Vulkan实例扩展。</span></span><br><span class="line">    <span class="comment">// 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 </span></span><br><span class="line">    <span class="comment">// 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。</span></span><br><span class="line">    <span class="comment">// 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。</span></span><br><span class="line">    glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">    createInfo.enabledExtensionCount = glfwExtensionCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// createInfo.ppEnabledLayerNames = glfwExtensions;</span></span><br><span class="line">    <span class="comment">// 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped)</span></span><br><span class="line">    <span class="comment">// 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。</span></span><br><span class="line">    createInfo.ppEnabledExtensionNames = glfwExtensions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体的最后两个成员确定要启用的全局验证层。</span></span><br><span class="line">    createInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)</span></span><br><span class="line">    VkResult res = <span class="built_in">vkCreateInstance</span>(&amp;createInfo, <span class="literal">nullptr</span>, &amp;instance);</span><br><span class="line">    <span class="keyword">if</span> (res != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create instance!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-验证层-Validation-layers"><a href="#二-验证层-Validation-layers" class="headerlink" title="二. 验证层(Validation layers)"></a>二. 验证层(Validation layers)</h1><h2 id="2-1-什么是-Validation-layers？"><a href="#2-1-什么是-Validation-layers？" class="headerlink" title="2.1 什么是 Validation layers？"></a>2.1 什么是 Validation layers？</h2><p>Vulkan API围绕最小驱动程序开销的想法而设计，该目标的一个表现形式是默认情况下API中的错误检查非常有限。<br>即使是将枚举设置为不正确的值或将空指针传递给所需参数这样简单的错误通常也不会被显式处理，只会导致崩溃或未定义的行为。<br>这一点，笔者已经深刻体会到了，(╯﹏╰)<br>因为Vulkan要求你对你所做的一切都非常明确，所以很容易犯很多小错误，例如使用新的GPU功能而忘记在逻辑设备创建时请求它。</p>
<p>但是，这并不意味着无法将这些检查添加到API中。<br>Vulkan为这种称为验证层的系统引入了一个优雅的系统: Validation layers.<br>验证层是可选组件，它挂接到Vulkan函数调用以应用其他操作。 </p>
<p>验证层中的常见操作是：</p>
<ol>
<li>根据规范检查参数值以检测误用</li>
<li>跟踪对象的创建和销毁以查找资源泄漏</li>
<li>通过跟踪调用的线程来检查线程安全性</li>
<li>将每个调用及其参数记录到标准输出方便调试</li>
<li>跟踪Vulkan要求进行性能分析和重放</li>
</ol>
<h2 id="2-2-Validation-layers示例"><a href="#2-2-Validation-layers示例" class="headerlink" title="2.2 Validation layers示例"></a>2.2 Validation layers示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkInstanceCreateInfo* pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks* pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance* instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCreateInfo == <span class="literal">nullptr</span> || instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;Null pointer passed to required parameter!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> VK_ERROR_INITIALIZATION_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real_vkCreateInstance</span>(pCreateInfo, pAllocator, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的vkCreateInstance中的if语句。官方文档上如此说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这些验证层可以自由堆叠，以包含您感兴趣的所有调试功能。</span><br><span class="line">您可以简单地为调试版本启用验证层，并为发布版本完全禁用它们，这将为您提供两全其美的优势！</span><br><span class="line">Vulkan没有内置任何验证层，但LunarG Vulkan SDK提供了一组很好的层来检查常见错误。</span><br><span class="line">它们也是完全开源的，因此您可以检查它们检查和贡献的错误类型。</span><br><span class="line">使用验证层是避免应用程序因意外依赖未定义行为而破坏不同驱动程序的最佳方法。</span><br><span class="line">验证层只有在已安装到系统上时才能使用。</span><br><span class="line">例如，LunarG验证层仅适用于安装了Vulkan SDK的PC。</span><br><span class="line">Vulkan中以前有两种不同类型的验证层：实例和设备特定。</span><br><span class="line">我们的想法是，实例层只会检查与全局Vulkan对象（如实例）相关的调用，而设备特定层只会检查与特定GPU相关的调用。</span><br><span class="line">现在已弃用特定于设备的层，这意味着实例验证层适用于所有Vulkan调用。</span><br><span class="line">规范文档仍建议您在设备级别启用验证层以及兼容性，这是某些实现所需的。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-启用验证层"><a href="#2-3-启用验证层" class="headerlink" title="2.3 启用验证层"></a>2.3 启用验证层</h2><p>如何启用Vulkan SDK提供的标准诊断层? 就像扩展一样，需要通过指定其名称来启用验证层。<br>所有有用的标准验证都捆绑在SDK中包含的层中，称为VK_LAYER_KHRONOS_validation。<br>让我们首先向程序添加两个配置变量，以指定要启用的层以及是否启用它们。 我已经选择将该值作为程序是否在调试模式下编译。<br>NDEBUG宏是C ++标准的一部分，意味着“不调试”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; validationLayers = &#123;</span><br><span class="line">    <span class="string">&quot;VK_LAYER_KHRONOS_validation&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-消息回调"><a href="#2-4-消息回调" class="headerlink" title="2.4 消息回调"></a>2.4 消息回调</h2><p>仅启用这些层并没有多大帮助，因为它们目前无法将调试消息中继回我们的程序。<br>要接收这些消息，我们必须设置一个带回调的调试信使，这需要VK_EXT_debug_utils扩展。<br>我们将首先创建一个getRequiredExtensions函数，根据是否启用验证层返回所需的扩展名列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">getRequiredExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** glfwExtensions;</span><br><span class="line">    glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">extensions</span><span class="params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">        extensions.<span class="built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GLFW指定的扩展始终是必需的，但有条件地添加了调试信使扩展(VK_EXT_debug_utils)。<br>请注意，在这里使用了VK_EXT_DEBUG_UTILS_EXTENSION_NAME宏，它等于文字字符串“VK_EXT_debug_utils”。 使用此宏可以避免拼写错误。<br>我们现在可以在createInstance中使用此函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> extensions = <span class="built_in">getRequiredExtensions</span>();</span><br><span class="line">createInfo.enabledExtensionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(extensions.<span class="built_in">size</span>());</span><br><span class="line">createInfo.ppEnabledExtensionNames = extensions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-调试回调函数-debugCallback"><a href="#2-4-1-调试回调函数-debugCallback" class="headerlink" title="2.4.1 调试回调函数 debugCallback"></a>2.4.1 调试回调函数 debugCallback</h3><p>现在让我们看一下调试回调函数的样子。<br>使用PFN_vkDebugUtilsMessengerCallbackEXT原型添加一个名为debugCallback的新静态成员函数。<br>VKAPI_ATTR和VKAPI_CALL确保该函数具有Vulkan调用它的正确签名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="title">debugCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* pUserData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VK_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个参数: VkDebugUtilsMessageSeverityFlagBitsEXT 指明了消息的严重程度<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT：诊断消息<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT：信息性消息，如创建资源<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT：有关行为的消息不一定是错误，但很可能是应用程序中的错误<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT：有关无效行为的消息，可能导致崩溃<br>可以根据这个参数过滤所需的信息。</li>
<li>第二个参数: VkDebugUtilsMessageTypeFlagsEXT 指明了消息的类型<br>•VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT：发生了与规范或性能无关的某些事件<br>•VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT：发生了违反规范或表明可能存在错误的事情<br>•VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT：潜在的非最佳使用Vulkan</li>
<li>第三个参数: VkDebugUtilsMessengerCallbackDataEXT 这个结构体包含了消息更多的细节内容<br>•pMessage：调试消息为以空字符结尾的字符串<br>•pObjects：与消息相关的Vulkan对象句柄数组<br>•object Count：数组中的对象数</li>
<li>第四个参数: pUserData 包含在回调设置期间指定的指针，并允许您将自己的数据传递给它。</li>
</ol>
<p>回调返回一个布尔值，指示是否应该中止触发验证层消息的Vulkan调用。<br>如果回调返回true，则调用将因VK_ERROR_VALIDATION_FAILED_EXT错误而中止。<br>这通常仅用于测试验证层本身，因此应始终返回VK_FALSE。</p>
<h3 id="2-4-2-注册调试回调"><a href="#2-4-2-注册调试回调" class="headerlink" title="2.4.2 注册调试回调"></a>2.4.2 注册调试回调</h3><p>在Vulkan中, 调试回调也是通过需要显式创建和销毁的句柄来管理的。 这样的回调是debug message的一部分，可以根据需要设置尽可能多的回调。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在成员变量中添加：VkDebugUtilsMessengerEXT</span></span><br><span class="line">VkDebugUtilsMessengerEXT debugMessenger;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="built_in">setupDebugMessenger</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupDebugMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableValidationLayers) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;</span><br><span class="line">    createInfo.messageSeverity =</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;</span><br><span class="line">    createInfo.messageType =</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;</span><br><span class="line">    <span class="comment">// 指定消息回调函数</span></span><br><span class="line">    createInfo.pfnUserCallback = debugCallback;</span><br><span class="line">    createInfo.pUserData = <span class="literal">nullptr</span>; <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>messageSeverity字段允许指定要为其调用回调的所有类型的严重性。<br>在这里指定了除VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT之外的所有类型，以接收有关可能问题的通知，同时省略详细的一般调试信息。<br>类似地，messageType字段可以过滤通知回调的消息类型。 在这里启用了所有类型。<br>最后，pfnUserCallback字段指定回调函数的指针。可以选择将指针传递给pUserData字段，该字段将通过pUserData参数传递给回调函数。<br>例如，可以使用它来传递指向HelloTriangleApplication类的指针。</p>
<p>应该将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。<br>然而因为这个function是一个扩展函数，它不会自动加载。<br>必须使用vkGetInstanceProcAddr查找其地址。 创建代理函数，然后在处理它，如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">CreateDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*</span></span></span><br><span class="line"><span class="params"><span class="function">    pDebugMessenger)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT)</span><br><span class="line">    <span class="built_in">vkGetInstanceProcAddr</span>(instance,<span class="string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以在 setupDebugMessenger 中调用此函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupDebugMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableValidationLayers) <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 实例化DebugUtilsMessengerEXT</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="literal">nullptr</span>,</span><br><span class="line">        &amp;debugMessenger) != VK_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to set up debug messenger!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后注意，既然有 vkCreateXXX, 就需要显示调用 vkDestroyXXX 哦！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessengerEXT debugMessenger, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    VkAllocationCallbacks* pAllocator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT)</span><br><span class="line">    <span class="built_in">vkGetInstanceProcAddr</span>(instance, <span class="string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">func</span>(instance, debugMessenger, pAllocator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你忘了调用DestroyDebugUtilsMessengerEXT去销毁debugMessenger，在关闭窗口的时候就会打印如下信息:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-2-%E5%88%9B%E5%BB%BAVulkan%E7%A4%BA%E4%BE%8B%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%B1%82/Vulkan_2_1.png" alt="图片"></p>
<h1 id="三-代码"><a href="#三-代码" class="headerlink" title="三. 代码"></a>三. 代码</h1><h2 id="3-1-Makefile"><a href="#3-1-Makefile" class="headerlink" title="3.1 Makefile"></a>3.1 Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64</span><br><span class="line"></span><br><span class="line">CFLAGS = -std=c++17 -I<span class="variable">$(VULKAN_SDK_PATH)</span>/<span class="keyword">include</span></span><br><span class="line">LDFLAGS = -L<span class="variable">$(VULKAN_SDK_PATH)</span>/lib -lvulkan `pkg-config --static --libs glfw3`</span><br><span class="line">LDFLAGS += -ldl</span><br><span class="line"></span><br><span class="line"><span class="section">HelloTriangleApplication: main.cpp</span></span><br><span class="line">	g++ <span class="variable">$(CFLAGS)</span> -o HelloTriangleApplication main.cpp <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: HelloTriangleApplication</span></span><br><span class="line">    LD_LIBRARY_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/lib</span><br><span class="line">        VK_LAYER_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/etc/explicit_layer.d ./HelloTriangleApplication</span><br><span class="line"></span><br><span class="line"><span class="section">clean:rm -f HelloTriangleApplication</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-main-cpp"><a href="#3-2-main-cpp" class="headerlink" title="3.2 main.cpp"></a>3.2 main.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * #include &lt;vulkan/vulkan.h&gt; // vulkan 头文件</span></span><br><span class="line"><span class="comment"> * 使用下面两行替换 vulkan头文件</span></span><br><span class="line"><span class="comment"> *   #define GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="comment"> *   #include &lt;GLFW/glfw3.h&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  GLFW 会自动加载 vulkan 头文件的。</span></span><br><span class="line"><span class="comment"> * GLFW是一个开源，多平台的库，用于桌面上的OpenGL，OpenGL ES和Vulkan开发。 </span></span><br><span class="line"><span class="comment"> * 它提供了一个简单的API，用于创建窗口，上下文和曲面，接收输入和事件。</span></span><br><span class="line"><span class="comment"> * GLFW是用C语言编写的，并且使用X Window系统（例如Linux和FreeBSD）对Windows，macOS和许多类Unix系统提供原生支持。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// 包含用于报告错误的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 用于资源管理部分中的lambda函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// cstdlib: EXIT_FAILURE, EXIT_SUCCESS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloTriangleApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">initWindow</span>();</span><br><span class="line">        <span class="built_in">initVulkan</span>();</span><br><span class="line">        <span class="built_in">mainLoop</span>();</span><br><span class="line">        <span class="built_in">cleanup</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> WIDTH = <span class="number">800</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> HEIGHT = <span class="number">600</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * WINDOW_TITLE = <span class="string">&quot;Vulkan&quot;</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步一定是先初始化GLFW库.</span></span><br><span class="line">        <span class="built_in">glfwInit</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为GLFW最初是为创建OpenGL上下文而设计的，</span></span><br><span class="line">        <span class="comment">// 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API</span></span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变</span></span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GLFW_FALSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建窗口</span></span><br><span class="line">        <span class="comment">// GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)</span></span><br><span class="line">        window = <span class="built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, WINDOW_TITLE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">checkAvailableExtensions</span>();</span><br><span class="line">        <span class="built_in">createInstance</span>();</span><br><span class="line">        <span class="comment">// 创建DEBUG消息回调</span></span><br><span class="line">        <span class="built_in">setupDebugMessenger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupDebugMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!enableValidationLayers) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;;</span><br><span class="line">        createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;</span><br><span class="line">        createInfo.messageSeverity =</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;</span><br><span class="line">        createInfo.messageType =</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指定消息回调函数</span></span><br><span class="line">        createInfo.pfnUserCallback = debugCallback;</span><br><span class="line">        createInfo.pUserData = <span class="literal">nullptr</span>; <span class="comment">// 可选</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化DebugUtilsMessengerEXT</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="literal">nullptr</span>,</span><br><span class="line">                &amp;debugMessenger) != VK_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to set up debug messenger!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkAvailableExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> extensionCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">extensions</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, extensions.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;available extensions:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; extension : extensions) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; extension.extensionName &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidationLayerSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> layerCount;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;VkLayerProperties&gt; <span class="title">availableLayers</span><span class="params">(layerCount)</span></span>;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* layerName : validationLayers) &#123;</span><br><span class="line">            <span class="comment">//bool layerFound = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layerProperties : availableLayers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//layerFound = true;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证层，检验VK_LAYER_KHRONOS_validation</span></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers &amp;&amp; !<span class="built_in">checkValidationLayerSupport</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;validation layers requested, but not available!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo</span></span><br><span class="line">        <span class="comment">// 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化</span></span><br><span class="line">        VkApplicationInfo appInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulkan中的许多结构要求在sType成员中明确指定类型。 </span></span><br><span class="line">        <span class="comment">// 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。</span></span><br><span class="line">        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;</span><br><span class="line"></span><br><span class="line">        appInfo.pApplicationName = <span class="string">&quot;Hello Triangle&quot;</span>;</span><br><span class="line">        appInfo.applicationVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        appInfo.pEngineName = <span class="string">&quot;No Engine&quot;</span>;</span><br><span class="line">        appInfo.engineVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        appInfo.apiVersion = VK_API_VERSION_1_1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulkan中的很多信息都是通过结构而不是函数参数传递的，</span></span><br><span class="line">        <span class="comment">// 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。</span></span><br><span class="line">        <span class="comment">// VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 </span></span><br><span class="line">        VkInstanceCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span><br><span class="line">        createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        createInfo.pApplicationInfo = &amp;appInfo;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 前两个参数很简单。 </span></span><br><span class="line"><span class="comment">        // Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。</span></span><br><span class="line"><span class="comment">        // GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo</span></span><br><span class="line"><span class="comment">        uint32_t glfwExtensionCount = 0;</span></span><br><span class="line"><span class="comment">        const char** glfwExtensions;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        // 返回GLFW所需的Vulkan实例扩展。</span></span><br><span class="line"><span class="comment">        // 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 </span></span><br><span class="line"><span class="comment">        // 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。</span></span><br><span class="line"><span class="comment">        // 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。</span></span><br><span class="line"><span class="comment">        glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped)</span></span><br><span class="line"><span class="comment">        // 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。</span></span><br><span class="line"><span class="comment">        createInfo.ppEnabledLayerNames = glfwExtensions;</span></span><br><span class="line"><span class="comment">        createInfo.ppEnabledExtensionNames = glfwExtensions;</span></span><br><span class="line"><span class="comment">        createInfo.enabledExtensionCount = glfwExtensionCount;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 返回GLFW所需的Vulkan实例扩展, 支持消息回调</span></span><br><span class="line">        <span class="keyword">auto</span> extensions = <span class="built_in">getRequiredExtensions</span>();</span><br><span class="line">        createInfo.enabledExtensionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(extensions.<span class="built_in">size</span>());</span><br><span class="line">        createInfo.ppEnabledExtensionNames = extensions.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构体的最后两个成员确定要启用的全局验证层。</span></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">            createInfo.enabledLayerCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(validationLayers.<span class="built_in">size</span>());</span><br><span class="line">            createInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)</span></span><br><span class="line">        VkResult res = <span class="built_in">vkCreateInstance</span>(&amp;createInfo, <span class="literal">nullptr</span>, &amp;instance);</span><br><span class="line">        <span class="keyword">if</span> (res != VK_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create instance!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加一个事件循环, 使应用程序保持运行直到发生错误或窗口关闭</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">            <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 vulkan 中推荐在创建的资源不需要后主动释放</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放debugMessenger(VkDebugUtilsMessengerEXT, 用于打印调试信息)</span></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">            <span class="built_in">DestroyDebugUtilsMessengerEXT</span>(instance, debugMessenger, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在 vulkan 中资源一般都是 vkCreateXXX 创建，由 vkDestroyXXX 或 vkFreeXXX 释放.</span></span><br><span class="line">        <span class="built_in">vkDestroyInstance</span>(instance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此函数会破坏指定的窗口及其上下文。 在调用此函数时，不会为该窗口调用其他回调。</span></span><br><span class="line">        <span class="comment">// 如果指定窗口的上下文在主线程上是最新的，则在销毁之前将其分离。</span></span><br><span class="line">        <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此功能会释放所有剩余的窗口和光标并释放任何其他已分配的资源。 </span></span><br><span class="line">        <span class="comment">// 调用此函数后，必须再次成功调用@ref glfwInit，然后才能使用大多数GLFW函数。</span></span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于消息回调Message Callback</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">getRequiredExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>** glfwExtensions;</span><br><span class="line">        glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">extensions</span><span class="params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">            extensions.<span class="built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> extensions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印debug信息</span></span><br><span class="line">    <span class="function"><span class="type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="title">debugCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* pUserData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> VK_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 VkDebugUtilsMessengerEXT 对象debugMessenger</span></span><br><span class="line">    <span class="function">VkResult <span class="title">CreateDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">        VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*</span></span></span><br><span class="line"><span class="params"><span class="function">        pDebugMessenger)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。 </span></span><br><span class="line">        <span class="comment">// 然而因为这个function是一个扩展函数，它不会自动加载。</span></span><br><span class="line">        <span class="comment">// 必须使用vkGetInstanceProcAddr查找其地址。</span></span><br><span class="line">        <span class="keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT)</span><br><span class="line">        <span class="built_in">vkGetInstanceProcAddr</span>(instance,<span class="string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁VkDebugUtilsMessengerEXT</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DestroyDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessengerEXT debugMessenger, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">        VkAllocationCallbacks* pAllocator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT)</span><br><span class="line">        <span class="built_in">vkGetInstanceProcAddr</span>(instance, <span class="string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">func</span>(instance, debugMessenger, pAllocator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window实例</span></span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    <span class="comment">// Vulkan实例</span></span><br><span class="line">    VkInstance instance;</span><br><span class="line">    <span class="comment">// DEBUG消息回调</span></span><br><span class="line">    VkDebugUtilsMessengerEXT debugMessenger;</span><br><span class="line">    <span class="comment">// 验证层</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; validationLayers = &#123;</span><br><span class="line">        <span class="string">&quot;VK_LAYER_KHRONOS_validation&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HelloTriangleApplication app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        app.<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(3)-设置物理设备和逻辑设备</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-3-%E8%AE%BE%E7%BD%AE%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是学习Vulkan Tutorial.pdf文档中的Physical devices and queue families(物理设备和队列系列)部分以及Logical device and queues(逻辑设备与队列)部分。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[Vulkan-文档]<a href="https://github.com/KhronosGroup/Vulkan-Docs">https://github.com/KhronosGroup/Vulkan-Docs</a></li>
<li>[Vulkan-feature查询]<a href="https://vulkan.lunarg.com/doc/view/1.0.26.0/linux/vkspec.chunked/ch31s01.html">https://vulkan.lunarg.com/doc/view/1.0.26.0/linux/vkspec.chunked/ch31s01.html</a></li>
</ol>
<h1 id="一-Physical-devices-and-queue-families-物理设备和队列系列"><a href="#一-Physical-devices-and-queue-families-物理设备和队列系列" class="headerlink" title="一. Physical devices and queue families(物理设备和队列系列)"></a>一. Physical devices and queue families(物理设备和队列系列)</h1><h2 id="1-1-选择物理显卡GPU"><a href="#1-1-选择物理显卡GPU" class="headerlink" title="1.1 选择物理显卡GPU"></a>1.1 选择物理显卡GPU</h2><p>在通过VkInstance初始化Vulkan库之后，需要在系统中查找并选择支持我们所需功能的图形显卡。<br>事实上，我们可以选择任意数量的显卡并同时使用。但在这里，只使用第一个适合我们需求的显卡。<br>我们将添加一个函数pickPhysicalDevice并在initVulkan函数中添加对它的调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">checkAvailableExtensions</span>();</span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="comment">// 创建DEBUG消息回调</span></span><br><span class="line">    <span class="built_in">setupDebugMessenger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择物理设备</span></span><br><span class="line">    <span class="built_in">pickPhysicalDevice</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pickPhysicalDevice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终选择的图形卡将存储在VkPhysicalDevice句柄中，该句柄作为新的类成员添加。当VkInstance被销毁时，该对象将被隐式销毁，因此我们不需要在清理函数中做任何新的操作。</p>
<ol>
<li>VkPhysicalDevice对象不能被显式销毁。相反，当检索到它们的VkInstance对象被撤销时，它们将隐式撤销。</li>
<li>一旦所有由VkPhysicalDevice对象创建的VkDevice对象都被销毁，VkInstance对象就可以被销毁。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;</span><br></pre></td></tr></table></figure>

<p>列出物理显卡的过程和列出vulkan扩展的过程类似，首先是获取本机物理显卡的数量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pickPhysicalDevice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> deviceCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 首先获取本机物理显卡数量</span></span><br><span class="line">    <span class="built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当然没有GPU时，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (deviceCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to find GPUs with Vulkan support!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;VkPhysicalDevice&gt; <span class="title">devices</span><span class="params">(deviceCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, devices.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有GPU, 选择合适的使用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; device : devices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isDeviceSuitable</span>(device)) &#123;</span><br><span class="line">            physicalDevice = device;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暂时没什么可以挑剔的，都可以吧</span></span><br><span class="line">    <span class="comment">// 其实大部分的机器只会有一个显卡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-基础设备适配性检查"><a href="#1-2-基础设备适配性检查" class="headerlink" title="1.2 基础设备适配性检查"></a>1.2 基础设备适配性检查</h2><p>通过查询细节来评估设备的适用性。<br>可以使用<strong>vkGetPhysicalDeviceProperties</strong>查询基本设备属性，如名称，类型和支持的Vulkan版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPhysicalDeviceProperties deviceProperties;</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceProperties</span>(device, &amp;deviceProperties);</span><br></pre></td></tr></table></figure>

<p>使用<strong>vkGetPhysicalDeviceFeatures</strong>查询对纹理压缩，64位浮点和多视口渲染（对VR有用）等可选功能的支持：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPhysicalDeviceFeatures deviceFeatures;</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceFeatures</span>(device, &amp;deviceFeatures);</span><br></pre></td></tr></table></figure>
<p>基本操作就是：</p>
<ol>
<li>通过vkGetPhysicalDeviceProperties获取本机设备的属性</li>
<li>查询vkGetPhysicalDeviceFeatures中可以被支持的feature</li>
</ol>
<p>举个例子，假设我们的应用程序仅适用于支持几何着色器的专用显卡。 那么isDeviceSuitable函数将如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    VkPhysicalDeviceProperties deviceProperties;</span><br><span class="line">    VkPhysicalDeviceFeatures deviceFeatures;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceProperties</span>(device, &amp;deviceProperties);</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceFeatures</span>(device, &amp;deviceFeatures);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU)</span><br><span class="line">            &amp;&amp; deviceFeatures.geometryShader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有可支持的feature见附录。<br>根据Vulkan Tutorial文档，有推荐使用评分机制来选择最合适的GPU，这个就见仁见智，看个人喜好，这里就不赘述了。</p>
<h2 id="1-3-Queue-families"><a href="#1-3-Queue-families" class="headerlink" title="1.3 Queue families"></a>1.3 Queue families</h2><p>几乎所有Vulkan中的操作，从绘图到上传纹理，都需要将命令提交到队列中(这一点研究过hwui的童鞋肯定深有体会)。<br>存在来自不同队列系列的不同类型的队列，并且每个队列族仅允许命令的子集。<br>例如，可能存在仅允许处理计算命令的队列系列或仅允许与存储器传输相关的命令的队列系列。</p>
<p>所有我们需要检查本机设备支持哪些队列系列，以及哪一个支持我们要使用的命令。<br>添加一个新函数findQueueFamilies，用于查找我们需要的所有队列系列。<br>比如查找支持图形命令的队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QueueFamilyIndices</span> &#123;</span><br><span class="line">    <span class="comment">// 别忘了添加头文件：including &lt;optional&gt;</span></span><br><span class="line">    <span class="comment">// optional用途如其名，它可以容纳一个对象值或是为空。</span></span><br><span class="line">    <span class="comment">// 典型的应用情景是函数调用时，如需根据条件返回一个对象（有效）或默认对象（无效）</span></span><br><span class="line">    <span class="comment">// 若该对象构造成本很高（资源分配等），可用optional返回一个空对象，提高效率。</span></span><br><span class="line">    std::optional&lt;<span class="type">uint32_t</span>&gt; graphicsFamily;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> graphicsFamily.<span class="built_in">has_value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">QueueFamilyIndices <span class="title">findQueueFamilies</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    QueueFamilyIndices indices;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查数量</span></span><br><span class="line">    <span class="type">uint32_t</span> queueFamilyCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 使用 vkGetPhysicalDeviceQueueFamilyProperties 检索队列系列是否正是我们需要的：</span></span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VkQueueFamilyProperties结构包含有关队列系列的一些详细信息</span></span><br><span class="line">    <span class="comment">// 包括支持的操作类型以及可基于该系列创建的队列数</span></span><br><span class="line">    <span class="function">std::vector&lt;VkQueueFamilyProperties&gt; <span class="title">queueFamilies</span><span class="params">(queueFamilyCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.<span class="built_in">data</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比如我们找到一个支持VK_QUEUE_GRAPHICS_BIT的队列系列</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; queueFamily : queueFamilies) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queueFamily.queueCount &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">            queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123;</span><br><span class="line"></span><br><span class="line">            indices.graphicsFamily = i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (indices.<span class="built_in">isComplete</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> indices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把这个检查加入isDeviceSuitable函数。<br>现在已经找到合适的物理设备了， 下一步是创建一个与之适配的逻辑设备。</p>
<h1 id="二-Logical-device-and-queues"><a href="#二-Logical-device-and-queues" class="headerlink" title="二. Logical device and queues"></a>二. Logical device and queues</h1><p>选择要使用的物理设备后，就可以创建一个与之适配的逻辑设备。<br>逻辑设备创建过程类似于实例创建过程，还需要指定现在要创建的队列（已经查询了哪些队列系列可用）。<br>并且从同一物理设备可以创建多个逻辑设备。</p>
<p>存储逻辑设备类似物理设备，也是使用句柄：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkDevice device;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-指定要创建的队列"><a href="#2-1-指定要创建的队列" class="headerlink" title="2.1 指定要创建的队列"></a>2.1 指定要创建的队列</h2><p>创建逻辑设备也是在结构体中指定一堆细节，其中第一个是VkDeviceQueueCreateInfo。<br>此结构描述了我们为单个队列系列所需的队列数。<br>比如创建具有图形功能的队列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QueueFamilyIndices indices = <span class="built_in">findQueueFamilies</span>(physicalDevice);</span><br><span class="line"></span><br><span class="line">VkDeviceQueueCreateInfo queueCreateInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;</span><br><span class="line">queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.<span class="built_in">value</span>();</span><br><span class="line">queueCreateInfo.queueCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当前可用的驱动程序只允许为每个队列系列创建少量队列，实际上也不需要多个队列。<br>因为可以在多个线程上创建所有命令缓冲区，然后使用一个低开销调用在主线程上一次性提交。</p>
<p>Vulkan允许为队列分配优先级，以使用介于0.0和1.0之间的浮点数来影响命令缓冲区执行的调度。<br><strong>即使只有一个队列，也是必需的</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> queuePriority = <span class="number">1.0f</span>;</span><br><span class="line">queueCreateInfo.pQueuePriorities = &amp;queuePriority;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-指定使用的设备功能-feature"><a href="#2-2-指定使用的设备功能-feature" class="headerlink" title="2.2 指定使用的设备功能(feature)"></a>2.2 指定使用的设备功能(feature)</h2><p>要指定的下一个信息是我们将要使用的一组设备feature。<br>这些是在[1.2]中使用vkGetPhysicalDeviceFeatures查询支持的功能，例如几何着色器。<br>如果不需要任何特殊的东西，可以简单地定义它并默认为VK_FALSE。<br>但一旦即将开始用Vulkan做更多有趣的事情，就需要设定这个结构了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-创建逻辑设备"><a href="#2-3-创建逻辑设备" class="headerlink" title="2.3 创建逻辑设备"></a>2.3 创建逻辑设备</h2><p>在VkDeviceQueueCreateInfo和VkPhysicalDeviceFeatures创建完毕后，就可以根据这个创建逻辑设备实例了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkDeviceCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先指定VkDeviceQueueCreateInfo</span></span><br><span class="line">createInfo.pQueueCreateInfos = &amp;queueCreateInfo;</span><br><span class="line">createInfo.queueCreateInfoCount = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 指定VkPhysicalDeviceFeatures</span></span><br><span class="line">createInfo.pEnabledFeatures = &amp;deviceFeatures;</span><br></pre></td></tr></table></figure>
<p>其余信息与VkInstanceCreateInfo结构相似，并要求指定扩展(Extensions)和验证层(Validation Layers)。不同之处在于这次是逻辑设备的。<br>设备特定扩展的其中之一是VK_KHR_swapchain，它允许您将该设备的渲染图像呈现给窗口。<br>系统中可能存在缺乏此功能的Vulkan设备，比如因为它们仅支持计算操作。</p>
<p>Vulkan的先前实现区分了实例和设备特定的验证层，但现在不做区分了。<br>也就是说VkDeviceCreateInfo的enabledLayerCount和ppEnabledLayerNames字段在最新实现中可以忽略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">createInfo.enabledExtensionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">    createInfo.enabledLayerCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(validationLayers.<span class="built_in">size</span>());</span><br><span class="line">    createInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    createInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似创建vulkan实例，这里使用 vkCreateDevice 函数创建逻辑设备：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 vkCreateDevice 创建逻辑设备，别忘了在cleanup函数中销毁</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="literal">nullptr</span>, &amp;device) != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create logical device!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-检索队列句柄"><a href="#2-4-检索队列句柄" class="headerlink" title="2.4 检索队列句柄"></a>2.4 检索队列句柄</h2><p>队列是与逻辑设备一起自动创建的，现在创建与它们接口的句柄。<br>使用 <strong>VkQueue</strong> 来存储队列的句柄，如存储图形队列的句柄：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkQueue graphicsQueue;</span><br></pre></td></tr></table></figure>
<p>当设备被销毁时，会隐式清除设备队列，因此我们不需要在清理中执行任何操作(vkCreateXXX才需要主动释放哦)。</p>
<p>我们可以使用vkGetDeviceQueue函数来检索每个队列系列的队列句柄。<br>参数是逻辑设备，队列系列，队列索引和指向存储队列句柄的变量的指针。<br>因为我们只是从这个系列创建一个队列，所以我们只使用索引0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vkGetDeviceQueue</span>(device, indices.graphicsFamily.<span class="built_in">value</span>(), <span class="number">0</span>, &amp;graphicsQueue);</span><br></pre></td></tr></table></figure>
<p>有了逻辑设备和队列句柄，我们现在可以开始使用显卡来做事了！<br>准备工作基本完成，后续我们可以设置资源并用窗口显示结果！<br>这次就不贴代码了。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="vulkan-feature"><a href="#vulkan-feature" class="headerlink" title="vulkan feature"></a>vulkan feature</h2><details>
<summary>vulkan feature</summary>
<pre><code>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义在 vulkan_core.h 文件中</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPhysicalDeviceFeatures</span> &#123;</span><br><span class="line">    VkBool32    robustBufferAccess;</span><br><span class="line">    VkBool32    fullDrawIndexUint32;</span><br><span class="line">    VkBool32    imageCubeArray;</span><br><span class="line">    VkBool32    independentBlend;</span><br><span class="line">    VkBool32    geometryShader;</span><br><span class="line">    VkBool32    tessellationShader;</span><br><span class="line">    VkBool32    sampleRateShading;</span><br><span class="line">    VkBool32    dualSrcBlend;</span><br><span class="line">    VkBool32    logicOp;</span><br><span class="line">    VkBool32    multiDrawIndirect;</span><br><span class="line">    VkBool32    drawIndirectFirstInstance;</span><br><span class="line">    VkBool32    depthClamp;</span><br><span class="line">    VkBool32    depthBiasClamp;</span><br><span class="line">    VkBool32    fillModeNonSolid;</span><br><span class="line">    VkBool32    depthBounds;</span><br><span class="line">    VkBool32    wideLines;</span><br><span class="line">    VkBool32    largePoints;</span><br><span class="line">    VkBool32    alphaToOne;</span><br><span class="line">    VkBool32    multiViewport;</span><br><span class="line">    VkBool32    samplerAnisotropy;</span><br><span class="line">    VkBool32    textureCompressionETC2;</span><br><span class="line">    VkBool32    textureCompressionASTC_LDR;</span><br><span class="line">    VkBool32    textureCompressionBC;</span><br><span class="line">    VkBool32    occlusionQueryPrecise;</span><br><span class="line">    VkBool32    pipelineStatisticsQuery;</span><br><span class="line">    VkBool32    vertexPipelineStoresAndAtomics;</span><br><span class="line">    VkBool32    fragmentStoresAndAtomics;</span><br><span class="line">    VkBool32    shaderTessellationAndGeometryPointSize;</span><br><span class="line">    VkBool32    shaderImageGatherExtended;</span><br><span class="line">    VkBool32    shaderStorageImageExtendedFormats;</span><br><span class="line">    VkBool32    shaderStorageImageMultisample;</span><br><span class="line">    VkBool32    shaderStorageImageReadWithoutFormat;</span><br><span class="line">    VkBool32    shaderStorageImageWriteWithoutFormat;</span><br><span class="line">    VkBool32    shaderUniformBufferArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderSampledImageArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderStorageBufferArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderStorageImageArrayDynamicIndexing;</span><br><span class="line">    VkBool32    shaderClipDistance;</span><br><span class="line">    VkBool32    shaderCullDistance;</span><br><span class="line">    VkBool32    shaderFloat64;</span><br><span class="line">    VkBool32    shaderInt64;</span><br><span class="line">    VkBool32    shaderInt16;</span><br><span class="line">    VkBool32    shaderResourceResidency;</span><br><span class="line">    VkBool32    shaderResourceMinLod;</span><br><span class="line">    VkBool32    sparseBinding;</span><br><span class="line">    VkBool32    sparseResidencyBuffer;</span><br><span class="line">    VkBool32    sparseResidencyImage2D;</span><br><span class="line">    VkBool32    sparseResidencyImage3D;</span><br><span class="line">    VkBool32    sparseResidency2Samples;</span><br><span class="line">    VkBool32    sparseResidency4Samples;</span><br><span class="line">    VkBool32    sparseResidency8Samples;</span><br><span class="line">    VkBool32    sparseResidency16Samples;</span><br><span class="line">    VkBool32    sparseResidencyAliased;</span><br><span class="line">    VkBool32    variableMultisampleRate;</span><br><span class="line">    VkBool32    inheritedQueries;</span><br><span class="line">&#125; VkPhysicalDeviceFeatures;</span><br></pre></td></tr></table></figure>

<h3 id="1-robustBufferAccess"><a href="#1-robustBufferAccess" class="headerlink" title="1. robustBufferAccess"></a>1. robustBufferAccess</h3><p>指定对缓冲区的访问是根据缓冲区描述符的范围进行边界检查的(由VkDescriptorBufferInfo::range，VkBufferViewCreateInfo::range或缓冲区的大小确定）。<br>超出范围访问不得导致应用程序终止，并且着色器加载，存储和原子的效果必须符合与如下相关的行为：</p>
<ul>
<li>如果满足以下任何条件，则认为缓冲区访问超出范围：   <ul>
<li>指针由OpImageTexelPointer形成，坐标小于零或大于或等于绑定范围内的整个元素的数量。</li>
<li>指针不是由OpImageTexelPointer形成的，并且指向的对象并不完全包含在绑定范围内。这包括通过变量指针执行的访问，其中不能静态地确定被访问的缓冲区描述符。未初始化的指针和指向OpConstantNull的指针被视为指向零大小的对象，因此通过这些指针的所有访问都被视为超出范围。<ul>
<li>注意：如果SPIR-V OpLoad指令加载结构并且结构的尾端超出边界，则结构的所有成员都被视为超出边界，即使最终的成员未被静态使用。</li>
</ul>
</li>
<li>如果确定给定SPIR-V块中的任何缓冲区访问超出范围，则在同一SPIR-V块中访问小于16字节的地址的任何其他相同类型（加载，存储或原子）访问 远离界外地址也可能被认为是超出界限。</li>
</ul>
</li>
<li>超出范围的缓冲区加载将返回以下任何值：<ul>
<li>从绑定到缓冲区的内存范围内的任何位置开始的值（可能包括超出缓冲区末尾的内存字节，直到绑定范围的末尾）。</li>
<li>向量读取的零值或（0,0,0，x）向量，其中x是向量组件类型中表示的有效值，可以是以下任意一种：<ul>
<li>有符号或无符号整数分量的0,1或最大可表示正整数值</li>
<li>0.0或1.0，用于浮点组件</li>
</ul>
</li>
</ul>
</li>
<li>越界写入可以修改绑定到缓冲区的内存范围内的值，但不能修改任何其他内存。</li>
<li>越界原子可以修改绑定到缓冲区的内存范围内的值，但不能修改任何其他内存，并返回未定义的值。</li>
<li>如果绑定顶点缓冲区范围中属性的偏移量加上属性的大小大于以下值，则顶点输入属性被视为超出边界。<ul>
<li><ol>
<li>vertexBufferRangeSize, if bindingStride &#x3D;&#x3D; 0; 或者</li>
</ol>
</li>
<li><ol start="2">
<li>(vertexBufferRangeSize - (vertexBufferRangeSize % bindingStride))</li>
</ol>
</li>
<li>其中vertexBufferRangeSize是绑定到顶点缓冲区绑定的内存范围的字节大小，bindingStride是相应顶点输入绑定的字节跨度。此外，如果使用特定顶点输入绑定的任何顶点输入属性超出边界，则使用该顶点着色器调用的顶点输入绑定的所有顶点输入属性被视为超出边界。</li>
<li>一旦顶点输入属性超出范围，将为其分配以下值之一：<ul>
<li>来自绑定到缓冲区的内存范围内任何位置的值，根据属性的格式进行转换。</li>
<li>零值，或（0,0,0，x）向量，格式根据属性的格式转换。</li>
</ul>
</li>
</ul>
</li>
<li>如果未启用robustBufferAccess，则应用程序不得执行越界访问。而一般来讲，robustBufferAccess都是需要开启的。</li>
</ul>
<h3 id="2-fullDrawIndexUint32"><a href="#2-fullDrawIndexUint32" class="headerlink" title="2. fullDrawIndexUint32"></a>2. fullDrawIndexUint32</h3><p>指定当使用VKIndexType为VK_INDEX_TYPE_UINT32时，索引绘制调用支持完整的32位索引范围。<br>maxDrawIndexedIndexValue是可以使用的最大索引值（除了原始重启索引，当VkIndexType是VK_INDEX_TYPE_UINT32时，它总是2^32-1）。<br>如果支持此功能，则maxDrawIndexedIndexValue必须为2^32-1; 否则它必须不小于2^24-1。</p>
<h3 id="3-imageCubeArray"><a href="#3-imageCubeArray" class="headerlink" title="3. imageCubeArray"></a>3. imageCubeArray</h3><p>指定是否可以创建VkImageViewType为VK_IMAGE_VIEW_TYPE_CUBE_ARRAY的图像视图，以及是否可以在着色器代码中使用相应的SampledCubeArray和ImageCubeArray SPIR-V功能。</p>
<h3 id="4-independentBlend"><a href="#4-independentBlend" class="headerlink" title="4. independentBlend"></a>4. independentBlend</h3><p>指定是否每个附件独立控制VkPipelineColorBlendAttachmentState设置。<br>如果未启用此功能，则所有颜色附件的VkPipelineColorBlendAttachmentState设置必须相同。<br>如果启用，可以为每个绑定的颜色附件提供不同的VkPipelineColorBlendAttachmentState。</p>
<h3 id="5-geometryShader"><a href="#5-geometryShader" class="headerlink" title="5. geometryShader"></a>5. geometryShader</h3><p>指定是否支持几何着色器。<br>如果未启用此功能，则不得使用VK_SHADER_STAGE_GEOMETRY_BIT和VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT枚举值。<br>这还指定着色器模块是否可以声明几何功能。</p>
<h3 id="6-tessellationShader"><a href="#6-tessellationShader" class="headerlink" title="6. tessellationShader"></a>6. tessellationShader</h3><p>指定是否支持曲面细分控制和评估着色器。<br>如果未启用此功能，则不得使用：</p>
<ul>
<li>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT：指定曲面细分控制阶段</li>
<li>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT：指定曲面细分评估阶段</li>
<li>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT：指定曲面细分控制着色器阶段</li>
<li>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT：指定曲面细分评估着色器阶段</li>
<li>VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO</li>
</ul>
<p>这还指定着色器模块是否可以声明Tessellation功能。</p>
<h3 id="7-sampleRateShading"><a href="#7-sampleRateShading" class="headerlink" title="7. sampleRateShading"></a>7. sampleRateShading</h3><p>指定是否支持样本着色和多重采样插值。<br>如果未启用此功能，则必须将VkPipelineMultisampleStateCreateInfo结构的sampleShadingEnable成员设置为VK_FALSE，并忽略minSampleShading成员。<br>这还指定着色器模块是否可以声明SampleRateShading功能。</p>
<h3 id="8-dualSrcBlend"><a href="#8-dualSrcBlend" class="headerlink" title="8. dualSrcBlend"></a>8. dualSrcBlend</h3><p>指定是否支持采用两个源的混合操作。<br>如果未启用此功能，则不得将：</p>
<ul>
<li>VK_BLEND_FACTOR_SRC1_COLOR：</li>
<li>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</li>
<li>VK_BLEND_FACTOR_SRC1_ALPHA</li>
<li>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</li>
</ul>
<p>以上枚举值用作源或目标混合因子。详细信息参阅 vkspec.html: 26.1.2. Dual-Source Blending</p>
<h3 id="9-logicOp"><a href="#9-logicOp" class="headerlink" title="9. logicOp"></a>9. logicOp</h3><p>指定是否支持逻辑运算。 如果未启用此功能，则必须将VkPipelineColorBlendStateCreateInfo结构的logicOpEnable成员设置为VK_FALSE，并忽略logicOp成员。</p>
<h3 id="10-multiDrawIndirect"><a href="#10-multiDrawIndirect" class="headerlink" title="10. multiDrawIndirect"></a>10. multiDrawIndirect</h3><p>指定是否支持多个draw间接。<br>如果未启用此功能，则vkCmdDrawIndirect和vkCmdDrawIndexedIndirect命令的drawCount参数必须为0或1.<br>如果不支持此功能，则VkPhysicalDeviceLimits结构的maxDrawIndirectCount(间接绘制调用支持的最大绘制计数)成员也必须为1。 </p>
<h3 id="11-drawIndirectFirstInstance"><a href="#11-drawIndirectFirstInstance" class="headerlink" title="11. drawIndirectFirstInstance"></a>11. drawIndirectFirstInstance</h3><p>指定间接绘制调用是否支持firstInstance参数。<br>如果未启用此功能，则提供给vkCmdDrawIndirect和vkCmdDrawIndexedIndirect命令的所有VkDrawIndirectCommand和VkDrawIndexedIndirectCommand结构的firstInstance成员必须为0。</p>
<h3 id="12-depthClamp"><a href="#12-depthClamp" class="headerlink" title="12. depthClamp"></a>12. depthClamp</h3><p>指定是否支持深度Clamp。<br>如果未启用此功能，则必须将VkPipelineRasterizationStateCreateInfo结构的depthClampEnable成员设置为VK_FALSE。<br>如果启用，将depthClampEnable设置为VK_TRUE将启用深度Clamp。</p>
<h3 id="13-depthBiasClamp"><a href="#13-depthBiasClamp" class="headerlink" title="13. depthBiasClamp"></a>13. depthBiasClamp</h3><p>指定是否支持深度偏置Clamp。<br>如果未启用此功能，则必须将VkPipelineRasterizationStateCreateInfo结构的depthBiasClamp成员设置为0.0，除非启用VK_DYNAMIC_STATE_DEPTH_BIAS动态状态，并且必须将vkCmdSetDepthBias的depthBiasClamp参数设置为0.0。</p>
<h3 id="14-fillModeNonSolid"><a href="#14-fillModeNonSolid" class="headerlink" title="14. fillModeNonSolid"></a>14. fillModeNonSolid</h3><p>指定是否支持点和线框填充模式。<br>如果未启用此功能，则VkPipelineRasterizationStateCreateInfo::polygonMode不得使用:</p>
<ul>
<li>VK_POLYGON_MODE_POINT:指定将多边形顶点绘制为点</li>
<li>VK_POLYGON_MODE_LINE:指定将多边形的边绘制为点</li>
</ul>
<h3 id="15-depthBounds"><a href="#15-depthBounds" class="headerlink" title="15. depthBounds"></a>15. depthBounds</h3><p>指定是否支持深度边界测试。<br>如果未启用此功能，则必须将VkPipelineDepthStencilStateCreateInfo结构的depthBoundsTestEnable成员设置为VK_FALSE。 当depthBoundsTestEnable设置为VK_FALSE时，将忽略VkPipelineDepthStencilStateCreateInfo结构的minDepthBounds和maxDepthBounds成员。</p>
<h3 id="16-wideLines"><a href="#16-wideLines" class="headerlink" title="16. wideLines"></a>16. wideLines</h3><p>指定是否支持宽度不是1.0的行。<br>如果未启用此功能，则必须将VkPipelineRasterizationStateCreateInfo结构的lineWidth成员设置为1.0，除非启用VK_DYNAMIC_STATE_LINE_WIDTH动态状态，并且必须将vWCmdSetLineWidth的lineWidth参数设置为1.0。<br>支持此功能时，支持的线宽的范围和粒度分别由VkPhysicalDeviceLimits结构的lineWidthRange和lineWidthGranularity成员指示。</p>
<h3 id="17-largePoints"><a href="#17-largePoints" class="headerlink" title="17. largePoints"></a>17. largePoints</h3><p>指定是否支持大小大于1.0的点。<br>如果未启用此功能，则仅支持着色器写入的点大小1.0。 支持的点大小的范围和粒度分别由VkPhysicalDeviceLimits结构的pointSizeRange和pointSizeGranularity成员指示。</p>
<h3 id="18-alphaToOne"><a href="#18-alphaToOne" class="headerlink" title="18. alphaToOne"></a>18. alphaToOne</h3><p>指定实现是否能够使用定点颜色的最大可表示alpha值或浮点颜色的1.0替换片段着色器中输出的颜色片段的alpha值。<br>如果未启用此功能，则必须将VkPipelineMultisampleStateCreateInfo结构的alphaToOneEnable成员设置为VK_FALSE。<br>否则，将alphaToOneEnable设置为VK_TRUE将启用alpha-to-one行为。</p>
<h3 id="19-multiViewport"><a href="#19-multiViewport" class="headerlink" title="19. multiViewport"></a>19. multiViewport</h3><p>指定是否支持多个Viewport。 如果未启用此功能：</p>
<ul>
<li>必须将VkPipelineViewportStateCreateInfo结构的viewportCount和scissorCount成员设置为1。</li>
<li>vkCmdSetViewport命令的firstViewport和viewportCount参数必须分别设置为0和1。</li>
<li>vkCmdSetScissor命令的firstScissor和scissorCount参数必须分别设置为0和1。</li>
</ul>
<h3 id="20-samplerAnisotropy"><a href="#20-samplerAnisotropy" class="headerlink" title="20. samplerAnisotropy"></a>20. samplerAnisotropy</h3><p>指定是否支持各向异性过滤。<br>如果未启用此功能，则VkSamplerCreateInfo结构的anisotropyEnable成员必须为VK_FALSE。</p>
<h3 id="21-textureCompressionETC2"><a href="#21-textureCompressionETC2" class="headerlink" title="21. textureCompressionETC2"></a>21. textureCompressionETC2</h3><p>指定是否支持所有ETC2和EAC压缩纹理格式。<br>如果启用此功能，则OptimalTilingFeatures中必须支持:</p>
<ul>
<li><p>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT:指定可以从中采样图像视图</p>
</li>
<li><p>VK_FORMAT_FEATURE_BLIT_SRC_BIT:指定图像可用作vkCmdBlitImage命令的srcImage</p>
</li>
<li><p>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT：图像视图可以与采样器一起使用(详细信息 vkspec.html:VkFormatFeatureFlagBits)</p>
<p>  以上格式的功能：</p>
<ul>
<li>VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK</li>
<li>VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK</li>
<li>VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK</li>
<li>VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK</li>
<li>VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK</li>
<li>VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK</li>
<li>VK_FORMAT_EAC_R11_UNORM_BLOCK</li>
<li>VK_FORMAT_EAC_R11_SNORM_BLOCK</li>
<li>VK_FORMAT_EAC_R11G11_UNORM_BLOCK</li>
<li>VK_FORMAT_EAC_R11G11_SNORM_BLOCK</li>
</ul>
</li>
</ul>
<p>要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。</p>
<h3 id="22-textureCompressionASTC-LDR"><a href="#22-textureCompressionASTC-LDR" class="headerlink" title="22. textureCompressionASTC_LDR"></a>22. textureCompressionASTC_LDR</h3><p>指定是否支持所有ASTC LDR压缩纹理格式。<br>如果启用此功能，则OptimalTilingFeatures中必须支持:</p>
<ul>
<li><p>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</p>
</li>
<li><p>VK_FORMAT_FEATURE_BLIT_SRC_BIT和VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</p>
<p>  以上格式的功能：</p>
<ul>
<li>VK_FORMAT_ASTC_4x4_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_4x4_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_5x4_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_5x4_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_5x5_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_5x5_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_6x5_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_6x5_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_6x6_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_6x6_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_8x5_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_8x5_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_8x6_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_8x6_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_8x8_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_8x8_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_10x5_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_10x5_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_10x6_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_10x6_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_10x8_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_10x8_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_10x10_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_10x10_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_12x10_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_12x10_SRGB_BLOCK</li>
<li>VK_FORMAT_ASTC_12x12_UNORM_BLOCK</li>
<li>VK_FORMAT_ASTC_12x12_SRGB_BLOCK</li>
</ul>
</li>
</ul>
<p>要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。</p>
<h3 id="23-textureCompressionBC"><a href="#23-textureCompressionBC" class="headerlink" title="23. textureCompressionBC"></a>23. textureCompressionBC</h3><p>指定是否支持所有BC压缩纹理格式。<br>如果启用此功能，则OptimalTilingFeatures中必须支持：</p>
<ul>
<li><p>VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT</p>
</li>
<li><p>VK_FORMAT_FEATURE_BLIT_SRC_BIT</p>
</li>
<li><p>VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</p>
<p>  以上格式的功能：</p>
<ul>
<li>VK_FORMAT_BC1_RGB_UNORM_BLOCK</li>
<li>VK_FORMAT_BC1_RGB_SRGB_BLOCK</li>
<li>VK_FORMAT_BC1_RGBA_UNORM_BLOCK</li>
<li>VK_FORMAT_BC1_RGBA_SRGB_BLOCK</li>
<li>VK_FORMAT_BC2_UNORM_BLOCK</li>
<li>VK_FORMAT_BC2_SRGB_BLOCK</li>
<li>VK_FORMAT_BC3_UNORM_BLOCK</li>
<li>VK_FORMAT_BC3_SRGB_BLOCK</li>
<li>VK_FORMAT_BC4_UNORM_BLOCK</li>
<li>VK_FORMAT_BC4_SNORM_BLOCK</li>
<li>VK_FORMAT_BC5_UNORM_BLOCK</li>
<li>VK_FORMAT_BC5_SNORM_BLOCK</li>
<li>VK_FORMAT_BC6H_UFLOAT_BLOCK</li>
<li>VK_FORMAT_BC6H_SFLOAT_BLOCK</li>
<li>VK_FORMAT_BC7_UNORM_BLOCK</li>
<li>VK_FORMAT_BC7_SRGB_BLOCK</li>
</ul>
</li>
</ul>
<p>要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。</p>
<h3 id="24-occlusionQueryPrecise"><a href="#24-occlusionQueryPrecise" class="headerlink" title="24. occlusionQueryPrecise"></a>24. occlusionQueryPrecise</h3><p>指定是否支持返回实际样本计数的遮挡查询。<br>通过在VkQueryPoolCreateInfo结构中指定VK_QUERY_TYPE_OCCLUSION的queryType并将其传递给vkCreateQueryPool，可以在VkQueryPool中创建遮挡查询。<br>如果启用此功能，则此类查询可以将flags参数中的VK_QUERY_CONTROL_PRECISE_BIT启用为vkCmdBeginQuery。<br>如果不支持此功能，则实现仅支持布尔遮挡查询。传递任何样本时，布尔查询将返回非零结果值，否则返回结果值为零。<br>启用此功能并设置VK_QUERY_CONTROL_PRECISE_BIT后，遮挡查询将报告传递的实际样本数。</p>
<h3 id="25-pipelineStatisticsQuery"><a href="#25-pipelineStatisticsQuery" class="headerlink" title="25. pipelineStatisticsQuery"></a>25. pipelineStatisticsQuery</h3><p>指定是否支持管道统计信息查询。<br>如果未启用此功能，则无法创建类型为VK_QUERY_TYPE_PIPELINE_STATISTICS的查询，并且无法在VkQueryPoolCreateInfo结构的pipelineStatistics成员中设置任何VkQueryPipelineStatisticFlagBits位。</p>
<h3 id="26-vertexPipelineStoresAndAtomics"><a href="#26-vertexPipelineStoresAndAtomics" class="headerlink" title="26. vertexPipelineStoresAndAtomics"></a>26. vertexPipelineStoresAndAtomics</h3><p>指定存储缓冲区和图像是否支持顶点，曲面细分和几何着色器阶段中的存储和原子操作。<br>如果未启用此功能，则着色器模块中这些阶段使用的所有存储器映像，存储纹理缓冲区缓冲区和存储缓冲区变量必须使用NonWritable修饰（或GLSL中的只读内存限定符）进行修饰。</p>
<h3 id="27-fragmentStoresAndAtomics"><a href="#27-fragmentStoresAndAtomics" class="headerlink" title="27. fragmentStoresAndAtomics"></a>27. fragmentStoresAndAtomics</h3><p>指定存储缓冲区和图像是否支持片段着色器阶段中的存储和原子操作。<br>如果未启用此功能，则着色器模块中片段阶段使用的所有存储器映像，存储纹理缓冲区缓冲区和存储缓冲区变量必须使用NonWritable修饰（或GLSL中的只读内存限定符）进行修饰。</p>
<h3 id="28-shaderTessellationAndGeometryPointSize"><a href="#28-shaderTessellationAndGeometryPointSize" class="headerlink" title="28. shaderTessellationAndGeometryPointSize"></a>28. shaderTessellationAndGeometryPointSize</h3><p>指定曲面细分控件，曲面细分评估和几何着色器阶段中是否提供PointSize内置修饰。<br>如果未启用此功能，则不得读取或写入使用PointSize内置修饰的成员，并且从曲面细分或几何着色器写入的所有点的大小均为1.0。<br>这还指定着色器模块是否可以为曲面细分控制和评估着色器声明TessellationPointSize功能，或者着色器模块是否可以为几何着色器声明GeometryPointSize功能。<br><strong>支持此功能的实现还必须支持tessellationShader或geometryShader功能中的一个或两个</strong>。</p>
<h3 id="29-shaderImageGatherExtended"><a href="#29-shaderImageGatherExtended" class="headerlink" title="29. shaderImageGatherExtended"></a>29. shaderImageGatherExtended</h3><p>指定着色器代码中是否可以使用扩展的图像收集指令集。<br>如果未启用此功能，则OpImage * Gather指令不支持Offset和ConstOffsets操作数。 这还指定着色器模块是否可以声明ImageGatherExtended功能。</p>
<h3 id="30-shaderStorageImageExtendedFormats"><a href="#30-shaderStorageImageExtendedFormats" class="headerlink" title="30. shaderStorageImageExtendedFormats"></a>30. shaderStorageImageExtendedFormats</h3><p>指定着色器代码中是否所有扩展存储器图像格式都可用。<br>如果启用此功能，则必须在所有扩展格式的optimalTilingFeatures中支持VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT功能。<br>要查询其他属性，或者未启用该功能，可以使用vkGetPhysicalDeviceFormatProperties和vkGetPhysicalDeviceImageFormatProperties来检查各个格式的支持属性。</p>
<h3 id="31-shaderStorageImageMultisample"><a href="#31-shaderStorageImageMultisample" class="headerlink" title="31. shaderStorageImageMultisample"></a>31. shaderStorageImageMultisample</h3><p>指定是否支持多重采样存储映像。<br>如果未启用此功能，则必须使用等于VK_SAMPLE_COUNT_1_BIT的样本创建使用包含VK_IMAGE_USAGE_STORAGE_BIT的用法创建的图像。<br>这还指定着色器模块是否可以声明StorageImageMultisample功能。</p>
<h3 id="32-shaderStorageImageReadWithoutFormat"><a href="#32-shaderStorageImageReadWithoutFormat" class="headerlink" title="32. shaderStorageImageReadWithoutFormat"></a>32. shaderStorageImageReadWithoutFormat</h3><p>指定存储图像是否需要在从存储器映像<strong>读取</strong>时指定格式限定符。<br>如果未启用此功能，则OpImageRead指令的OpTypeImage不得为Unknown。<br>这还指定着色器模块是否可以声明StorageImageReadWithoutFormat功能。</p>
<h3 id="33-shaderStorageImageWriteWithoutFormat"><a href="#33-shaderStorageImageWriteWithoutFormat" class="headerlink" title="33. shaderStorageImageWriteWithoutFormat"></a>33. shaderStorageImageWriteWithoutFormat</h3><p>指定存储图像是否需要在<strong>写入</strong>存储图像时指定格式限定符。<br>如果未启用此功能，则OpImageWrite指令的OpTypeImage不得为Unknown。<br>这还指定着色器模块是否可以声明StorageImageWriteWithoutFormat功能。</p>
<h3 id="34-shaderUniformBufferArrayDynamicIndexing"><a href="#34-shaderUniformBufferArrayDynamicIndexing" class="headerlink" title="34. shaderUniformBufferArrayDynamicIndexing"></a>34. shaderUniformBufferArrayDynamicIndexing</h3><p>指定是否可以通过着色器代码中的动态统一整数表达式对统一缓冲区的数组建立索引。<br>如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER或VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC的资源必须仅由常量整数表达式编制索引。<br>这还指定着色器模块是否可以声明UniformBufferArrayDynamicIndexing功能。</p>
<h3 id="35-shaderSampledImageArrayDynamicIndexing"><a href="#35-shaderSampledImageArrayDynamicIndexing" class="headerlink" title="35. shaderSampledImageArrayDynamicIndexing"></a>35. shaderSampledImageArrayDynamicIndexing</h3><p>指定采样器阵列或采样图像是否可以通过着色器代码中的动态统一整数表达式进行索引。<br>如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_SAMPLER，VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER或VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE的资源必须仅由常量整数表达式编制索引。<br>这还指定着色器模块是否可以声明SampledImageArrayDynamicIndexing功能。</p>
<h3 id="36-shaderStorageBufferArrayDynamicIndexing"><a href="#36-shaderStorageBufferArrayDynamicIndexing" class="headerlink" title="36. shaderStorageBufferArrayDynamicIndexing"></a>36. shaderStorageBufferArrayDynamicIndexing</h3><p>指定是否可以通过着色器代码中的动态统一整数表达式索引存储缓冲区的数组。<br>如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_STORAGE_BUFFER或VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC的资源必须仅由常量整数表达式编制索引。<br>这还指定着色器模块是否可以声明StorageBufferArrayDynamicIndexing功能。</p>
<h3 id="37-shaderStorageImageArrayDynamicIndexing"><a href="#37-shaderStorageImageArrayDynamicIndexing" class="headerlink" title="37. shaderStorageImageArrayDynamicIndexing"></a>37. shaderStorageImageArrayDynamicIndexing</h3><p>指定是否可以通过着色器代码中的动态统一整数表达式索引存储器图像数组。<br>如果未启用此功能，则在着色器代码中聚合到数组中时，描述符类型为VK_DESCRIPTOR_TYPE_STORAGE_IMAGE的资源必须仅通过常量整数表达式编制索引。<br>这还指定着色器模块是否可以声明StorageImageArrayDynamicIndexing功能。</p>
<h3 id="38-shaderClipDistance"><a href="#38-shaderClipDistance" class="headerlink" title="38. shaderClipDistance"></a>38. shaderClipDistance</h3><p>指定着色器代码中是否支持ClipDistance。<br>如果未启用此功能，则不得在着色器模块中读取或写入使用ClipDistance内置装饰的任何成员。<br>这还指定着色器模块是否可以声明ClipDistance功能。</p>
<h3 id="39-shaderCullDistance"><a href="#39-shaderCullDistance" class="headerlink" title="39. shaderCullDistance"></a>39. shaderCullDistance</h3><p>指定着色器代码中是否支持CullDistance。<br>如果未启用此功能，则不得在着色器模块中读取或写入使用CullDistance内置装饰的任何成员。<br>这还指定着色器模块是否可以声明CullDistance功能。</p>
<h3 id="40-shaderFloat64"><a href="#40-shaderFloat64" class="headerlink" title="40. shaderFloat64"></a>40. shaderFloat64</h3><p>指定着色器代码中是否支持64位浮点（双精度）。<br>如果未启用此功能，则不得在着色器代码中使用64位浮点类型。<br>这还指定着色器模块是否可以声明Float64功能。</p>
<h3 id="41-shaderInt64"><a href="#41-shaderInt64" class="headerlink" title="41. shaderInt64"></a>41. shaderInt64</h3><p>指定着色器代码中是否支持64位整数（有符号和无符号）。<br>如果未启用此功能，则不得在着色器代码中使用64位整数类型。<br>这还指定着色器模块是否可以声明Int64功能。</p>
<h3 id="42-shaderInt16"><a href="#42-shaderInt16" class="headerlink" title="42. shaderInt16"></a>42. shaderInt16</h3><p>指定着色器代码中是否支持16位整数（有符号和无符号）。<br>如果未启用此功能，则不得在着色器代码中使用16位整数类型。<br>这还指定着色器模块是否可以声明Int16功能。</p>
<h3 id="43-shaderResourceResidency"><a href="#43-shaderResourceResidency" class="headerlink" title="43. shaderResourceResidency"></a>43. shaderResourceResidency</h3><p>指定着色器代码是否支持返回资源驻留信息的图像操作。<br>如果未启用此功能，则不得在着色器代码中使用OpImageSparse *指令。<br>这还指定着色器模块是否可以声明SparseResidency功能。<br>该功能至少需要支持一个sparseResidency *功能。</p>
<h3 id="44-shaderResourceMinLod"><a href="#44-shaderResourceMinLod" class="headerlink" title="44. shaderResourceMinLod"></a>44. shaderResourceMinLod</h3><p>指定着色器代码中是否支持指定最小资源LOD的图像操作。<br>如果未启用此功能，则不得在着色器代码中使用MinLod图像操作数。<br>这还指定着色器模块是否可以声明MinLod功能。</p>
<h3 id="45-sparseBinding"><a href="#45-sparseBinding" class="headerlink" title="45. sparseBinding"></a>45. sparseBinding</h3><p>指定是否可以在不透明的稀疏块级别而不是在对象级别管理资源内存。<br>如果未启用此功能，则必须使用vkBindBufferMemory和vkBindImageMemory命令仅基于每个对象绑定资源内存。 在这种情况下，不能分别使用VkBufferCreateInfo和VkImageCreateInfo结构的flags成员中设置的VK_BUFFER_CREATE_SPARSE_BINDING_BIT和VK_IMAGE_CREATE_SPARSE_BINDING_BIT创建缓冲区和映像。 否则，可以按稀疏资源特征中的描述管理资源存储器。</p>
<h3 id="46-sparseResidencyBuffer"><a href="#46-sparseResidencyBuffer" class="headerlink" title="46. sparseResidencyBuffer"></a>46. sparseResidencyBuffer</h3><p>指定设备是否可以访问部分驻留缓冲区。<br>如果未启用此功能，则不能使用VkBufferCreateInfo结构的flags成员中设置的VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT创建缓冲区。</p>
<h3 id="47-sparseResidencyImage2D"><a href="#47-sparseResidencyImage2D" class="headerlink" title="47. sparseResidencyImage2D"></a>47. sparseResidencyImage2D</h3><p>指定设备是否可以访问每个像素1个样本的部分驻留的2D图像。<br>如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_1_BIT的图像。</p>
<h3 id="48-sparseResidencyImage3D"><a href="#48-sparseResidencyImage3D" class="headerlink" title="48. sparseResidencyImage3D"></a>48. sparseResidencyImage3D</h3><p>指定设备是否可以访问部分驻留的3D图像。<br>如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_3D的映像。</p>
<h3 id="49-sparseResidency2Samples"><a href="#49-sparseResidency2Samples" class="headerlink" title="49. sparseResidency2Samples"></a>49. sparseResidency2Samples</h3><p>指定物理设备是否可以访问具有每像素2个样本的部分驻留的2D图像。<br>如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_2_BIT的图像。</p>
<h3 id="50-sparseResidency4Samples"><a href="#50-sparseResidency4Samples" class="headerlink" title="50. sparseResidency4Samples"></a>50. sparseResidency4Samples</h3><p>指定物理设备是否可以访问每个像素有4个样本的部分驻留的2D图像。<br>如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_4_BIT的图像。</p>
<h3 id="51-sparseResidency8Samples"><a href="#51-sparseResidency8Samples" class="headerlink" title="51. sparseResidency8Samples"></a>51. sparseResidency8Samples</h3><p>指定物理设备是否可以访问具有每像素8个样本的部分驻留的2D图像。<br>如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_8_BIT的图像。</p>
<h3 id="52-sparseResidency16Samples"><a href="#52-sparseResidency16Samples" class="headerlink" title="52. sparseResidency16Samples"></a>52. sparseResidency16Samples</h3><p>指定物理设备是否可以访问每个像素16个样本的部分驻留的2D图像。<br>如果未启用此功能，则不得使用VkImageCreateInfo结构的flags成员中设置的VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT创建imageType为VK_IMAGE_TYPE_2D且样本设置为VK_SAMPLE_COUNT_16_BIT的图像。</p>
<h3 id="53-sparseResidencyAliased"><a href="#53-sparseResidencyAliased" class="headerlink" title="53. sparseResidencyAliased"></a>53. sparseResidencyAliased</h3><p>指定物理设备是否可以正确访问别名到多个位置的数据。<br>如果未启用此功能，则不得分别在VkBufferCreateInfo和VkImageCreateInfo结构的flags成员中使用VK_BUFFER_CREATE_SPARSE_ALIASED_BIT和VK_IMAGE_CREATE_SPARSE_ALIASED_BIT枚举值。</p>
<h3 id="54-variableMultisampleRate"><a href="#54-variableMultisampleRate" class="headerlink" title="54. variableMultisampleRate"></a>54. variableMultisampleRate</h3><p>指定在没有附件的子通行期间将绑定到命令缓冲区的所有管道是否必须具有VkPipelineMultisampleStateCreateInfo::rasterizationSamples的相同值。<br>如果设置为VK_TRUE，则实现支持不带附件的子通道中的可变多重采样率。<br>如果设置为VK_FALSE，则绑定在此子通道中的所有管道必须具有相同的多采样率。 但这在子通道使用任何附件的情况下无效。</p>
<h3 id="55-inheritedQueries"><a href="#55-inheritedQueries" class="headerlink" title="55. inheritedQueries"></a>55. inheritedQueries</h3><p>指定在查询处于活动状态时是否可以执行辅助命令缓冲区。</p>
<p></p></code></pre><p></p>
</details>


<p>说明：vkspec.html（2019&#x2F;05&#x2F;03）是从官方文档 <a href="https://github.com/KhronosGroup/Vulkan-Docs/">https://github.com/KhronosGroup/Vulkan-Docs/</a> 中制作生成的。可以自行下载最新代码制作，也可以直接下载：</p>
<ol>
<li>csdn（需要5积分，不知道怎么去掉这个）：<a href="https://download.csdn.net/download/u014535072/11158246">https://download.csdn.net/download/u014535072/11158246</a></li>
<li>百度网盘：链接: <a href="https://pan.baidu.com/s/1IyPnb-2ti1SjU0puFKwYUQ">https://pan.baidu.com/s/1IyPnb-2ti1SjU0puFKwYUQ</a> 提取码: f2c2</li>
</ol>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(4)-Surface和交换链</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-4-Surface%E5%92%8C%E4%BA%A4%E6%8D%A2%E9%93%BE/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是学习Vulkan Tutorial.pdf文档中的Window Surface和Swap Chain的部分。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[Vulkan-文档]<a href="https://github.com/KhronosGroup/Vulkan-Docs">https://github.com/KhronosGroup/Vulkan-Docs</a></li>
</ol>
<h1 id="一-Window-Surface"><a href="#一-Window-Surface" class="headerlink" title="一. Window Surface"></a>一. Window Surface</h1><p>由于Vulkan是一个与平台无关的API，因此无法直接与窗口系统进行交互。<br>要在Vulkan和窗口系统之间建立连接以向屏幕显示结果，我们需要使用WSI（窗口系统集成）扩展。<br>这就需要使用到VK_KHR_surface，它公开了一个VkSurfaceKHR对象，表示一个抽象类型的Surface，以呈现渲染图像。<br>我们程序中的Surface将由我们已经使用GLFW打开的窗口支持。VK_KHR_surface扩展是一个实例级扩展，我们实际上已经启用它，因为它包含在glfwGetRequiredInstanceExtensions返回的列表中。</p>
<p>一般需要在创建实例后立即创建窗口Surface，因为它实际上可以影响物理设备选择。<br>但如果你只需要离屏渲染，窗口Surface是Vulkan中完全可选的组件。 Vulkan允许这样做，而不是像OpenGL一样必须创建一个不可见的窗口。</p>
<h2 id="1-1-创建窗口Surface"><a href="#1-1-创建窗口Surface" class="headerlink" title="1.1 创建窗口Surface"></a>1.1 创建窗口Surface</h2><p>在Vulkan中使用VkSurfaceKHR表示窗口Surface：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkSurfaceKHR surface;</span><br></pre></td></tr></table></figure>
<p>虽然VkSurfaceKHR对象及其用法与平台无关，但它的创建并不是因为它取决于窗口系统的细节。例如，它需要Windows上的HWND和HMODULE句柄。因此，扩展中有一个特定于平台的添加，在Windows上称为VK_KHR_win32_surface，并且还自动包含在glfwGetRequiredInstanceExtensions的列表中。<br>但使用像GLFW这样的库然后继续使用特定于平台的代码没有任何意义。<br>GLFW实际上有glfwCreateWindowSurface来帮我们处理平台的差异。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 使用glfw创建WindowSurface</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">createWindowSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">glfwCreateWindowSurface</span>(instance, window, <span class="literal">nullptr</span>, &amp;surface) != VK_SUCCESS) &#123;</span><br><span class="line">         <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create window surface!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 记得释放</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 释放WindowSurface</span></span><br><span class="line">     <span class="built_in">vkDestroySurfaceKHR</span>(instance, surface, <span class="literal">nullptr</span>);</span><br><span class="line">     ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-Swap-Chain-交换链"><a href="#二-Swap-Chain-交换链" class="headerlink" title="二. Swap Chain-交换链"></a>二. Swap Chain-交换链</h1><p>Vulkan没有“默认帧缓冲区”的概念，取而代之的是名为 “swap chain” 即交换链，也就是渲染的缓冲区，必须在Vulkan中明确创建。<br>交换链本质上是一个等待呈现给屏幕的图像队列。应用程序将获取这样的图像以绘制它，然后将其返回到队列中。<br>队列的工作原理以及从队列中显示图像的条件取决于交换链的设置方式，但交换链的一般用途是将图像的显示与屏幕的刷新率同步。</p>
<h2 id="2-1-检查GPU是否支持交换链"><a href="#2-1-检查GPU是否支持交换链" class="headerlink" title="2.1 检查GPU是否支持交换链"></a>2.1 检查GPU是否支持交换链</h2><p>并不是所有的GPU都支持图像显示(比如专为服务器设计的)，其次，由于图像显示严重依赖于窗口系统和与窗口相关的Surface，因此它实际上不是Vulkan核心的一部分。<br>所以必须在查询其支持后才能启用K_KHR_swapchain设备扩展。</p>
<p>可以扩展isDeviceSuitable函数以检查是否支持此扩展。<br>之前已经实现过如何列出VkPhysicalDevice支持的扩展，这样做法其实一样。值得注意的是，Vulkan头文件提供了一个很好的宏VK_KHR_SWAPCHAIN_EXTENSION_NAME，定义为VK_KHR_swapchain。<br>使用此宏的优点是编译器将捕获拼写错误。首先声明所需设备扩展的列表，类似于要启用的验证层列表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; deviceExtensions = &#123;</span><br><span class="line">    VK_KHR_SWAPCHAIN_EXTENSION_NAME</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    QueueFamilyIndices indices = <span class="built_in">findQueueFamilies</span>(device);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> extensionsSupported = <span class="built_in">checkDeviceExtensionSupport</span>(device);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indices.<span class="built_in">isComplete</span>() &amp;&amp; extensionsSupported;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkDeviceExtensionSupport</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> extensionCount;</span><br><span class="line">    <span class="built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="literal">nullptr</span>, &amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">availableExtensions</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">    <span class="built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="literal">nullptr</span>, &amp;extensionCount, availableExtensions.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::set&lt;std::string&gt; <span class="title">requiredExtensions</span><span class="params">(deviceExtensions.begin(), deviceExtensions.end())</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历当前所有可支持的扩展，并逐步移除也存在于deviceExtensions中的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; extension : availableExtensions) &#123;</span><br><span class="line">        requiredExtensions.<span class="built_in">erase</span>(extension.extensionName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为empty时，表示所有deviceExtensions中的扩展均支持</span></span><br><span class="line">    <span class="keyword">return</span> requiredExtensions.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-使能设备扩展"><a href="#2-2-使能设备扩展" class="headerlink" title="2.2 使能设备扩展"></a>2.2 使能设备扩展</h2><p>使用交换链需要首先使能VK_KHR_swapchain扩展。<br>方法也很简单，只需要在创建逻辑设备的时候声明一下即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">createInfo.enabledExtensionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(deviceExtensions.<span class="built_in">size</span>());</span><br><span class="line">createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<h2 id="2-3-获取关于swap-chain更多支持细节"><a href="#2-3-获取关于swap-chain更多支持细节" class="headerlink" title="2.3 获取关于swap chain更多支持细节"></a>2.3 获取关于swap chain更多支持细节</h2><p>只检查交换链是否可用是不够的，因为它实际上可能与我们创建的窗口Surface不兼容（有点坑）。<br>创建交换链还涉及比vulkan实例和设备创建时更多的设置，因此我们需要在能够继续之前查明更多的细节。<br>需要检查的基本上有以下三种属性：</p>
<ul>
<li>基本Surface功能（交换链中的最小&#x2F;最大图像数，图像的最小&#x2F;最大宽度和高度）</li>
<li>Surface的格式（像素格式，色彩空间）</li>
<li>可用的呈现模式</li>
</ul>
<p>与创建队列类似，同样可以使用一个结构体来存储传递这些细节部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SwapChainSupportDetails</span> &#123;</span><br><span class="line">    VkSurfaceCapabilitiesKHR capabilities; <span class="comment">// 基本Surface功能</span></span><br><span class="line">    std::vector&lt;VkSurfaceFormatKHR&gt; formats; <span class="comment">// Surface格式</span></span><br><span class="line">    std::vector&lt;VkPresentModeKHR&gt; presentModes; <span class="comment">// 可用的呈现模式(presentation modes)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接来下是查询细节部分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SwapChainSupportDetails <span class="title">querySwapChainSupport</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    SwapChainSupportDetails details;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 查询基本Surface功能</span></span><br><span class="line">    <span class="comment">// 需要使用到本机物理设备(GPU), 以及创建的逻辑设备对应的Surface，结果保存在VkSurfaceCapabilitiesKHR结构体中</span></span><br><span class="line">    <span class="comment">// VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)</span></span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;details.capabilities);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查询可支持的Surface格式</span></span><br><span class="line">    <span class="comment">// 类似扩展，按例先查询一下数量，然后更新细节到VkSurfaceFormatKHR的队列中</span></span><br><span class="line">    <span class="type">uint32_t</span> formatCount;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (formatCount != <span class="number">0</span>) &#123;</span><br><span class="line">        details.formats.<span class="built_in">resize</span>(formatCount);</span><br><span class="line">        <span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, details.formats.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 查询可用的呈现模式(presentation modes)</span></span><br><span class="line">    <span class="type">uint32_t</span> presentModeCount;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (presentModeCount != <span class="number">0</span>) &#123;</span><br><span class="line">        details.presentModes.<span class="built_in">resize</span>(presentModeCount);</span><br><span class="line">        <span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, details.presentModes.<span class="built_in">data</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> details;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-为swap-chain-交换链选择合适的设置"><a href="#2-4-为swap-chain-交换链选择合适的设置" class="headerlink" title="2.4 为swap chain-交换链选择合适的设置"></a>2.4 为swap chain-交换链选择合适的设置</h2><p>满足了swapChainAnequate条件，那么物理设备肯定是支持我们的应用程序的，但还可以有许多不同的最优性模式。<br>有三种类型的设置可以选择：</p>
<ul>
<li>Surface格式（颜色深度）</li>
<li>呈现模式（将图像“交换”到屏幕的条件）</li>
<li>交换范围（交换链中图像的分辨率）</li>
</ul>
<h3 id="2-4-1-Surface格式"><a href="#2-4-1-Surface格式" class="headerlink" title="2.4.1 Surface格式"></a>2.4.1 Surface格式</h3><p>在Vulkan中，Surface格式使用结构体 VkSurfaceFormatKHR 来表示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSurfaceFormatKHR</span> &#123;</span><br><span class="line">    VkFormat           format; <span class="comment">// 格式</span></span><br><span class="line">    VkColorSpaceKHR    colorSpace; <span class="comment">// 色彩空间</span></span><br><span class="line">&#125; VkSurfaceFormatKHR;</span><br></pre></td></tr></table></figure>
<p>如上每个VkSurfaceFormatKHR条目都包含一个格式和一个colorSpace成员。</p>
<ol>
<li>格式成员指定颜色通道和类型。例如，VK_FORMAT_B8G8R8A8_UNORM意味着我们以8位无符号整数的顺序存储B，G，R和alpha通道，每个像素总共32位。</li>
<li>colorSpace成员使用VK_COLOR_SPACE_SRGB_NONLINEAR_KHR标志指示是否支持SRGB色彩空间。请注意，在旧版本的规范中，此标志曾被称为VK_COLORSPACE_SRGB_NONLINEAR_KHR。对于色彩空间，我们将使用SRGB（如果可用），因为它会产生更准确的感知色彩。直接使用SRGB颜色有点挑战，因此我们将使用标准RGB作为颜色格式，其中最常见的一种是VK_FORMAT_B8G8R8A8_UNORM。</li>
</ol>
<p>最好的情况是 Surface 没有首选格式，Vulkan只通过返回一个格式成员设置为VK_FORMAT_UNDEFINED的VkSurfaceFormatKHR条目来指示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择合适交换链和Surface的格式</span></span><br><span class="line"><span class="function">VkSurfaceFormatKHR <span class="title">chooseSwapSurfaceFormat</span><span class="params">(<span class="type">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (availableFormats.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; availableFormats[<span class="number">0</span>].format == VK_FORMAT_UNDEFINED) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; availableFormat : availableFormats) &#123;</span><br><span class="line">        <span class="keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM &amp;&amp;</span><br><span class="line">            availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> availableFormat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有找到合适的，保险起见，直接使用第一个就好了</span></span><br><span class="line">    <span class="keyword">return</span> availableFormats[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-呈现模式-Presentation-Mode"><a href="#2-4-2-呈现模式-Presentation-Mode" class="headerlink" title="2.4.2 呈现模式(Presentation Mode)"></a>2.4.2 呈现模式(Presentation Mode)</h3><p>呈现模式可以说是交换链中最重要的设置，因为它代表了向屏幕显示图像的实际条件。<br>Vulkan有四种可用的模式：</p>
<ul>
<li>VK_PRESENT_MODE_IMMEDIATE_KHR：应用程序提交的图像会立即传输到屏幕上，这可能会导致撕裂现象(上下或者左右图像不匹配，前后两帧合成)。</li>
<li>VK_PRESENT_MODE_FIFO_KHR：交换链是一个队列，当刷新显示并且程序在队列的后面插入渲染图像时，显示从队列前面获取图像。如果队列已满，则程序必须等待。这与现代游戏中的垂直同步最相似。刷新显示的那一刻被称为“垂直空白”。</li>
<li>VK_PRESENT_MODE_FIFO_RELAXED_KHR：如果应用程序延迟且队列在最后一个垂直空白处为空，则此模式仅与前一个模式不同。而不是等待下一个垂直空白，图像最终到达时立即传输。这可能会导致明显的撕裂。</li>
<li>VK_PRESENT_MODE_MAILBOX_KHR：这是第二种模式的另一种变体。当队列已满时，已排队的图像将被替换为较新的图像，而不是阻塞应用程序。此模式可用于实现三重缓冲，与使用双缓冲的标准垂直同步相比，可以避免使用明显更少的延迟问题进行撕裂。</li>
</ul>
<p>比如我们试试机器是否支持三重缓冲, 即允许我们通过渲染尽可能最新的新图像直到垂直空白来避免撕裂，同时仍保持相当低的延迟:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkPresentModeKHR <span class="title">chooseSwapPresentMode</span><span class="params">(<span class="type">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span>&#123;</span><br><span class="line">    VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; availablePresentMode : availablePresentModes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123;</span><br><span class="line">            <span class="keyword">return</span> availablePresentMode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) &#123;</span><br><span class="line">            bestMode = availablePresentMode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-交换范围-Swap-extent"><a href="#2-4-3-交换范围-Swap-extent" class="headerlink" title="2.4.3 交换范围(Swap extent)"></a>2.4.3 交换范围(Swap extent)</h3><p>交换范围是交换链图像的分辨率，它几乎总是完全等于绘制的窗口的分辨率。<br>可能的分辨率范围在 VkSurfaceCapabilitiesKHR 结构中定义。</p>
<p>Vulkan通过在currentExtent成员中设置宽度和高度来匹配窗口的分辨率。<br>但是，一些窗口管理器允许在这里有所不同, 通过将currentExtent中的宽度和高度设置为特殊值来表示：uint32_t的最大值。在这种情况下，要选择与minImageExtent和maxImageExtent范围内的窗口最匹配的分辨率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择交换链分辨率</span></span><br><span class="line"><span class="function">VkExtent2D <span class="title">chooseSwapExtent</span><span class="params">(<span class="type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> capabilities.currentExtent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        VkExtent2D actualExtent = &#123;WIDTH, HEIGHT&#125;;</span><br><span class="line">        actualExtent.width = std::<span class="built_in">max</span>(capabilities.minImageExtent.width, std::<span class="built_in">min</span>(capabilities.maxImageExtent.width, actualExtent.width));</span><br><span class="line">        actualExtent.height = std::<span class="built_in">max</span>(capabilities.minImageExtent.height, std::<span class="built_in">min</span>(capabilities.maxImageExtent.height, actualExtent.height));</span><br><span class="line">        <span class="keyword">return</span> actualExtent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-创建交换链"><a href="#2-5-创建交换链" class="headerlink" title="2.5 创建交换链"></a>2.5 创建交换链</h2><p>上述步骤已经把创建交换链的三个主要属性设置了，接下来就是创建交换链对象：VkSwapchainKHR swapChain;<br>除了上述的三个主要属性，其实还需要做的是：</p>
<ul>
<li>绑定窗口Surface</li>
<li>设置交换链图像细节，包括最小图像数量、图像图层数量</li>
<li>处理将在多个队列系列中使用的交换链图像。如果图形队列系列与呈现队列不同，需要从图形队列中绘制交换链中的图像，然后在呈现队列中提交它们。 有两种方法可以处理从多个队列访问的图像：<ul>
<li>VK_SHARING_MODE_EXCLUSIVE：映像一次由一个队列系列拥有，并且必须在将其用于另一个队列系列之前显式转移所有权。 此选项提供最佳性能。</li>
<li>VK_SHARING_MODE_CONCURRENT：可以跨多个队列系列使用映像，而无需显式所有权传输。</li>
</ul>
</li>
</ul>
<p>类似创建其他对象，交换链的创建依赖结构体：VkSwapchainCreateInfoKHR</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取物理设备可支持的交换链细节部分</span></span><br><span class="line">    SwapChainSupportDetails swapChainSupport = <span class="built_in">querySwapChainSupport</span>(physicalDevice);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择合适的Surface格式</span></span><br><span class="line">    VkSurfaceFormatKHR surfaceFormat = <span class="built_in">chooseSwapSurfaceFormat</span>(swapChainSupport.formats);</span><br><span class="line">    <span class="comment">// 选择合适的呈现模式</span></span><br><span class="line">    VkPresentModeKHR presentMode = <span class="built_in">chooseSwapPresentMode</span>(swapChainSupport.presentModes);</span><br><span class="line">    <span class="comment">// 选择合适的分辨率</span></span><br><span class="line">    VkExtent2D extent = <span class="built_in">chooseSwapExtent</span>(swapChainSupport.capabilities);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须设置交换链运行所需的最小图像数量：</span></span><br><span class="line">    <span class="comment">// 有时可能必须等待驱动程序完成内部操作才能获取另一个要渲染的图像。 因此，建议最小值加1：</span></span><br><span class="line">    <span class="type">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 边界检查，防止越界，超出交换链可支持的最大图像数量</span></span><br><span class="line">    <span class="keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123;</span><br><span class="line">        imageCount = swapChainSupport.capabilities.maxImageCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建交换链对象</span></span><br><span class="line">    VkSwapchainCreateInfoKHR createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;</span><br><span class="line">    createInfo.surface = surface; <span class="comment">// 绑定窗口Surface</span></span><br><span class="line"></span><br><span class="line">    createInfo.minImageCount = imageCount; <span class="comment">// 设置最小图像数量</span></span><br><span class="line">    createInfo.imageFormat = surfaceFormat.format; <span class="comment">// 设置图像格式</span></span><br><span class="line">    createInfo.imageColorSpace = surfaceFormat.colorSpace; <span class="comment">// 设置图像颜色空间</span></span><br><span class="line"></span><br><span class="line">    createInfo.imageExtent = extent; <span class="comment">// 设置分辨率</span></span><br><span class="line">    createInfo.imageArrayLayers = <span class="number">1</span>; <span class="comment">// 指定每个图像所包含的图层数量, 除非是立体3D应用程序，否则始终为1。 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// imageUsage 是 VkImageUsageFlags 类型, 指定将使用交换链中的图像进行哪种操作</span></span><br><span class="line">    createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; <span class="comment">// 指定该图像可用于创建适合用作颜色的VkImageView或解析VkFramebuffer中的附件。</span></span><br><span class="line"></span><br><span class="line">    QueueFamilyIndices indices = <span class="built_in">findQueueFamilies</span>(physicalDevice);</span><br><span class="line">    <span class="type">uint32_t</span> queueFamilyIndices[] = &#123;indices.graphicsFamily.<span class="built_in">value</span>(), indices.presentFamily.<span class="built_in">value</span>()&#125;;</span><br><span class="line">    <span class="keyword">if</span> (indices.graphicsFamily != indices.presentFamily) &#123;</span><br><span class="line">        createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;</span><br><span class="line">        createInfo.queueFamilyIndexCount = <span class="number">2</span>;</span><br><span class="line">        createInfo.pQueueFamilyIndices = queueFamilyIndices;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">        createInfo.queueFamilyIndexCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">        createInfo.pQueueFamilyIndices = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以指定某个变换应该应用于交换链中的图像（支持变换功能），如顺时针旋转90度或水平翻转。 要指定您不需要任何转换，只需指定当前转换。</span></span><br><span class="line">    createInfo.preTransform = swapChainSupport.capabilities.currentTransform;</span><br><span class="line">    <span class="comment">// compositeAlpha字段指定是否应该使用alpha通道与窗口系统中的其他窗口进行混合。 一般都是忽略alpha通道，因此设置为VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR。</span></span><br><span class="line">    createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置呈现模式</span></span><br><span class="line">    createInfo.presentMode = presentMode;</span><br><span class="line">    <span class="comment">// 如果剪裁的成员设置为VK_TRUE，那么这意味着我们不关心被遮挡的像素的颜色</span></span><br><span class="line">    <span class="comment">// 例如因为另一个窗口位于它们前面。 除非真的需要能够读回这些像素并获得可预测的结果，否则可以通过启用剪辑获得最佳性能。</span></span><br><span class="line">    createInfo.clipped = VK_TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Vulkan时，交换链可能会在应用程序运行时变为无效或未优化，例如因为窗口已调整大小。</span></span><br><span class="line">    <span class="comment">// 在这种情况下，交换链实际上需要从头开始重新创建，并且必须在此字段中指定对旧交换链的引用, 后续在研究。</span></span><br><span class="line">    <span class="comment">// 假设我们只会创建一个交换链</span></span><br><span class="line">    createInfo.oldSwapchain = VK_NULL_HANDLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;swapChain) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create swap chain!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-1-VkImageUsageFlags"><a href="#2-5-1-VkImageUsageFlags" class="headerlink" title="2.5.1 VkImageUsageFlags"></a>2.5.1 VkImageUsageFlags</h3><p>VkImageUsageFlags是一个位掩码类型，用于设置零或更多VkImageUsageFlagBits的掩码。<br>用于指定图像进行的操作类型, 有如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkImageUsageFlagBits</span> &#123;</span><br><span class="line">    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_IMAGE_USAGE_TRANSFER_DST_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_IMAGE_USAGE_SAMPLED_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_IMAGE_USAGE_STORAGE_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkImageUsageFlagBits;</span><br></pre></td></tr></table></figure>
<ul>
<li>VK_IMAGE_USAGE_TRANSFER_SRC_BIT: 指定图像可用作传输命令的源。</li>
<li>VK_IMAGE_USAGE_TRANSFER_DST_BIT: 指定图像可用作传输命令的目标。</li>
<li>VK_IMAGE_USAGE_SAMPLED_BIT: 指定该图像可用于创建适合占用VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE或VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型的VkDescriptorSet槽的VkImageView，并由着色器进行采样。</li>
<li>VK_IMAGE_USAGE_STORAGE_BIT: 指定该图像可用于创建适合占用VK_DESCRIPTOR_TYPE_STORAGE_IMAGE类型的VkDescriptorSet插槽的VkImageView。</li>
<li>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: 指定该图像可用于创建适合用作颜色的VkImageView或解析VkFramebuffer中的附件。</li>
<li>VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: 指定该图像可用于创建适合用作VkFramebuffer中的深度&#x2F;模板附件的VkImageView。</li>
<li>VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: 指定绑定到此映像的内存将使用VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT进行分配。可以为任何可用于创建适合用作颜色，分辨率，深度&#x2F;模板或输入附件的VkImageView的图像设置此位。</li>
<li>VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: 指定该图像可用于创建适合占用VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT类型的VkDescriptorSet槽的VkImageView; 从着色器读取作为输入附件; 并用作帧缓冲区中的输入附件。</li>
</ul>
<h3 id="2-5-2-处理将在多个队列系列中使用的交换链图像"><a href="#2-5-2-处理将在多个队列系列中使用的交换链图像" class="headerlink" title="2.5.2 处理将在多个队列系列中使用的交换链图像"></a>2.5.2 处理将在多个队列系列中使用的交换链图像</h3><p>如果队列系列不同，那么需要使用并发模式来避免必须执行所有权。<br>并发模式要求使用queueFamilyIndexCount和pQueueFamilyIndices参数预先指定将共享哪些队列系列所有权。<br>如果图形队列系列和表示队列系列是相同的（大多数硬件都是这种情况），那么我们应该坚持独占模式，因为并发模式要求指定至少两个不同的队列系列。</p>
<h2 id="2-6-检索交换链图像"><a href="#2-6-检索交换链图像" class="headerlink" title="2.6 检索交换链图像"></a>2.6 检索交换链图像</h2><p>创建了交换链对象后，就可以检索其中的VkImages的句柄，这些VkImages是用于后续渲染操作的。<br>我们可以使用一个Set集合存储这些VkImages:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;VkImage&gt; swapChainImages;</span><br></pre></td></tr></table></figure>
<p>类似于Surface, 这些VkImage是不需要我们主动销毁的。在交换链被销毁时，Vulkan自动就会销毁这些VkImage了。</p>
<p>一般在vkCreateSwapchainKHR调用之后立即检索createSwapChain函数末尾的句柄。<br>在交换链中只是指定了最少数量的图像，Vulkan允许实现创建更多的图像。创建后记得调整容器大小，最后再次调用它来检索VkImage。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先获取交换链中图像数量</span></span><br><span class="line"><span class="built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 调整set集合大小</span></span><br><span class="line">swapChainImages.<span class="built_in">resize</span>(imageCount);</span><br><span class="line"><span class="comment">// 获取VkImage对象</span></span><br><span class="line"><span class="built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>

<h2 id="2-7-小结"><a href="#2-7-小结" class="headerlink" title="2.7 小结"></a>2.7 小结</h2><p>这部分内容比较多，小结一下：</p>
<h3 id="2-7-1-什么是交换链？"><a href="#2-7-1-什么是交换链？" class="headerlink" title="2.7.1 什么是交换链？"></a>2.7.1 什么是交换链？</h3><p>交换链本质上是一个等待呈现给屏幕的图像队列。应用程序将获取这样的图像以绘制它，然后将其返回到队列中。</p>
<h3 id="2-7-2-创建交换链的一般步骤"><a href="#2-7-2-创建交换链的一般步骤" class="headerlink" title="2.7.2 创建交换链的一般步骤"></a>2.7.2 创建交换链的一般步骤</h3><ol>
<li>确认当前物理设备(GPU)是否支持交换链</li>
<li>创建逻辑设备时，使能交换链扩展(ppEnabledExtensionNames)</li>
<li>获取当前设备支持swap chain的更多细节</li>
<li>创建swap chain对象<ol>
<li>绑定窗口Surface</li>
<li>设置最小图像数量 minImageCount</li>
<li>选择合适的图像格式 imageFormat </li>
<li>选择合适的图像颜色空间 imageColorSpace</li>
<li>选择合适的图像分辨率 imageExtent</li>
<li>设置图像图层 imageArrayLayers</li>
<li>设置图像操作方式 imageUsage</li>
<li>选择图像呈现模式 presentMode</li>
<li>是否需要裁剪功能 clipped(VK_TRUE, VK_FALSE)</li>
<li>设置旧交换链的引用 oldSwapchain</li>
</ol>
</li>
<li>获取交换链图像(VkImage)对象集合</li>
</ol>
<p>虽然到目前为止，我们编出来的程序还只是一个800*600的黑窗口。但是已经万事具备了，下一步就可以把图像内容呈现到窗口里了。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(5)-图像视图及Pipeline简述</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-5-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%8F%8APipeline%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要介绍VkImageView以及着色器的创建，并且我们将学习到如何编写一个渐变颜色的三角形着色器。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[SPIR-V] <a href="https://www.khronos.org/spir/">https://www.khronos.org/spir/</a></li>
<li>[SPIR-V doc] <a href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html">https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html</a></li>
<li>[GLSL开发手册] <a href="https://github.com/wshxbqq/GLSL-Card">https://github.com/wshxbqq/GLSL-Card</a></li>
</ol>
<h1 id="一-Image-views"><a href="#一-Image-views" class="headerlink" title="一. Image views"></a>一. Image views</h1><p>在Render pipeline中使用VkImage, 包括在交换链中，需要创建一个VkImageView的对象。<br>VkImageView实际上就是图像的视图。它描述了如何访问图像以及要访问的图像部分，例如，如果它应被视为2D纹理深度纹理而没有任何mipmapping级别。<br>接下来我们试试为交换链中的每个图像创建一个基本VkImageView。<br>创建VkImageView的方式也是通过一个结构体：VkImageViewCreateInfo, 来指明细节.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageViewCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                pNext;</span><br><span class="line">    VkImageViewCreateFlags     flags;</span><br><span class="line">    VkImage                    image;</span><br><span class="line">    VkImageViewType            viewType;</span><br><span class="line">    VkFormat                   format;</span><br><span class="line">    VkComponentMapping         components;</span><br><span class="line">    VkImageSubresourceRange    subresourceRange;</span><br><span class="line">&#125; VkImageViewCreateInfo;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>VkImage: 绑定对应图像</li>
<li>VkImageViewType: 图像视图类型<ul>
<li>一维纹理: VK_IMAGE_VIEW_TYPE_1D、VK_IMAGE_VIEW_TYPE_1D_ARRAY</li>
<li>二维纹理: VK_IMAGE_VIEW_TYPE_2D、VK_IMAGE_VIEW_TYPE_2D_ARRAY</li>
<li>三维纹理: VK_IMAGE_VIEW_TYPE_3D</li>
<li>立方体贴图: VK_IMAGE_VIEW_TYPE_CUBE、VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</li>
</ul>
</li>
<li>VkFormat: 图像格式</li>
<li>VkComponentMapping: 图像颜色通道，即RGB和Alpha通道</li>
<li>VkImageSubresourceRange:描述了图像的目的以及应该访问图像的哪个部分</li>
</ul>
<p>特别的，如果是3D应用程序, 那应该创建一个带有多个layer的交换链。这样可以通过访问不同的图层为每个图像创建多个图像视图，以表示左右视图。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createImageViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置集合大小</span></span><br><span class="line">    swapChainImageViews.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImageViews.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        VkImageViewCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">        createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;</span><br><span class="line">        createInfo.image = swapChainImages[i]; <span class="comment">// 绑定 VkImage</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// viewType和format字段指定应如何解释图像数据</span></span><br><span class="line">        <span class="comment">// viewType参数指定图像为一维纹理，二维纹理，三维纹理或立方体贴图</span></span><br><span class="line">        createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;</span><br><span class="line">        <span class="comment">// 图像格式</span></span><br><span class="line">        createInfo.format = swapChainImageFormat;</span><br><span class="line">        <span class="comment">// 图像颜色通道，即RGB和Alpha通道。比如将所有通道映射到红色通道以获得单色纹理，或者将常量值0和1映射到通道。这里选择默认映射:</span></span><br><span class="line">        createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">        createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">        createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">        createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// subresourceRange字段描述了图像的目的是什么以及应该访问图像的哪个部分。</span></span><br><span class="line">        <span class="comment">// 这里图像将用作颜色目标，没有任何mipmapping级别或多个层。</span></span><br><span class="line">        createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">        createInfo.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">        createInfo.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">        createInfo.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">        createInfo.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，通过vkCreateXXX创建的对象，都需要我们主动去释放</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">vkCreateImageView</span>(device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;swapChainImageViews[i]) != VK_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create image views!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放交换链对应的图像视图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> imageView : swapChainImageViews) &#123;</span><br><span class="line">        <span class="built_in">vkDestroyImageView</span>(device, imageView, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了图像视图足以开始将图像用作纹理，但还不能直接用作渲染目标。需要一个间接步骤，称为帧缓冲，但首先我们必须设置图形管道。</p>
<h1 id="二-图形管道-Pipeline-简介"><a href="#二-图形管道-Pipeline-简介" class="headerlink" title="二. 图形管道 Pipeline 简介"></a>二. 图形管道 Pipeline 简介</h1><p>所谓图形管道就是一系列操作，它们将网格的顶点和纹理一直带到渲染目标中的像素。简化概述如下所示：</p>
<ol>
<li>输入汇编程序(input assembler): 从指定的缓冲区收集原始顶点数据，也可以使用索引缓冲区重复某些元素，而不必复制顶点数据本身。</li>
<li>顶点着色器(vertex shader): 针对每个顶点运行，并且通常应用变换以将顶点位置从模型空间转换到屏幕空间。它还沿着管道传递每顶点数据。</li>
<li>曲面细分着色器(tessellation shaders): 根据特定规则细分几何体以提高网格质量。通常用于使砖墙和楼梯等表面在附近时看起来不那么平坦。</li>
<li>几何着色器(geometry shader): 在每个基元(三角形，直线，点)上运行，并且可以丢弃它或输出比原来更多的基元。类似于曲面细分着色器，但更灵活。但没有得到太多应用，因为大多数显卡的性能都不是很好。</li>
<li>光栅化阶段(rasterization stage): 将基元离散化为片段。这些是它们填充在帧缓冲区上的像素元素。在屏幕之外的片段都将被丢弃，顶点着色器输出的属性将在片段之间进行插值。由于深度测试，通常在这里也丢弃其他原始片段后面的片段。</li>
<li>片段着色器(fragment shader): 为存活的每个片段调用片段着色器，并确定片段写入哪些帧缓冲区以及使用哪些颜色和深度值。它可以使用来自顶点着色器的插值数据来完成此操作，其中可以包括纹理坐标和法线照明等内容。</li>
<li>颜色混合阶段(color blending stage): 应用操作来混合映射到帧缓冲区中的相同像素的不同片段。 碎片可以简单地相互覆盖，加起来或根据透明度进行混合。<ol>
<li>绿色的阶段被称为固定功能阶段。这些阶段允许使用参数调整其操作，但它们的工作方式是预定义的。</li>
<li>橙色的阶段是可编程的，这意味着可以将代码上传到图形卡，以完全应用想要的操作。 </li>
<li>例如，实现从纹理和光照到光线跟踪器的任何内容。这些程序同时在许多GPU内核上运行，以并行处理许多对象，如顶点和片段。，可以使用片段着色器</li>
</ol>
</li>
</ol>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-5-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%8F%8APipeline%E7%AE%80%E8%BF%B0/Vulkan_5_1.png" alt="图片"></p>
<p>在OpenGL和Direct3D中，可以使用glBlendFunc和OMSetBlendState等调用随意更改任何管道设置。<br>但Vulkan中的图形管道几乎完全不可变，因此如果要更改着色器，绑定不同的帧缓冲区或更改混合函数，则必须从头开始重新创建管道。<br>缺点是您必须创建许多管道，这些管道代表您要在渲染操作中使用的所有状态组合。但是，因为您将在管道中执行的所有操作都是事先知道的，所以驱动程序可以更好地优化它。</p>
<p>根据您的目的，某些可编程阶段是可选的。例如，如果您只是绘制简单几何体，则可以禁用曲面细分和几何体阶段。<br>如果您只对深度值感兴趣，则可以禁用片段着色器阶段，这对阴影贴图生成很有用。</p>
<p>记住<strong>创建管道需要在创建VkImageView之后</strong>。</p>
<p>具体的创建需要依赖上述各个着色器，我们先熟悉一下这些着色器。</p>
<h1 id="三-着色器-Shader-modules"><a href="#三-着色器-Shader-modules" class="headerlink" title="三. 着色器(Shader modules)"></a>三. 着色器(Shader modules)</h1><p>Vulkan中的着色器代码必须以字节码格式指定，而不是像GLSL和HLSL这样的人类可读语法。</p>
<ul>
<li>GLSL是一种具有C风格语法的着色语言。写在其中的程序具有为每个对象调用的主函数。</li>
<li>GLSL使用全局变量来处理输入和输出，而不是使用输入参数和返回值作为输出。该语言包括许多有助于图形编程的功能，如内置向量和矩阵基元。包括交叉积，矩阵向量积和向量周围反射等操作的函数。</li>
</ul>
<p>而Vulkan中的这种字节码格式称为<strong>SPIR-V</strong>，旨在与Vulkan和OpenCL（两种Khronos API）一起使用。<br>SPIR-V是一种用于图形着色器和计算内核的简单二进制中间语言。 更多信息可以参考 <a href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html">https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html</a></p>
<p>使用字节码格式的优点是比GPU供应商编写的将着色器代码转换为本机代码的编译器要简单的得多。<br>过去已经表明，使用像GLSL这样的人类可读语法，一些GPU供应商对标准的解释相当灵活。<br>如果碰巧使用其中一个供应商编写的不标准GPU着色器，那么由于语法错误，可能其他供应商的驱动程序会拒绝我们的代码，或者更糟糕的，由于编译器错误，着色器运行方式不同。而使用简单的字节码格式，如SPIR-V，则可以避免此类问题。</p>
<p>但是，这并不意味着我们需要手动编写这个字节码。 Khronos发布了自己独立于供应商的编译器，将GLSL编译为SPIR-V。<br>此编译器旨在验证着色器代码是否完全符合标准，并生成一个可与程序一起提供的SPIR-V二进制文件。<br>我们还可以将此编译器作为库包含在运行时生成SPIR-V。<br>这个编译器已经包含在LunarG SDK中作为glslangValidator.exe，无需额外下载。</p>
<p>接下来我们使用GLSL语言(详细参考: <a href="https://github.com/wshxbqq/GLSL-Card)%E7%BC%96%E5%86%99%E7%9D%80%E8%89%B2%E5%99%A8%E3%80%82">https://github.com/wshxbqq/GLSL-Card)编写着色器。</a></p>
<h2 id="3-1-顶点着色器-Vertex-Shader"><a href="#3-1-顶点着色器-Vertex-Shader" class="headerlink" title="3.1 顶点着色器 Vertex Shader"></a>3.1 顶点着色器 Vertex Shader</h2><p>矢量类型称为vec，其数字表示元素的数量。 例如，3D位置将存储在vec3中。<br>可以通过.x等成员访问单个组件，但也可以同时从多个组件创建新的向量。 例如，表达式vec3（1.0,2.0,3.0）.xy将导致vec2。<br>向量的构造函数也可以采用向量对象和标量值的组合。 例如，vec3可以用vec3（vec2（1.0,2.0），3.0）构建。</p>
<p>顶点着色器处理每个传入的顶点。 它将其属性（如世界位置，颜色，法线和纹理坐标）作为输入。<br>输出是剪辑坐标中的最终位置以及需要传递到片段着色器的属性，如颜色和纹理坐标。<br>然后，光栅化器将这些值插入片段上以产生平滑的梯度。<br>剪辑坐标是来自顶点着色器的四维矢量，其随后通过将整个矢量除以其最后一个分量而变为标准化设备坐标。 这些标准化的设备坐标是齐次坐标，它将帧缓冲区映射到[-1,1]乘[-1,1]坐标系，如下所示：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-5-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%8F%8APipeline%E7%AE%80%E8%BF%B0/Vulkan_5_2.png" alt="图片"></p>
<p>注意xy轴的方向，类似Android中的坐标轴，而不是OpenGL中的坐标轴方向。<br>接下来我们通过顶点着色器和片段着色器以在屏幕上呈现一个三角形,如下图：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-5-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%8F%8APipeline%E7%AE%80%E8%BF%B0/Vulkan_5_3.png" alt="图片"></p>
<p>我们可以直接输出归一化设备坐标，方法是将它们作为顶点着色器的剪辑坐标输出，最后一个组件设置为1.<br>这样，将剪辑坐标转换为规范化设备坐标的划分不会改变任何东西。<br>通常这些坐标将存储在顶点缓冲区中，但在Vulkan中创建顶点缓冲区并用数据填充它并不简单。<br>如果我们直接在顶点着色器中包含坐标，那么可以这样写：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec2</span> positions[<span class="number">3</span>] = <span class="type">vec2</span>[](</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">-0.5</span>),</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>),</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">-0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(positions[gl_VertexIndex], <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个顶点的生成都需要调用main函数。<br>内置的<strong>gl_VertexIndex</strong>变量包含当前顶点的索引，一般是顶点缓冲区的索引。在这里，它是顶点数据的硬编码数组的索引。<br>从着色器中的常量数组访问每个顶点的位置，并与虚拟z和w组件组合以在剪辑坐标中生成位置，内置变量gl_Position用作输出。</p>
<h2 id="3-2-片段着色器-Fragment-Shader"><a href="#3-2-片段着色器-Fragment-Shader" class="headerlink" title="3.2 片段着色器 Fragment Shader"></a>3.2 片段着色器 Fragment Shader</h2><p>由顶点着色器的位置形成的三角形用片段填充屏幕上的区域。<br>在这些片段上调用片段着色器以生成帧缓冲区（或帧缓冲区）的颜色和深度。<br>为整个三角形输出红色的简单片段着色器如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 帧缓冲区的索引为0</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> outColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    outColor = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GLSL中的颜色是4分量矢量，其中R，G，B和α通道在[0,1]范围内。<br>与顶点着色器中的gl_Position不同，没有内置变量来输出当前片段的颜色。 所以必须为每个帧缓冲区指定自己的输出变量，其中layout（location &#x3D; 0）修饰符指定帧缓冲区的索引。<br>红色将写入此outColor变量，该变量链接到索引0处的第一个（也是唯一的）帧缓冲区。</p>
<h2 id="3-3-为每个顶点着色"><a href="#3-3-为每个顶点着色" class="headerlink" title="3.3 为每个顶点着色"></a>3.3 为每个顶点着色</h2><p>如果我们想要实现渐变颜色的三角形，如下：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-5-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%8F%8APipeline%E7%AE%80%E8%BF%B0/Vulkan_5_4.png" alt="图片"></p>
<p>这就需要我们为三个顶点中的每一个指定不同的颜色。 顶点着色器现在应该包含一个颜色的数组，就像它对位置一样.</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">vec3</span> colors[<span class="number">3</span>] = <span class="type">vec3</span>[](</span><br><span class="line">    <span class="comment">// vec3(r,g,b)</span></span><br><span class="line">    <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>),</span><br><span class="line">    <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>),</span><br><span class="line">    <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>每一个vec3对应一个顶点。现在我们只需要将这些顶点颜色传递给片段着色器，这样就可以将它们的插值输出到帧缓冲区。<br>将颜色输出添加到顶点着色器并在main函数中写入：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec2</span> positions[<span class="number">3</span>] = <span class="type">vec2</span>[](</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">-0.5</span>),</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>),</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">-0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(positions[gl_VertexIndex], <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = colors[gl_VertexIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要在片段着色器中添加匹配的输入：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 帧缓冲区的索引为0</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    outColor = <span class="type">vec4</span>(fragColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入变量不一定必须使用相同的名称，因为我们使用location指令指定的索引讲它们链接在一起。<br>如上图所示，fragColor的值将自动插入三个顶点之间的片段，从而产生平滑的渐变。</p>
<h2 id="3-4-编译着色器"><a href="#3-4-编译着色器" class="headerlink" title="3.4 编译着色器"></a>3.4 编译着色器</h2><p>首先在我们的工程目录下创建一个 shaders 的目录，用于保存我们的着色器。<br>首先是 shader.vert 文件：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为fragColor</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角形顶点坐标</span></span><br><span class="line"><span class="type">vec2</span> positions[<span class="number">3</span>] = <span class="type">vec2</span>[](</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">-0.5</span>),</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.5</span>),</span><br><span class="line">    <span class="type">vec2</span>(<span class="number">-0.5</span>, <span class="number">0.5</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渐变颜色</span></span><br><span class="line"><span class="type">vec3</span> colors[<span class="number">3</span>] = <span class="type">vec3</span>[](</span><br><span class="line">    <span class="type">vec3</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>),</span><br><span class="line">    <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>),</span><br><span class="line">    <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(positions[gl_VertexIndex], <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = colors[gl_VertexIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有 shader.frag 文件:</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> outColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    outColor = <span class="type">vec4</span>(fragColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-1-Linux平台下编译方式"><a href="#3-4-1-Linux平台下编译方式" class="headerlink" title="3.4.1 Linux平台下编译方式"></a>3.4.1 Linux平台下编译方式</h3><p>使用 vulkan SDK中的glslangValidator来编译shader文件:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslangValidator -V shader.vert</span></span><br><span class="line"><span class="comment">#/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslangValidator -V shader.frag</span></span><br><span class="line">/home/jh/Program/vulkan/1.1.106.0/x86_64/bin/glslangValidator -V shader.vert</span><br><span class="line">/home/jh/Program/vulkan/1.1.106.0/x86_64/bin/glslangValidator -V shader.frag</span><br></pre></td></tr></table></figure>
<p>执行上面的脚本后，会在当前目录生成对应的: frag.spv和vert.spv文件<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-5-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%8F%8APipeline%E7%AE%80%E8%BF%B0/Vulkan_5_5.png" alt="Vulkan_5_5.png"></p>
<h3 id="3-4-2-Windows平台编译方式"><a href="#3-4-2-Windows平台编译方式" class="headerlink" title="3.4.2 Windows平台编译方式"></a>3.4.2 Windows平台编译方式</h3><p>类似，不赘述</p>
<p>另外Vulkan SDK包含libshaderc库，用于从程序中将GLSL代码编译为SPIR-V。</p>
<h2 id="3-5-加载着色器"><a href="#3-5-加载着色器" class="headerlink" title="3.5 加载着色器"></a>3.5 加载着色器</h2><p>加载着色器就是读取我们编译好的shader文件:frag.spv和vert.spv.<br>c++中读取文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::vector&lt;<span class="type">char</span>&gt; <span class="title">readFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ate: 从文件末尾开始阅读</span></span><br><span class="line">    <span class="comment">// binary: 二进制流形式</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename, std::ios::ate | std::ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to open file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fileSize = (<span class="type">size_t</span>) file.<span class="built_in">tellg</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(fileSize)</span></span>;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">    file.<span class="built_in">read</span>(buffer.<span class="built_in">data</span>(), fileSize);</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如读取 vert.spv:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> vertShaderCode = <span class="built_in">readFile</span>(<span class="string">&quot;shaders/vert.spv&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>读取成功后，记得check一下文件大小是否匹配。</p>
<h2 id="3-6-创建着色器模块-shader-modules-VkShaderModule"><a href="#3-6-创建着色器模块-shader-modules-VkShaderModule" class="headerlink" title="3.6 创建着色器模块(shader modules - VkShaderModule)"></a>3.6 创建着色器模块(shader modules - VkShaderModule)</h2><p>在Vulkan中使用VkShaderModule存储着色器. 使用结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkShaderModuleCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType              sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                  pNext;</span><br><span class="line">    VkShaderModuleCreateFlags    flags;</span><br><span class="line">    <span class="type">size_t</span>                       codeSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*              pCode;</span><br><span class="line">&#125; VkShaderModuleCreateInfo;</span><br></pre></td></tr></table></figure>
<p>封装成createShaderModule方法,方便后续调用.<br>其实VkShaderModule只是一个对着色器文件的封装而已。使用方法：vkCreateShaderModule</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkShaderModule <span class="title">createShaderModule</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; code)</span> </span>&#123;</span><br><span class="line">    VkShaderModuleCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;</span><br><span class="line">    createInfo.codeSize = code.<span class="built_in">size</span>();</span><br><span class="line">    createInfo.pCode = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint32_t</span>*&gt;(code.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    VkShaderModule shaderModule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vkResult device, const  *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateShaderModule</span>(device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create shader module!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shaderModule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-7-着色器阶段创建-shader-stage"><a href="#3-7-着色器阶段创建-shader-stage" class="headerlink" title="3.7 着色器阶段创建(shader stage)"></a>3.7 着色器阶段创建(shader stage)</h2><p>只是有 VkShaderModule，还不够。要使用着色器，还需要在创建管道(Pipeline)时，使用VkPipelineShaderStageCreateInfo结构讲其分配到特定的管道阶段。<br>比如在管道中填充顶点着色器: vert.spv</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineShaderStageCreateInfo vertShaderStageInfo = &#123;&#125;;</span><br><span class="line">vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;</span><br><span class="line">vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; <span class="comment">// 指明当前是顶点阶段 (3.7.1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定包含代码的着色器模块</span></span><br><span class="line">vertShaderStageInfo.<span class="keyword">module</span> = vertShaderModule;</span><br><span class="line"><span class="comment">// 指定要调用的着色器模块函数（称为入口点）</span></span><br><span class="line">vertShaderStageInfo.pName = <span class="string">&quot;main&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有一个（可选的）成员pSpecializationInfo，这里不会在这里使用。它允许您指定着色器常量的值。<br>当使用单个着色器模块，通过为其中使用的常量指定不同的值，就可以在创建管道时配置其行为。<br>这比在渲染时使用变量配置着色器更有效，因为编译器可以执行优化，例如消除依赖于这些值的if语句。<br>默认为nullptr，struct初始化会自动执行。</p>
<h3 id="3-7-1-Shader-Stage"><a href="#3-7-1-Shader-Stage" class="headerlink" title="3.7.1 Shader Stage"></a>3.7.1 Shader Stage</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkShaderStageFlagBits</span> &#123;</span><br><span class="line">    VK_SHADER_STAGE_VERTEX_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_SHADER_STAGE_GEOMETRY_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_SHADER_STAGE_FRAGMENT_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_SHADER_STAGE_COMPUTE_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL_GRAPHICS = <span class="number">0x0000001F</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL = <span class="number">0x7FFFFFFF</span>,</span><br><span class="line">    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkShaderStageFlagBits;</span><br></pre></td></tr></table></figure>
<ul>
<li>VK_SHADER_STAGE_VERTEX_BIT: 顶点阶段</li>
<li>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: 曲面细分控制阶段</li>
<li>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: 曲面细分评估阶段</li>
<li>VK_SHADER_STAGE_GEOMETRY_BIT: 几何阶段</li>
<li>VK_SHADER_STAGE_FRAGMENT_BIT: 片段阶段</li>
<li>VK_SHADER_STAGE_COMPUTE_BIT: 计算阶段</li>
<li>VK_SHADER_STAGE_ALL_GRAPHICS: 用作速记的位组合，用于指定上面定义的所有图形阶段（不包括计算阶段）。</li>
<li>VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: 用作速记的位组合，用于指定设备支持的所有着色器阶段，包括扩展引入的所有其他阶段。</li>
</ul>
<h3 id="3-7-2-为着色器指定管道"><a href="#3-7-2-为着色器指定管道" class="headerlink" title="3.7.2 为着色器指定管道"></a>3.7.2 为着色器指定管道</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createGraphicsPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> vertShaderCode = <span class="built_in">readFile</span>(<span class="string">&quot;shaders/vert.spv&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> fragShaderCode = <span class="built_in">readFile</span>(<span class="string">&quot;shaders/frag.spv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    VkShaderModule vertShaderModule = <span class="built_in">createShaderModule</span>(vertShaderCode);</span><br><span class="line">    VkShaderModule fragShaderModule = <span class="built_in">createShaderModule</span>(fragShaderCode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为管道指定着色器</span></span><br><span class="line">    VkPipelineShaderStageCreateInfo shaderStages[] =  &#123;vertShaderStageInfo, fragShaderStageInfo&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记得销毁shader</span></span><br><span class="line">    <span class="built_in">vkDestroyShaderModule</span>(device, vertShaderModule, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyShaderModule</span>(device, fragShaderModule, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图形管道 其他部分设置在下个文章中讨论。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(6)-创建管道的几个固定操作</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>其他图形API为图形管道的大多数阶段提供了默认状态。但在Vulkan中，必须明确所有内容，从视口大小到颜色混合功能。<br>接下来我们试着填写配置这些固定功能操作的所有结构。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h1 id="一-Vertex-input"><a href="#一-Vertex-input" class="headerlink" title="一. Vertex input"></a>一. Vertex input</h1><p>VkPipelineVertexInputStateCreateInfo结构描述将传递给顶点着色器的顶点数据的格式。<br>它以两种方式描述了这一点：</p>
<ul>
<li>绑定( Bindings )：数据之间的间距以及数据是按顶点还是按实例（请参阅实例化）</li>
<li>属性描述( Attribute descriptions )：传递给顶点着色器的属性的类型，从哪个绑定加载它们</li>
</ul>
<p>因为我们直接在顶点着色器中对顶点数据进行硬编码，所以我们将填充此结构以指定现在没有要加载的顶点数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createGraphicsPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 这里为管道指定着色器</span></span><br><span class="line">    VkPipelineShaderStageCreateInfo shaderStages[] =  &#123;vertShaderStageInfo, fragShaderStageInfo&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点着色器的数据输入</span></span><br><span class="line">    VkPipelineVertexInputStateCreateInfo vertexInputInfo = &#123;&#125;;</span><br><span class="line">    vertexInputInfo.sType = </span><br><span class="line">            VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;</span><br><span class="line"></span><br><span class="line">    vertexInputInfo.vertexBindingDescriptionCount = <span class="number">0</span>;</span><br><span class="line">    vertexInputInfo.pVertexBindingDescriptions = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">    vertexInputInfo.vertexAttributeDescriptionCount = <span class="number">0</span>;</span><br><span class="line">    vertexInputInfo.pVertexAttributeDescriptions = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pVertexBindingDescriptions和pVertexAttributeDescriptions 成员指向一个结构数组，描述前面提到的加载顶点数据的细节。<br>后续在学习顶点缓冲的时候详细分析。</p>
<h1 id="二-Input-assembly"><a href="#二-Input-assembly" class="headerlink" title="二. Input assembly"></a>二. Input assembly</h1><p>VkPipelineInputAssemblyStateCreateInfo结构描述了两件事：</p>
<ol>
<li>将从顶点绘制什么类型的几何, 由成员变量topology 指定。可以使用如下值：<ul>
<li>VK_PRIMITIVE_TOPOLOGY_POINT_LIST：来自顶点的点</li>
<li>VK_PRIMITIVE_TOPOLOGY_LINE_LIST：来自每2个顶点的行而不重用</li>
<li>VK_PRIMITIVE_TOPOLOGY_LINE_STRIP：每行的结束顶点用作下一行的起始顶点</li>
<li>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST：每3个顶点的三角形，无需重复使用</li>
<li>VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP：每个三角形的第二个和第三个顶点用作下一个三角形的前两个顶点</li>
</ul>
</li>
<li>是否应启用基元重启。</li>
</ol>
<p>通常，顶点缓冲区按顺序从顶点缓冲区加载，但是使用元素缓冲区可以指定要自己使用的索引，这允许您执行重用顶点等优化。<br>如果将primitiveRestartEnable成员设置为VK_TRUE，则可以通过使用特殊索引0xFFFF或0xFFFFFFFF来分解_STRIP拓扑模式中的行和三角形。</p>
<p>如果是绘制三角形，创建如下的 VkPipelineInputAssemblyStateCreateInfo：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineInputAssemblyStateCreateInfo inputAssembly = &#123;&#125;;</span><br><span class="line">inputAssembly.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;</span><br><span class="line">inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;</span><br><span class="line">inputAssembly.primitiveRestartEnable = VK_FALSE;</span><br></pre></td></tr></table></figure>

<h1 id="三-Viewports-and-scissors"><a href="#三-Viewports-and-scissors" class="headerlink" title="三. Viewports and scissors"></a>三. Viewports and scissors</h1><h2 id="3-1-Viewports"><a href="#3-1-Viewports" class="headerlink" title="3.1 Viewports"></a>3.1 Viewports</h2><p>视窗描述了输出将被渲染到的帧缓冲区域。 基本总是（0,0）到（宽度，高度），也就是窗口大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkViewport viewport = &#123;&#125;;</span><br><span class="line">viewport.x = <span class="number">0.0f</span>;</span><br><span class="line">viewport.y = <span class="number">0.0f</span>;</span><br><span class="line">viewport.width = (<span class="type">float</span>) swapChainExtent.width; <span class="comment">// 交换链，即帧缓冲区</span></span><br><span class="line">viewport.height = (<span class="type">float</span>) swapChainExtent.height;</span><br><span class="line">viewport.minDepth = <span class="number">0.0f</span>;</span><br><span class="line">viewport.maxDepth = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure>
<p>交换链及其图像的大小可能与窗口的宽度和高度不同。 交换链图像将在以后用作帧缓冲区，因此我们不能轻易改变它们的大小。<br>minDepth和maxDepth值指定用于帧缓冲区的深度值范围。 这些值必须在[0.0f，1.0f]范围内，但minDepth可能高于maxDepth。<br>虽然视窗定义了从图像到帧缓冲的转换，但剪刀矩形定义了实际存储像素的区域。<br>剪刀矩形外的任何像素都将被光栅化器丢弃。 它们的功能类似于过滤器而不是转换。<br>差异如下所示。 请注意，左边的剪刀矩形只是导致该图像的众多可能性之一，只要它比视口大：</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-6-%E5%88%9B%E5%BB%BA%E7%AE%A1%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9B%BA%E5%AE%9A%E6%93%8D%E4%BD%9C/Vulkan_6_1.png" alt="图片"></p>
<p>也就是说Viewport会缩放以显示完整的图片，而scissors会裁剪(或者说遮挡)图片内容。</p>
<h2 id="3-2-Scissors"><a href="#3-2-Scissors" class="headerlink" title="3.2 Scissors"></a>3.2 Scissors</h2><p>简单定义一个可以绘制整个帧缓冲的Scissor:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkRect2D scissor = &#123;&#125;;</span><br><span class="line">scissor.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">scissor.extent = swapChainExtent;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-使用方式"><a href="#3-3-使用方式" class="headerlink" title="3.3 使用方式"></a>3.3 使用方式</h2><p>现在使用VkPipelineViewportStateCreateInfo结构将此视口和剪刀矩形组合成视口状态。<br>可以在某些图形卡上使用多个视口和剪刀矩形，因此其成员需要引用它们的数组。使用多个需要启用GPU功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineViewportStateCreateInfo viewportState = &#123;&#125;;</span><br><span class="line">viewportState.sType =</span><br><span class="line">        VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;</span><br><span class="line">viewportState.viewportCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pViewports = &amp;viewport;</span><br><span class="line">viewportState.scissorCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pScissors = &amp;scissor;</span><br></pre></td></tr></table></figure>

<h1 id="四-Rasterizer-光栅化"><a href="#四-Rasterizer-光栅化" class="headerlink" title="四. Rasterizer (光栅化)"></a>四. Rasterizer (光栅化)</h1><p>光栅化器采用由顶点着色器的顶点整形的几何体，并将其转换为片段着色器着色的片段。<br>它还可以执行深度测试，面部剔除和剪刀测试，并且可以配置为输出填充整个多边形或仅填充边缘的片段（线框渲染）。<br>所有这些都是使用VkPipelineRasterizationStateCreateInfo结构配置的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineRasterizationStateCreateInfo rasterizer = &#123;&#125;;</span><br><span class="line">rasterizer.sType =</span><br><span class="line">    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;</span><br><span class="line">rasterizer.depthClampEnable = VK_FALSE;</span><br><span class="line">rasterizer.rasterizerDiscardEnable = VK_FALSE;</span><br><span class="line">rasterizer.polygonMode = VK_POLYGON_MODE_FILL;</span><br><span class="line">rasterizer.lineWidth = <span class="number">1.0f</span>;</span><br><span class="line">rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;</span><br><span class="line">rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;</span><br><span class="line">rasterizer.depthBiasEnable = VK_FALSE;</span><br><span class="line">rasterizer.depthBiasConstantFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasClamp = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasSlopeFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure>
<ol>
<li>depthClampEnable: 设置为VK_TRUE，那么超出近平面和远平面的fragment将被夹住，而不是丢弃它们。这在某些特殊情况下很有用，比如阴影贴图。使用此功能需要启用GPU功能。</li>
<li>rasterizerDiscardEnable: 设置为VK_TRUE，那么几何图形永远不会通过光栅化阶段。这基本上禁止任何输出到帧缓冲区。</li>
<li>polygonMode: 多边形模态决定了如何为几何图形生成fragment。有以下几种模式:(使用FILL以外的任何模式都需要启用GPU功能)<ol>
<li>VK_POLYGON_MODE_FILL: 用fragment填充多边形的区域</li>
<li>VK_POLYGON_MODE_LINE: 多边形边缘以直线的形式绘制</li>
<li>VK_POLYGON_MODE_POINT: 用点绘制多边形顶点</li>
</ol>
</li>
<li>lineWidth: 用来描述线条的粗细。支持的最大线宽取决于硬件，任何超过1.0f的线路都需要启用宽带GPU功能。</li>
<li>cullMode: 确定要使用的面消隐的类型。可以禁用消隐、消隐正面、消隐背面或两者兼有。</li>
<li>frontFace: 指定要视为正面的面的顶点顺序，可以是顺时针或逆时针。</li>
</ol>
<p>光栅化器可以通过添加一个常量值或根据fragment的坡度对深度值进行偏移来改变深度值。这有时用于阴影映射，一般不使用时只需将depthBiasEnable设置为VK_FALSE。</p>
<h1 id="五-Multisampling-多重采样"><a href="#五-Multisampling-多重采样" class="headerlink" title="五. Multisampling 多重采样"></a>五. Multisampling 多重采样</h1><p>VkPipelineMultisampleStateCreateInfo结构体用于配置vulkan中的多重采样。</p>
<p>是通过将光栅化为同一像素的多个多边形的片段着色器结果组合在一起实现的，这也是抗锯齿的方式之一。主要是在图形边缘地区做多重采样，这是最明显的锯齿伪影发生的地方。</p>
<p>如果只有一个多边形映射到一个像素，它不需要多次运行片段着色器，因此它比简单地渲染到更高的分辨率然后缩小比例的开销小得多。</p>
<p>启用多重采样需要启用GPU功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineMultisampleStateCreateInfo multisampling = &#123;&#125;;</span><br><span class="line">multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;</span><br><span class="line">multisampling.sampleShadingEnable = VK_FALSE;</span><br><span class="line">multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">multisampling.minSampleShading = <span class="number">1.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">multisampling.pSampleMask = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">multisampling.alphaToCoverageEnable = VK_FALSE; <span class="comment">// Optional</span></span><br><span class="line">multisampling.alphaToOneEnable = VK_FALSE;</span><br></pre></td></tr></table></figure>

<ol>
<li>sampleShadingEnable:  可用于启用采样着色。</li>
<li>rasterizationSamples: 指定用于光栅化的样本数, 一共有7个可选<ol>
<li>VK_SAMPLE_COUNT_1_BIT: 指定每像素1个采样的图像。</li>
<li>VK_SAMPLE_COUNT_2_BIT: 指定每像素2个采样的图像。</li>
<li>VK_SAMPLE_COUNT_4_BIT: 指定每像素4个采样的图像。</li>
<li>VK_SAMPLE_COUNT_8_BIT: 指定每像素8个采样的图像。</li>
<li>VK_SAMPLE_COUNT_16_BIT: 指定每像素16个采样的图像。</li>
<li>VK_SAMPLE_COUNT_32_BIT: 指定每像素32个采样的图像。</li>
<li>VK_SAMPLE_COUNT_64_BIT: 指定每像素64个采样的图像。</li>
</ol>
</li>
<li>minSampleShading: 若sampleShadingEnable设置为VK_TRUE，则指定采样着色的最小部分。</li>
</ol>
<p>后续详细研究，当前先暂时关闭该功能。</p>
<h1 id="六-Color-blending-颜色混合"><a href="#六-Color-blending-颜色混合" class="headerlink" title="六. Color blending 颜色混合"></a>六. Color blending 颜色混合</h1><p>片段着色器返回颜色后，需要将其与帧缓冲区中已有的颜色组合。这种转换称为颜色混合，有两种方法：</p>
<ol>
<li>将新旧值混合生成最终颜色</li>
<li>使用位运算组合新旧值</li>
</ol>
<p>有两种类型的结构可以配置颜色混合。</p>
<ol>
<li>VkPipelineColorBlendAttachmentState: 包含每个附加帧缓冲区的配置，</li>
<li>VkPipelineColorBlendStateCreateInfo: 包含全局颜色混合设置。</li>
</ol>
<h2 id="6-1-VkPipelineColorBlendAttachmentState-结构"><a href="#6-1-VkPipelineColorBlendAttachmentState-结构" class="headerlink" title="6.1 VkPipelineColorBlendAttachmentState 结构"></a>6.1 VkPipelineColorBlendAttachmentState 结构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineColorBlendAttachmentState colorBlendAttachment = &#123;&#125;;</span><br><span class="line">colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT</span><br><span class="line">                                    | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;</span><br><span class="line">colorBlendAttachment.blendEnable = VK_FALSE;</span><br><span class="line">colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE;</span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line">colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO;</span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line">colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span class="comment">// Optional</span></span><br><span class="line">colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;</span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line">colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;</span><br><span class="line"><span class="comment">// Optional</span></span><br><span class="line">colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure>

<p>此每帧缓冲区结构允许您配置颜色混合的第一种方式。将要执行的操作使用以下伪代码演示原理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (blendEnable) &#123;</span><br><span class="line">    finalColor.rgb = (srcColorBlendFactor * newColor.rgb)</span><br><span class="line">                &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);</span><br><span class="line">    finalColor.a = (srcAlphaBlendFactor * newColor.a)</span><br><span class="line">                &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finalColor = newColor;</span><br><span class="line">&#125;</span><br><span class="line">finalColor = finalColor &amp; colorWriteMask;</span><br></pre></td></tr></table></figure>

<p>如果blendEnable设置为VK_FALSE，则片段着色器中的新颜色将不经修改地通过。否则，执行这两个混合操作来计算新颜色。<br>生成的颜色与colorWriteMask进行AND运算，以确定实际通过哪些通道。</p>
<p>使用颜色混合最常用的方法是实现alpha混合，我们希望新颜色与基于不透明度的旧颜色混合。最终颜色的计算如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">finalColor.rgb = newAlpha * newColor + (<span class="number">1</span> - newAlpha) * oldColor;</span><br><span class="line">finalColor.a = newAlpha.a;</span><br></pre></td></tr></table></figure>

<p>这可以通过以下参数实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现alpha混合</span></span><br><span class="line">colorBlendAttachment.blendEnable = VK_TRUE;</span><br><span class="line">colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;</span><br><span class="line">colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;</span><br><span class="line">colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;</span><br><span class="line">colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;</span><br><span class="line">colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;</span><br><span class="line">colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD;</span><br></pre></td></tr></table></figure>

<p>可以在VkBlendFactor和VkBlendOp中找到所有可用的操作：</p>
<table>
<thead>
<tr>
<th>VkBlendFactor</th>
<th>RGB Blend Factors (Sr,Sg,Sb) or (Dr,Dg,Db)</th>
<th>Alpha Blend Factor (Sa or Da)</th>
</tr>
</thead>
<tbody><tr>
<td>VK_BLEND_FACTOR_ZERO</td>
<td>(0,0,0)</td>
<td>0</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE</td>
<td>(1,1,1)</td>
<td>1</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_SRC_COLOR</td>
<td>(Rs0,Gs0,Bs0)</td>
<td>As0</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR</td>
<td>(1-Rs0,1-Gs0,1-Bs0)</td>
<td>1-As0</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_DST_COLOR</td>
<td>(Rd,Gd,Bd)</td>
<td>Ad</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR</td>
<td>(1-Rd,1-Gd,1-Bd)</td>
<td>1-Ad</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_SRC_ALPHA</td>
<td>(As0,As0,As0)</td>
<td>As0</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA</td>
<td>(1-As0,1-As0,1-As0)</td>
<td>1-As0</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_DST_ALPHA</td>
<td>(Ad,Ad,Ad)</td>
<td>Ad</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA</td>
<td>(1-Ad,1-Ad,1-Ad)</td>
<td>1-Ad</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_CONSTANT_COLOR</td>
<td>(Rc,Gc,Bc)</td>
<td>Ac</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR</td>
<td>(1-Rc,1-Gc,1-Bc)</td>
<td>1-Ac</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_CONSTANT_ALPHA</td>
<td>(Ac,Ac,Ac)</td>
<td>Ac</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA</td>
<td>(1-Ac,1-Ac,1-Ac)</td>
<td>1-Ac</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_SRC_ALPHA_SATURATE</td>
<td>(f,f,f); f &#x3D; min(As0,1-Ad)</td>
<td>1</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_SRC1_COLOR</td>
<td>(Rs1,Gs1,Bs1)</td>
<td>As1</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR</td>
<td>(1-Rs1,1-Gs1,1-Bs1)</td>
<td>1-As1</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_SRC1_ALPHA</td>
<td>(As1,As1,As1)</td>
<td>As1</td>
</tr>
<tr>
<td>VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA</td>
<td>(1-As1,1-As1,1-As1)</td>
<td>1-As1</td>
</tr>
</tbody></table>
<p>备注:</p>
<ol>
<li>Rs0、Gs0、Bs0和As0分别表示与正在混合的颜色附件相对应的片段输出位置的第一源颜色R、G、B和A分量。</li>
<li>Rs1、Gs1、Bs1和As1分别表示第二源颜色R、G、B和A分量，用于对应于被混合的颜色附件的片段输出位置，这些分量在双源混合模式中使用。</li>
<li>Rd、Gd、Bd和Ad表示目的颜色的R、G、B和A分量。也就是说，此片段&#x2F;样本的相应颜色附件中当前的颜色。</li>
<li>Rc、Gc、Bc和Ac分别表示混合常数R、G、B和A组分。</li>
</ol>
<p>选择源和目标混合因子后，它们连同源和目标组件一起传递给混合操作。RGB和alpha组件可以使用不同的操作。指定操作的VkBlendOp的可能值为：</p>
<table>
<thead>
<tr>
<th>VkBlendOp</th>
<th>RGB Components</th>
<th>Alpha Component</th>
</tr>
</thead>
<tbody><tr>
<td>VK_BLEND_OP_ADD</td>
<td>R &#x3D; Rs0 × Sr + Rd × Dr<br>G &#x3D; Gs0 × Sg + Gd × Dg<br>B &#x3D; Bs0 × Sb + Bd × Db</td>
<td>A &#x3D; As0 × Sa + Ad × Da</td>
</tr>
<tr>
<td>VK_BLEND_OP_SUBTRACT</td>
<td>R &#x3D; Rs0 × Sr - Rd × Dr<br>G &#x3D; Gs0 × Sg - Gd × Dg<br>B &#x3D; Bs0 × Sb - Bd × Db</td>
<td>A &#x3D; As0 × Sa - Ad × Da</td>
</tr>
<tr>
<td>VK_BLEND_OP_REVERSE_SUBTRACT</td>
<td>R &#x3D; Rd × Dr - Rs0 × Sr<br>G &#x3D; Gd × Dg - Gs0 × Sg<br>B &#x3D; Bd × Db - Bs0 × Sb</td>
<td>A &#x3D; Ad × Da - As0 × Sa</td>
</tr>
<tr>
<td>VK_BLEND_OP_MIN</td>
<td>R &#x3D; min(Rs0,Rd)<br>G &#x3D; min(Gs0,Gd)<br>B &#x3D; min(Bs0,Bd)</td>
<td>A &#x3D; min(As0,Ad)</td>
</tr>
<tr>
<td>VK_BLEND_OP_MAX</td>
<td>R &#x3D; max(Rs0,Rd)<br>G &#x3D; max(Gs0,Gd)<br>B &#x3D; max(Bs0,Bd)</td>
<td>A &#x3D; max(As0,Ad)</td>
</tr>
</tbody></table>
<p>备注:</p>
<ol>
<li>Rs0、Gs0、Bs0和As0分别表示第一源颜色R、G、B和A分量。</li>
<li>Rd、Gd、Bd和Ad表示目的颜色的R、G、B和A分量。也就是说，此片段&#x2F;样本的相应颜色附件中当前的颜色。</li>
<li>Sr、Sg、Sb和Sa分别表示源混合因子R、G、B和A组分。</li>
<li>Dr、Dg、Db和Da分别表示目标混合因子R、G、B和A分量。</li>
</ol>
<h2 id="6-2-VkPipelineColorBlendStateCreateInfo-全局颜色混合设置"><a href="#6-2-VkPipelineColorBlendStateCreateInfo-全局颜色混合设置" class="headerlink" title="6.2 VkPipelineColorBlendStateCreateInfo 全局颜色混合设置"></a>6.2 VkPipelineColorBlendStateCreateInfo 全局颜色混合设置</h2><p>VkPipelineColorBlendStateCreateInfo结构引用所有帧缓冲区的结构数组，并允许您设置可以在上述计算中用作混合因子的混合常数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineColorBlendStateCreateInfo colorBlending = &#123;&#125;;</span><br><span class="line">colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;</span><br><span class="line">colorBlending.logicOpEnable = VK_FALSE;</span><br><span class="line">colorBlending.logicOp = VK_LOGIC_OP_COPY; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.attachmentCount = <span class="number">1</span>;</span><br><span class="line">colorBlending.pAttachments = &amp;colorBlendAttachment;</span><br><span class="line">colorBlending.blendConstants[<span class="number">0</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">1</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">2</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">colorBlending.blendConstants[<span class="number">3</span>] = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure>
<p>如果要使用第二种混合方法（按位组合），则应将logicOpEnable设置为VK_TRUE。然后可以在logicOp字段中指定位操作。请注意，这将自动禁用第一个方法，就像为每个附加的帧缓冲区将blendEnable设置为VK_FALSE一样！colorWriteMask也将用于此模式，以确定帧缓冲区中的哪些通道将实际受到影响。也可以禁用这两种模式，这种情况下，片段颜色将被不修改地写入帧缓冲区。</p>
<h1 id="七-Dynamic-state-可动态修改状态"><a href="#七-Dynamic-state-可动态修改状态" class="headerlink" title="七. Dynamic state 可动态修改状态"></a>七. Dynamic state 可动态修改状态</h1><p>一小部分状态是可以不需要重新创建管道，直接修改的；比如viewport的大小，线宽和颜色混合常数等。</p>
<p>可以使用 VkPipelineDynamicStateCreateInfo 来更改这些动态参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkDynamicState dynamicStates[] = &#123;</span><br><span class="line">    VK_DYNAMIC_STATE_VIEWPORT,</span><br><span class="line">    VK_DYNAMIC_STATE_LINE_WIDTH</span><br><span class="line">&#125;;</span><br><span class="line">VkPipelineDynamicStateCreateInfo dynamicState = &#123;&#125;;</span><br><span class="line">dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;</span><br><span class="line">dynamicState.dynamicStateCount = <span class="number">2</span>;</span><br><span class="line">dynamicState.pDynamicStates = dynamicStates;</span><br></pre></td></tr></table></figure>
<p>这将导致忽略这些值的配置，并要求在绘图时指定相应配置。</p>
<h1 id="八-Pipeline-layout-管道布置图"><a href="#八-Pipeline-layout-管道布置图" class="headerlink" title="八. Pipeline layout 管道布置图"></a>八. Pipeline layout 管道布置图</h1><p>可以在着色器中使用统一的值，类似于可以在绘制时更改的动态状态变量，以更改着色器的行为，而无需重新创建它们。</p>
<p>通常用于将变换矩阵传递给顶点着色器，或在片段着色器中创建纹理采样器。</p>
<p>在创建管道期间，需要通过创建VkPipelineLayout对象来指定这些统一值。创建一个类成员来保存这个对象，稍后会从其他函数中引用它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipelineLayout pipelineLayout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createGraphicsPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;;</span><br><span class="line">    pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;</span><br><span class="line">    pipelineLayoutInfo.setLayoutCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    pipelineLayoutInfo.pSetLayouts = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">    pipelineLayoutInfo.pushConstantRangeCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    pipelineLayoutInfo.pPushConstantRanges = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="literal">nullptr</span>,</span><br><span class="line">            &amp;pipelineLayout) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create pipeline layout!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构还指定了push常量，这是将动态值传递给着色器的另一种方式，我们将在以后的章节中讨论。</p>
<p>管道布局将在整个程序的整个生命周期内被引用，因此在结束时应销毁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="九-小结"><a href="#九-小结" class="headerlink" title="九. 小结"></a>九. 小结</h1><p>所有的固定函数状态都是这样！这是一个很大的工作，以设置所有这些从头开始，但好处是，我们现在几乎完全了解一切正在进行的图形管道！<br>这减少了运行到意外行为的机会，因为某些组件的默认状态不是您所期望的。不过，在我们最终创建图形管道之前，还有一个对象需要创建，那就是渲染过程。</p>
<p>总结一下到目前位为止，创建图形管道应该做的操作:</p>
<ol>
<li>Vertex Input 描述将传递给顶点着色器的顶点数据的格式</li>
<li>Input assembly 描述顶点绘制几何类型</li>
<li>Viewports and scissors 描述将被渲染到的帧缓冲区域</li>
<li>Rasterizer 光栅化配置</li>
<li>Multisampling 配置多重采样</li>
<li>Color blending 配置颜色混合</li>
<li>Pipeline layout 创建管道布置图</li>
</ol>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(7)-渲染过程及创建图形管道</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-7-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Render passes, 即渲染过程。在完成创建管道之前，我们需要告诉Vulkan渲染时将使用的帧缓冲区附件。</p>
<p>我们需要指定将有多少颜色和深度缓冲区，为每个缓冲区使用多少个样本，以及在整个渲染操作中应如何处理它们的内容。</p>
<p>所有这些信息都包装在一个render pass对象中，为其创建一个新的createRenderPass函数。在createGraphicsPipeline之前从initVulkan调用此函数。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="built_in">setupDebugCallback</span>();</span><br><span class="line">    <span class="built_in">createSurface</span>();</span><br><span class="line">    <span class="built_in">pickPhysicalDevice</span>();</span><br><span class="line">    <span class="built_in">createLogicalDevice</span>();</span><br><span class="line">    <span class="built_in">createSwapChain</span>();</span><br><span class="line">    <span class="built_in">createImageViews</span>();</span><br><span class="line">    <span class="built_in">createRenderPass</span>();</span><br><span class="line">    <span class="built_in">createGraphicsPipeline</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createRenderPass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vulkan图形管线和计算管线的区别之一是，你使用图形管线来渲染出像素，组成图像以供处理或显示给用户。在复杂的图形应用程序中，图片经过很多遍构建，每一遍都生成场景的一部分，应用全帧效果如后期处理、合成、渲染用户界面元素等等。这样的一遍可以使用Vulkan 中 renderpass 对象表示。</p>
<p>一个单一的的renderpass对象封装了多个pass或者一系列最终图像的几个渲染阶段，renderpass对象包含输出图像所需的信息。</p>
<p>所有的绘制必须被包含在一个renderpass中。甚至，图形管线需要知道他们把渲染结果发往哪儿，因此，有必要在创建图形管线之前创建一个renderpass对象，告知正在生成图像的管线有关图像的信息。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h1 id="一-Attachment-description-附件说明"><a href="#一-Attachment-description-附件说明" class="headerlink" title="一. Attachment description 附件说明"></a>一. Attachment description 附件说明</h1><p>在这里，我们仅有一个颜色缓冲区附件，由交换链中的一个图像表示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createRenderPass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkAttachmentDescription colorAttachment = &#123;&#125;;</span><br><span class="line">    colorAttachment.format = swapChainImageFormat;</span><br><span class="line">    colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>颜色附件的格式应该与交换链图像的格式匹配，而且我们还没有对多重采样做任何事情，所以只要使用1个样本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</span><br><span class="line">colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;</span><br><span class="line"></span><br><span class="line">colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</span><br><span class="line">colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br></pre></td></tr></table></figure>
<p>loadOp和storeOp决定在呈现之前和呈现之后如何处理附件中的数据。loadOp和storeOp应用于颜色和深度数据，以及stencilLoadOp&#x2F;<br>stencilStoreOp应用于模具数据。这里不会对模板缓冲区执行任何操作，因此加载和存储的结果是无关的。</p>
<h2 id="1-1-loadOp"><a href="#1-1-loadOp" class="headerlink" title="1.1 loadOp"></a>1.1 loadOp</h2><ol>
<li>VK_ATTACHMENT_LOAD_OP_LOAD: 指定将保留渲染区域中图像的先前内容。对于深度&#x2F;模具格式的附件，这将使用访问类型VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ位。对于颜色格式的附件，这将使用访问类型VK_ACCESS_COLOR_ATTACHMENT_READ位。</li>
<li>VK_ATTACHMENT_LOAD_OP_CLEAR: 指定将渲染区域中的内容清除为统一值，该值在渲染过程实例开始时指定。对于深度&#x2F;模板格式的附件，这将使用访问类型VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE位。对于颜色格式的附件，这将使用访问类型VK_ACCESS_COLOR_ATTACHMENT_WRITE位。</li>
<li>VK_ATTACHMENT_LOAD_OP_DONT_CARE: 指定不需要保留区域中的前一个内容；附件的内容将在渲染区域内未定义。对于深度&#x2F;模板格式的附件，这将使用访问类型VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE位。对于颜色格式的附件，这将使用访问类型VK_ACCESS_COLOR_ATTACHMENT_WRITE位。</li>
</ol>
<h2 id="1-2-storeOp"><a href="#1-2-storeOp" class="headerlink" title="1.2 storeOp"></a>1.2 storeOp</h2><ol>
<li>VK_ATTACHMENT_STORE_OP_STORE: 指定在渲染过程中和渲染区域内生成的内容写入内存，以后可以读取</li>
<li>VK_ATTACHMENT_STORE_OP_DONT_CARE: 指定渲染后不需要渲染区域内的内容，这些内容可能会被丢弃；附件的内容将在渲染区域内未定义。</li>
</ol>
<h2 id="1-3-内存中像素的布局"><a href="#1-3-内存中像素的布局" class="headerlink" title="1.3 内存中像素的布局"></a>1.3 内存中像素的布局</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line">colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;</span><br></pre></td></tr></table></figure>
<p>Vulkan中的纹理和帧缓冲区由具有特定像素格式的VkImage对象表示，但是，内存中像素的布局可能会根据您尝试对图像执行的操作而改变。</p>
<p>initialLayout指定在渲染过程开始之前图像将具有的布局。finalLayout最终布局指定渲染过程完成时自动转换到的布局。</p>
<p>对initialLayout使用VK_IMAGE_LAYOUT_UNDEFINED意味着我们不关心图像在以前的布局中是什么。这个特殊值的警告是图像的内容不能保证被保存，但这并不重要，因为我们无论如何都要清除它。<strong>我们希望图像在渲染后可以使用交换链进行显示，这就是为什么我们使用VK_IMAGE_LAYOUT_PRESENT_SRC_KHR作为finalLayout。</strong></p>
<p>一些最常见的布局有：</p>
<ol>
<li>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: 用作颜色附件的图像</li>
<li>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 交换链中要显示的图像</li>
<li>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 要用作内存复制操作目标的图像</li>
</ol>
<p>我们将在“纹理”一章中更深入地讨论这个主题，但现在需要知道的是，图像需要转换到适合其下一步将要涉及的操作的特定布局。</p>
<h1 id="二-Subpasses-and-attachment-references-子过程和附件引用"><a href="#二-Subpasses-and-attachment-references-子过程和附件引用" class="headerlink" title="二. Subpasses and attachment references 子过程和附件引用"></a>二. Subpasses and attachment references 子过程和附件引用</h1><p>单个渲染过程可以由多个子过程组成。子过程是依赖于先前过程中帧缓冲区的内容的后续呈现操作。</p>
<p>例如一系列相继应用的后处理效果。如果将这些渲染操作分组到一个渲染过程中，则Vulkan能够对操作重新排序，并节省内存带宽以获得可能更好的性能。</p>
<p>这里对于一个三角形，使用一个子过程。</p>
<p>每个子过程引用一个或多个附件，这些附件是我们使用前面部分中的结构描述的。这些引用本身就是VKatAttchmentReference结构，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkAttachmentReference colorAttachmentRef = &#123;&#125;;</span><br><span class="line">colorAttachmentRef.attachment = <span class="number">0</span>;</span><br><span class="line">colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;</span><br></pre></td></tr></table></figure>

<ol>
<li>attachment参数通过附件描述数组中的索引指定要引用的附件。我们的数组由一个VkAttachmentDescription组成，所以它的索引是0。</li>
<li>layout指定在使用此引用的子过程期间希望附件具有的布局。当子进程启动时，Vulkan将自动将附件转换到此布局。使用附件作为一个颜色缓冲区，VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL LAYOUT会给我们带来最好的性能，顾名思义。</li>
</ol>
<p>子过程使用VkSubpassDescription结构进行描述：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkSubpassDescription subpass = &#123;&#125;;</span><br><span class="line">subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</span><br><span class="line">subpass.colorAttachmentCount = <span class="number">1</span>;</span><br><span class="line">subpass.pColorAttachments = &amp;colorAttachmentRef; <span class="comment">// 指定对颜色附件的引用</span></span><br></pre></td></tr></table></figure>
<p>Vulkan将来也可能支持计算子过程，所以我们必须明确表示这是一个图形子过程。<br>此数组中附件的索引直接从具有layout（location&#x3D;0）out vec4 outColor指令的片段着色器引用！</p>
<p>子过程可以引用以下类型的附件：</p>
<ol>
<li>pColorAttachments: 颜色附件</li>
<li>pInputAttachments: 从着色器读取的附件</li>
<li>pResolveAttachments: 用于多重采样颜色附件的附件</li>
<li>pDepthStencilAttachment: 深度和模板数据附件</li>
<li>pPreserveAttachments: 此子过程未使用但必须保留数据的附件</li>
</ol>
<h1 id="三-Render-pass-渲染过程"><a href="#三-Render-pass-渲染过程" class="headerlink" title="三. Render pass 渲染过程"></a>三. Render pass 渲染过程</h1><p>上面已经描述了附件和引用它的基本子过程，我们就可以创建渲染过程本身了。</p>
<p>渲染过程表示附件、子过程和子过程之间的依赖关系的集合，并描述如何在子过程中使用附件。</p>
<p>创建一个新的类成员变量，将VkRenderPass对象保持在pipelineLayout变量的正上方：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkRenderPass renderPass;</span><br><span class="line">VkPipelineLayout pipelineLayout;</span><br></pre></td></tr></table></figure>
<p>可以通过使用附件和子过程数组填充VkRenderPassCreateInfo结构来创建渲染过程对象。VkAttachmentReference对象使用此数组的索引引用附件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建渲染过程</span></span><br><span class="line">VkRenderPassCreateInfo renderPassInfo = &#123;&#125;;</span><br><span class="line">renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;</span><br><span class="line">renderPassInfo.attachmentCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pAttachments = &amp;colorAttachment;</span><br><span class="line">renderPassInfo.subpassCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pSubpasses = &amp;subpass;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateRenderPass</span>(device, &amp;renderPassInfo, <span class="literal">nullptr</span>, &amp;renderPass) != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create render pass!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与管道布局一样，渲染过程将在整个程序中被引用，因此只应在结束时进行清理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyRenderPass</span>(device, renderPass, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前我们以及做了很多工作了，下一步就是创建图形管道对象了！</p>
<h1 id="四-创建-pipeline"><a href="#四-创建-pipeline" class="headerlink" title="四. 创建 pipeline"></a>四. 创建 pipeline</h1><p>快速回顾现在拥有的对象类型：</p>
<ol>
<li>shader stages: 定义图形管道可编程阶段功能的着色器模块</li>
<li>Fixed-function state: 定义管道固定函数阶段的所有结构，如输入程序集、光栅化器、视口和颜色混合</li>
<li>Pipeline layout: 可在绘制时更新的着色器引用的统一值和推送值</li>
<li>Render pass: 管道阶段引用的附件及其用法</li>
</ol>
<p>所有这些组合都充分定义了图形管道的功能，因此现在可以开始在createGraphicsPipeline函数末尾填充VkGraphicsPipelineCreateInfo结构。<br>但是是在调用vkDestroyShaderModule之前，因为在创建过程中使用仍然需要使用这些着色器！</p>
<p>VkGraphicsPipelineCreateInfo结构包括一个shader-reate-info结构数组，其中包含所有所需的活动着色器阶段、定义所有相关固定函数阶段的创建信息以及管道布局。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkGraphicsPipelineCreateInfo pipelineInfo = &#123;&#125;;</span><br><span class="line">pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;</span><br><span class="line">pipelineInfo.stageCount = <span class="number">2</span>;</span><br><span class="line">pipelineInfo.pStages = shaderStages;</span><br><span class="line"><span class="comment">// 首先引用VkPipelineShaderStageCreateInfo结构的数组。</span></span><br><span class="line">pipelineInfo.pVertexInputState = &amp;vertexInputInfo;</span><br><span class="line">pipelineInfo.pInputAssemblyState = &amp;inputAssembly;</span><br><span class="line">pipelineInfo.pViewportState = &amp;viewportState;</span><br><span class="line">pipelineInfo.pRasterizationState = &amp;rasterizer;</span><br><span class="line">pipelineInfo.pMultisampleState = &amp;multisampling;</span><br><span class="line">pipelineInfo.pDepthStencilState = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.pColorBlendState = &amp;colorBlending;</span><br><span class="line">pipelineInfo.pDynamicState = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"><span class="comment">// 然后引用所有描述固定函数阶段的结构。</span></span><br><span class="line">pipelineInfo.layout = pipelineLayout;</span><br><span class="line"><span class="comment">// 之后是管道布局，它是一个Vulkan句柄而不是结构指针。</span></span><br><span class="line">pipelineInfo.renderPass = renderPass;</span><br><span class="line">pipelineInfo.subpass = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>最后，我们有了渲染过程的引用以及使用这个图形管道的子过程的索引。也可以将其他渲染过程用于此管道而不是此特定实例，但它们必须与renderPass兼容。下面描述了兼容性的要求，但这里不使用该特性。</p>
<p>实际上还有两个参数：basePipelineHandle和basePipelineIndex。</p>
<p>Vulkan允许通过从现有管道派生来创建新的图形管道。管道衍生品的想法是，当管道具有与现有管道具有许多相同功能时，设置管道成本更低，并且可以更快地在同一父管道之间切换。<br>可以指定现有管道的句柄（带有basePipelineHandle），也可以引用另一个将由basePipelineIndex的索引创建的管道。</p>
<p>现在只有一个管道，所以只需要指定一个null句柄和一个无效的索引。只有在VkGraphicsPipelineCreateInfo的flags字段中指定VK_PIPELINE_CREATE_UBIT标志时，才使用这些值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.basePipelineIndex = <span class="number">-1</span>; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure>

<p>通过创建一个类成员来保存VkPipeline对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPipeline graphicsPipeline;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建图形管道</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateGraphicsPipelines</span>(device, VK_NULL_HANDLE, <span class="number">1</span>,</span><br><span class="line">        &amp;pipelineInfo, <span class="literal">nullptr</span>, &amp;graphicsPipeline) != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create graphics pipeline!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vkCreateGraphicsPipelines实际上比Vulkan中常用的对象创建函数有更多的参数。<br>它的设计是支持在一次调用中获取多个VkGraphicsPipelineCreateInfo对象并创建多个VkPipeline对象。</p>
<p>第二个参数（我们为其传递了VK_NULL_HANDLE参数）引用了一个可选的VkPipelineCache对象。管道缓存可用于在对vkCreateGraphicsPipelines的多个调用中存储和重用与管道创建相关的数据，如果缓存存储到文件中，甚至可以跨程序执行。这使得以后可以大大加快管道的创建速度。我们将在管道缓存中讨论这个问题。</p>
<p>所有常见的绘图操作都需要图形管道，因此也只能在程序结束时销毁：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vkDestroyPipeline</span>(device, graphicsPipeline, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行程序来确认所有这些艰苦的工作已经成功地创建了管道！我们已经非常接近看到屏幕上弹出一些东西(实际现在还没有看到任何东西，黑乎乎一片)。</p>
<p>接下来将从交换链图像设置实际的帧缓冲区，并准备绘图命令。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(8)-帧缓冲区和指令缓冲区</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Framebuffers, 帧缓冲区。之前我们在学习’Swap Chain-交换链’时提到Vulkan没有“默认帧缓冲区”的概念，取而代之的是名为 “swap chain” 即交换链，也就是渲染的缓冲区，必须在Vulkan中明确创建。 现在我们已经设置了渲染过程，以期望使用与交换链图像相同格式的单个帧缓冲区，但实际上我们还没有创建任何帧缓冲区。</p>
<p>通过将渲染过程创建期间指定的附件包装到VkFramebuffer对象中来绑定附件。</p>
<p>帧缓冲区对象引用表示附件的所有VkImageView对象。在我们的情况下，这将只是一个单一的：颜色附件。但是，我们必须用于附件的图像取决于在检索用于表示的图像时交换链返回的图像。这意味着我们必须为交换链中的所有图像创建一个帧缓冲区，并使用与绘制时检索到的图像相对应的帧缓冲区。</p>
<span id="more"></span>

<h1 id="一-VkFramebuffer-创建帧缓冲区"><a href="#一-VkFramebuffer-创建帧缓冲区" class="headerlink" title="一. VkFramebuffer 创建帧缓冲区"></a>一. VkFramebuffer 创建帧缓冲区</h1><p>帧缓冲区由VkFramebuffer句柄表示： VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkFramebuffer)</p>
<p>通过调用vkCreateFramebuffer来创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateFramebuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkFramebufferCreateInfo*              pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFramebuffer*                              pFramebuffer)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建帧缓冲区的逻辑设备</li>
<li>pCreateInfo: 指向VkFramebufferCreateInfo结构，该结构描述有关帧缓冲区创建的附加信息。</li>
<li>pAllocator: 控制主机内存分配</li>
<li>pFramebuffer: 指向返回结果帧缓冲区对象的VkFramebuffer句柄。</li>
</ol>
<p>我们创建一个VkFramebuffer的集合来保存所有帧缓冲:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;VkFramebuffer&gt; swapChainFramebuffers;</span><br></pre></td></tr></table></figure>

<p>在一个新函数createFramebuffers中为该数组创建对象，该函数在创建图形管道之后立即从initVulkan调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="built_in">setupDebugCallback</span>();</span><br><span class="line">    <span class="built_in">createSurface</span>();</span><br><span class="line">    <span class="built_in">pickPhysicalDevice</span>();</span><br><span class="line">    <span class="built_in">createLogicalDevice</span>();</span><br><span class="line">    <span class="built_in">createSwapChain</span>();</span><br><span class="line">    <span class="built_in">createImageViews</span>();</span><br><span class="line">    <span class="built_in">createRenderPass</span>();</span><br><span class="line">    <span class="built_in">createGraphicsPipeline</span>();</span><br><span class="line">    <span class="built_in">createFramebuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在createFramebuffers最开始，调整帧缓冲区容器的大小以容纳所有交换链图像视图, 然后遍历图像视图并从它们创建帧缓冲区：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createFramebuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    swapChainFramebuffers.<span class="built_in">resize</span>(swapChainImageViews.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImageViews.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        VkImageView attachments[] = &#123;</span><br><span class="line">        swapChainImageViews[i]</span><br><span class="line">    &#125;;</span><br><span class="line">    VkFramebufferCreateInfo framebufferInfo = &#123;&#125;;</span><br><span class="line">    framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;</span><br><span class="line">    framebufferInfo.renderPass = renderPass;</span><br><span class="line">    framebufferInfo.attachmentCount = <span class="number">1</span>;</span><br><span class="line">    framebufferInfo.pAttachments = attachments;</span><br><span class="line">    framebufferInfo.width = swapChainExtent.width;</span><br><span class="line">    framebufferInfo.height = swapChainExtent.height;</span><br><span class="line">    framebufferInfo.layers = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateFramebuffer</span>(device, &amp;framebufferInfo, <span class="literal">nullptr</span>,</span><br><span class="line">            &amp;swapChainFramebuffers[i]) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create framebuffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，帧缓冲区的创建非常简单:</p>
<ol>
<li>首先需要指定帧缓冲区需要与哪个renderPass兼容。只能对与之兼容的渲染过程使用帧缓冲区，这意味着它们使用相同数量和类型的附件。</li>
<li>attachmentCount和pAttachments参数指定应绑定到渲染过程pAttachment数组中相应附件描述的VkImageView对象。</li>
<li>宽度和高度参数是交换链中获取的宽高</li>
<li>layers是指图像数组中的层数。我们的交换链图像是单个图像，因此层的数量是1。</li>
</ol>
<p>我们应该先删除帧缓冲区，然后再删除它们所基于的图像视图和渲染过程，但必须在完成渲染之后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> framebuffer : swapChainFramebuffers) &#123;</span><br><span class="line">        <span class="built_in">vkDestroyFramebuffer</span>(device, framebuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经到达了一个里程碑–拥有了渲染所需的所有对象。接下来，我们将编写第一个实际的绘图指令。</p>
<h1 id="二-Command-buffers-指令缓冲区"><a href="#二-Command-buffers-指令缓冲区" class="headerlink" title="二. Command buffers 指令缓冲区"></a>二. Command buffers 指令缓冲区</h1><p>Vulkan中的指令，比如绘图操作和内存传输，不是直接使用函数调用来执行的。必须在指令缓冲区对象中记录想要执行的所有操作。这样做的好处是，所有设置绘图指令的工作都可以提前在多个线程中完成。之后，只需告诉Vulkan在主循环中执行指令。</p>
<p>指令缓冲区是用来记录指令的对象，这些指令可以随后提交到设备队列中执行。指令缓冲区有两级:一级指令缓冲区，它可以执行二级指令缓冲区，并提交给队列;二级指令缓冲区，它可以由一级指令缓冲区执行，但不直接提交给队列。</p>
<h2 id="2-1-Command-pools-指令池"><a href="#2-1-Command-pools-指令池" class="headerlink" title="2.1 Command pools 指令池"></a>2.1 Command pools 指令池</h2><p>在创建指令缓冲区之前必须先创建指令池。指令池管理用于存储缓冲区的内存，并从它们中分配指令缓冲区。</p>
<p>指令池通过允许不同的线程使用不同的分配器来提高多线程性能，而不需要每次使用都进行内部同步。</p>
<p>由VkCommandPool对象表示： VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCommandPool)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkCommandPool commandPool;</span><br></pre></td></tr></table></figure>

<p>创建指令池函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateCommandPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCommandPoolCreateInfo*              pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandPool*                              pCommandPool)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建指令池的逻辑设备</li>
<li>pCreateInfo: 一个指向VkCommandPoolCreateInfo结构实例的指针，该结构指定指令池对象的状态。</li>
<li>pAllocator: 控制内存分配</li>
<li>pCommandPool: 指向一个VkCommandPool句柄，创建的池返回该句柄。</li>
</ol>
<h3 id="2-1-1-创建指令池"><a href="#2-1-1-创建指令池" class="headerlink" title="2.1.1 创建指令池"></a>2.1.1 创建指令池</h3><p>我们创建一个新的函数：createCommandPool, 来执行创建指令池：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// checkAvailableExtensions();</span></span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="comment">// 创建DEBUG消息回调</span></span><br><span class="line">    <span class="built_in">setupDebugMessenger</span>();</span><br><span class="line">    <span class="comment">// 创建surface</span></span><br><span class="line">    <span class="built_in">createSurface</span>();</span><br><span class="line">    <span class="comment">// 选择物理设备</span></span><br><span class="line">    <span class="built_in">pickPhysicalDevice</span>();</span><br><span class="line">    <span class="comment">// 创建逻辑设备</span></span><br><span class="line">    <span class="built_in">createLogicalDevice</span>();</span><br><span class="line">    <span class="comment">// 创建交换链</span></span><br><span class="line">    <span class="built_in">createSwapChain</span>();</span><br><span class="line">    <span class="comment">// 创建交换链图像的VkImageView</span></span><br><span class="line">    <span class="built_in">createImageViews</span>();</span><br><span class="line">    <span class="comment">// 创建渲染通道</span></span><br><span class="line">    <span class="built_in">createRenderPass</span>();</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="built_in">createGraphicsPipeline</span>();</span><br><span class="line">    <span class="comment">// 创建帧缓冲区</span></span><br><span class="line">    <span class="built_in">createFramebuffers</span>();</span><br><span class="line">    <span class="comment">// 创建指令缓冲池</span></span><br><span class="line">    <span class="built_in">createCommandPool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createCommandPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QueueFamilyIndices queueFamilyIndices = <span class="built_in">findQueueFamilies</span>(physicalDevice);</span><br><span class="line">    VkCommandPoolCreateInfo poolInfo = &#123;&#125;;</span><br><span class="line">    poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</span><br><span class="line">    poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.<span class="built_in">value</span>();</span><br><span class="line">    poolInfo.flags = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateCommandPool</span>(device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;commandPool) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create command pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指令缓冲区是通过将它们提交到设备队列(比如我们检索到的图形和展示队列)上来执行的。</p>
<p>每个指令池只能分配提交到单一类型队列上的指令缓冲区。我们将记录绘图的指令，这就是我们选择图形队列家族的原因。</p>
<h3 id="2-1-2-VkCommandPoolCreateInfo"><a href="#2-1-2-VkCommandPoolCreateInfo" class="headerlink" title="2.1.2 VkCommandPoolCreateInfo"></a>2.1.2 VkCommandPoolCreateInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandPoolCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType             sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                 pNext;</span><br><span class="line">    VkCommandPoolCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                    queueFamilyIndex;</span><br><span class="line">&#125; VkCommandPoolCreateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 此结构的类型，VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</li>
<li>pNext: 为空或指向特定于扩展的结构的指针。</li>
<li>flags: 是VkCommandPoolCreateFlagBits的位掩码, 指示指令池和从中分配的指令缓冲区的使用行为。</li>
<li>queueFamilyIndex: 指定队列族。从这个指令池分配的所有指令缓冲区必须在来自相同队列族的队列上提交。</li>
</ol>
<h3 id="2-1-3-VkCommandPoolCreateFlags"><a href="#2-1-3-VkCommandPoolCreateFlags" class="headerlink" title="2.1.3 VkCommandPoolCreateFlags"></a>2.1.3 VkCommandPoolCreateFlags</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkCommandPoolCreateFlagBits</span> &#123;</span><br><span class="line">    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkCommandPoolCreateFlagBits;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_COMMAND_POOL_CREATE_TRANSIENT_BIT:指定从池中分配的指令缓冲区将是短暂的，这意味着它们将在相对较短的时间内被重置或释放。这个标志可以被实现用来控制池内的内存分配行为。</li>
<li>VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT:允许从池中分配的任何指令缓冲区被单独重置到初始状态;或者通过调用vkResetCommandBuffer，或者在调用vkBeginCommandBuffer时通过隐式重置。如果在池中没有设置这个标志，那么vkResetCommandBuffer绝对不能被从池中分配的任何指令缓冲区调用。</li>
<li>VK_COMMAND_POOL_CREATE_PROTECTED_BIT:指定从池中分配的指令缓冲区为受保护的指令缓冲区。如果未启用受保护的内存特性，则不能设置VK_COMMAND_POOL_CREATE_PROTECTED_BIT标志位。</li>
</ol>
<p>鉴于我们将只在程序开始时记录指令缓冲区，然后在主循环中多次执行它们，因此我们不会使用这这些标志。</p>
<h3 id="2-1-4-vkDestroyCommandPool"><a href="#2-1-4-vkDestroyCommandPool" class="headerlink" title="2.1.4 vkDestroyCommandPool"></a>2.1.4 vkDestroyCommandPool</h3><p>使用vkCreateCommandPool功能完成指令池的创建，指令将在整个程序中使用来绘制屏幕上的东西，所以池应该只在结束时销毁:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放指令池</span></span><br><span class="line">    <span class="built_in">vkDestroyCommandPool</span>(device, commandPool, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Command-buffer-allocation-指令缓冲区分配"><a href="#2-2-Command-buffer-allocation-指令缓冲区分配" class="headerlink" title="2.2 Command buffer allocation 指令缓冲区分配"></a>2.2 Command buffer allocation 指令缓冲区分配</h2><p>现在我们可以开始分配指令缓冲区并在其中记录绘图指令。因为其中一个绘图指令涉及到绑定正确的VkFramebuffer，所以我们实际上必须再次为交换链中的每个图像记录一个指令缓冲区。</p>
<p>为此，创建一个VkCommandBuffer对象列表作为类成员。当它们的指令池被销毁时，指令缓冲区将被自动释放，所以我们不需要显式的清理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;VkCommandBuffer&gt; commandBuffers;</span><br></pre></td></tr></table></figure>
<p>现在开始使用createCommandBuffers函数，为每个交换链图像(VkImageView)分配和记录指令。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createCommandBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commandBuffers.<span class="built_in">resize</span>(swapChainFramebuffers.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-vkAllocateCommandBuffers"><a href="#2-2-1-vkAllocateCommandBuffers" class="headerlink" title="2.2.1 vkAllocateCommandBuffers"></a>2.2.1 vkAllocateCommandBuffers</h3><p>指令缓冲区是通过vkAllocateCommandBuffers函数分配的，该函数以VkCommandBufferAllocateInfo结构体作为参数，指定指令池和要分配的缓冲区数量:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateCommandBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCommandBufferAllocateInfo*          pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer*                            pCommandBuffers)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 指令池所属的逻辑设备。</li>
<li>pAllocateInfo: 指向VkCommandBufferAllocateInfo结构实例的指针，该结构描述了分配的参数。</li>
<li>pCommandBuffers: 指向VkCommandBuffer句柄数组的指针，在该数组中返回生成的指令缓冲区对象。数组必须至少为pAllocateInfo的commandBufferCount成员指定的长度commandBufferCount。每个分配的指令缓冲区都从初始状态开始。(就是commandBuffers集的首个元素的地址)</li>
</ol>
<h3 id="2-2-2-VkCommandBufferAllocateInfo"><a href="#2-2-2-VkCommandBufferAllocateInfo" class="headerlink" title="2.2.2 VkCommandBufferAllocateInfo"></a>2.2.2 VkCommandBufferAllocateInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType         sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*             pNext;</span><br><span class="line">    VkCommandPool           commandPool;</span><br><span class="line">    VkCommandBufferLevel    level;</span><br><span class="line">    <span class="type">uint32_t</span>                commandBufferCount;</span><br><span class="line">&#125; VkCommandBufferAllocateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 结构体类型</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>commandPool: 分配此指令缓冲区的指令池</li>
<li>level: VkCommandBufferLevel值，指定指令缓冲区级别</li>
<li>commandBufferCount: 从池中分配的指令缓冲区的数量</li>
</ol>
<p>VkCommandBufferLevel, 指定指令缓冲区级别:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkCommandBufferLevel</span> &#123;</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_PRIMARY = <span class="number">0</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_SECONDARY = <span class="number">1</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkCommandBufferLevel;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_COMMAND_BUFFER_LEVEL_PRIMARY:指定主指令缓冲区，可以提交到队列执行，但不能从其他指令缓冲区调用。</li>
<li>VK_COMMAND_BUFFER_LEVEL_SECONDARY:指定次要指令缓冲区，不能直接提交，但可以从主指令缓冲区调用。</li>
</ol>
<h3 id="2-2-3-createCommandBuffers"><a href="#2-2-3-createCommandBuffers" class="headerlink" title="2.2.3 createCommandBuffers"></a>2.2.3 createCommandBuffers</h3><p>接下来就是完成指令缓冲区集的创建：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createCommandBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commandBuffers.<span class="built_in">resize</span>(swapChainFramebuffers.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.commandPool = commandPool;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandBufferCount = (<span class="type">uint32_t</span>) commandBuffers.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, commandBuffers.<span class="built_in">data</span>()) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate command buffers!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里不使用辅助指令缓冲区功能，但是可以想象，重用来自主要指令缓冲区的常用操作是很有帮助的</p>
<h2 id="2-3-启动指令缓冲区记录"><a href="#2-3-启动指令缓冲区记录" class="headerlink" title="2.3 启动指令缓冲区记录"></a>2.3 启动指令缓冲区记录</h2><p>记录的指令包括将管道和描述符集绑定到指令缓冲区的指令、修改动态状态的指令、绘制指令(用于图形渲染)、调度指令(用于计算)、执行次要指令缓冲区的指令(仅用于主要指令缓冲区)、复制缓冲区和图像的指令，以及其他指令。</p>
<p>为什么需要记录指令？ 先看一下指令缓冲区的生命周期。</p>
<h3 id="2-3-1-指令缓冲区的生命周期"><a href="#2-3-1-指令缓冲区的生命周期" class="headerlink" title="2.3.1 指令缓冲区的生命周期"></a>2.3.1 指令缓冲区的生命周期</h3><p>每个指令缓冲区总是处于以下状态之一:</p>
<ol>
<li>Initial(初始状态): 当一个指令缓冲区被分配时，它处于初始状态。一些指令能够将一个指令缓冲区或一组指令缓冲区从任何可执行状态、记录状态或无效状态重置回该状态。处于初始状态的指令缓冲区只能移动到记录状态或释放。</li>
<li>Recording(记录状态): vkBeginCommandBuffer改变指令缓冲区的状态从初始状态到记录状态。一旦指令缓冲区处于记录状态，可以使用vkCmd*指令记录到指令缓冲区。</li>
<li>Executable(可执行状态): vkEndCommandBuffer结束指令缓冲区的记录，并将其从记录状态移动到可执行状态。可执行指令缓冲区可以提交、重置或记录到另一个指令缓冲区。</li>
<li>Pending(挂起状态): 指令缓冲区的队列提交将指令缓冲区的状态从可执行状态更改为挂起状态。在挂起状态下，应用程序不能试图以任何方式修改指令缓冲区-因为设备可能正在处理记录到它的指令。一旦指令缓冲区的执行完成，指令缓冲区将返回到可执行状态，或者返回无效状态(如果它是通过VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT记录的)。应该使用一个同步指令来检测何时发生这种情况。</li>
<li>Invalid(无效状态):某些操作，如修改或删除记录到指令缓冲区的指令中使用的资源，将把该指令缓冲区的状态转换为无效状态。处于无效状态的指令缓冲区只能被重置或释放。</li>
</ol>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-8-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E6%8C%87%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/Vulkan_8_1.png" alt="生命周期"></p>
<p>所以记录状态可以理解为记录绘制操作，然后记录完毕就转为可执行状态，等待被执行。</p>
<h3 id="2-3-2-记录指令缓冲区"><a href="#2-3-2-记录指令缓冲区" class="headerlink" title="2.3.2 记录指令缓冲区"></a>2.3.2 记录指令缓冲区</h3><p>通过调用vkBeginCommandBuffer开始记录指令缓冲区，并使用一个小的VkCommandBufferBeginInfo结构作为参数，指定关于这个特定指令缓冲区使用的一些细节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkBeginCommandBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCommandBufferBeginInfo*             pBeginInfo)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer: 待放入记录状态的指令缓冲区的句柄。</li>
<li>pBeginInfo: VkCommandBufferBeginInfo结构的一个实例，它定义了关于指令缓冲区如何开始记录的附加信息。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkCommandBufferBeginInfo</span> &#123;</span><br><span class="line">    VkStructureType                          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                              pNext;</span><br><span class="line">    VkCommandBufferUsageFlags                flags;</span><br><span class="line">    <span class="type">const</span> VkCommandBufferInheritanceInfo*    pInheritanceInfo;</span><br><span class="line">&#125; VkCommandBufferBeginInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 结构体类型</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>flags: 是VkCommandBufferUsageFlagBits的位掩码，指定命令缓冲区的使用行为。</li>
<li>pInheritanceInfo: 是一个指向VkCommandBufferInheritanceInfo结构的指针，如果commandBuffer是一个次要命令缓冲区，就会使用这个结构。如果这是一个主命令缓冲区，那么这个值将被忽略。</li>
</ol>
<p>在VkCommandBufferBeginInfo::flags中设置位来指定命令缓冲区的使用行为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkCommandBufferUsageFlagBits</span> &#123;</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkCommandBufferUsageFlagBits;</span><br></pre></td></tr></table></figure>
<ol>
<li>VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:指定命令缓冲区的每个记录将只提交一次，命令缓冲区将被重置并在每次提交之间再次记录。</li>
<li>VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT:指定次要命令缓冲区被认为完全位于渲染通道内。如果这是一个主命令缓冲区，那么这个位会被忽略。</li>
<li>VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:指定当命令缓冲区处于挂起状态时，可以重新提交给队列，并记录到多个主要命令缓冲区中。</li>
</ol>
<p>开始指令缓冲区记录:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; commandBuffers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    VkCommandBufferBeginInfo beginInfo = &#123;&#125;;</span><br><span class="line">    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">    <span class="comment">// 标记该指令缓冲区可重复追加指令</span></span><br><span class="line">    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;</span><br><span class="line">    beginInfo.pInheritanceInfo = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkBeginCommandBuffer</span>(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to begin recording command buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT标志是因为我们可能已经在为下一帧调度绘图命令，而最后一帧还没有完成。pInheritanceInfo参数仅与辅助命令缓冲区相关。它指定从调用的主命令缓冲区继承哪个状态。</p>
<p>如果命令缓冲区已经被记录过一次，那么调用vkBeginCommandBuffer将隐式重置它。以后不可能向缓冲区追加命令。</p>
<h2 id="2-4-启动渲染通道"><a href="#2-4-启动渲染通道" class="headerlink" title="2.4 启动渲染通道"></a>2.4 启动渲染通道</h2><p>通过vkCmdBeginRenderPass开始绘制。渲染通道是使用VkRenderPassBeginInfo结构中的一些参数来配置的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBeginRenderPass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkRenderPassBeginInfo*                pRenderPassBegin,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSubpassContents                           contents)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer: 指令缓冲区</li>
<li>VkRenderPassBeginInfo: 是一个指向VkRenderPassBeginInfo结构的指针，提供的渲染通道的详细信息</li>
<li>contents: 是一个VkSubpassContents值，控制渲染通道内的绘图命令将如何提供,可以有两个值:<ol>
<li>VK_SUBPASS_CONTENTS_INLINE:render pass命令将被嵌入到主命令缓冲区中，而不会执行次要命令缓冲区。</li>
<li>VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS:render pass命令将从次要命令缓冲区执行。</li>
</ol>
</li>
</ol>
<p>在开始渲染通道实例之后，命令缓冲区准备好记录该渲染通道的第一个子通道的命令。</p>
<h3 id="2-4-1-VkRenderPassBeginInfo"><a href="#2-4-1-VkRenderPassBeginInfo" class="headerlink" title="2.4.1 VkRenderPassBeginInfo"></a>2.4.1 VkRenderPassBeginInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkRenderPassBeginInfo</span> &#123;</span><br><span class="line">    VkStructureType        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*            pNext;</span><br><span class="line">    VkRenderPass           renderPass;</span><br><span class="line">    VkFramebuffer          framebuffer;</span><br><span class="line">    VkRect2D               renderArea;</span><br><span class="line">    <span class="type">uint32_t</span>               clearValueCount;</span><br><span class="line">    <span class="type">const</span> VkClearValue*    pClearValues;</span><br><span class="line">&#125; VkRenderPassBeginInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 结构体类型</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>renderPass: 渲染通道</li>
<li>framebuffer: 指令缓冲区</li>
<li>renderArea: 渲染通道实例影响的渲染区域</li>
<li>clearValueCount: pClearValues中的元素数量</li>
<li>pClearValues: 是一个VkClearValue结构的数组，它包含每个附件的清除值，如果附件使用的loadOp值是VK_ATTACHMENT_LOAD_OP_CLEAR，或者附件具有深度&#x2F;模板格式并使用的stencilLoadOp值是VK_ATTACHMENT_LOAD_OP_CLEAR。数组按附件号索引。只使用与已清除附件对应的元素。pClearValues的其他元素将被忽略。</li>
</ol>
<p>renderArea渲染区域是受渲染通道实例影响的渲染区域。附件加载、存储和多样本解析操作的影响仅限于x和y坐标落在所有附件渲染区域内的像素。渲染区域扩展到framebuffer的所有层。应用程序必须确保(必要时使用scissor)所有的渲染都包含在渲染区域内。渲染区域必须包含在framebuffer尺寸内。</p>
<h3 id="2-4-2-start-a-Render-Pass"><a href="#2-4-2-start-a-Render-Pass" class="headerlink" title="2.4.2 start a Render Pass"></a>2.4.2 start a Render Pass</h3><p>应用程序一次记录一个render pass实例的命令，方法是开始一个render pass实例，遍历子通道(subpass)来记录该子通道的命令，然后结束render pass实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkRenderPassBeginInfo renderPassInfo = &#123;&#125;;</span><br><span class="line">renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;</span><br><span class="line"><span class="comment">// 渲染通道本身和要绑定的附件</span></span><br><span class="line">renderPassInfo.renderPass = renderPass;</span><br><span class="line"><span class="comment">// 每个交换链图像创建了一个framebuffer，将其指定为颜色附件。</span></span><br><span class="line">renderPassInfo.framebuffer = swapChainFramebuffers[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染区域定义着色器加载和存储的位置。该区域之外的像素将具有未定义的值。它应该与附件的大小相匹配，以获得最佳性能。</span></span><br><span class="line">renderPassInfo.renderArea.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">renderPassInfo.renderArea.extent = swapChainExtent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用于VK_ATTACHMENT_LOAD_OP_CLEAR的清除值，我们将其用作颜色附件的加载操作。将透明颜色定义为100%不透明度的黑色。</span></span><br><span class="line">VkClearValue clearColor = &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;;</span><br><span class="line">renderPassInfo.clearValueCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pClearValues = &amp;clearColor;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-基本绘制指令"><a href="#2-4-3-基本绘制指令" class="headerlink" title="2.4.3 基本绘制指令"></a>2.4.3 基本绘制指令</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染通道现在可以开始了。所有记录命令的函数都可以通过它们的vkCmd前缀来识别。它们都返回void，所以在完成记录之前不会有错误处理。</span></span><br><span class="line"><span class="built_in">vkCmdBeginRenderPass</span>(commandBuffers[i], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line"><span class="built_in">vkCmdBindPipeline</span>(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);</span><br><span class="line"><span class="built_in">vkCmdDraw</span>(commandBuffers[i], <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vkCmdEndRenderPass</span>(commandBuffers[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkEndCommandBuffer</span>(commandBuffers[i]) != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to record command buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-1-vkCmdBindPipeline"><a href="#2-4-3-1-vkCmdBindPipeline" class="headerlink" title="2.4.3.1 vkCmdBindPipeline"></a>2.4.3.1 vkCmdBindPipeline</h4><p>管道被创建后，可以使用以下命令将其绑定到指令缓冲区:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindPipeline</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineBindPoint                         pipelineBindPoint,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipeline                                  pipeline)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer: 是即将绑定到管道的命令缓冲区</li>
<li>pipelineBindPoint:是一个VkPipelineBindPoint值，指定管道对象是图形管道还是计算管道。<ol>
<li>VK_PIPELINE_BIND_POINT_COMPUTE: 管道控制vkCmdDispatch和vkCmdDispatchIndirect的行为。</li>
<li>VK_PIPELINE_BIND_POINT_GRAPHICS: 管道控制所有绘制命令的行为。其他命令不受管道状态的影响。</li>
</ol>
</li>
<li>pipeline: 即将绑定的管道</li>
</ol>
<p>一旦绑定，管道绑定将影响命令缓冲区中的后续图形或计算命令，直到另一个管道绑定到绑定点。</p>
<h4 id="2-4-3-2-vkCmdDraw"><a href="#2-4-3-2-vkCmdDraw" class="headerlink" title="2.4.3.2 vkCmdDraw"></a>2.4.3.2 vkCmdDraw</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDraw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    vertexCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    instanceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstVertex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstInstance)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>commandBuffer: 绘制指令记录到的指令缓冲区</li>
<li>vertexCount: 要绘制的顶点数</li>
<li>instanceCount: 要绘制的实例数</li>
<li>firstVertex: 要绘制的第一个顶点的索引</li>
<li>firstInstance: 要绘制的第一个实例的索引</li>
</ol>
<p>当执行该命令时，将使用当前基元拓扑和vertexCount连续顶点索引(第一个vertexIndex值等于firstVertex)组装基元。这些原语是用从firstInstance开始的instanceIndex绘制的instanceCount时间，并按顺序增加每个实例。组装的原语执行绑定的图形管道。</p>
<h4 id="2-4-3-3-vkCmdEndRenderPass"><a href="#2-4-3-3-vkCmdEndRenderPass" class="headerlink" title="2.4.3.3 vkCmdEndRenderPass"></a>2.4.3.3 vkCmdEndRenderPass</h4><p>在记录了最后一个子过程的指令之后，结束渲染通道实例调用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdEndRenderPass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer)</span></span>;</span><br></pre></td></tr></table></figure>
<p>结束渲染通道实例在最终子通道上执行一切多样本解析操作。</p>
<h4 id="2-4-3-4-vkEndCommandBuffer"><a href="#2-4-3-4-vkEndCommandBuffer" class="headerlink" title="2.4.3.4 vkEndCommandBuffer"></a>2.4.3.4 vkEndCommandBuffer</h4><p>一旦开始记录，应用程序将记录指令序列(vkCmd*)，以在指令缓冲区、绘制、调度和其他指令中设置状态。调用完成vkEndCommandBuffer命令缓冲区的记录:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkEndCommandBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果在记录过程中发生了错误，vkEndCommandBuffer将返回一个不成功的返回码来通知应用程序。</p>
<p>如果应用程序希望进一步使用指令缓冲区，则必须重置指令缓冲区。指令缓冲区必须处于记录状态，并被移动到可执行状态。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(1)-服务启动和Activity窗口回顾</title>
    <url>/2022/05/01/WMS(1)-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%92%8CActivity%E7%AA%97%E5%8F%A3%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>


<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>之前我们通过Vsync这个Android绘制的脉搏疏通了绘制的流程，在Activity的显示研究过程中，粗略接触了WindowManagerService，也即Android的窗口管理。</p>
<p>接下来我们深入探讨一下Android中的窗口管理设计，以便我们理解View、Activity、Window、Task等之间的关系。</p>
<p>首先还是从WindowManagerService服务的启动开始，在Android开机流程中，我们知道WMS是在引导服务和核心服务启动之后才会开始的:</p>
<span id="more"></span>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    t.traceBegin(<span class="string">&quot;StartWindowManagerService&quot;</span>);</span><br><span class="line">    <span class="comment">// WMS needs sensor service ready</span></span><br><span class="line">    ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">    mSensorServiceStart = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1.1 WMS的初始化</span></span><br><span class="line">    wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PhoneWindowManager</span>(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">    <span class="comment">// 发布WMS</span></span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm, <span class="comment">/* allowIsolated= */</span> <span class="literal">false</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">            <span class="comment">/* allowIsolated= */</span> <span class="literal">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    t.traceBegin(<span class="string">&quot;SetWindowManagerService&quot;</span>);</span><br><span class="line">    mActivityManagerService.setWindowManager(wm);</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    t.traceBegin(<span class="string">&quot;WindowManagerServiceOnInitReady&quot;</span>);</span><br><span class="line">    wm.onInitReady();</span><br><span class="line">    t.traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里眼尖的同学发现了，WMS的启动必须等待SensorService的启动完毕，为什么呢,后面给出答案。</p>
<h1 id="一-WMS启动"><a href="#一-WMS启动" class="headerlink" title="一. WMS启动"></a>一. WMS启动</h1><p>从上面也看出了，WMS的启动是先调用了其静态方法main, 并传入context, inputManager及ActivityTaskManager等，还有一个WindowManagerPolicy子类PhoneWindowManager的对象.</p>
<h2 id="1-1-WindowManagerService-main"><a href="#1-1-WindowManagerService-main" class="headerlink" title="1.1 WindowManagerService.main"></a>1.1 WindowManagerService.main</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="type">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span><br><span class="line"><span class="params">        ActivityTaskManagerService atm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> main(context, im, showBootMsgs, onlyCore, policy, atm,</span><br><span class="line">            SurfaceControl.Transaction::<span class="keyword">new</span>, Surface::<span class="keyword">new</span>, SurfaceControl.Builder::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns an instance of the WindowManagerService. This call allows the caller</span></span><br><span class="line"><span class="comment"> * to override factories that can be used to stub native calls during test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="type">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span><br><span class="line"><span class="params">        ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory,</span></span><br><span class="line"><span class="params">        Supplier&lt;Surface&gt; surfaceFactory,</span></span><br><span class="line"><span class="params">        Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用&quot;android.display&quot;线程初始化WindowManagerService</span></span><br><span class="line">    <span class="comment">// 初始化没有结束时，调用main的线程会被阻塞</span></span><br><span class="line">    DisplayThread.getHandler().runWithScissors(() -&gt;</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">WindowManagerService</span>(context, im, showBootMsgs, onlyCore, policy,</span><br><span class="line">                    atm, transactionFactory, surfaceFactory, surfaceControlFactory), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的双冒号”::”、Supplier以及Function都是java8引入的函数式编程语法。这里值得注意的是runWithScissors方法。</p>
<h2 id="1-2-DisplayThread-getHandler"><a href="#1-2-DisplayThread-getHandler" class="headerlink" title="1.2 DisplayThread.getHandler"></a>1.2 DisplayThread.getHandler</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DisplayThread</span> <span class="keyword">extends</span> <span class="title class_">ServiceThread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DisplayThread sInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler sHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DisplayThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// DisplayThread runs important stuff, but these are not as important as things running in</span></span><br><span class="line">        <span class="comment">// AnimationThread. Thus, set the priority to one lower.</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;android.display&quot;</span>, Process.THREAD_PRIORITY_DISPLAY + <span class="number">1</span>, <span class="literal">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ensureThreadLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">DisplayThread</span>();</span><br><span class="line">            sInstance.start();</span><br><span class="line">            sInstance.getLooper().setTraceTag(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">            sHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(sInstance.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Handler <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DisplayThread.class) &#123;</span><br><span class="line">            ensureThreadLocked();</span><br><span class="line">            <span class="keyword">return</span> sHandler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可以看出DisplayThread其实就是Android里的”android.display”线程，优先级仅仅比THREAD_PRIORITY_DISPLAY低一档。</p>
<h3 id="1-2-1-Handler-runWithScissors"><a href="#1-2-1-Handler-runWithScissors" class="headerlink" title="1.2.1 Handler.runWithScissors"></a>1.2.1 Handler.runWithScissors</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">runWithScissors</span><span class="params">(<span class="meta">@NonNull</span> Runnable r, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;runnable must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout must be non-negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() == mLooper) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BlockingRunnable</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockingRunnable</span>(r);</span><br><span class="line">    <span class="keyword">return</span> br.postAndWait(<span class="built_in">this</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到该方法首先检查了参数合法性，然后判断当前允许的线程是否是Handler处理线程:</p>
<ol>
<li>如果是Handler处理线程，则执行runnable</li>
<li>如果不是，则创建一个BlockingRunnable，执行其postAndWait方法</li>
</ol>
<p>从postAndWait名字中可以推测，必定是需要等待指定runnable在Handler处理线程上执行完毕后，调用runWithScissors的线程才能继续运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BlockingRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mTask;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mDone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingRunnable</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        mTask = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTask.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runnable执行完毕后标记mDone为true,然后通知所以等待线程</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                mDone = <span class="literal">true</span>;</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postAndWait</span><span class="params">(Handler handler, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="comment">// 当handler中已经存在此runnable时，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!handler.post(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">expirationTime</span> <span class="operator">=</span> SystemClock.uptimeMillis() + timeout;</span><br><span class="line">                <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待delay时长</span></span><br><span class="line">                        wait(delay);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以runWithScissors方法为啥会标记为hide呢，明明很好的实现了将某个任务放到指定线程执行并等待该任务执行完毕后继续。</p>
<ol>
<li>考虑到如果等待超时，postAndWait返回的也是false,但是对应runnable的message仍旧处于Handler的MessageQueue之中，这样该runnable最终还是会被执行的。</li>
<li>可能造成死锁，因为runWithScissors所处线程会一直等待，除非超时。比如任务所处的handler的Looper被调用了quit()退出时。我们知道quit方法是会清理Looper的MessageQueue中所有消息，如果此时timeout的时间设置的是0，那么runWithScissors方法所处的线程会一直等到天荒地老。除非Looper退出时是调用的quitSafely(), 该方法只会清空MessageQueue中当前时间点之后的message,在这之前的message仍会被执行。</li>
</ol>
<p>而我们知道，DisplayThread代表线程是不会退出的(除非关机), 所以这里调用runWithScissors是安全的。</p>
<h2 id="1-3-WindowManagerService"><a href="#1-3-WindowManagerService" class="headerlink" title="1.3 WindowManagerService"></a>1.3 WindowManagerService</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> showBootMsgs, <span class="type">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span><br><span class="line"><span class="params">        ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory,</span></span><br><span class="line"><span class="params">        Supplier&lt;Surface&gt; surfaceFactory,</span></span><br><span class="line"><span class="params">        Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 在LockGuard中创建代表WINDOW的Lock, 可以帮助检测系统服务内部锁的机制</span></span><br><span class="line">    installLock(<span class="built_in">this</span>, INDEX_WINDOW);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 标记当前设备是否是可触摸的</span></span><br><span class="line">    mInTouchMode = context.getResources().getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_defaultInTouchMode);</span><br><span class="line">    <span class="comment">// 设置是否允许触摸，现在手机、平板设备一般都是可触摸的</span></span><br><span class="line">    inputManager.setInTouchMode(mInTouchMode);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过surfaceControlFactory可以直接生成SurfaceControl.Builder的对象</span></span><br><span class="line">    mSurfaceControlFactory = surfaceControlFactory;</span><br><span class="line">    <span class="comment">// 其实是实现了Supplier接口的SurfaceControl.Transaction::new</span></span><br><span class="line">    mTransactionFactory = transactionFactory;</span><br><span class="line">    <span class="comment">// 其实是实现了Supplier接口Surface::new</span></span><br><span class="line">    mSurfaceFactory = surfaceFactory;</span><br><span class="line">    <span class="comment">// 创建Transaction对象, 注意每次调用get方法生成的都是新的SurfaceControl.Transaction对象</span></span><br><span class="line">    mTransaction = mTransactionFactory.get();</span><br><span class="line">    <span class="comment">// 这个policy就是PhoneWindowPolicy</span></span><br><span class="line">    mPolicy = policy;</span><br><span class="line">    <span class="comment">// 创建WindowAnimator</span></span><br><span class="line">    mAnimator = <span class="keyword">new</span> <span class="title class_">WindowAnimator</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 创建RootWindowContainer</span></span><br><span class="line">    mRoot = <span class="keyword">new</span> <span class="title class_">RootWindowContainer</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 創建WindowSurfacePlacer，如其名，用於定位窗口及其表面</span></span><br><span class="line">    <span class="comment">// 通过计算窗口的框架来设置窗口的位置，然后根据这些框架来定位Surface</span></span><br><span class="line">    mWindowPlacerLocked = <span class="keyword">new</span> <span class="title class_">WindowSurfacePlacer</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 創建TaskSnapshotController，用於获取相应任务的快照(位图)并将其放入缓存</span></span><br><span class="line">    mTaskSnapshotController = <span class="keyword">new</span> <span class="title class_">TaskSnapshotController</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建WakeLock,用于在转屏等动作时保持cpu不休眠</span></span><br><span class="line">    mScreenFrozenLock = mPowerManager.newWakeLock(</span><br><span class="line">            PowerManager.PARTIAL_WAKE_LOCK, <span class="string">&quot;SCREEN_FROZEN&quot;</span>);</span><br><span class="line">    mScreenFrozenLock.setReferenceCounted(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于管理监听Display的层次属性变化的监听器</span></span><br><span class="line">    mDisplayNotificationController = <span class="keyword">new</span> <span class="title class_">DisplayWindowListenerController</span>(<span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建WakeLock,在必要时保持屏幕常量</span></span><br><span class="line">    mHoldingScreenWakeLock = mPowerManager.newWakeLock(</span><br><span class="line">            PowerManager.SCREEN_BRIGHT_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG_WM);</span><br><span class="line">    mHoldingScreenWakeLock.setReferenceCounted(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于执行不需要持有WindowManager的锁的窗口动画</span></span><br><span class="line">    mSurfaceAnimationRunner = <span class="keyword">new</span> <span class="title class_">SurfaceAnimationRunner</span>(mTransactionFactory,</span><br><span class="line">            mPowerManagerInternal);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 用于任务拖动定位的控制器</span></span><br><span class="line">    mTaskPositioningController = <span class="keyword">new</span> <span class="title class_">TaskPositioningController</span>(</span><br><span class="line">            <span class="built_in">this</span>, mInputManager, mActivityTaskManager, mH.getLooper());</span><br><span class="line">    <span class="comment">// 该类处理并组合从多个视图中生成的拖动事件，然后向任何已经注册了回调的ondragdroplistener触发事件。</span></span><br><span class="line">    mDragDropController = <span class="keyword">new</span> <span class="title class_">DragDropController</span>(<span class="built_in">this</span>, mH.getLooper());</span><br><span class="line">    <span class="comment">// 用于强制显示高刷新率的包的Denylist</span></span><br><span class="line">    mHighRefreshRateDenylist = HighRefreshRateDenylist.create(context.getResources());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建DisplayAreaPolicyProvider，用于后续的DisplayAreaPolicy的构建</span></span><br><span class="line">    mDisplayAreaPolicyProvider = DisplayAreaPolicy.Provider.fromResources(</span><br><span class="line">            mContext.getResources());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置全局阴影</span></span><br><span class="line">    setGlobalShadowSettings();</span><br><span class="line">    mAnrController = <span class="keyword">new</span> <span class="title class_">AnrController</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 管理创建和释放启动窗口Surface</span></span><br><span class="line">    mStartingSurfaceController = <span class="keyword">new</span> <span class="title class_">StartingSurfaceController</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里省略的很多设置代码，仅贴了一些比较重要或者有趣的类对象初始化。</p>
<h1 id="二-Activity的Window创建"><a href="#二-Activity的Window创建" class="headerlink" title="二. Activity的Window创建"></a>二. Activity的Window创建</h1><p>之前我们在*Activity的显示(1)*一文中有分析过，应用的Activity在onCreate方法中setContentView设置了UI布局，之后在该Activity第一次resume时，初始化ViewRootImpl，当该Activity是应用进程第一个被resume的Activity时，建立进程与WMS的通信通道，也就是WindowSession!</p>
<p>最后ViewRootImpl的setView方法中，通过binder调用WindowManager的addToDisplay,之后进入到SystemServer进程调用到WMS.addWindow，在这里创建该Activity对应的WindowState,并保存在mWindowMap中。</p>
<p>如下即是WMS中addWindow的关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContentOrCreate(displayId, attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasParent</span> <span class="operator">=</span> parentWindow != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">rootType</span> <span class="operator">=</span> hasParent ? parentWindow.mAttrs.type : type;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">addToastWindowRequiresToken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">windowContextToken</span> <span class="operator">=</span> attrs.mWindowContextToken;</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasParent) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 一般走这里创建WindowToken</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">                token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">                        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们可以看到WMS中几个关键的类: WindowState,WindowToken,ActivityRecord等。之前我们就绘制过这个类图：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_1.png" alt="1-1"></p>
<ol>
<li>WindowToken: 是在WindowManagerService 中定义的一个基类，顾名思义，它是用来标识某一个窗口。可以把WindowToken看成是一个显示令牌，无论是系统窗口还是应用窗口，添加新的窗口时需要使用这个令牌向WMS表明自己的身份，添加窗口(addWindow)时会创建WindowToken，销毁窗口的时候移除WindowToken(removeWindowToken方法)。</li>
<li>ActivityRecord(原AppWindowToken): 顾名思义，它是用来标识app, 跟准确的说法，是用来标识某个具体的Activity. App每个的Activity对应一個ActivityRecord。其中的appToken為IApplicationToken.Stub类型，有了它就可以找到对应的ActivityRecord.</li>
</ol>
<p>从上面的关系图也能发现，这个WindowToken中token是关键点，我们尚未理清这个值的含义，接下来我们分析一下这个token的来源：</p>
<h2 id="2-1-PhoneWindow的创建"><a href="#2-1-PhoneWindow的创建" class="headerlink" title="2.1 PhoneWindow的创建"></a>2.1 PhoneWindow的创建</h2><p>简单回顾一下 Activity 对应的 PhoneWindow的创建，注意这里仅仅是App进程中的Window.</p>
<p>我们从handleLaunchActivity开始:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Activity <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-performLaunchActivity"><a href="#2-1-1-performLaunchActivity" class="headerlink" title="2.1.1 performLaunchActivity"></a>2.1.1 performLaunchActivity</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Activity <span class="title function_">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">    <span class="type">ActivityInfo</span> <span class="variable">aInfo</span> <span class="operator">=</span> r.activityInfo;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> appContext.getClassLoader();</span><br><span class="line">        <span class="comment">// 通过反射生成Activity</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建应用Application</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> r.packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 这里传入的window一般是null的</span></span><br><span class="line">            activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken, r.shareableActivityToken);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">                <span class="comment">// 将该Activity保存至mActivities集合中，key值就是ActivityClientRecord中的token</span></span><br><span class="line">                mActivities.put(r.token, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用performLaunchActivity就一定会创建一个新的Activity对象，并保存在mActivities集合中。</p>
<h3 id="2-1-2-Activity-attach"><a href="#2-1-2-Activity-attach" class="headerlink" title="2.1.2 Activity.attach"></a>2.1.2 Activity.attach</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span><br><span class="line"><span class="params">        Instrumentation instr, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">        CharSequence title, Activity parent, String id,</span></span><br><span class="line"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="line"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,</span></span><br><span class="line"><span class="params">        IBinder shareableActivityToken)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建Activity对应的PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(mWindowControllerCallback);</span><br><span class="line">    mWindow.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 设置PhoneWindow的WindowManager</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当Activity的parent不为空时，该Activity的PhoneWindow对应的容器就是其parent对应的窗口</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到一个Activity对应一个PhoneWindow, 而且PhoneWindow是在Activity launch的时候才创建的。</p>
<h2 id="2-2-WindowToken中token的作用"><a href="#2-2-WindowToken中token的作用" class="headerlink" title="2.2 WindowToken中token的作用"></a>2.2 WindowToken中token的作用</h2><p>我们假设添加window的Activity是该应用第一个被resume的activity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WMS.addWindow函数中：</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowToken.java</span></span><br><span class="line">WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type, <span class="type">boolean</span> persistOnEmpty,</span><br><span class="line">        DisplayContent dc, <span class="type">boolean</span> ownerCanManageAppTokens, <span class="type">boolean</span> roundedCornerOverlay) &#123;</span><br><span class="line">    <span class="built_in">this</span>(service, _token, type, persistOnEmpty, dc, ownerCanManageAppTokens,</span><br><span class="line">            roundedCornerOverlay, <span class="literal">false</span> <span class="comment">/* fromClientToken */</span>, <span class="literal">null</span> <span class="comment">/* options */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type, <span class="type">boolean</span> persistOnEmpty,</span><br><span class="line">        DisplayContent dc, <span class="type">boolean</span> ownerCanManageAppTokens, <span class="type">boolean</span> roundedCornerOverlay,</span><br><span class="line">        <span class="type">boolean</span> fromClientToken, <span class="meta">@Nullable</span> Bundle options) &#123;</span><br><span class="line">    <span class="built_in">super</span>(service);</span><br><span class="line">    token = _token;</span><br><span class="line">    windowType = type;</span><br><span class="line">    mOptions = options;</span><br><span class="line">    mPersistOnEmpty = persistOnEmpty;</span><br><span class="line">    mOwnerCanManageAppTokens = ownerCanManageAppTokens;</span><br><span class="line">    mRoundedCornerOverlay = roundedCornerOverlay;</span><br><span class="line">    mFromClientToken = fromClientToken;</span><br><span class="line">    <span class="keyword">if</span> (dc != <span class="literal">null</span>) &#123;</span><br><span class="line">        dc.addWindowToken(token, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从WindowToken的构造函数和其初始化的传参中可以看到，WindowToken中的token就是attrs的token,或者是client(IWindow)转换来的。</p>
<h3 id="2-2-1-LayoutParams中的token"><a href="#2-2-1-LayoutParams中的token" class="headerlink" title="2.2.1 LayoutParams中的token"></a>2.2.1 LayoutParams中的token</h3><p>溯源addWindow, 在ViewRootImpl.setView时，会将该LayoutParams作为参数传入，注意，有两个LayoutParams，一个是WindowManager.LayoutParams, 一个是其父类ViewGroup.LayoutParams:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_2.png" alt="1_2"></p>
<p>而ViewRootImpl.setView也是在 WindowManagerGlobal.addView 时调用的,也就是ActivityThread处理该Activity的Resume状态时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isForward, String reason)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> r.activity;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">        <span class="comment">// 现将该View设置为不可见</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">        <span class="comment">// 从这里拿到的params, 所以token也需要查一下这个LayoutParams</span></span><br><span class="line">        <span class="comment">// 最后可以发现是在PhoneWindow创建时候创建的默认值，token还是null的</span></span><br><span class="line">        WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        <span class="comment">// 注意这里type表示为应用窗口</span></span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 这里的wm是Activity中保存的WindowManager, 是该Activity被创建</span></span><br><span class="line">                <span class="comment">// 后调用其attach函数创建Window时的WindowManagerImpl,这一部分我</span></span><br><span class="line">                <span class="comment">// 们在Activity的显示(1)中有分析</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            ......</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上可以看出只有当该Activity的window是尚未被添加且此次resume状态时是需要可见的时候，才会将该Activity对应View添加至WindowManager中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowManagerImpl.addView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    applyTokens(params);</span><br><span class="line">    <span class="comment">// 这里的WMI是在Activity调用attach时通过createLocalWindowManager创建的</span></span><br><span class="line">    <span class="comment">// mParentWindow就是创建该WMI的window,即Activity里的PhoneWindow</span></span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,</span><br><span class="line">            mContext.getUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">applyTokens</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// Only use the default token if we don&#x27;t have a parent window and a token.</span></span><br><span class="line">    <span class="keyword">if</span> (mDefaultToken != <span class="literal">null</span> &amp;&amp; mParentWindow == <span class="literal">null</span> &amp;&amp; wparams.token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// token在此赋值吗？其实一般不是的，这个mDefaultToken只有AccessibilityService中会设置</span></span><br><span class="line">        <span class="comment">// 所以mDefaultToken还是null的</span></span><br><span class="line">        wparams.token = mDefaultToken;</span><br><span class="line">    &#125;</span><br><span class="line">    wparams.mWindowContextToken = mWindowContextToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然不是在此追踪，但是我们可以发现mGlobal.addView中的LayoutParams仍然是ViewGroup.LayoutParams类型，其并不带有token成员。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowManagerGlobal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="line"><span class="params">        Display display, Window parentWindow, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 因为WindowManager.LayoutParams是ViewGroup.LayoutParams子类，所以可以强制转换</span></span><br><span class="line">    <span class="comment">// 但是token默认是null的</span></span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// parentWindow一般不为null,如果是ApplicationType的window，这就是resume的Activity里的PhoneWindow自身</span></span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调整 WindowManager.LayoutParams</span></span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 2.3 创建ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">        ......</span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意每个Activity对应一个PhoneWindow, 一个PhoneWindow对应一个WindowManager(即WindowManagerImpl), 而PhoneWindow继承自Window。PhoneWindow在其对应的Activity被调用attach时创建， 然后会创建WindowManagerImpl，保存在PhoneWindow的mWindowManager成员中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Window.java</span></span><br><span class="line"><span class="comment">// Activity.attach -&gt; PhoneWindow.setWindowManager-&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hardwareAccelerated)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个就是Activity中的 mToken, 对应的是LocalActivityManager.LocalActivityRecord</span></span><br><span class="line">    <span class="comment">// 顺便说一下这个token是在startActivity时创建的</span></span><br><span class="line">    mAppToken = appToken;</span><br><span class="line">    mAppName = appName;</span><br><span class="line">    mHardwareAccelerated = hardwareAccelerated;</span><br><span class="line">    <span class="keyword">if</span> (wm == <span class="literal">null</span>) &#123;</span><br><span class="line">        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityThread.handleResumeActivity-&gt;WindowManagerImpl.addView-&gt;WindowManagerGlobal.addView-&gt;</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">adjustLayoutParamsForSubWindow</span><span class="params">(WindowManager.LayoutParams wp)</span> &#123;</span><br><span class="line">    <span class="type">CharSequence</span> <span class="variable">curTitle</span> <span class="operator">=</span> wp.getTitle();</span><br><span class="line">    <span class="comment">// 在handleResumeActivity我们可以看到这个type被指明为TYPE_BASE_APPLICATION</span></span><br><span class="line">    <span class="keyword">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">            wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 到目前为止，token确实是null的</span></span><br><span class="line">        <span class="keyword">if</span> (wp.token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// mContainer是包含此窗户的容器，没有设置时，DecorWindow将作为顶级窗口</span></span><br><span class="line">            wp.token = mContainer == <span class="literal">null</span> ? mAppToken : mContainer.mAppToken;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般Window的mContainer是null的，所以wp.token就是Window的mAppToken,也即Activity中的mToken, 对应LocalActivityManager.LocalActivityRecord, 通过此变量可以快速找到Activity、ActivityInfo、Window等。所以最后Activity对应的WindowState中对应的WindowToken里的token成员变量就是Activity中的mToken.</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_3.png" alt="1-3"></p>
<h2 id="2-3-Activity的View与Window的关系"><a href="#2-3-Activity的View与Window的关系" class="headerlink" title="2.3 Activity的View与Window的关系"></a>2.3 Activity的View与Window的关系</h2><p>在应用的一个Activity对象即将resume时，会通过WindowManagerImpl将View与该Activity对应的PhoneWindow关联起来。这部分发生WindowManagerGlobal.addView中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowManagerGlobal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="line"><span class="params">        Display display, Window parentWindow, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 创建ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">        ......</span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的View 就是 r.window.getDecorView() 获取的decorView; 而parentWindow就是该Activity首次launch时创建的PhoneWindow（如果没有parent Activity时）</p>
<p>简单回顾下 PhoneWindow 的 DecorView是怎么来的：</p>
<ol>
<li>在Activity被launch后，会调用其onCreate方法</li>
<li>应用会在这个方法中调用setContentView, 将该Activity对应的View或者layout资源ID传入</li>
<li>然后在调用该Activity对应PhoneWindow的setContentView方法<ol>
<li>如果是首次调用，则先调用installDecor方法创建DecorView</li>
<li>之后通过PhoneWindow中的mLayoutInflater将该View实例化</li>
<li>最后将该View保存在PhoneWindow的ViewGroup对象mContentParent中</li>
</ol>
</li>
</ol>
<p>这部分的流程比如installDecor方法我们之后讨论View的生成时再详细分析。所以简单来说，Activity对应的layout视图作为一个子视图保存在这个Activity对应PhoneWindow的DecorView中。</p>
<h2 id="2-4-IWindowSession-PhoneWindow与WMS的交互"><a href="#2-4-IWindowSession-PhoneWindow与WMS的交互" class="headerlink" title="2.4 IWindowSession - PhoneWindow与WMS的交互"></a>2.4 IWindowSession - PhoneWindow与WMS的交互</h2><p>Activity对应的Window和WMS的交互肯定是双向的，那么:</p>
<ol>
<li>Activity对应的PhoneWindow需要保存WMS的client端</li>
<li>WMS需要保存该PhoneWindow的client端</li>
</ol>
<p>毫无疑问，PhoneWindow中保存WMS的client端就是对应的IWindowManager, 保存在WindowManagerGlobal中。而PhoneWindow会用在其对应的ViewRootImpl中继承了IWindow.Stub的W类的对象，通过binder传递到WMS中，作为PhoneWindow在WMS中的client端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(context, display, WindowManagerGlobal.getWindowSession(),</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/* useSfChoreographer */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(<span class="meta">@UiContext</span> Context context, Display display, IWindowSession session,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> useSfChoreographer)</span> &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = session;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建W对象</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> <span class="title class_">W</span>(<span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">                .......</span><br><span class="line">                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(), userId,</span><br><span class="line">                        mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets,</span><br><span class="line">                        mTempControls);</span><br><span class="line">                ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_4.png" alt="1-4"></p>
<p>由此可见，ViewRootImpl发挥这至关重要的作用，其不仅包含Activity对应的View, PhoneWindow及该Window的属性LayoutParams, 还保存着作为WMS中该Activity的Window的服务端W类的对象。</p>
<p>之前我们略有分析mWindowSession的创建，这里我们直接给出时序图：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_5.png" alt="1-5"></p>
<p>之前我们也说过:</p>
<ol>
<li>IWindowManager 对应WindowManagerService, 应用进程端通过这个接口即可向WMS传递消息.</li>
<li>IWindowSession 通过这个Session和WMS中的Session交互.暂时还不理解这个作用</li>
<li>W extends IWindow 对应应用进程端的窗口, WMS通过这个向应用进程的Window发送消息.</li>
</ol>
<p>现在我们分析IWindowSession的方法其实不难理解，IWindowSession是为了方便管理某个应用的某个Window与WMS通信的，虽然最后也是与WMS通信，但是将通信过程也视为一个对象，方便了管理。</p>
<h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>本文中分析了Android显示框架中Framework层最重要的WMS服务启动过程，以及复习了Activity窗口的创建过程。</p>
<h2 id="3-1-WMS服务启动"><a href="#3-1-WMS服务启动" class="headerlink" title="3.1 WMS服务启动"></a>3.1 WMS服务启动</h2><ol>
<li>WMS服务是在引导服务和核心服务启动之后启动的，而且必须等待Sensor服务的启动完毕。</li>
<li>WMS服务的启动首先初始化了”android.display”线程，然后将启动过程放在此线程中处理，主线程阻塞等待该启动完毕。</li>
<li>WMS服务的创建过程：<ol>
<li>创建了WindowAnimator</li>
<li>创建RootWindowContainer</li>
<li>创建WindowSurfacePlacer，如其名，用於定位窗口及其表面</li>
<li>创建TaskSnapshotController，用於获取相应任务的快照(位图)并将其放入缓存</li>
<li>设置全局阴影等等</li>
</ol>
</li>
<li>WMS服务创建完毕后，通过ServiceManager将其发布，服务名为Context.WINDOW_SERVICE</li>
</ol>
<h2 id="3-2-Activity、Window与WindowManagerService"><a href="#3-2-Activity、Window与WindowManagerService" class="headerlink" title="3.2 Activity、Window与WindowManagerService"></a>3.2 Activity、Window与WindowManagerService</h2><ol>
<li>Activity在第一次启动后，调用attach方法时，会创建PhoneWindow以及对应的WindowManagerImpl</li>
<li>在Activity第一次resume时，调用该Activity的WindowManagerImpl创建ViewRootImpl<ol>
<li>在创建ViewRootImpl之前，会通过adjustLayoutParamsForSubWindow将该Activity的mToken保存在PhoneWindow的LayoutParams中</li>
<li>创建ViewRootImpl过程中，会通过IWindowManager与WMS通信，创建IWindowSession, 用于该Activity的Window和WMS通信</li>
</ol>
</li>
<li>创建ViewRootImpl之后，再通过期间创建的IWindowSession与将该Activity的IWindow、相关Window属性传递给WMS.</li>
</ol>
<p>接下来我们看看WMS是怎么管理不同应用的Window的。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
        <tag>WMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(9)-渲染和显示</title>
    <url>/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在这一章里，所有的事情都要集中起来。我们将编写drawFrame函数，该函数将在主循环中被调用，以将三角形置于屏幕上。创建函数并从mainLoop调用它.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        <span class="built_in">drawFrame</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="一-同步"><a href="#一-同步" class="headerlink" title="一. 同步"></a>一. 同步</h1><p>drawFrame函数将执行以下操作:</p>
<ol>
<li>从交换链获取一个映像</li>
<li>在framebuffer中以该图像作为附件执行命令缓冲</li>
<li>将图像返回到交换链以便显示</li>
</ol>
<p>这些事件都是使用单个函数调用设置的，但它们是异步执行的。函数调用将在操作实际完成之前返回，并且执行的顺序也未定义。因为每个操作都依赖于前一个完成，所以需要同步机制。</p>
<p>有两种同步交换链事件的方法:栅栏和信号量。</p>
<p>它们都是可以用于协调操作的对象，方法是让一个操作信号和另一个操作等待栅栏或信号量从无信号状态变为有信号状态。</p>
<p>不同的是，你可以通过vkWaitForFences来访问fences的状态，而信号量却不能。</p>
<p>fence主要用于通过呈现操作同步应用程序本身，而信号量用于在命令队列内或跨命令队列同步操作。我们想要同步draw命令和表示的队列操作，这使得信号量最适合。</p>
<h2 id="1-1-信号量同步"><a href="#1-1-信号量同步" class="headerlink" title="1.1 信号量同步"></a>1.1 信号量同步</h2><p>信号量是一种同步原语，可以用来在提交给队列的批之间插入依赖关系。信号量有两种状态——有信号的和无信号的。一个信号量的状态可以在一批命令执行完成后发出信号。批处理可以在开始执行前等待信号量变成有信号的，也可以在批处理开始执行前等待信号量变成无信号的。</p>
<p>与Vulkan中的大多数对象一样，信号量是内部数据的接口，通常对应用程序是不透明的。这个内部数据被称为信号量的有效负载。但是，为了能够与当前设备之外的代理进行通信，必须能够将有效负载导出为一种普遍理解的格式，然后再从该格式导入。信号量的内部数据可以包括对任何资源的引用，以及与在该信号量对象上执行的信号或非信号操作相关的待定工作。</p>
<p>下面提供了向信号量导入和导出内部数据的机制。这些机制间接地使应用程序能够跨进程和API边界在两个或多个信号量和其他同步原语之间共享信号量状态。</p>
<p>信号量由VkSemaphore句柄表示:VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkSemaphore)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSemaphoreCreateInfo*                pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore*                                pSemaphore)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 创建信号量的逻辑设备</li>
<li>pCreateInfo: 指向VkSemaphoreCreateInfo结构体实例的指针，该结构体包含了如何创建信号量的信息</li>
<li>pAllocator: 控制内存分配</li>
<li>pSemaphore: 指向返回结果信号量对象的句柄。</li>
</ol>
<p>创建时，信号量处于无信号状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSemaphoreCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType           sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*               pNext;</span><br><span class="line">    VkSemaphoreCreateFlags    flags;</span><br><span class="line">&#125; VkSemaphoreCreateInfo;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 此结构的类型，VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>flags: 当前API下无可用flag, 未来版本的Vulkan API或扩展可能会像对其他结构一样为flag和pNext参数添加功能</li>
</ol>
<h3 id="1-2-创建信号量-vkCreateSemaphore"><a href="#1-2-创建信号量-vkCreateSemaphore" class="headerlink" title="1.2 创建信号量 vkCreateSemaphore"></a>1.2 创建信号量 vkCreateSemaphore</h3><p>需要一个信号量来表示图像已经获得并准备好呈现，还需要另一个信号量来表示渲染已经完成并可以进行呈现。创建两个类成员来存储这些信号量对象:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkSemaphore imageAvailableSemaphore;</span><br><span class="line">VkSemaphore renderFinishedSemaphore;</span><br></pre></td></tr></table></figure>

<p>创建信号量需要填写VkSemaphoreCreateInfo，但是在当前版本的API中，除了sType之外实际上没有任何必需的字段:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createSemaphores</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSemaphores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;;</span><br><span class="line">    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;imageAvailableSemaphore) != VK_SUCCESS</span><br><span class="line">            || <span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;renderFinishedSemaphore) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create semaphores!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，信号量应该在程序结束时清除，当所有的命令都已经完成，不再需要更多的同步:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vkDestroySemaphore</span>(device, renderFinishedSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroySemaphore</span>(device, imageAvailableSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-从交换链获取图像"><a href="#二-从交换链获取图像" class="headerlink" title="二. 从交换链获取图像"></a>二. 从交换链获取图像</h1><p>如前所述，在drawFrame函数中需要做的第一件事是从交换链中获取图像。回想一下，交换链是一个扩展特性，所以我们必须使用一个具有vk*KHR命名约定的函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> imageIndex;</span><br><span class="line">    <span class="built_in">vkAcquireNextImageKHR</span>(device, swapChain,</span><br><span class="line">            std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>(),</span><br><span class="line">            imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取一个可用的可呈现图像使用，并检索该图像的索引，调用: vkAcquireNextImageKHR:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAcquireNextImageKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSwapchainKHR                              swapchain,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span>                                    timeout,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSemaphore                                 semaphore,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence                                     fence,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>*                                   pImageIndex)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>device: 提供逻辑设备句柄</li>
<li>swapChain: 交换链对象的句柄, 从这个交换链中获取图像</li>
<li>timeout: 指定如果没有可用的映像，函数将等待多长时间(以纳秒为单位)。</li>
<li>semaphore: 是VK_NULL_HANDLE或者一个信号量</li>
<li>fence: VK_NULL_HANDLE或fence to signal。</li>
<li>pImageIndex: 一个指向uint32_t的指针, 用于输出可用的交换链映像的索引, 索引指的是swapChainImages数组中的VkImage。我们将使用这个索引来选择正确的命令缓冲区。</li>
</ol>
<p>当成功时，vkAcquireNextImageKHR从swapchain获得一个应用程序可以使用的图像，并将pImageIndex设置为该图像在swapchain中的索引。表示引擎在获取图像时可能还没有完成对图像的读取，因此应用程序必须使用信号量和&#x2F;或栅栏来确保图像布局和内容在表示引擎读取完成之前不会被修改。如果semaphore不是VK_NULL_HANDLE，应用程序可能会认为，一旦vkAcquireNextImageKHR返回，semaphore引用的信号量信号操作已经提交执行。图像获取的顺序取决于实现，并且可能与图像呈现的顺序不同。</p>
<p>如果timeout为0，则vkAcquireNextImageKHR不会等待，并且会成功获取镜像，或者失败并返回VK_NOT_READY，如果没有可用的镜像。如果指定的超时时间在获取镜像之前过期，vkAcquireNextImageKHR将返回VK_TIMEOUT。如果timeout是UINT64_MAX，超时时间被认为是无限的，vkAcquireNextImageKHR将阻塞直到一个图像被获取或一个错误发生。</p>
<p>如果应用程序当前获取的(但尚未呈现的)图像数量小于或等于swapchain中的图像数量与vksurfacecabiltieskhr::minImageCount值之间的差值，则最终会获得一个图像。如果当前获取的图像数量大于此值，则不应该调用vkAcquireNextImageKHR;如果是，timeout不能是UINT64_MAX。</p>
<p>如果一个图像成功获得，vkAcquireNextImageKHR必须要么返回VK_SUCCESS，要么返回VK_SUBOPTIMAL_KHR，如果交换链不再完全匹配表面属性，但仍然可以用于表示。</p>
<h1 id="三-提交指令缓冲区"><a href="#三-提交指令缓冲区" class="headerlink" title="三. 提交指令缓冲区"></a>三. 提交指令缓冲区</h1><p>队列提交和同步是通过VkSubmitInfo结构中的参数配置的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSubmitInfo</span> &#123;</span><br><span class="line">    VkStructureType                sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                    pNext;</span><br><span class="line">    <span class="type">uint32_t</span>                       waitSemaphoreCount;</span><br><span class="line">    <span class="type">const</span> VkSemaphore*             pWaitSemaphores;</span><br><span class="line">    <span class="type">const</span> VkPipelineStageFlags*    pWaitDstStageMask;</span><br><span class="line">    <span class="type">uint32_t</span>                       commandBufferCount;</span><br><span class="line">    <span class="type">const</span> VkCommandBuffer*         pCommandBuffers;</span><br><span class="line">    <span class="type">uint32_t</span>                       signalSemaphoreCount;</span><br><span class="line">    <span class="type">const</span> VkSemaphore*             pSignalSemaphores;</span><br><span class="line">&#125; VkSubmitInfo;</span><br></pre></td></tr></table></figure>

<ol>
<li>sType: 此结构的类型，VK_STRUCTURE_TYPE_SUBMIT_INFO</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>waitSemaphoreCount: 执行批处理的命令缓冲区之前需要等待的信号量的数量</li>
<li>pWaitSemaphores: 指向VkSemaphore句柄数组的指针，在这个批处理的命令缓冲区开始执行之前，要等待该句柄。如果提供了等待的信号量，则定义一个信号量等待操作。</li>
<li>pWaitDstStageMask: 指向每个对应的信号量等待将发生的管道阶段数组的指针</li>
<li>commandBufferCount: 批处理中要执行的命令缓冲区的数量</li>
<li>pCommandBuffers: 指向要在批处理中执行的VkCommandBuffer句柄数组的指针</li>
<li>signalSemaphoreCount: 在pCommandBuffers中指定的命令完成执行后要发出信号的信号量的数量</li>
<li>pSignalSemaphores: 指向VkSemaphore句柄数组的指针，当这个批处理的命令缓冲区完成执行时，VkSemaphore句柄数组将发出信号。如果提供了要发送信号的信号量，它们定义了一个信号量信号操作。</li>
</ol>
<p>命令缓冲区在pCommandBuffers中出现的顺序用于确定提交顺序，因此所有的隐式排序都保证遵守它。除了这些隐式排序保证和任何显式同步原语之外，这些命令缓冲区可能会重叠或以其他方式乱序执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前三个参数指定在执行开始之前等待哪些信号量，以及在管道的哪个阶段等待。</span></span><br><span class="line">VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;</span><br><span class="line"><span class="comment">// 我们希望等待向图像写入颜色，直到它可用为止，因此我们指定了向颜色附件写入的图形管道阶段。</span></span><br><span class="line">VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;</span><br><span class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pWaitSemaphores = waitSemaphores;</span><br><span class="line"><span class="comment">// 理论上已经可以开始执行顶点着色器，而还没有可用图像。</span></span><br><span class="line"><span class="comment">// waitStages数组中的每一项都对应于在pwaitsemaphres中具有相同索引的信号量。</span></span><br><span class="line">submitInfo.pWaitDstStageMask = waitStages;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定实际提交哪些命令缓冲区以执行</span></span><br><span class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pCommandBuffers = &amp;commandBuffers[imageIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定在命令缓冲区完成执行后要发送哪些信号量</span></span><br><span class="line">VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;</span><br><span class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pSignalSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用vkqueuessubmit将命令缓冲区提交到图形队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用vkqueuessubmit将命令缓冲区提交到图形队列。当工作负载更大时，该函数接受一个VkSubmitInfo结构数组作为效率参数。<br>最后一个参数引用一个可选的fence，该fence将在命令缓冲区完成执行时发出信号。我们使用信号量进行同步，所以我们将传递一个VK_NULL_HANDLE。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkQueueSubmit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkQueue                                     queue,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    submitCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSubmitInfo*                         pSubmits,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkFence                                     fence)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>queue: 命令缓冲将被提交到的队列</li>
<li>submitCount: 提交数组pSubmits中的元素数量</li>
<li>pSubmits: 指向VkSubmitInfo结构数组的指针，每个结构都指定了一个命令缓冲区提交批处理</li>
<li>fence: 可选的fence句柄，一旦所有提交的命令缓冲区完成执行，就会发出信号。如果fence不是VK_NULL_HANDLE，则定义一个fence信号操作</li>
</ol>
<p><strong>提交可能是一个高开销的操作，应用程序应该尽可能少的调用vkqueuessubmit来批量处理。</strong></p>
<h1 id="四-Subpass依赖"><a href="#四-Subpass依赖" class="headerlink" title="四. Subpass依赖"></a>四. Subpass依赖</h1><p>渲染通道中的子通道会自动处理图像布局的转换。这些转换由子传递依赖项控制，子传递依赖项指定子传递之间的内存和执行依赖项。</p>
<p>我们现在只有一个Subpass，但是在这个Subpass之前和之后的操作也被算作隐式的“Subpasses”。</p>
<p>有两个内置的依赖关系负责渲染通道开始和结束的转换，但前者没有在正确的时间发生。它假设转换发生在管道的开始，但是我们在那一点还没有获得图像!</p>
<p>有两种方法来处理这个问题：</p>
<ol>
<li>将imageAvailableSemaphore的等待阶段更改为VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT，以确保渲染通道直到图像可用时才开始</li>
<li>让渲染通道等待VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT阶段。</li>
</ol>
<p>在这里使用第二种方法，因为这是一个很好的方式来了解子传递依赖项及其工作方式。Subpass依赖在VkSubpassDependency结构中指定。</p>
<p>在createRenderPass函数中添加一个:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkSubpassDependency dependency = &#123;&#125;;</span><br><span class="line"><span class="comment">// 指定依赖项</span></span><br><span class="line">dependency.srcSubpass = VK_SUBPASS_EXTERNAL;</span><br><span class="line"><span class="comment">// 从属子传递的索引</span></span><br><span class="line">dependency.dstSubpass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定要等待的操作以及这些操作发生的阶段</span></span><br><span class="line"><span class="comment">// 需要等待交换链完成对图像的读取后才能访问它。这可以通过等待颜色附件输出阶段本身来完成。</span></span><br><span class="line">dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</span><br><span class="line">dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这一阶段应该等待的操作是在颜色连接阶段，包括阅读和书写颜色连接。</span></span><br><span class="line"><span class="comment">// 这些设置将防止转换发生，直到它是真正必要的(和允许的):当我们想要开始写入颜色。</span></span><br><span class="line">renderPassInfo.dependencyCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pDependencies = &amp;dependency;</span><br></pre></td></tr></table></figure>
<p>特殊值VK_SUBPASS_EXTERNAL指的是在渲染传递之前或之后的隐式子传递，这取决于它是在srcSubpass还是dstSubpass中指定的。<br>索引0指向我们的子通道，它是第一个也是唯一一个。dstSubpass必须始终高于srcSubpass，以防止依赖关系图中的循环。</p>
<h1 id="五-显示"><a href="#五-显示" class="headerlink" title="五. 显示"></a>五. 显示</h1><p>绘制框架的最后一步是将结果提交回交换链，使其最终显示在屏幕上。</p>
<p><strong>在应用程序可以呈现一个图像之前，图像的布局必须转换为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR布局，或者对于一个共享的可呈现图像，必须转换为VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR布局。</strong></p>
<h2 id="5-1-VkPresentInfoKHR"><a href="#5-1-VkPresentInfoKHR" class="headerlink" title="5.1 VkPresentInfoKHR"></a>5.1 VkPresentInfoKHR</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPresentInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*              pNext;</span><br><span class="line">    <span class="type">uint32_t</span>                 waitSemaphoreCount;</span><br><span class="line">    <span class="type">const</span> VkSemaphore*       pWaitSemaphores;</span><br><span class="line">    <span class="type">uint32_t</span>                 swapchainCount;</span><br><span class="line">    <span class="type">const</span> VkSwapchainKHR*    pSwapchains;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*          pImageIndices;</span><br><span class="line">    VkResult*                pResults;</span><br><span class="line">&#125; VkPresentInfoKHR;</span><br></pre></td></tr></table></figure>
<ol>
<li>sType: 此结构的类型，VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</li>
<li>pNext: 为空或指向特定于扩展的结构的指针</li>
<li>waitsemaphore: 在发出当前请求之前等待的信号量的数量, 可能是零。</li>
<li>pwaitsemaphres: 空的或指向带有waitsemaphore条目的VkSemaphore对象数组的指针，它指定了在发出当前请求之前需要等待的信号量。</li>
<li>swapchainCount: 指令提供给交换链的数量</li>
<li>pSwapchains: 指向带有swapchainCount条目的VkSwapchainKHR对象数组的指针。给定的交换链不能在此列表中出现多次。</li>
<li>pImageIndices: 指向每个swapchain的可呈现图像数组的索引数组的指针，其中包含swapchainCount条目。这个数组中的每个条目都标识要在pSwapchains数组中的相应条目上显示的图像。</li>
<li>results: 指向带有swapchainCount条目的VkResult类型元素数组的指针。不需要每个swapchain结果的应用程序可以对结果使用NULL。如果非null，则results中的每个条目都将被设置为VkResult，以表示与pSwapchains中的相同索引相对应的交换链。</li>
</ol>
<h2 id="5-2-显示设置"><a href="#5-2-显示设置" class="headerlink" title="5.2 显示设置"></a>5.2 显示设置</h2><p>通过drawFrame函数末尾的VkPresentInfoKHR结构来配置显示相关设置:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkPresentInfoKHR presentInfo = &#123;&#125;;</span><br><span class="line">presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;</span><br><span class="line"><span class="comment">// 指定在表示发生之前等待哪些信号量，就像VkSubmitInfo一样</span></span><br><span class="line">presentInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">presentInfo.pWaitSemaphores = signalSemaphores;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定要向其显示图像的交换链，以及每个交换链的图像索引。</span></span><br><span class="line">VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;</span><br><span class="line">presentInfo.swapchainCount = <span class="number">1</span>;</span><br><span class="line">presentInfo.pSwapchains = swapChains;</span><br><span class="line">presentInfo.pImageIndices = &amp;imageIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定一个VkResult值数组，以便在表示成功时检查每个交换链。</span></span><br><span class="line"><span class="comment">// 只使用单个交换链，就不需要，因为可以简单地使用当前函数的返回值。</span></span><br><span class="line">presentInfo.pResults = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vkQueuePresentKHR函数提交请求，以向交换链请求一个图像</span></span><br><span class="line"><span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br></pre></td></tr></table></figure>

<p>现在编译运行一下我们的程序:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/Vulkan_9_1.png" alt="图片"></p>
<p>ohhhh!!!!整整一千多行的代码，终于不是黑糊糊的窗口了。</p>
<p>当启用验证层时，程序在关闭时就会崩溃。从debugCallback打印到终端的消息告诉我们为什么:</p>
<p>记住，drawFrame中的所有操作都是异步的。这意味着当我们退出mainLoop中的循环时，绘图和表示操作可能仍然在进行。当这种情况发生时，清理资源就可能带来异常。</p>
<p>要解决这个问题，我们应该等待逻辑设备完成操作，然后退出mainLoop并销毁窗口:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        <span class="built_in">drawFrame</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vkDeviceWaitIdle</span>(device);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-1-vkQueuePresentKHR"><a href="#5-2-1-vkQueuePresentKHR" class="headerlink" title="5.2.1 vkQueuePresentKHR"></a>5.2.1 vkQueuePresentKHR</h3><p>在将所有渲染命令排队并将图像转换到正确的布局后，要将图像排队显示，调用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkQueuePresentKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkQueue                                     queue,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkPresentInfoKHR*                     pPresentInfo)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>queue是一个能够在与图像交换链相同的设备上显示到目标表面平台的队列。</li>
<li>pPresentInfo是一个指向VkPresentInfoKHR结构体的指针，该结构体指定了表示的参数。</li>
</ol>
<p>应用程序不需要按照获取图像的顺序来呈现图像——应用程序可以任意地呈现当前获取的任何图像。</p>
<h1 id="六-Frames-in-flight"><a href="#六-Frames-in-flight" class="headerlink" title="六. Frames in flight"></a>六. Frames in flight</h1><p>如果在启用了验证层的情况下运行应用程序，并且监视应用程序的内存使用情况，则可能会注意到它正在缓慢增长。 </p>
<p>原因是应用程序正在使用drawFrame函数快速提交工作，但实际上并没有检查是否有任何工作完成。如果CPU提交工作的速度快于GPU不能跟上的工作，那么队列将缓慢地填满工作。 更糟糕的是，我们同时对多个帧重用了imageAvailableSemaphore和renderFinishedSemaphore。</p>
<p>解决此问题的简单方法是提交后等待工作完成，例如使用vkQueueWaitIdle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br><span class="line">    <span class="built_in">vkQueueWaitIdle</span>(presentQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们可能无法以这种方式最佳地使用GPU，因为整个图形流水线现在一次只能使用一帧。 当前帧已经经过的阶段是空闲的，可能已经用于下一帧。 现在，我们将扩展我们的应用程序，以允许在运行多个frame的同时仍限制堆积的工作量。</p>
<p>首先在程序顶部添加一个常量，该常量定义应同时处理多少帧, 以及每个frame应具有自己的一组信号：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FRAMES_IN_FLIGHT = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;</span><br><span class="line">std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSemaphores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    imageAvailableSemaphores.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line">    renderFinishedSemaphores.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line"></span><br><span class="line">    VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;;</span><br><span class="line">    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS</span><br><span class="line">                || <span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create semaphores for a frame!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;</span><br><span class="line">        <span class="built_in">vkDestroySemaphore</span>(device, renderFinishedSemaphores[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">vkDestroySemaphore</span>(device, imageAvailableSemaphores[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，drawFrame也需要修改:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vkAcquireNextImageKHR</span>(device, swapChain, std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>(),</span><br><span class="line">            imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);</span><br><span class="line">    ...</span><br><span class="line">    VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;;</span><br><span class="line">    ...</span><br><span class="line">    VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的currentFrame可以通过取模来获取: currentFrame &#x3D; (currentFrame + 1)%MAX_FRAMES_IN_FLIGHT</p>
<p>通过使用模（％）运算符，我们确保帧索引在每个MAX_FRAMES_IN_FLIGHT排队的帧之后循环。</p>
<h2 id="6-1-fence机制"><a href="#6-1-fence机制" class="headerlink" title="6.1 fence机制"></a>6.1 fence机制</h2><p>尽管我们现在已经设置了必需的对象以方便同时处理多个帧，但实际上并没有阻止提交超过MAX_FRAMES_IN_FLIGHT个对象。 现在只有GPU-GPU同步，没有CPU-GPU同步来跟踪工作的进行情况。 我们可能正在使用第0帧对象，而第0帧仍在显示中！</p>
<p>为了执行CPU-GPU同步，Vulkan提供了第二种类型的同步原语，称为fences。 在可以发信号并等待信号的意义上，fence与信号相似，但是这次我们实际上在自己的代码中等待信号。 我们首先为每个框架创建一个fence：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;</span><br><span class="line">std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;</span><br><span class="line">std::vector&lt;VkFence&gt; inFlightFences;</span><br><span class="line"><span class="type">size_t</span> currentFrame = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>因为fence也是同步机制，所以最好把同步对象的创建放在一起，吧createSemaphores改名成createSyncObjects:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createSyncObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    imageAvailableSemaphores.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line">    renderFinishedSemaphores.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line">    inFlightFences.<span class="built_in">resize</span>(MAX_FRAMES_IN_FLIGHT);</span><br><span class="line"></span><br><span class="line">    VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;;</span><br><span class="line">    semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;</span><br><span class="line"></span><br><span class="line">    VkFenceCreateInfo fenceInfo = &#123;&#125;;</span><br><span class="line">    fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS</span><br><span class="line">                || <span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS</span><br><span class="line">                || <span class="built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="literal">nullptr</span>, &amp;inFlightFences[i]) != VK_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create synchronization objects for a frame!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也要记得销毁fence.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放信号量和fence</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; MAX_FRAMES_IN_FLIGHT; i ++) &#123;</span><br><span class="line">        <span class="built_in">vkDestroySemaphore</span>(device, renderFinishedSemaphores[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">vkDestroySemaphore</span>(device, imageAvailableSemaphores[i], <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vkDestroyFence</span>(device, inFlightFences[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在使用fence进行同步。vkqueuessubmit调用包含一个可选参数，用于传递一个fence，当命令缓冲区执行完毕时，该fence应该被通知。我们可以用它来表示一个帧已经完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待当前帧fence完成</span></span><br><span class="line">    <span class="built_in">vkWaitForFences</span>(device, <span class="number">1</span>, &amp;inFlightFences[currentFrame], VK_TRUE, std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    <span class="built_in">vkResetFences</span>(device, <span class="number">1</span>, &amp;inFlightFences[currentFrame]);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// VkQueue是Vulkan中应用程序向GPU提交命令的唯一途径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to submit draw command buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vkWaitForFences函数接受一个fences数组，在返回之前等待其中任何一个或者所有的栅栏被通知。我们在这里传递的VK_TRUE表示我们希望等待所有的fence，但在单个fence的情况下，这显然无关紧要。就像vkAcquireNextImageKHR一样，这个函数也是需要一个超时。</p>
<p>与信号量不同，我们需要通过vkResetFences调用来手动将栅栏恢复到无信号状态。如果你现在运行这个程序，你会注意到一些奇怪的东西。应用程序似乎不再呈现任何东西。<br>这是因为在等一个还没被提交的fence! 这里的问题是，在默认情况下，fence是在无信号状态下创建的。这意味着如果我们以前没有用过fence，vkWaitForFences将会永远等下去。为了解决这个问题，我们可以改变fence的创建，在有信号的状态下初始化它，就像我们已经完成了初始帧的渲染一样:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VkFenceCreateInfo fenceInfo = &#123;&#125;;</span><br><span class="line">fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;</span><br><span class="line">fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT; <span class="comment">// 初始化fence</span></span><br></pre></td></tr></table></figure>

<p>程序现在应该可以正常工作了，内存泄漏也消失了! 我们已经实现了所有需要的同步，以确保排队的工作不超过两个帧。请注意，代码的其他部分，如最终的清理，可以依赖于更粗糙的同步，如vkDeviceWaitIdle，应该根据性能需求决定使用哪种方法。</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-9-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/Vulkan_9_2.png" alt="图片"><br>Vulkan管道的框图</p>
<h1 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h1><p>现在我们已经写了一千多行的代码，总算把Vulkan的这一套简单的过了一遍。在继续后续学习之前，有必要先总结一下，巩固基础。</p>
<p>首先Vulkan是什么：Vulkan是一个低开销、跨平台的二维、三维图形与计算的应用程序接口（API）。本身是一个与平台无关的API，所以不包括用于创建显示渲染结果的窗口的工具。所以借助 GLFW （当然也可以是其他库如SDL）创建窗口。</p>
<p>下面是一个Vuklan应用一般流程的简述:</p>
<ol>
<li>借助GLFW库，创建显示窗口。</li>
<li>创建Vulkan实例VkInstance<ol>
<li>使用VkApplicationInfo和VkInstanceCreateInfo声明相关配置</li>
<li>调用 vkCreateInstance, 创建 vulkan 实例</li>
</ol>
</li>
<li>如果是开发调试，可以启用验证层<ol>
<li>实现调试回调函数</li>
<li>通过VkDebugUtilsMessengerCreateInfoEXT.pfnUserCallback绑定消息回调函数</li>
<li>通过CreateDebugUtilsMessengerEXT函数实例化DebugUtilsMessengerEXT</li>
<li>注意在不需要的时候显示销毁回调实例 PFN_vkDestroyDebugUtilsMessengerEXT</li>
</ol>
</li>
<li>检索合适的物理设备<ol>
<li>通过vkEnumeratePhysicalDevices获取本机物理显卡，并根据需要选择合适GPU<ol>
<li>通过vkGetPhysicalDeviceProperties检查显卡的基本功能</li>
<li>查询vkGetPhysicalDeviceFeatures中可以被支持的feature</li>
</ol>
</li>
<li>挑选需要的队列族<ol>
<li>通过vkGetPhysicalDeviceQueueFamilyProperties获取物理显卡支持的队列，并挑选需要的队列</li>
</ol>
</li>
</ol>
</li>
<li>创建逻辑设备 VkDevice<ol>
<li>首先将4.2.1中挑选的队列记录在VkDeviceQueueCreateInfo中，指定要创建的队列VkDeviceCreateInfo.pQueueCreateInfos</li>
<li>指定使用的设备功能(feature)，比如几何着色器等</li>
<li>通过vkCreateDevice函数创建逻辑设备，注意在不需要的时候显示销毁逻辑设备(vkDestroyDevice)</li>
<li>队列是与逻辑设备一起自动创建的，直接通过vkGetDeviceQueue获取该逻辑设备上指定的队列即可（当逻辑设备被销毁时，会隐式清除设备队列）</li>
</ol>
</li>
<li>创建Surface<ol>
<li>启用VK_KHR_surface扩展，通过glfw的glfwCreateWindowSurface创建VkSurfaceKHR</li>
</ol>
</li>
<li>创建交换链，即渲染缓冲区, 本质上是一个等待呈现给屏幕的图像队列<ol>
<li>检查GPU是否支持交换链，VK_KHR_SWAPCHAIN_EXTENSION_NAME</li>
<li>使能设备VK_KHR_swapchain扩展</li>
<li>获取关于swap chain更多支持细节<ol>
<li>基本Surface功能（交换链中的最小&#x2F;最大图像数，图像的最小&#x2F;最大宽度和高度）</li>
<li>Surface的格式（像素格式，色彩空间）</li>
<li>可用的呈现模式</li>
</ol>
</li>
<li>为交换链选择合适的设置，如Surface格式（颜色深度）、呈现模式（将图像“交换”到屏幕的条件）、交换范围（交换链中图像的分辨率）等</li>
<li>创建swap chain对象 VkSwapchainKHR<ol>
<li>绑定窗口Surface</li>
<li>设置最小图像数量 minImageCount</li>
<li>选择合适的图像格式 imageFormat </li>
<li>选择合适的图像颜色空间 imageColorSpace</li>
<li>选择合适的图像分辨率 imageExtent</li>
<li>设置图像图层 imageArrayLayers</li>
<li>设置图像操作方式 imageUsage</li>
<li>选择图像呈现模式 presentMode</li>
<li>是否需要裁剪功能 clipped(VK_TRUE, VK_FALSE)</li>
<li>设置旧交换链的引用 oldSwapchain</li>
</ol>
</li>
<li>获取交换链图像(VkImage)对象集合</li>
</ol>
</li>
<li>创建渲染过程，Render Passes<ol>
<li>通过vkCreateRenderPass创建，在不需要时通过vkDestroyRenderPass销毁</li>
</ol>
</li>
<li>创建图形管道, 在Vulkan中，必须明确所有内容，从视口大小到颜色混合功能。有如下几个固定操作：<ol>
<li>输入汇编程序(input assembler): 从指定的缓冲区收集原始顶点数据，也可以使用索引缓冲区重复某些元素，而不必复制顶点数据本身。</li>
<li>顶点着色器(vertex shader): 针对每个顶点运行，并且通常应用变换以将顶点位置从模型空间转换到屏幕空间。它还沿着管道传递每顶点数据。</li>
<li>曲面细分着色器(tessellation shaders): 根据特定规则细分几何体以提高网格质量。通常用于使砖墙和楼梯等表面在附近时看起来不那么平坦。</li>
<li>几何着色器(geometry shader): 在每个基元(三角形，直线，点)上运行，并且可以丢弃它或输出比原来更多的基元。类似于曲面细分着色器，但更灵活。但没有得到太多应用，因为大多数显卡的性能都不是很好。</li>
<li>光栅化阶段(rasterization stage): 将基元离散化为片段。这些是它们填充在帧缓冲区上的像素元素。在屏幕之外的片段都将被丢弃，顶点着色器输出的属性将在片段之间进行插值。由于深度测试，通常在这里也丢弃其他原始片段后面的片段。</li>
<li>片段着色器(fragment shader): 为存活的每个片段调用片段着色器，并确定片段写入哪些帧缓冲区以及使用哪些颜色和深度值。它可以使用来自顶点着色器的插值数据来完成此操作，其中可以包括纹理坐标和法线照明等内容。</li>
<li>颜色混合阶段(color blending stage): 应用操作来混合映射到帧缓冲区中的相同像素的不同片段。 fragment可以简单地相互覆盖，加起来或根据透明度进行混合。<ol>
<li>输入汇编程序、光栅化和颜色混合阶段阶段被称为固定功能阶段。这些阶段允许使用参数调整其操作，但它们的工作方式是预定义的。</li>
<li>顶点着色器、曲面细分着色器、几何着色器和片段着色器阶段是可编程的，这意味着可以将代码上传到图形卡，以完全应用想要的操作。 </li>
<li>例如，实现从纹理和光照到光线跟踪器的任何内容。这些程序同时在许多GPU内核上运行，以并行处理许多对象，如顶点和片段。，可以使用片段着色器</li>
</ol>
</li>
<li>通过vkCreateGraphicsPipelines创建图形管道，指明渲染过程</li>
</ol>
</li>
<li>创建帧缓冲区<ol>
<li>调整帧缓冲区容器的大小以容纳所有交换链图像视图</li>
<li>指定帧缓冲区需要与哪个renderPass兼容。只能对与之兼容的渲染过程使用帧缓冲区，这意味着它们使用相同数量和类型的附件。</li>
<li>attachmentCount和pAttachments参数指定应绑定到渲染过程pAttachment数组中相应附件描述的VkImageView对象。</li>
<li>帧缓冲区宽度和高度参数是交换链中获取的宽高</li>
<li>帧缓冲区的layers是指图像数组中的层数</li>
<li>在不需要时，通过vkDestroyFramebuffer销毁帧缓冲区</li>
</ol>
</li>
<li>创建指令缓冲区，Vulkan必须在指令缓冲区对象中记录想要执行的所有操作<ol>
<li>先创建创建指令缓冲池，Command pool</li>
<li>创建指令缓冲区，大小和帧缓冲一致</li>
</ol>
</li>
<li>渲染和显示<ol>
<li>从交换链获取一个映像</li>
<li>在framebuffer中以该图像作为附件执行命令缓冲，提交指令缓冲区</li>
<li>将图像返回到交换链以便显示</li>
<li>渲染显示的过程需要同步</li>
</ol>
</li>
</ol>
<p>好的，现在我们又加深了一遍印象，这其中诸多细节我们后续挖掘。</p>
]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(2)-WMS中RootDisplayArea的创建</title>
    <url>/2022/05/02/WMS(2)-WMS%E4%B8%ADRootDisplayArea%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在我们开始分析WMS是怎么管理不同应用的Window的时，有点一头雾水，不知如何下手。那么我们还是从单个Activity的Window被添加至WMS中来入手。</p>
<p>从上文中我们知道PhoneWindow是通过IWindowSession被添加的，在ViewRoontImpl中调用了addToDisplayAsUser:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,</span><br><span class="line">        getHostVisibility(), mDisplay.getDisplayId(), userId,</span><br><span class="line">        mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets,</span><br><span class="line">        mTempControls);</span><br></pre></td></tr></table></figure>

<p>这里的mWindow是ViewRootImpl.W类的对象，用于WMS和该Window通信。</p>
<span id="more"></span>
<h1 id="一-Activity的Window被添加至WMS"><a href="#一-Activity的Window被添加至WMS" class="headerlink" title="一. Activity的Window被添加至WMS"></a>一. Activity的Window被添加至WMS</h1><p>mWindowSession是ViewRootImpl被创建时通过IWindowManager在WMS中创建并返回的。这个我们回顾下：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_1.png" alt="2-1"></p>
<h2 id="1-1-Session-addToDisplayAsUser"><a href="#1-1-Session-addToDisplayAsUser" class="headerlink" title="1.1 Session.addToDisplayAsUser"></a>1.1 Session.addToDisplayAsUser</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addToDisplayAsUser</span><span class="params">(IWindow window, WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> viewVisibility, <span class="type">int</span> displayId, <span class="type">int</span> userId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="built_in">this</span>, window, attrs, viewVisibility, displayId, userId,</span><br><span class="line">            requestedVisibility, outInputChannel, outInsetsState, outActiveControls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mService自然就是WMS本身了。</p>
<h2 id="1-2-WMS-addWindow"><a href="#1-2-WMS-addWindow" class="headerlink" title="1.2 WMS.addWindow"></a>1.2 WMS.addWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 1.2.1 获取该token对应的DisplayContent</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContentOrCreate(displayId, attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasParent</span> <span class="operator">=</span> parentWindow != <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 当该Activity没有parent时，此时获取的token还是null</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasParent) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1.2.2 一般走这里创建WindowToken</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">                token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">                        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-1-WMS-getDisplayContentOrCreate"><a href="#1-2-1-WMS-getDisplayContentOrCreate" class="headerlink" title="1.2.1 WMS.getDisplayContentOrCreate"></a>1.2.1 WMS.getDisplayContentOrCreate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DisplayContent <span class="title function_">getDisplayContentOrCreate</span><span class="params">(<span class="type">int</span> displayId, IBinder token)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的DisplayContent找到保存该token的WindowToken</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowToken</span> <span class="variable">wToken</span> <span class="operator">=</span> mRoot.getWindowToken(token);</span><br><span class="line">        <span class="keyword">if</span> (wToken != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> wToken.getDisplayContent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mRoot.getDisplayContentOrCreate(displayId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先遍历所有的DisplayContent尝试找到保存该token的WindowToken，自然是没有的，我们是第一次添加。</p>
<p>mRoot是WMS服务启动时创建的RootWindowContainer对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayContent <span class="title function_">getDisplayContentOrCreate</span><span class="params">(<span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否已被创建，假设已创建</span></span><br><span class="line">    <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContent(displayId);</span><br><span class="line">    <span class="keyword">if</span> (displayContent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> displayContent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The system isn&#x27;t fully initialized yet.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Display</span> <span class="variable">display</span> <span class="operator">=</span> mDisplayManager.getDisplay(displayId);</span><br><span class="line">    <span class="keyword">if</span> (display == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The display is not registered in DisplayManager.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2.1.1 创建DisplayContent</span></span><br><span class="line">    displayContent = <span class="keyword">new</span> <span class="title class_">DisplayContent</span>(display, <span class="built_in">this</span>);</span><br><span class="line">    addChild(displayContent, POSITION_BOTTOM);</span><br><span class="line">    <span class="keyword">return</span> displayContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisplayContent <span class="title function_">getDisplayContent</span><span class="params">(<span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (displayContent.mDisplayId == displayId) &#123;</span><br><span class="line">            <span class="keyword">return</span> displayContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为了便于后续分析，先看看相关的类图:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_2.png" alt="2-2"></p>
<p>从类的成员变量上推测：</p>
<ol>
<li>WindowState: 代表Activity在WMS中的Window</li>
<li>DisplayContent: 管理显示窗口以及显示区域</li>
<li>DisplayPolicy: 管理显示窗口的可视化，决定哪些窗口可以有焦点，可以被”看见”(mFocusedWindow)</li>
</ol>
<p>注意到这些类图里有很多都使用了WindowContainer，这个类中最重要的是一个WindowList类的成员，该类就是一个继承了ArrayList的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        add(<span class="number">0</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">0</span> ? get(size() - <span class="number">1</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">0</span> ? get(<span class="number">0</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单包装了ArrayList, 实现了三个方法：</p>
<ol>
<li>addFirst: 将元素添加至index为0的位置，原先元素的index依次+1</li>
<li>peekLast: 获取集合最后一个元素</li>
<li>peekFirst: 获取集合第一个元素</li>
</ol>
<h4 id="1-2-1-1-DisplayContent-的创建"><a href="#1-2-1-1-DisplayContent-的创建" class="headerlink" title="1.2.1.1 DisplayContent 的创建"></a>1.2.1.1 DisplayContent 的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayContent(Display display, RootWindowContainer root) &#123;</span><br><span class="line">    <span class="built_in">super</span>(root.mWindowManager, <span class="string">&quot;DisplayContent&quot;</span>, FEATURE_ROOT);</span><br><span class="line">    ......</span><br><span class="line">    mRootWindowContainer = root;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建DisplayPolicy</span></span><br><span class="line">    mDisplayPolicy = <span class="keyword">new</span> <span class="title class_">DisplayPolicy</span>(mWmService, <span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化DisplayAreaPolicy</span></span><br><span class="line">    mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(</span><br><span class="line">            mWmService, <span class="built_in">this</span> <span class="comment">/* content */</span>, <span class="built_in">this</span> <span class="comment">/* root */</span>, mImeWindowsContainer);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DisplayContent的初始化中做了很多工作，包括创建SurfaceControl等等，但这不是我们目前关注的。</p>
<p>DisplayContent是继承了RootDisplayArea, 其对应的Feature是FEATURE_ROOT，表示是该逻辑显示设备上的根显示区域</p>
<p>DisplayPolicy暂时不是我们关注的，主要了解下其是在这里初始化即可, 重点是初始化DisplayAreaPolicy。</p>
<h4 id="1-2-1-2-DisplayAreaPolicy的初始化"><a href="#1-2-1-2-DisplayAreaPolicy的初始化" class="headerlink" title="1.2.1.2 DisplayAreaPolicy的初始化"></a>1.2.1.2 DisplayAreaPolicy的初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getDisplayAreaPolicyProvider拿到的就是WMS初始化时创建的mDisplayAreaPolicyProvider</span></span><br><span class="line"><span class="comment">// 初始化时的代码：</span></span><br><span class="line"><span class="comment">// mDisplayAreaPolicyProvider = DisplayAreaPolicy.Provider.fromResources(</span></span><br><span class="line"><span class="comment">//            mContext.getResources());</span></span><br><span class="line">mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(</span><br><span class="line">        mWmService, <span class="built_in">this</span> <span class="comment">/* content */</span>, <span class="built_in">this</span> <span class="comment">/* root */</span>, mImeWindowsContainer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DisplayAreaPolicy.java</span></span><br><span class="line"><span class="keyword">static</span> Provider <span class="title function_">fromResources</span><span class="params">(Resources res)</span> &#123;</span><br><span class="line">    <span class="comment">// config_deviceSpecificDisplayAreaPolicyProvider用于特定屏幕设备的DisplayAreaPolicy初始化</span></span><br><span class="line">    <span class="comment">// 一般都是个空值，除非屏幕设备特殊</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> res.getString(</span><br><span class="line">            com.android.internal.R.string.config_deviceSpecificDisplayAreaPolicyProvider);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="comment">// 使用默认的DisplayAreaPolicy初始化构造器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DisplayAreaPolicy</span>.DefaultProvider();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static final class DefaultProvider implements DisplayAreaPolicy.Provider</span></span><br><span class="line"><span class="keyword">public</span> DisplayAreaPolicy <span class="title function_">instantiate</span><span class="params">(WindowManagerService wmService,</span></span><br><span class="line"><span class="params">        DisplayContent content, RootDisplayArea root,</span></span><br><span class="line"><span class="params">        DisplayArea.Tokens imeContainer)</span> &#123;</span><br><span class="line">    <span class="comment">// FEATURE_DEFAULT_TASK_CONTAINER 默认任务容器所在的显示区域</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskDisplayArea</span> <span class="variable">defaultTaskDisplayArea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDisplayArea</span>(content, wmService,</span><br><span class="line">            <span class="string">&quot;DefaultTaskDisplayArea&quot;</span>, FEATURE_DEFAULT_TASK_CONTAINER);</span><br><span class="line">    <span class="keyword">final</span> List&lt;TaskDisplayArea&gt; tdaList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    tdaList.add(defaultTaskDisplayArea);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层次结构生成， 将在此基础上构建DisplayArea层次结构。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">HierarchyBuilder</span> <span class="variable">rootHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HierarchyBuilder</span>(root);</span><br><span class="line">    <span class="comment">// 设置基本容器（即使显示器不支持输入法）以及设置mTaskDisplayAreas集合</span></span><br><span class="line">    rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);</span><br><span class="line">    <span class="comment">// 这个就是确认Display是否包含FLAG_TRUSTED, 一般是包含的</span></span><br><span class="line">    <span class="keyword">if</span> (content.isTrusted()) &#123;</span><br><span class="line">        <span class="comment">// 1.2.1.3 设置rootHierarchy中的feature</span></span><br><span class="line">        configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.1.4 实例化DisplayAreaPolicy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DisplayAreaPolicyBuilder</span>().setRootHierarchy(rootHierarchy).build(wmService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了名为”DefaultTaskDisplayArea”的显示区域-TaskDisplayArea，并将其放入层次结构生成器中，然后设置该层次结构生成器的相应参数，最后通过DisplayAreaPolicyBuilder实例化DisplayAreaPolicy。</p>
<p>注意传入的content和root都是DisplayContent本身。</p>
<h4 id="1-2-1-3-DisplayAreaPolicy-DefaultProvider-configureTrustedHierarchyBuilder"><a href="#1-2-1-3-DisplayAreaPolicy-DefaultProvider-configureTrustedHierarchyBuilder" class="headerlink" title="1.2.1.3 DisplayAreaPolicy.DefaultProvider.configureTrustedHierarchyBuilder"></a>1.2.1.3 DisplayAreaPolicy.DefaultProvider.configureTrustedHierarchyBuilder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureTrustedHierarchyBuilder</span><span class="params">(HierarchyBuilder rootHierarchy,</span></span><br><span class="line"><span class="params">        WindowManagerService wmService, DisplayContent content)</span> &#123;</span><br><span class="line">    <span class="comment">// 窗口放大应该在顶部，因为只有一个表面被放大</span></span><br><span class="line">    rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;WindowedMagnification&quot;</span>, FEATURE_WINDOWED_MAGNIFICATION)</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (content.isDefaultDisplay) &#123;</span><br><span class="line">        <span class="comment">// 只有默认显示可以有剪切</span></span><br><span class="line">        <span class="comment">// See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked.</span></span><br><span class="line">        rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;HideDisplayCutout&quot;</span>, FEATURE_HIDE_DISPLAY_CUTOUT)</span><br><span class="line">                ......</span><br><span class="line">                .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;OneHandedBackgroundPanel&quot;</span>, FEATURE_ONE_HANDED_BACKGROUND_PANEL)</span><br><span class="line">                ......</span><br><span class="line">                .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;OneHanded&quot;</span>, FEATURE_ONE_HANDED)</span><br><span class="line">    &#125;</span><br><span class="line">    rootHierarchy</span><br><span class="line">            .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;FullscreenMagnification&quot;</span>, FEATURE_FULLSCREEN_MAGNIFICATION)</span><br><span class="line">            ......</span><br><span class="line">            .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;ImePlaceholder&quot;</span>, FEATURE_IME_PLACEHOLDER)</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里的层次结构对应DisplayContent所处的DisplayId是默认的显示设备即DEFAULT_DISPLA，默认是添加6个FEATURE：</p>
<ol>
<li>FEATURE_WINDOWED_MAGNIFICATION: 可以放大的显示区域(比如无障碍里的放大镜)</li>
<li>FEATURE_HIDE_DISPLAY_CUTOUT: 用于隐藏显示裁剪功能的显示区域</li>
<li>FEATURE_ONE_HANDED_BACKGROUND_PANEL:显示区域为单手背景层</li>
<li>FEATURE_ONE_HANDED: 单手功能的显示区域</li>
<li>FEATURE_FULLSCREEN_MAGNIFICATION: 可以放大的显示区域,但这个是整个显示放大</li>
<li>FEATURE_IME_PLACEHOLDER: 可以放置IME(输入法窗口)容器的显示区域</li>
</ol>
<p>注意这里的顺序比较重要。</p>
<h4 id="1-2-1-4-DisplayAreaPolicyBuilder-build"><a href="#1-2-1-4-DisplayAreaPolicyBuilder-build" class="headerlink" title="1.2.1.4 DisplayAreaPolicyBuilder.build"></a>1.2.1.4 DisplayAreaPolicyBuilder.build</h4><p>可以看到DisplayAreaPolicy的构建其实是采用build设计模式，最后由DisplayAreaPolicyBuilder生成DisplayAreaPolicy：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DisplayAreaPolicyBuilder.java</span></span><br><span class="line">Result <span class="title function_">build</span><span class="params">(WindowManagerService wmService)</span> &#123;</span><br><span class="line">    validate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将窗口添加到组层次结构之前，将DisplayArea组根附加到屏幕层次结构</span></span><br><span class="line">    <span class="comment">// 这里的mRootHierarchyBuilder就是上面DefaultProvider.instantiate初始化的rootHierarchy</span></span><br><span class="line">    mRootHierarchyBuilder.build(mDisplayAreaGroupHierarchyBuilders);</span><br><span class="line">    List&lt;RootDisplayArea&gt; displayAreaGroupRoots = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            mDisplayAreaGroupHierarchyBuilders.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mDisplayAreaGroupHierarchyBuilders.size(); i++) &#123;</span><br><span class="line">        <span class="type">HierarchyBuilder</span> <span class="variable">hierarchyBuilder</span> <span class="operator">=</span> mDisplayAreaGroupHierarchyBuilders.get(i);</span><br><span class="line">        hierarchyBuilder.build();</span><br><span class="line">        displayAreaGroupRoots.add(hierarchyBuilder.mRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用默认的DefaultSelectRootForWindowFunction</span></span><br><span class="line">    <span class="keyword">if</span> (mSelectRootForWindowFunc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// RootHierarchyBuilder.mRoot就是创建的DisplayContent</span></span><br><span class="line">        mSelectRootForWindowFunc = <span class="keyword">new</span> <span class="title class_">DefaultSelectRootForWindowFunction</span>(</span><br><span class="line">                mRootHierarchyBuilder.mRoot, displayAreaGroupRoots);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(wmService, mRootHierarchyBuilder.mRoot, displayAreaGroupRoots,</span><br><span class="line">            mSelectRootForWindowFunc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultSelectRootForWindowFunction的构造</span></span><br><span class="line">DefaultSelectRootForWindowFunction(RootDisplayArea displayRoot,</span><br><span class="line">        List&lt;RootDisplayArea&gt; displayAreaGroupRoots) &#123;</span><br><span class="line">    <span class="comment">// 所以mDisplayRoot其实就是拥有该DisplayAreaPolicy的DisplayContent</span></span><br><span class="line">    mDisplayRoot = displayRoot;</span><br><span class="line">    mDisplayAreaGroupRoots = Collections.unmodifiableList(displayAreaGroupRoots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回的是DisplayAreaPolicyBuilder.Result类对象。并且其TaskDisplayArea是FEATURE_DEFAULT_TASK_CONTAINER，表示默认任务容器所在的显示区域。</p>
<h3 id="1-2-2-WindowToken的创建"><a href="#1-2-2-WindowToken的创建" class="headerlink" title="1.2.2 WindowToken的创建"></a>1.2.2 WindowToken的创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br></pre></td></tr></table></figure>

<p>这里的attrs.token我们之前也分析了，其实就是Activity里的mToken.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type, <span class="type">boolean</span> persistOnEmpty,</span><br><span class="line">        DisplayContent dc, <span class="type">boolean</span> ownerCanManageAppTokens, <span class="type">boolean</span> roundedCornerOverlay,</span><br><span class="line">        <span class="type">boolean</span> fromClientToken, <span class="meta">@Nullable</span> Bundle options) &#123;</span><br><span class="line">    <span class="built_in">super</span>(service);</span><br><span class="line">    <span class="comment">// WindowToken中保存了来自Activity的mToken</span></span><br><span class="line">    token = _token;</span><br><span class="line">    windowType = type;</span><br><span class="line">    mOptions = options;</span><br><span class="line">    mPersistOnEmpty = persistOnEmpty;</span><br><span class="line">    mOwnerCanManageAppTokens = ownerCanManageAppTokens;</span><br><span class="line">    mRoundedCornerOverlay = roundedCornerOverlay;</span><br><span class="line">    mFromClientToken = fromClientToken;</span><br><span class="line">    <span class="comment">// DisplayContent 不是null的</span></span><br><span class="line">    <span class="keyword">if</span> (dc != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将该WindowToken添加到DisplayContent中</span></span><br><span class="line">        dc.addWindowToken(token, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将该WindowToken添加到DisplayContent中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addWindowToken</span><span class="params">(IBinder binder, WindowToken token)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将该token保存至mTokenMap中，注意这里的key是binder，即对应Activity中的mToken(LocalActivityRecord)</span></span><br><span class="line">    mTokenMap.put(binder, token);</span><br><span class="line">    <span class="comment">// 判断该WindowToken是否是ActivityRecord，这里并不是</span></span><br><span class="line">    <span class="keyword">if</span> (token.asActivityRecord() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将该WindowToken的DisplayContent赋值为当前DisplayContent</span></span><br><span class="line">        token.mDisplayContent = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 该token对应Activity的Window类型是TYPE_BASE_APPLICATION</span></span><br><span class="line">        <span class="keyword">switch</span> (token.windowType) &#123;</span><br><span class="line">            <span class="keyword">case</span> TYPE_INPUT_METHOD:</span><br><span class="line">            <span class="keyword">case</span> TYPE_INPUT_METHOD_DIALOG:</span><br><span class="line">                mImeWindowsContainer.addChild(token);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 将该token保存至mDisplayAreaPolicy中</span></span><br><span class="line">                mDisplayAreaPolicy.addWindow(token);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mDisplayAreaPolicy是该DisplayContent初始化时创建的，所以 mDisplayAreaPolicy.addWindow(token) 其实是调用了 DisplayAreaPolicyBuilder.Result.addWindow：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWindow</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    DisplayArea.<span class="type">Tokens</span> <span class="variable">area</span> <span class="operator">=</span> findAreaForToken(token);</span><br><span class="line">    area.addChild(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    <span class="comment">// mSelectRootForWindowFunc就是DefaultSelectRootForWindowFunction</span></span><br><span class="line">    <span class="keyword">return</span> mSelectRootForWindowFunc.apply(token.windowType, token.mOptions)</span><br><span class="line">            .findAreaForToken(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mSelectRootForWindowFunc一般都是DefaultSelectRootForWindowFunction：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RootDisplayArea <span class="title function_">apply</span><span class="params">(Integer windowType, Bundle options)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayAreaGroupRoots.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> mDisplayRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认mDisplayAreaGroupRoots中只有一个RootDisplayArea，也就是mDisplayRoot，（CTS测试会有多个）</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">null</span> &amp;&amp; options.containsKey(KEY_ROOT_DISPLAY_AREA_ID)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">rootId</span> <span class="operator">=</span> options.getInt(KEY_ROOT_DISPLAY_AREA_ID);</span><br><span class="line">        <span class="keyword">if</span> (mDisplayRoot.mFeatureId == rootId) &#123;</span><br><span class="line">            <span class="keyword">return</span> mDisplayRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mDisplayAreaGroupRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDisplayAreaGroupRoots.get(i).mFeatureId == rootId) &#123;</span><br><span class="line">                <span class="keyword">return</span> mDisplayAreaGroupRoots.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDisplayRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mSelectRootForWindowFunc.apply(token.windowType, token.mOptions).findAreaForToken(token)其实是根据Window类型和Window所在的显示屏幕来选择应该将此WindowToken放入哪个RootDisplayArea中存储。</p>
<p>一般来说，mDisplayAreaGroupRoots中只有一个元素，即mDisplayRoot，也就是DisplayContent（猜猜什么情况下会有多个DisplayContent？）。所以这个方法其实等效于：mDisplayRoot.findAreaForToken，这里的mDisplayRoot就是DisplayContent：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findAreaForToken(token.windowType, token.mOwnerCanManageAppTokens,</span><br><span class="line">            token.mRoundedCornerOverlay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(<span class="type">int</span> windowType, <span class="type">boolean</span> ownerCanManageAppTokens,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> roundedCornerOverlay)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取window类型对应的layer，getWindowLayerFromTypeLw看[Window类型转Layer](#222-windowmanagerpolicygetwindowlayerfromtypelw)。</span></span><br><span class="line">    <span class="comment">// 一般应用的window类型是 TYPE_BASE_APPLICATION （值为1，handleResumeActivity中赋值的）</span></span><br><span class="line">    <span class="comment">// 所以windowLayerFromType就是APPLICATION_LAYER！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">windowLayerFromType</span> <span class="operator">=</span> mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,</span><br><span class="line">            ownerCanManageAppTokens, roundedCornerOverlay);</span><br><span class="line">    <span class="comment">// 所以这里就会抛出异常？？？</span></span><br><span class="line">    <span class="keyword">if</span> (windowLayerFromType == APPLICATION_LAYER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAreaForLayer[windowLayerFromType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Activity对应的windowType是TYPE_BASE_APPLICATION，所以拿到的windowLayerFromType就是APPLICATION_LAYER，那么这里必然会抛出异常！这个疑问我们后续分析，先看返回值，这里最终是返回了RootDisplayArea中mAreaForLayer数组对应存储的对象，接下来我们看看这个数组是如何被创建。</p>
<h1 id="二-RootDisplayArea的构造"><a href="#二-RootDisplayArea的构造" class="headerlink" title="二. RootDisplayArea的构造"></a>二. RootDisplayArea的构造</h1><h2 id="2-1-HierarchyBuilder-build"><a href="#2-1-HierarchyBuilder-build" class="headerlink" title="2.1 HierarchyBuilder.build"></a>2.1 HierarchyBuilder.build</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="meta">@Nullable</span> List&lt;HierarchyBuilder&gt; displayAreaGroupHierarchyBuilders)</span> &#123;</span><br><span class="line">    <span class="comment">// ------ 第一部分 --------</span></span><br><span class="line">    <span class="comment">// 这个mPolicy就是WMS服务初始化时候创建的PhoneWindowManager</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowManagerPolicy</span> <span class="variable">policy</span> <span class="operator">=</span> mRoot.mWmService.mPolicy;</span><br><span class="line">    <span class="comment">// getMaxWindowLayer值目前是固定的36，也就是窗口Layer最大不能超过36，稍后我们就知道为什么是36了！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxWindowLayerCount</span> <span class="operator">=</span> policy.getMaxWindowLayer() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> DisplayArea.Tokens[] displayAreaForLayer =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DisplayArea</span>.Tokens[maxWindowLayerCount];</span><br><span class="line">    <span class="comment">// 由前面的分析可知，这里的feature数目是6个</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; featureAreas =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;(mFeatures.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mFeatures.size(); i++) &#123;</span><br><span class="line">        featureAreas.put(mFeatures.get(i), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// PendingArea是一个树形结构, 以下使用PA替代</span></span><br><span class="line">    PendingArea[] areaForLayer = <span class="keyword">new</span> <span class="title class_">PendingArea</span>[maxWindowLayerCount];</span><br><span class="line">    <span class="comment">// 创建根PA，并用其填充上面创建的36个PA数组，也就是每一个PA对应一个WindowLayer</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">PendingArea</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 注意这里areaForLayer数组中每一个元素都是root，而不是copy了一个PA</span></span><br><span class="line">    Arrays.fill(areaForLayer, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------ 第二部分 --------</span></span><br><span class="line">    <span class="comment">// 创建显示区域以覆盖所有的Feature</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mFeatures.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Feature</span> <span class="variable">feature</span> <span class="operator">=</span> mFeatures.get(i);</span><br><span class="line">        <span class="type">PendingArea</span> <span class="variable">featureArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">            <span class="comment">// Feature的mWindowLayers是一个boolean类型的数组，但是该值又是什么意思呢？</span></span><br><span class="line">            <span class="comment">// 这里我们先打断一下，看看Feature是怎么构造的--[2.2.3](DisplayAreaPolicyBuilder.Feature的构造)</span></span><br><span class="line">            <span class="keyword">if</span> (feature.mWindowLayers[layer]) &#123;</span><br><span class="line">                <span class="comment">// 此功能将应用于此窗口层。为它找到一个显示区：</span></span><br><span class="line">                <span class="comment">// 可以重用现有的一个，如果它是为上一层的此功能创建的，并且应用到上一层的最后一个功能与应用到当前层的功能相同（因此它们可以共享相同的父显示区域）</span></span><br><span class="line">                <span class="keyword">if</span> (featureArea == <span class="literal">null</span> || featureArea.mParent != areaForLayer[layer]) &#123;</span><br><span class="line">                    <span class="comment">// 没有合适的显示区域：</span></span><br><span class="line">                    <span class="comment">// 在该层的上一个区域（作为父对象）下创建一个新区域。</span></span><br><span class="line">                    featureArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(feature, layer, areaForLayer[layer]);</span><br><span class="line">                    areaForLayer[layer].mChildren.add(featureArea);</span><br><span class="line">                &#125;</span><br><span class="line">                areaForLayer[layer] = featureArea;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此功能不会应用于此窗口层。如果需要应用到下一层，需要为此创建一个新的显示区域。</span></span><br><span class="line">                featureArea = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------ 第三部分 --------</span></span><br><span class="line">    <span class="comment">// 为每个层创建Tokens作为叶子</span></span><br><span class="line">    <span class="type">PendingArea</span> <span class="variable">leafArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leafType</span> <span class="operator">=</span> LEAF_TYPE_TOKENS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">        <span class="comment">// 2.2.1 获取当前layer类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> typeOfLayer(policy, layer);</span><br><span class="line">        <span class="comment">// 检查我们是否可以重用上一层的相同Tokens。如果上一个图层与当前图层的类型相同，并且没有仅应用于其中一个图层的功能，则会发生这种情况。</span></span><br><span class="line">        <span class="keyword">if</span> (leafArea == <span class="literal">null</span> || leafArea.mParent != areaForLayer[layer]</span><br><span class="line">                || type != leafType) &#123;</span><br><span class="line">            <span class="comment">// 为当前layer创建新的Tokens</span></span><br><span class="line">            leafArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span> <span class="comment">/* feature */</span>, layer, areaForLayer[layer]);</span><br><span class="line">            areaForLayer[layer].mChildren.add(leafArea);</span><br><span class="line">            leafType = type;</span><br><span class="line">            <span class="keyword">if</span> (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123;</span><br><span class="line">                <span class="comment">// 我们使用传入的TaskDisplayAreas作为层的任务容器类型。</span></span><br><span class="line">                <span class="comment">// 即使没有TaskDisplayArea，也不要创建Tokens。</span></span><br><span class="line">                addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);</span><br><span class="line">                addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],</span><br><span class="line">                        displayAreaGroupHierarchyBuilders);</span><br><span class="line">                leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leafType == LEAF_TYPE_IME_CONTAINERS) &#123;</span><br><span class="line">                <span class="comment">// 我们使用传入的ImeContainer作为层的ime容器类型。</span></span><br><span class="line">                <span class="comment">// 即使没有ime容器，也不要创建Tokens。</span></span><br><span class="line">                leafArea.mExisting = mImeContainer;</span><br><span class="line">                leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leafArea.mMaxLayer = layer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------ 第四部分 --------</span></span><br><span class="line">    <span class="comment">// [2.5.1]计算最大layer</span></span><br><span class="line">    root.computeMaxLayer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [2.5.2]构建了一个PendingAreas树，其中包含表示层次结构的所有必要信息，现在创建并将真实的显示区域附加到根目录</span></span><br><span class="line">    root.instantiateChildren(mRoot, displayAreaForLayer, <span class="number">0</span>, featureAreas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [2.5.3]完成DisplayArea的创建，缓存结果便于快速访问</span></span><br><span class="line">    mRoot.onHierarchyBuilt(mFeatures, displayAreaForLayer, featureAreas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法使用以下属性构造图层层次结构：</p>
<ol>
<li>每个Feature映射到一组显示区域(PendingArea)</li>
<li>添加窗口后，对于该窗口类型所属的每个要素，它都是该要素的相应显示区域之一的后代。</li>
<li>保持Z顺序，即如果Z范围（区域）表示显示区域内的窗口层集：<br> 对于每对DisplayArea同级(a，b)，其中a低于b，它保持 max(z-range(a)) &lt;&#x3D; min(z-range(b))</li>
</ol>
<p>下面的算法迭代地创建这样一个层次结构：<br>-最初，所有窗口都附加到根目录。<br>-对于每个feature，我们通过在层上循环创建一组显示区域<br>-如果该feature确实适用于当前层，我们需要为它找到一个显示区域以满足（2）<br>-如果当前feature也适用于前一层（满足（3）），并且应用于前一层的最后一个特征与应用于当前层的最后一个特征相同（满足（2）），我们可以重用前一层的区域<br>-否则，我们将在应用于当前层的最后一个功能下面创建一个新的显示区域</p>
<p>云里雾里的，看不懂啊, 将这段代码分成四个部分，逐一解析。</p>
<h2 id="2-2-build的第一部分-layer-feature"><a href="#2-2-build的第一部分-layer-feature" class="headerlink" title="2.2 build的第一部分 - layer, feature"></a>2.2 build的第一部分 - layer, feature</h2><h3 id="2-2-1-layer类型-–-HierarchyBuilder-typeOfLayer"><a href="#2-2-1-layer类型-–-HierarchyBuilder-typeOfLayer" class="headerlink" title="2.2.1 layer类型 – HierarchyBuilder.typeOfLayer"></a>2.2.1 layer类型 – HierarchyBuilder.typeOfLayer</h3><p>此方法获取layer对应的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">typeOfLayer</span><span class="params">(WindowManagerPolicy policy, <span class="type">int</span> layer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (layer == APPLICATION_LAYER) &#123;</span><br><span class="line">        <span class="keyword">return</span> LEAF_TYPE_TASK_CONTAINERS;</span><br><span class="line">    <span class="comment">// 2.2.2 获取输入法对应的layer类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)</span><br><span class="line">            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) &#123;</span><br><span class="line">        <span class="keyword">return</span> LEAF_TYPE_IME_CONTAINERS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LEAF_TYPE_TOKENS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里的layer类型有三种:</p>
<ol>
<li>LEAF_TYPE_TOKENS: tokens的layer</li>
<li>LEAF_TYPE_TASK_CONTAINERS: 作为Task的layer</li>
<li>LEAF_TYPE_IME_CONTAINERS: 作为输入法的layer</li>
</ol>
<p>其次当layer&#x3D;2时，其type为LEAF_TYPE_TASK_CONTAINERS；当layer&#x3D;15或16时，其type为LEAF_TYPE_IME_CONTAINERS；其余layer都是LEAF_TYPE_TOKENS类型。</p>
<h3 id="2-2-2-WindowManagerPolicy-getWindowLayerFromTypeLw"><a href="#2-2-2-WindowManagerPolicy-getWindowLayerFromTypeLw" class="headerlink" title="2.2.2 WindowManagerPolicy.getWindowLayerFromTypeLw"></a>2.2.2 WindowManagerPolicy.getWindowLayerFromTypeLw</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getWindowLayerFromTypeLw</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> canAddInternalSystemWindow,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> roundedCornerOverlay)</span> &#123;</span><br><span class="line">    <span class="comment">// 始终将圆角层放在最上面, 所以返回的layer类型就是对应最大的layer index</span></span><br><span class="line">    <span class="comment">// 所谓圆角层是指手机屏幕的四个角，现在大多时候圆角，会用一层黑色覆盖避免硬件显示的毛刺</span></span><br><span class="line">    <span class="comment">// 这样也容易调整角的弧度，使得出厂机器表现一致</span></span><br><span class="line">    <span class="keyword">if</span> (roundedCornerOverlay &amp;&amp; canAddInternalSystemWindow) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMaxWindowLayer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 窗口类型是应用窗口时，返回的layer就是APPLICATION_LAYER（2）</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_LAYER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TYPE_WALLPAPER:</span><br><span class="line">            <span class="comment">// 墙纸在底部，不过可能会被WindowManager移动</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> TYPE_POINTER:</span><br><span class="line">            <span class="comment">// （鼠标）指针层</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="number">35</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Slog.e(<span class="string">&quot;WindowManager&quot;</span>, <span class="string">&quot;Unknown window type: &quot;</span> + type);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就可以解答刚刚的疑问了，为什么layer数量是36了，在考虑上面Window类型和Layer类型的对应，可以想到，layer类型的也是其Z轴的位置！</p>
<table>
<thead>
<tr>
<th>Window类型</th>
<th>值</th>
<th>作用</th>
<th>Layer(Z轴)</th>
</tr>
</thead>
<tbody><tr>
<td>TYPE_WALLPAPER</td>
<td>2013</td>
<td>壁纸窗口</td>
<td>1</td>
</tr>
<tr>
<td>[FIRST_APPLICATION_WINDOW,<br>LAST_APPLICATION_WINDOW]</td>
<td>[1, 99]</td>
<td>应用窗口</td>
<td>2</td>
</tr>
<tr>
<td>TYPE_PRESENTATION<br>TYPE_PRIVATE_PRESENTATION<br>TYPE_DOCK_DIVIDER<br>TYPE_QS_DIALOG<br>TYPE_PHONE</td>
<td>2037<br>2030<br>2034<br>2035<br>2002</td>
<td>*在外部显示器上显示的窗口<br>*在专用屏幕上方显示的窗口<br>*显示调整docked堆栈大小的窗口<br>*用于快速设置的窗口<br>*phone窗口，比如来电窗口</td>
<td>3</td>
</tr>
<tr>
<td>TYPE_SEARCH_BAR<br>TYPE_VOICE_INTERACTION_STARTING</td>
<td>2001<br>2033</td>
<td>*搜索栏窗口,位于屏幕顶部<br>*语音交互层的启动窗口</td>
<td>4</td>
</tr>
<tr>
<td>TYPE_VOICE_INTERACTION</td>
<td>2031</td>
<td>语音交互层窗口</td>
<td>5</td>
</tr>
<tr>
<td>TYPE_INPUT_CONSUMER</td>
<td>2022</td>
<td>systemUI栏隐藏时使用输入事件的窗口</td>
<td>6</td>
</tr>
<tr>
<td>TYPE_SYSTEM_DIALOG</td>
<td>2008</td>
<td>从状态栏滑出的面板窗口</td>
<td>7</td>
</tr>
<tr>
<td>TYPE_TOAST</td>
<td>2005</td>
<td>临时通知窗口，即toast窗口</td>
<td>8</td>
</tr>
<tr>
<td>TYPE_PRIORITY_PHONE</td>
<td>2007</td>
<td>优先电话UI界面</td>
<td>9</td>
</tr>
<tr>
<td>TYPE_SYSTEM_ALERT</td>
<td>2003</td>
<td>系统窗口，比如低电Dialog或者ANR之类</td>
<td>10或者13</td>
</tr>
<tr>
<td>TYPE_APPLICATION_OVERLAY</td>
<td>2038</td>
<td>应用覆盖窗口,在所有窗口的上方<br>但在关键系统窗口（如状态栏）的下方<br>需要SYSTEM_ALERT_WINDOW权限</td>
<td>12</td>
</tr>
<tr>
<td>TYPE_INPUT_METHOD</td>
<td>2011</td>
<td>内部输入法窗口，显示在普通用户界面上方。<br>可以调整应用窗口的大小或平移，以在显示<br>此窗口时保持输入焦点可见</td>
<td>15</td>
</tr>
<tr>
<td>TYPE_INPUT_METHOD_DIALOG</td>
<td>2012</td>
<td>显示在当前输入法窗口上方的内部输入法<br>对话框窗口</td>
<td>16</td>
</tr>
<tr>
<td>TYPE_STATUS_BAR</td>
<td>2000</td>
<td>状态栏</td>
<td>17</td>
</tr>
<tr>
<td>TYPE_STATUS_BAR_ADDITIONAL</td>
<td>2041</td>
<td>用于在屏幕的非常规部分（即屏幕的左侧或<br>底部）显示状态栏窗口</td>
<td>18</td>
</tr>
<tr>
<td>TYPE_NOTIFICATION_SHADE</td>
<td>2040</td>
<td>状态栏下拉的通知栏窗口和keyguard</td>
<td>19</td>
</tr>
<tr>
<td>TYPE_STATUS_BAR_SUB_PANEL</td>
<td>2017</td>
<td>从状态栏滑出的面板窗口</td>
<td>20</td>
</tr>
<tr>
<td>TYPE_KEYGUARD_DIALOG</td>
<td>2009</td>
<td>keyguard创建的对话框窗口</td>
<td>21</td>
</tr>
<tr>
<td>TYPE_VOLUME_OVERLAY</td>
<td>2020</td>
<td>音量调整窗口</td>
<td>22</td>
</tr>
<tr>
<td>TYPE_SYSTEM_OVERLAY</td>
<td>2006</td>
<td>系统覆盖窗口，需要显示在所有其他窗口之上。<br>这些窗口不能获取输入焦点，否则会干扰keyguard</td>
<td>23或者11</td>
</tr>
<tr>
<td>TYPE_NAVIGATION_BAR</td>
<td>2019</td>
<td>导航栏窗口，即虚拟按键的窗口</td>
<td>24</td>
</tr>
<tr>
<td>TYPE_NAVIGATION_BAR_PANEL</td>
<td>2024</td>
<td>导航栏面板窗口</td>
<td>25</td>
</tr>
<tr>
<td>TYPE_SCREENSHOT</td>
<td>2036</td>
<td>截图窗口,用于屏幕截图动画、区域选择和UI</td>
<td>26</td>
</tr>
<tr>
<td>TYPE_SYSTEM_ERROR</td>
<td>2010</td>
<td>内部系统错误窗口</td>
<td>27或者10</td>
</tr>
<tr>
<td>TYPE_MAGNIFICATION_OVERLAY</td>
<td>2027</td>
<td>放大覆盖窗口。启用辅助功能放大时，用于<br>突出显示的放大部分</td>
<td>28</td>
</tr>
<tr>
<td>TYPE_DISPLAY_OVERLAY</td>
<td>2026</td>
<td>显示覆盖窗口。用于模拟辅助显示设备</td>
<td>29</td>
</tr>
<tr>
<td>TYPE_DRAG</td>
<td>2016</td>
<td>拖放窗口</td>
<td>30</td>
</tr>
<tr>
<td>TYPE_ACCESSIBILITY_OVERLAY</td>
<td>2032</td>
<td>无障碍辅助窗口</td>
<td>31</td>
</tr>
<tr>
<td>TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY</td>
<td>2039</td>
<td>无障碍辅助放大窗口</td>
<td>32</td>
</tr>
<tr>
<td>TYPE_SECURE_SYSTEM_OVERLAY</td>
<td>2015</td>
<td>安全系统覆盖窗口。<br>这些窗口不能获取输入焦点，否则会干扰keyguard</td>
<td>33</td>
</tr>
<tr>
<td>TYPE_BOOT_PROGRESS</td>
<td>2021</td>
<td>开机动画之后的启动对话框窗口</td>
<td>34</td>
</tr>
<tr>
<td>TYPE_POINTER</td>
<td>2018</td>
<td>鼠标指针窗口。如轨迹追踪球</td>
<td>35</td>
</tr>
<tr>
<td>-</td>
<td>roundedCornerOverlay&#x3D;true<br>canAddInternalSystemWindow&#x3D;true</td>
<td>圆角层，始终在最上面</td>
<td>36</td>
</tr>
</tbody></table>
<p>在分析DisplayArea的构造时，首先需要了解下这些类的作用：Feature、Feature.Builder、HierarchyBuilder：</p>
<h3 id="2-2-3-DisplayAreaPolicyBuilder-Feature的构造"><a href="#2-2-3-DisplayAreaPolicyBuilder-Feature的构造" class="headerlink" title="2.2.3 DisplayAreaPolicyBuilder.Feature的构造"></a>2.2.3 DisplayAreaPolicyBuilder.Feature的构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Feature</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span>[] mWindowLayers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NewDisplayAreaSupplier mNewDisplayAreaSupplier;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意mWindowLayers是一个boolean数组，这里的feature有如下几种：</p>
<table>
<thead>
<tr>
<th>Feature Name</th>
<th>ID</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>FEATURE_ROOT</td>
<td>0</td>
<td>表示该逻辑显示设备上的根显示区域</td>
</tr>
<tr>
<td>FEATURE_DEFAULT_TASK_CONTAINER</td>
<td>1</td>
<td>默认任务容器所在的显示区域</td>
</tr>
<tr>
<td>FEATURE_WINDOW_TOKENS</td>
<td>2</td>
<td>无Activity的显示区域</td>
</tr>
<tr>
<td>FEATURE_ONE_HANDED</td>
<td>3</td>
<td>单手功能的显示区域</td>
</tr>
<tr>
<td>FEATURE_WINDOWED_MAGNIFICATION</td>
<td>4</td>
<td>可以放大的显示区域。包含在{@link WindowManager.LayoutParams#TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY}下面的所有窗口</td>
</tr>
<tr>
<td>FEATURE_FULLSCREEN_MAGNIFICATION</td>
<td>5</td>
<td>可以放大的显示区域,但这个是整个显示放大</td>
</tr>
<tr>
<td>FEATURE_HIDE_DISPLAY_CUTOUT</td>
<td>6</td>
<td>用于隐藏显示裁剪功能的显示区域</td>
</tr>
<tr>
<td>FEATURE_IME_PLACEHOLDER</td>
<td>7</td>
<td>可以放置IME容器的显示区域。当IME目标改变时，如果IME容器可能被重表示为该层次结构，那么应该在每个根层次结构上启用。</td>
</tr>
<tr>
<td>FEATURE_ONE_HANDED_BACKGROUND_PANEL</td>
<td>8</td>
<td>显示区域为单手背景层，防止用户在打开暗主题时，无法清楚地识别屏幕已进入单手模式。</td>
</tr>
<tr>
<td>FEATURE_SYSTEM_LAST</td>
<td>10000</td>
<td>系统特征显示区的最后一个id，作为边界</td>
</tr>
<tr>
<td>FEATURE_VENDOR_FIRST</td>
<td>10001</td>
<td>供应商特定的显示区域定义可以从该值开始</td>
</tr>
<tr>
<td>FEATURE_VENDOR_LAST</td>
<td>20001</td>
<td>供应商特定的显示区域定义用该值作为边界</td>
</tr>
<tr>
<td>FEATURE_RUNTIME_TASK_CONTAINER_FIRST</td>
<td>20002</td>
<td>可以在运行时创建的任务显示区域以此值开始</td>
</tr>
</tbody></table>
<h3 id="2-2-4-DisplayAreaPolicyBuilder-Feature-Builder"><a href="#2-2-4-DisplayAreaPolicyBuilder-Feature-Builder" class="headerlink" title="2.2.4 DisplayAreaPolicyBuilder.Feature.Builder"></a>2.2.4 DisplayAreaPolicyBuilder.Feature.Builder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerPolicy mPolicy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span>[] mLayers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">NewDisplayAreaSupplier</span> <span class="variable">mNewDisplayAreaSupplier</span> <span class="operator">=</span> DisplayArea::<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mExcludeRoundedCorner</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Builder(WindowManagerPolicy policy, String name, <span class="type">int</span> id) &#123;</span><br><span class="line">        mPolicy = policy;</span><br><span class="line">        mName = name;</span><br><span class="line">        mId = id;</span><br><span class="line">        <span class="comment">// mPolicy.getMaxWindowLayer = 36</span></span><br><span class="line">        mLayers = <span class="keyword">new</span> <span class="title class_">boolean</span>[mPolicy.getMaxWindowLayer() + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Feature <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mExcludeRoundedCorner) &#123;</span><br><span class="line">            <span class="comment">// 将mLayers[36]置为false</span></span><br><span class="line">            mLayers[mPolicy.getMaxWindowLayer()] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// builder中的mLayers就是Feature中的mWindowLayers</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Feature</span>(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意看这里的mLayers，也是一个boolean数组，是一一对应36个layer的。</p>
<p>接下来看看 DisplayAreaPolicyBuilder.Feature.Builder 中关键方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将mLayers中所有元素都置为true</span></span><br><span class="line">Builder <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">    Arrays.fill(mLayers, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个int数组，其元素值代表Window类型,标记这些window窗口对应的layer为true</span></span><br><span class="line">Builder <span class="title function_">and</span><span class="params">(<span class="type">int</span>... types)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> types[i];</span><br><span class="line">        <span class="comment">// 将该Window类型对应的layer置位true</span></span><br><span class="line">        set(type, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个int数组，其元素值代表Window类型, 标记这些window窗口对应的layer为false</span></span><br><span class="line">Builder <span class="title function_">except</span><span class="params">(<span class="type">int</span>... types)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> types[i];</span><br><span class="line">        set(type, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从layer所处z轴从低往高直到typeInclusive类型窗口对应的layer，全部标记为true</span></span><br><span class="line"><span class="comment">// 注意是包含typeInclusive类型的</span></span><br><span class="line">Builder <span class="title function_">upTo</span><span class="params">(<span class="type">int</span> typeInclusive)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> layerFromType(typeInclusive, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        mLayers[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set(typeInclusive, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将window类型为type对应的layer在mLayers中标记为value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">    mLayers[layerFromType(type, <span class="literal">true</span>)] = value;</span><br><span class="line">    <span class="comment">// 当window类型是应用覆盖窗口时，其在所有窗口的上方, 但在关键系统窗口（如状态栏）的下方</span></span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_APPLICATION_OVERLAY) &#123;</span><br><span class="line">        <span class="comment">// 这是多余的一句了。。。</span></span><br><span class="line">        mLayers[layerFromType(type, <span class="literal">true</span>)] = value;</span><br><span class="line">        <span class="comment">// 将TYPE_SYSTEM_ALERT、TYPE_SYSTEM_OVERLAY、TYPE_SYSTEM_ERROR的Layer对应的数组元素也置为true</span></span><br><span class="line">        mLayers[layerFromType(TYPE_SYSTEM_ALERT, <span class="literal">false</span>)] = value;</span><br><span class="line">        mLayers[layerFromType(TYPE_SYSTEM_OVERLAY, <span class="literal">false</span>)] = value;</span><br><span class="line">        mLayers[layerFromType(TYPE_SYSTEM_ERROR, <span class="literal">false</span>)] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">layerFromType</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> internalWindows)</span> &#123;</span><br><span class="line">    <span class="comment">// 所以这个type是window的类型</span></span><br><span class="line">    <span class="keyword">return</span> mPolicy.getWindowLayerFromTypeLw(type, internalWindows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们通过分析FEATURE_WINDOWED_MAGNIFICATION和FEATURE_IME_PLACEHOLDER的构造，来理解，这个Feature的作用</p>
<h4 id="2-2-4-1-FEATURE-WINDOWED-MAGNIFICATION"><a href="#2-2-4-1-FEATURE-WINDOWED-MAGNIFICATION" class="headerlink" title="2.2.4.1 FEATURE_WINDOWED_MAGNIFICATION"></a>2.2.4.1 FEATURE_WINDOWED_MAGNIFICATION</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;WindowedMagnification&quot;</span>,</span><br><span class="line">                    FEATURE_WINDOWED_MAGNIFICATION)</span><br><span class="line">                    .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    <span class="comment">// Make the DA dimmable so that the magnify window also mirrors the dim layer.</span></span><br><span class="line">                    .setNewDisplayAreaSupplier(DisplayArea.Dimmable::<span class="keyword">new</span>)</span><br><span class="line">                    .build());</span><br></pre></td></tr></table></figure>

<p>FEATURE_WINDOWED_MAGNIFICATION的feature构造，注释上标记的是代表可以放大的显示区域(比如无障碍里的放大镜)，名称是”WindowedMagnification”：</p>
<ol>
<li>首先调用 Builder.upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY), TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY的layer对应Z轴值为32，也就是mLayer中0~31的值都是true</li>
<li>调用except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)，将其对应的layer值32置为false</li>
</ol>
<h4 id="2-2-4-2-FEATURE-IME-PLACEHOLDER"><a href="#2-2-4-2-FEATURE-IME-PLACEHOLDER" class="headerlink" title="2.2.4.2 FEATURE_IME_PLACEHOLDER"></a>2.2.4.2 FEATURE_IME_PLACEHOLDER</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;ImePlaceholder&quot;</span>,</span><br><span class="line">                    FEATURE_IME_PLACEHOLDER)</span><br><span class="line">                    .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)</span><br><span class="line">                    .build());</span><br></pre></td></tr></table></figure>

<p>FEATURE_IME_PLACEHOLDER的feature构造，注释上标记的是代表可以放置IME(输入法窗口)容器的显示区域，只有一个最简单的and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG), 也就是仅仅将该feature中mWindowLayers里对应TYPE_INPUT_METHOD(15)和TYPE_INPUT_METHOD_DIALOG(16)的layer置位true, 其他都是false.</p>
<p>好了，大致明白Feature的构造过程，以及mWindowLayers中的值来源，现在在回过头继续看 <a href="#x1-hierarchybuilderbuild">HierarchyBuilder.build</a> 过程。</p>
<h2 id="2-3-build第二部分–PendingArea的构造"><a href="#2-3-build第二部分–PendingArea的构造" class="headerlink" title="2.3 build第二部分–PendingArea的构造"></a>2.3 build第二部分–PendingArea的构造</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mFeatures.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">// 按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Feature</span> <span class="variable">feature</span> <span class="operator">=</span> mFeatures.get(i);</span><br><span class="line">    <span class="type">PendingArea</span> <span class="variable">featureArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">        <span class="comment">// Feature的mWindowLayers是一个boolean类型的数组，但是该值又是什么意思呢？</span></span><br><span class="line">        <span class="comment">// 这里我们先打断一下，看看Feature是怎么构造的--[2.2.3](DisplayAreaPolicyBuilder.Feature的构造)</span></span><br><span class="line">        <span class="keyword">if</span> (feature.mWindowLayers[layer]) &#123;</span><br><span class="line">            <span class="comment">// 此功能将应用于此窗口层。为它找到一个显示区：</span></span><br><span class="line">            <span class="comment">// 可以重用现有的一个，如果它是为上一层的此功能创建的，并且应用到上一层的最后一个功能与应用到当前层的功能相同（因此它们可以共享相同的父显示区域）</span></span><br><span class="line">            <span class="keyword">if</span> (featureArea == <span class="literal">null</span> || featureArea.mParent != areaForLayer[layer]) &#123;</span><br><span class="line">                <span class="comment">// 没有合适的显示区域：</span></span><br><span class="line">                <span class="comment">// 在该层的上一个区域（作为父对象）下创建一个新区域。</span></span><br><span class="line">                featureArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(feature, layer, areaForLayer[layer]);</span><br><span class="line">                areaForLayer[layer].mChildren.add(featureArea);</span><br><span class="line">            &#125;</span><br><span class="line">            areaForLayer[layer] = featureArea;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此功能不会应用于此窗口层。如果需要应用到下一层，需要为此创建一个新的显示区域。</span></span><br><span class="line">            featureArea = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以默认的DisplayContent为例，有6个FEATURE：</p>
<table>
<thead>
<tr>
<th>Feature名</th>
<th>操作</th>
<th>mWindowLayers中为true的元素</th>
<th>mWindowLayers中为false的元素</th>
</tr>
</thead>
<tbody><tr>
<td>FEATURE_WINDOWED_MAGNIFICATION</td>
<td>.upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)<br>.except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</td>
<td>[0,31]</td>
<td>[32,36]</td>
</tr>
<tr>
<td>FEATURE_HIDE_DISPLAY_CUTOUT</td>
<td>.all()<br>.except(TYPE_NAVIGATION_BAR,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_STATUS_BAR,TYPE_NOTIFICATION_SHADE)</td>
<td>all</td>
<td>17,19,24,25</td>
</tr>
<tr>
<td>FEATURE_ONE_HANDED_BACKGROUND_PANEL</td>
<td>.upTo(TYPE_WALLPAPER)</td>
<td>0</td>
<td>[1,36]</td>
</tr>
<tr>
<td>FEATURE_ONE_HANDED</td>
<td>.all()<br>.except(TYPE_NAVIGATION_BAR, <br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL)</td>
<td>all</td>
<td>24,25</td>
</tr>
<tr>
<td>FEATURE_FULLSCREEN_MAGNIFICATION</td>
<td>.all()<br>.except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD_DIALOG<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_MAGNIFICATION_OVERLAY,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL)</td>
<td>all</td>
<td>15,16,24,25,32</td>
</tr>
<tr>
<td>FEATURE_IME_PLACEHOLDER</td>
<td>.and(TYPE_INPUT_METHOD,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD_DIALOG)</td>
<td>15,16</td>
<td>all</td>
</tr>
</tbody></table>
<ol>
<li>第一个feature-FEATURE_WINDOWED_MAGNIFICATION里的mWindowLayers是[0,31]为true,其他位为false, 当此feature遍历完毕之后，areaForLayer数组中[0,31]的元素都是同一个新创建的PA，记为PA_for_WF_0(其mParent为root)， 其他元素都是指向root，而且现在root.mChildren中的唯一元素就是PA_for_WF_0. areaForLayer中的结果如下:<ol>
<li>[0,31] &#x3D; PA_for_WF_0(其mParent为root)</li>
<li>[32,36]&#x3D; root</li>
</ol>
</li>
<li>FEATURE_HIDE_DISPLAY_CUTOUT里除了17,19,24,25号其余都是true：<ol>
<li>当第二个for循环开始时，featureArea为null, 会新建一个PA, 记为PA_for_HDC_0， 并将其保存到root.mChildren中</li>
<li>依次将areaForLayer[0,16]置为PA_for_HDC_0</li>
<li>当layer为17时，因为FEATURE_HIDE_DISPLAY_CUTOUT.mWindowLayers[17]为false, 所以会将featureArea重置为null, 继续</li>
<li>当layer为18时，而FEATURE_HIDE_DISPLAY_CUTOUT.mWindowLayers[18]为true, 所以又创建一个PA, 记为PA_for_HDC_18，并将areaForLayer[18]置为PA_for_HDC_18</li>
<li>重复制止遍历完毕<ol>
<li>现在areaForLayer中的结果如下:<ol>
<li>[0,16] &#x3D; PA_for_HDC_0  (此PA的mParent为PA_for_WF_0)</li>
<li>[17]   &#x3D; PA_for_WF_0</li>
<li>[18]   &#x3D; PA_for_HDC_18 (此PA的mParent为PA_for_WF_0)</li>
<li>[19]   &#x3D; PA_for_WF_0</li>
<li>[20,23]&#x3D; PA_for_HDC_20 (此PA的mParent为PA_for_WF_0)</li>
<li>[24,25]&#x3D; PA_for_WF_0</li>
<li>[26,31]&#x3D; PA_for_HDC_26 (此PA的mParent为PA_for_WF_0)</li>
<li>[32,35]&#x3D; PA_for_HDC_32 (此PA的mParent为root)</li>
<li>[36]   &#x3D; root</li>
</ol>
</li>
<li>root.mChildren结果中保存PA_for_WF_0、PA_for_HDC_0、PA_for_HDC_18、PA_for_HDC_20及PA_for_HDC_26,PA_for_HDC_32</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>这么分析不够直观，我们画个图来看看:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_3.png" alt="2-3"></p>
<p>然后其他的feature过程省略，直接看结果:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_4.png" alt="2-4"></p>
<p>于此同时，各个PA中的mParent指向如下：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_5.png" alt="2-5"></p>
<p>注意每个PA中的mChildren集合包含所有以该PA为mParent的PA. 其子PA按从上到下，从左到右的顺序依次被添加到该PA中。</p>
<h2 id="2-4-build第三部分–创建Tokens"><a href="#2-4-build第三部分–创建Tokens" class="headerlink" title="2.4 build第三部分–创建Tokens"></a>2.4 build第三部分–创建Tokens</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------ 第三部分 --------</span></span><br><span class="line"><span class="comment">// 为每个层创建Tokens作为叶子</span></span><br><span class="line"><span class="type">PendingArea</span> <span class="variable">leafArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">leafType</span> <span class="operator">=</span> LEAF_TYPE_TOKENS;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">    <span class="comment">// 2.2.1 获取当前layer类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> typeOfLayer(policy, layer);</span><br><span class="line">    <span class="comment">// 检查我们是否可以重用上一层的相同Tokens。如果上一个图层与当前图层的类型相同，并且没有仅应用于其中一个图层的功能，则会发生这种情况。</span></span><br><span class="line">    <span class="keyword">if</span> (leafArea == <span class="literal">null</span> || leafArea.mParent != areaForLayer[layer]</span><br><span class="line">            || type != leafType) &#123;</span><br><span class="line">        <span class="comment">// 为当前layer创建新的Tokens</span></span><br><span class="line">        leafArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span> <span class="comment">/* feature */</span>, layer, areaForLayer[layer]);</span><br><span class="line">        areaForLayer[layer].mChildren.add(leafArea);</span><br><span class="line">        leafType = type;</span><br><span class="line">        <span class="keyword">if</span> (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123;</span><br><span class="line">            <span class="comment">// 使用传入的TaskDisplayAreas作为任务容器类型。</span></span><br><span class="line">            <span class="comment">// [2.4.1] 即 DisplayAreaPolicy的初始化 的时候创建的 DefaultTaskDisplayArea</span></span><br><span class="line">            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);</span><br><span class="line">            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],</span><br><span class="line">                    displayAreaGroupHierarchyBuilders);</span><br><span class="line">            leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leafType == LEAF_TYPE_IME_CONTAINERS) &#123;</span><br><span class="line">            <span class="comment">// 我们使用传入的ImeContainer作为层的ime容器类型。</span></span><br><span class="line">            <span class="comment">// 即使没有ime容器，也不要创建Tokens。</span></span><br><span class="line">            leafArea.mExisting = mImeContainer;</span><br><span class="line">            leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    leafArea.mMaxLayer = layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段循环看起来和第二段中的循环类似，从Z轴最底层往上依次遍历37个layer。typeOfLayer这个我们已经分析过了: 其次当layer&#x3D;2(也就是APPLICATION_LAYER)时，其type为LEAF_TYPE_TASK_CONTAINERS；当layer&#x3D;15或16时，其type为LEAF_TYPE_IME_CONTAINERS；其余layer都是LEAF_TYPE_TOKENS类型：</p>
<ol>
<li>layer&#x3D;0时，layerType&#x3D;LEAF_TYPE_TOKENS， 创建一个PA,记为PA_TOKENS_0, 其mParent指向areaForLayer[0], 也即是 PA_for_FM_0, 并将该PA添加到PA_for_FM_0的mChildren中。</li>
<li>layer&#x3D;1时，layerType&#x3D;LEAF_TYPE_TOKENS， 现在leafArea就是PA_TOKENS_0, 所以此次循环仅仅是将PA_TOKENS_0.mMaxLayer改成当前layer也就是1.</li>
<li>layer&#x3D;2时，layerType&#x3D;LEAF_TYPE_TASK_CONTAINERS, 新建一个PA, 记为 PA_TASK_2, 其mParent指向areaForLayer[2],即 PA_for_FM_2</li>
<li>layer&#x3D;3时，layerType&#x3D;LEAF_TYPE_TOKENS， 创建一个PA,记为PA_TOKENS_3, 其mParent指向areaForLayer[3], 还是 PA_for_FM_2</li>
</ol>
<p>最终结果如下:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_6.png" alt="2-6"></p>
<p>上图中，leafArea的命名方式是 PA_layerType_minLayer_max_Layer. 箭头指向的方向就是其parent方向。</p>
<h3 id="2-4-1-HierarchyBuilder-addTaskDisplayAreasToApplicationLayer"><a href="#2-4-1-HierarchyBuilder-addTaskDisplayAreasToApplicationLayer" class="headerlink" title="2.4.1 HierarchyBuilder.addTaskDisplayAreasToApplicationLayer"></a>2.4.1 HierarchyBuilder.addTaskDisplayAreasToApplicationLayer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTaskDisplayAreasToApplicationLayer</span><span class="params">(PendingArea parentPendingArea)</span> &#123;</span><br><span class="line">    <span class="comment">// mTaskDisplayAreas中仅包含一个名为&quot;DefaultTaskDisplayArea&quot;的TaskDisplayArea</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mTaskDisplayAreas.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">PendingArea</span> <span class="variable">leafArea</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span> <span class="comment">/* feature */</span>, APPLICATION_LAYER, parentPendingArea);</span><br><span class="line">        <span class="comment">// 将mTaskDisplayAreas中的DisplayArea放入该PA中</span></span><br><span class="line">        leafArea.mExisting = mTaskDisplayAreas.get(i);</span><br><span class="line">        leafArea.mMaxLayer = APPLICATION_LAYER;</span><br><span class="line">        <span class="comment">// 添加一个新的PA, 记为 PA_Task_2_2_tda</span></span><br><span class="line">        parentPendingArea.mChildren.add(leafArea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们知道传入的parentPendingArea就是上面构造的areaForLayer[APPLICATION_LAYER], 即 PA_for_FM_2!</p>
<p>这里就是把mTaskDisplayAreas中所有的TaskDisplayArea保存到PA_for_FM_2中, 最后结果如下:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_7.png" alt="2-7"></p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_8.png" alt="2-8"></p>
<h2 id="2-5-build第四部分–创建DisplayArea"><a href="#2-5-build第四部分–创建DisplayArea" class="headerlink" title="2.5 build第四部分–创建DisplayArea"></a>2.5 build第四部分–创建DisplayArea</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------ 第四部分 --------</span></span><br><span class="line"><span class="comment">// [2.5.1]计算最大layer</span></span><br><span class="line">root.computeMaxLayer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2.5.2]构建了一个PendingAreas树，其中包含表示层次结构的所有必要信息，现在创建并将真实的显示区域附加到根目录</span></span><br><span class="line">root.instantiateChildren(mRoot, displayAreaForLayer, <span class="number">0</span>, featureAreas);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2.5.3]完成DisplayArea的创建，缓存结果便于快速访问</span></span><br><span class="line">mRoot.onHierarchyBuilt(mFeatures, displayAreaForLayer, featureAreas);</span><br></pre></td></tr></table></figure>

<h3 id="2-5-1-计算最大layer"><a href="#2-5-1-计算最大layer" class="headerlink" title="2.5.1 计算最大layer"></a>2.5.1 计算最大layer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">computeMaxLayer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mChildren.size(); i++) &#123;</span><br><span class="line">        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mMaxLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有上面的图可以知道，root的children中最大的mMaxLayer为PA_TOKENS_36_36, 值为36。</p>
<h3 id="2-5-2-遍历PA树生成DisplayArea"><a href="#2-5-2-遍历PA树生成DisplayArea" class="headerlink" title="2.5.2 遍历PA树生成DisplayArea"></a>2.5.2 遍历PA树生成DisplayArea</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">instantiateChildren</span><span class="params">(DisplayArea&lt;DisplayArea&gt; parent, DisplayArea.Tokens[] areaForLayer,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> level, Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; areas)</span> &#123;</span><br><span class="line">    <span class="comment">// 将root里面的mChildren按照mMinLayer的大小排序，最小的在前面</span></span><br><span class="line">    mChildren.sort(Comparator.comparingInt(pendingArea -&gt; pendingArea.mMinLayer));</span><br><span class="line">    <span class="comment">// 遍历所有的children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mChildren.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PendingArea</span> <span class="variable">child</span> <span class="operator">=</span> mChildren.get(i);</span><br><span class="line">        <span class="comment">// 为该children创建DisplayArea</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayArea</span> <span class="variable">area</span> <span class="operator">=</span> child.createArea(parent, areaForLayer);</span><br><span class="line">        <span class="keyword">if</span> (area == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TaskDisplayArea 和 ImeContainer 可以不用设置</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为父DisplayArea添加新建的DisplayArea,且放在最前面</span></span><br><span class="line">        <span class="comment">// POSITION_TOP的值是Integer.MAX_VALUE, 这里的意思就是放在parent.mChildren集合的最末尾（Z轴来看就是最上面）</span></span><br><span class="line">        <span class="comment">// parent就是DisplayContent本身</span></span><br><span class="line">        parent.addChild(area, WindowContainer.POSITION_TOP);</span><br><span class="line">        <span class="keyword">if</span> (child.mFeature != <span class="literal">null</span>) &#123;</span><br><span class="line">            areas.get(child.mFeature).add(area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为每一个子PA遍历生成其子树的DisplayArea</span></span><br><span class="line">        child.instantiateChildren(area, areaForLayer, level + <span class="number">1</span>, areas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mChildren中只有三个PA, 分别是: PA_for_WF_0, PA_for_HDC_32以及PA_TOKENS_36_36. </p>
<p>这个方法不难看出，就是简单的遍历我们之前创建的PA树，然后给出了root之外的所有PA生成其对应的DisplayArea。</p>
<p>注意这里的传入的parent就是mRoot, 也就是DisplayContent，所以DisplayContent.mChildren中存入的元素就是此时构建的DisplayArea。</p>
<h4 id="2-5-2-1-PendingArea-createArea"><a href="#2-5-2-1-PendingArea-createArea" class="headerlink" title="2.5.2.1 PendingArea.createArea"></a>2.5.2.1 PendingArea.createArea</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DisplayArea <span class="title function_">createArea</span><span class="params">(DisplayArea&lt;DisplayArea&gt; parent,</span></span><br><span class="line"><span class="params">        DisplayArea.Tokens[] areaForLayer)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16</span></span><br><span class="line">    <span class="keyword">if</span> (mExisting != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mExisting.asTokens() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为layer存储WindowToken的容器</span></span><br><span class="line">            fillAreaForLayers(mExisting.asTokens(), areaForLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mExisting;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSkipTokens) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DisplayArea.Type type;</span><br><span class="line">    <span class="keyword">if</span> (mMinLayer &gt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.ABOVE_TASKS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mMaxLayer &lt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.BELOW_TASKS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = DisplayArea.Type.ANY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）</span></span><br><span class="line">    <span class="keyword">if</span> (mFeature == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayArea.<span class="type">Tokens</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisplayArea</span>.Tokens(parent.mWmService, type,</span><br><span class="line">                <span class="string">&quot;Leaf:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer);</span><br><span class="line">        fillAreaForLayers(leaf, areaForLayer);</span><br><span class="line">        <span class="keyword">return</span> leaf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,</span><br><span class="line">                mFeature.mName + <span class="string">&quot;:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer, mFeature.mId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会创建PendingArea对应的DisplayArea，对于我们的PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16！</p>
<p><strong>这里我们先看看PA_TASK_2_2_tda的DisplayArea的创建：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16</span></span><br><span class="line"><span class="keyword">if</span> (mExisting != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mExisting.asTokens() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为layer存储WindowToken的容器</span></span><br><span class="line">        fillAreaForLayers(mExisting.asTokens(), areaForLayer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mExisting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道PA_TASK_2_2_tda的mExisting就是<a href="#1212-displayareapolicy%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">1.2.1.2 DisplayAreaPolicy的初始化</a>中创建的”DefaultTaskDisplayArea”</p>
<blockquote>
<p>final TaskDisplayArea defaultTaskDisplayArea &#x3D; new TaskDisplayArea(content, wmService, “DefaultTaskDisplayArea”, FEATURE_DEFAULT_TASK_CONTAINER);</p>
</blockquote>
<p>而TaskDisplayArea又是继承了DisplayArea， 其asTokens直接返回了null, 所以说PA_TASK_2_2_tda的DisplayArea就是其mExisting!</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_9.png" alt="2-9"></p>
<p><strong>接下来是PA_IME_15_16的DisplayArea的创建：</strong></p>
<p>因为mImeContainer是在DisplayContent初始化过程中创建的ImeContainer类的对象，其就是Tokens的子类。所以mExisting.asTokens()确实不为null：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillAreaForLayers</span><span class="params">(DisplayArea.Tokens leaf, DisplayArea.Tokens[] areaForLayer)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mMinLayer; i &lt;= mMaxLayer; i++) &#123;</span><br><span class="line">        areaForLayer[i] = leaf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是将displayAreaForLayer中从minLayer到maxLayer都改成该PA的mExisting. 也就是 displayAreaForLayer[15], displayAreaForLayer[16]为mImeContainer!</p>
<p><strong>当mExisting为null时PA对应的DisplayArea的创建：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayArea.Type type;</span><br><span class="line"><span class="keyword">if</span> (mMinLayer &gt; APPLICATION_LAYER) &#123;</span><br><span class="line">    type = DisplayArea.Type.ABOVE_TASKS;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mMaxLayer &lt; APPLICATION_LAYER) &#123;</span><br><span class="line">    type = DisplayArea.Type.BELOW_TASKS;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    type = DisplayArea.Type.ANY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）</span></span><br><span class="line"><span class="keyword">if</span> (mFeature == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> DisplayArea.<span class="type">Tokens</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisplayArea</span>.Tokens(parent.mWmService, type,</span><br><span class="line">            <span class="string">&quot;Leaf:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer);</span><br><span class="line">    fillAreaForLayers(leaf, areaForLayer);</span><br><span class="line">    <span class="keyword">return</span> leaf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,</span><br><span class="line">            mFeature.mName + <span class="string">&quot;:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer, mFeature.mId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PA的mFeature只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_10.png" alt="2-10"></p>
<ol>
<li>当mFeature为null时，也就是当前PA是leafArea(即PA为TOKENS、TASK或者IME时)，直接创建Tokens,然后进行displayAreaForLayer的填充</li>
<li>当mFeature不为null时，通过mNewDisplayAreaSupplier创建DisplayArea<ol>
<li>当feature为FEATURE_WINDOWED_MAGNIFICATION，通过DisplayArea.Dimmable::new创建一个Dimmable</li>
<li>其余feature通过DisplayArea::new创建一个DisplayArea</li>
</ol>
</li>
</ol>
<p>所以遍历PA树生成DisplayArea就是将PA树除root节点之外，给每一个子PA创建一个DisplayArea.</p>
<p>经过这步骤之后，displayAreaForLayer[0~36]中的元素如下：</p>
<ol>
<li>displayAreaForLayer[2]     &#x3D; PA_TASK_2_2_tda</li>
<li>displayAreaForLayer[15,16] &#x3D; mImeContainer</li>
<li>其余元素皆为新建的DisplayArea.Tokens</li>
</ol>
<h3 id="2-5-3-RootDisplayArea-onHierarchyBuilt"><a href="#2-5-3-RootDisplayArea-onHierarchyBuilt" class="headerlink" title="2.5.3 RootDisplayArea.onHierarchyBuilt"></a>2.5.3 RootDisplayArea.onHierarchyBuilt</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onHierarchyBuilt</span><span class="params">(ArrayList&lt;Feature&gt; features, DisplayArea.Tokens[] areaForLayer,</span></span><br><span class="line"><span class="params">            Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; featureToDisplayAreas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mHasBuiltHierarchy) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Root should only build the hierarchy once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mHasBuiltHierarchy = <span class="literal">true</span>;</span><br><span class="line">    mFeatures = Collections.unmodifiableList(features);</span><br><span class="line">    <span class="comment">// 注意这里将构建的displayAreaForLayer保存在了mAreaForLayer中</span></span><br><span class="line">    mAreaForLayer = areaForLayer;</span><br><span class="line">    mFeatureToDisplayAreas = featureToDisplayAreas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，仅仅是将传入的参数保存起来。并且将mHasBuiltHierarchy标记为true, 表明RootTaskDisplayArea仅仅需要构建一次层次结构。</p>
<h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。</p>
<p>这里的DisplayContent是继承了RootDisplayArea, 其对应的Feature是FEATURE_ROOT，表示是该逻辑显示设备上的根显示区域。DisplayContent的初始化中做了很多工作，包括创建SurfaceControl，创建DisplayPolicy等等，重点是初始化DisplayAreaPolicy，而DisplayAreaPolicy的初始化过程中也同时构建了DisplayContent的层次结构器。</p>
<p>这个层次结构的初始化过程稍显复杂，可以看 <a href="#21-hierarchybuilderbuild">HierarchyBuilder.build</a> 上面的分析，大致分为四个部分:</p>
<ol>
<li><a href="#22-build%E7%9A%84%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86---layer-feature">第一部分</a> Layer的数量为37个,最上层是root, 默认DisplayArea的Feature有六个</li>
<li><a href="#23-build%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86--pendingarea%E7%9A%84%E6%9E%84%E9%80%A0">第二部分</a> 构造PA树<ol>
<li>按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部</li>
<li>依次编译该feature中定义的mWindowLayer数组，该数组由37个boolean值组成，从小到大一次对应37层layer</li>
<li>如果mWindowLayer[layer]的值为true, 那么根据需要创建子PA</li>
</ol>
</li>
<li><a href="#24-build%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86--%E5%88%9B%E5%BB%BAtokens">第三部分</a> 遍历第二部分创建的PA树，根据window类型创建对应叶子节点的PA</li>
<li><a href="#25-build%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86--%E5%88%9B%E5%BB%BAdisplayarea">第四部分</a> 为PA树的每个PA创建对应的DisplayArea，并将结果存储在RootDisplayArea（DisplayContent）中</li>
</ol>
<p>接下来我们分析WindowToke到底是如何管理的，包括WindowState的作用，而且我们分析WindowState创建的时候发现会抛出异常，这个问题我们下篇文章分析。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Vsync</tag>
        <tag>WMS</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(3)-ActivityRecord和WindowToken.md</title>
    <url>/2022/05/03/WMS(3)-ActivityRecord%E5%92%8CWindowToken/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上文中我们知道Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。</p>
<p>在Activity的Window被添加至WMS中，我们仅仅分析了一半，然后重点区分析了DisplayContent的构建，了解了其层次结构器的创建过程以及layer的个数和Window类型对应的layer。现在我们接着看WindowToken的创建，上文中留有一个疑问：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(<span class="type">int</span> windowType, <span class="type">boolean</span> ownerCanManageAppTokens,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> roundedCornerOverlay)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取window类型对应的layer，getWindowLayerFromTypeLw看[Window类型转Layer](#222-windowmanagerpolicygetwindowlayerfromtypelw)。</span></span><br><span class="line">    <span class="comment">// 一般应用的window类型是 TYPE_BASE_APPLICATION （值为1，handleResumeActivity中赋值的）</span></span><br><span class="line">    <span class="comment">// 所以windowLayerFromType就是APPLICATION_LAYER！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">windowLayerFromType</span> <span class="operator">=</span> mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,</span><br><span class="line">            ownerCanManageAppTokens, roundedCornerOverlay);</span><br><span class="line">    <span class="comment">// 所以这里就会抛出异常？？？</span></span><br><span class="line">    <span class="keyword">if</span> (windowLayerFromType == APPLICATION_LAYER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAreaForLayer[windowLayerFromType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Activity对应的windowType是TYPE_BASE_APPLICATION，所以拿到的windowLayerFromType就是APPLICATION_LAYER，那么这里必然会抛出异常！</p>
<p>当然按照正常理解来说，必然不会发生异常才对，所以是我们流程分析哪里有问题？ 是也不是，这里就要留意到应用启动过程了，回到Activity的启动过程，我们先看ActivityRecord的创建过程。</p>
<h1 id="一-ActivityRecord的创建"><a href="#一-ActivityRecord的创建" class="headerlink" title="一. ActivityRecord的创建"></a>一. ActivityRecord的创建</h1><p>ActivityRecord类是WindowToken子类：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/3_1.png" alt="3-1"></p>
<p>而且从名字中也可以看出，这个类应该是和Activity一一对应的，那么应该在Activity启动流程中哪个步骤创建其对象呢？不难理解，肯定是在startActivity的过程中。</p>
<p>Activity的启动流程这里就不展开了，直接看关键代码.</p>
<h2 id="1-1-ActivityTaskManagerService-startActivity"><a href="#1-1-ActivityTaskManagerService-startActivity" class="headerlink" title="1.1 ActivityTaskManagerService.startActivity"></a>1.1 ActivityTaskManagerService.startActivity</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span><br><span class="line"><span class="params">        IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="type">int</span> userId, <span class="type">boolean</span> validateIncomingUser)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// obtainStarter其实就是通过ActivityStarter.DefaultFactory获取ActivityStarter</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setCallingFeatureId(callingFeatureId)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setUserId(userId)</span><br><span class="line">            .execute(); <span class="comment">// 执行Activity的启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Activity的启动委托给ActivityStarter执行。</p>
<h2 id="1-2-ActivityStarter-execute"><a href="#1-2-ActivityStarter-execute" class="headerlink" title="1.2 ActivityStarter.execute"></a>1.2 ActivityStarter.execute</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            ......</span><br><span class="line">            res = executeRequest(mRequest);</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">executeRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 注意这里的inTask是null的，因为ActivityStarter构建时没有设置inTask.</span></span><br><span class="line">    <span class="type">Task</span> <span class="variable">inTask</span> <span class="operator">=</span> request.inTask;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [1.2.1] 针对此次启动的Activity创建对应的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>.Builder(mService)</span><br><span class="line">            .setCaller(callerApp)</span><br><span class="line">            .setLaunchedFromPid(callingPid)</span><br><span class="line">            .setLaunchedFromUid(callingUid)</span><br><span class="line">            .setLaunchedFromPackage(callingPackage)</span><br><span class="line">            .setLaunchedFromFeature(callingFeatureId)</span><br><span class="line">            .setIntent(intent)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setActivityInfo(aInfo)</span><br><span class="line">            .setConfiguration(mService.getGlobalConfiguration())</span><br><span class="line">            .setResultTo(resultRecord)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setComponentSpecified(request.componentSpecified)</span><br><span class="line">            .setRootVoiceInteraction(voiceSession != <span class="literal">null</span>)</span><br><span class="line">            .setActivityOptions(checkedOptions)</span><br><span class="line">            .setSourceRecord(sourceRecord)</span><br><span class="line">            .build();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [1.3] 启动Activity</span></span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, <span class="literal">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityRecord的初始化是采用了Build模式.</p>
<h3 id="1-2-1-ActivityRecord的初始化"><a href="#1-2-1-ActivityRecord的初始化" class="headerlink" title="1.2.1 ActivityRecord的初始化"></a>1.2.1 ActivityRecord的初始化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ActivityRecord</span><span class="params">(ActivityTaskManagerService _service, WindowProcessController _caller,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> _launchedFromPid, <span class="type">int</span> _launchedFromUid, String _launchedFromPackage,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String _launchedFromFeature, Intent _intent, String _resolvedType,</span></span><br><span class="line"><span class="params">        ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,</span></span><br><span class="line"><span class="params">        String _resultWho, <span class="type">int</span> _reqCode, <span class="type">boolean</span> _componentSpecified,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> _rootVoiceInteraction, ActivityTaskSupervisor supervisor,</span></span><br><span class="line"><span class="params">        ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState,</span></span><br><span class="line"><span class="params">        TaskDescription _taskDescription, <span class="type">long</span> _createTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里创建的Token是IApplicationToken.Stub的子类, 保存在ActivityRecord父类WindowToken的成员变量token中</span></span><br><span class="line">    <span class="built_in">super</span>(_service.mWindowManager, <span class="keyword">new</span> <span class="title class_">Token</span>(_intent).asBinder(), TYPE_APPLICATION, <span class="literal">true</span>,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* displayContent */</span>, <span class="literal">false</span> <span class="comment">/* ownerCanManageAppTokens */</span>);</span><br><span class="line"></span><br><span class="line">    mAtmService = _service;</span><br><span class="line">    appToken = (Token) token;</span><br><span class="line">    info = aInfo;</span><br><span class="line">    ......</span><br><span class="line">    appToken.attach(<span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Token</span> <span class="keyword">extends</span> <span class="title class_">IApplicationToken</span>.Stub &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(ActivityRecord activity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weakActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already attached...&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将传入的ActivityRecord用弱引用方式保存起来</span></span><br><span class="line">        weakActivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>所以ActivityRecord里的appToken其实是ActivityRecord初始化时创建的Token(为IApplicationToken.Stub的子类)，里面保存了该Activity的Intent信息。</p>
<h2 id="1-3-ActivityStarter-startActivityUnchecked"><a href="#1-3-ActivityStarter-startActivityUnchecked" class="headerlink" title="1.3 ActivityStarter.startActivityUnchecked"></a>1.3 ActivityStarter.startActivityUnchecked</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.3.1 设置初始化状态</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">                voiceInteractor, restrictedBgActivity);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取可重用的task</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">reusedTask</span> <span class="operator">=</span> getReusableTask();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 计算目标task</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">targetTask</span> <span class="operator">=</span> reusedTask != <span class="literal">null</span> ? reusedTask : computeTargetTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">newTask</span> <span class="operator">=</span> targetTask == <span class="literal">null</span>;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 因为当前Activity是应用启动的第一个Activity，所以newTask为true,targetTaskTop就是null的了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">targetTaskTop</span> <span class="operator">=</span> newTask</span><br><span class="line">            ? <span class="literal">null</span> : targetTask.getTopNonFinishingActivity();</span><br><span class="line">    <span class="keyword">if</span> (targetTaskTop != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为此次Activity的启动回收task</span></span><br><span class="line">        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAddingToTask = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取当前焦点（前台）Task</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">topRootTask</span> <span class="operator">=</span> mPreferredTaskDisplayArea.getFocusedRootTask();</span><br><span class="line">    <span class="keyword">if</span> (topRootTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断待启动的Activity是否与前台Activity一致</span></span><br><span class="line">        startResult = deliverToCurrentTopIfNeeded(topRootTask, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mTargetRootTask == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取root task.</span></span><br><span class="line">        mTargetRootTask = getLaunchRootTask(mStartActivity, mLaunchFlags, targetTask, mOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要创建新的task</span></span><br><span class="line">    <span class="keyword">if</span> (newTask) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">taskToAffiliate</span> <span class="operator">=</span> (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="literal">null</span>)</span><br><span class="line">                ? mSourceRecord.getTask() : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 设置新的Task</span></span><br><span class="line">        setNewTask(taskToAffiliate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAddingToTask) &#123;</span><br><span class="line">        addOrReparentStartingActivity(targetTask, <span class="string">&quot;adding to task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 交给对应Task启动Activity</span></span><br><span class="line">    mTargetRootTask.startActivityLocked(mStartActivity,</span><br><span class="line">            topRootTask != <span class="literal">null</span> ? topRootTask.getTopNonFinishingActivity() : <span class="literal">null</span>, newTask,</span><br><span class="line">            mKeepCurTransition, mOptions, startFromSamePackage);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNewTask</span><span class="params">(Task taskToAffiliate)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">toTop</span> <span class="operator">=</span> !mLaunchTaskBehind &amp;&amp; !mAvoidMoveToFront;</span><br><span class="line">    <span class="comment">// 创建新的Task，关于Task的创建我们后续分析</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> mTargetRootTask.reuseOrCreateTask(</span><br><span class="line">            mNewTaskInfo != <span class="literal">null</span> ? mNewTaskInfo : mStartActivity.info,</span><br><span class="line">            mNewTaskIntent != <span class="literal">null</span> ? mNewTaskIntent : mIntent, mVoiceSession,</span><br><span class="line">            mVoiceInteractor, toTop, mStartActivity, mSourceRecord, mOptions);</span><br><span class="line">    mService.getTransitionController().collectExistenceChange(task);</span><br><span class="line">    <span class="comment">// [1.4] 保存Activity至task！</span></span><br><span class="line">    addOrReparentStartingActivity(task, <span class="string">&quot;setTaskFromReuseOrCreateNewTask - mReuseTask&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们假设启动的Activity是应用的首个Activity，而且也没有设置affinity，这样在启动该Activity时，会创建新的Task, 并在该Task中保存ActivityRecord！</p>
<h3 id="1-3-1-ActivityStarter-setInitialState-设置初始化状态"><a href="#1-3-1-ActivityStarter-setInitialState-设置初始化状态" class="headerlink" title="1.3.1 ActivityStarter.setInitialState - 设置初始化状态"></a>1.3.1 ActivityStarter.setInitialState - 设置初始化状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setInitialState</span><span class="params">(ActivityRecord r, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> doResume, <span class="type">int</span> startFlags, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity)</span> &#123;</span><br><span class="line">    reset(<span class="literal">false</span> <span class="comment">/* clearRequest */</span>);</span><br><span class="line"></span><br><span class="line">    mStartActivity = r;</span><br><span class="line">    ......</span><br><span class="line">    mLaunchParams.reset();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 因为mLaunchParams被重置了，所以mPreferredTaskDisplayArea获取的就是mRootWindowContainer.getDefaultTaskDisplayArea</span></span><br><span class="line">    <span class="comment">// 即上文中RootDisplayArea创建的Result中的mDefaultTaskDisplayArea</span></span><br><span class="line">    mPreferredTaskDisplayArea = mLaunchParams.hasPreferredTaskDisplayArea()</span><br><span class="line">            ? mLaunchParams.mPreferredTaskDisplayArea</span><br><span class="line">            : mRootWindowContainer.getDefaultTaskDisplayArea();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先先清理ActivityStarter内部成员，然后依次赋值。</p>
<h2 id="1-4-ActivityStarter-addOrReparentStartingActivity"><a href="#1-4-ActivityStarter-addOrReparentStartingActivity" class="headerlink" title="1.4 ActivityStarter.addOrReparentStartingActivity"></a>1.4 ActivityStarter.addOrReparentStartingActivity</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addOrReparentStartingActivity</span><span class="params">(Task parent, String reason)</span> &#123;</span><br><span class="line">    <span class="comment">// mStartActivity是该Activity启动时创建的ActivityRecord.</span></span><br><span class="line">    <span class="comment">// ActivityRecord.getTask就是获取其task成员，该成员目前是没有被赋值的</span></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.getTask() == <span class="literal">null</span> || mStartActivity.getTask() == parent) &#123;</span><br><span class="line">        <span class="comment">// [1.5] 将该ActivityRecord添加至task中</span></span><br><span class="line">        parent.addChild(mStartActivity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mStartActivity.reparent(parent, parent.getChildCount() <span class="comment">/* top */</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-Task-addChild"><a href="#1-5-Task-addChild" class="headerlink" title="1.5 Task.addChild"></a>1.5 Task.addChild</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(ActivityRecord r)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认添加到该Task的最上层</span></span><br><span class="line">    addChild(r, Integer.MAX_VALUE <span class="comment">/* add on top */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(WindowContainer child, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断mChildren集合中是否存在元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hadChild</span> <span class="operator">=</span> hasChild();</span><br><span class="line">    <span class="comment">// [1.5.1] 获取当前Task最上层的WindowContainer对应的Activity类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">activityType</span> <span class="operator">=</span> getActivityType();</span><br><span class="line">    <span class="comment">// [1.5.2] 调整被添加的ActivityRecord在task中的位置</span></span><br><span class="line">    index = getAdjustedChildPosition(child, index);</span><br><span class="line">    <span class="comment">// [1.6] 将WindowContainer添加至mChildren中index位置</span></span><br><span class="line">    <span class="built_in">super</span>.addChild(child, index);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-Task-getActivityType"><a href="#1-5-1-Task-getActivityType" class="headerlink" title="1.5.1 Task.getActivityType"></a>1.5.1 Task.getActivityType</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getActivityType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Task的父类是WindowContainer, WindowContainer的父类是ConfigurationContainer</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">applicationType</span> <span class="operator">=</span> <span class="built_in">super</span>.getActivityType();</span><br><span class="line">    <span class="keyword">if</span> (applicationType != ACTIVITY_TYPE_UNDEFINED || !hasChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getTopChild().getActivityType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/content/res/Configuration.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getActivityType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// mFullConfiguration就是Configuration.java类</span></span><br><span class="line">    <span class="keyword">return</span> mFullConfiguration.windowConfiguration.getActivityType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/app/WindowConfiguration.java</span></span><br><span class="line"><span class="meta">@ActivityType</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getActivityType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mActivityType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityType有如下取值:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACTIVITY_TYPE_UNDEFINED</td>
<td>0</td>
<td>Activity类型尚未定义</td>
</tr>
<tr>
<td>ACTIVITY_TYPE_STANDARD</td>
<td>1</td>
<td>标准Activity类型</td>
</tr>
<tr>
<td>ACTIVITY_TYPE_HOME</td>
<td>2</td>
<td>Home或Launcher的Activity类型</td>
</tr>
<tr>
<td>ACTIVITY_TYPE_RECENTS</td>
<td>3</td>
<td>Recents或者Overview的Activity类型，系统中只有一个具有此类型的Activity</td>
</tr>
<tr>
<td>ACTIVITY_TYPE_ASSISTANT</td>
<td>4</td>
<td>Assistant Activity类型</td>
</tr>
<tr>
<td>ACTIVITY_TYPE_DREAM</td>
<td>5</td>
<td>Dream Activity类型</td>
</tr>
</tbody></table>
<p>一般情况都是ACTIVITY_TYPE_STANDARD或者ACTIVITY_TYPE_HOME类型。当前Task获取的值应该是初始化的默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConfigurationContainer.java:mFullConfiguration</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Configuration</span> <span class="variable">mFullConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration.java:windowConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">WindowConfiguration</span> <span class="variable">windowConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowConfiguration</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowConfiguration.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WindowConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    unset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unset</span><span class="params">()</span> &#123;</span><br><span class="line">    setToDefaults();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setToDefaults</span><span class="params">()</span> &#123;</span><br><span class="line">    setAppBounds(<span class="literal">null</span>);</span><br><span class="line">    setBounds(<span class="literal">null</span>);</span><br><span class="line">    setMaxBounds(<span class="literal">null</span>);</span><br><span class="line">    setWindowingMode(WINDOWING_MODE_UNDEFINED);</span><br><span class="line">    setActivityType(ACTIVITY_TYPE_UNDEFINED);</span><br><span class="line">    setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED);</span><br><span class="line">    setRotation(ROTATION_UNDEFINED);</span><br><span class="line">    setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ActivityType是被设置成：ACTIVITY_TYPE_UNDEFINED，也即未定义类型！</p>
<h3 id="1-5-2-Task-getAdjustedChildPosition"><a href="#1-5-2-Task-getAdjustedChildPosition" class="headerlink" title="1.5.2 Task.getAdjustedChildPosition"></a>1.5.2 Task.getAdjustedChildPosition</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getAdjustedChildPosition</span><span class="params">(WindowContainer wc, <span class="type">int</span> suggestedPosition)</span> &#123;</span><br><span class="line">    <span class="comment">// wc就是创建的ActivityRecord, 这里就是检查Activity是否带有FLAG_SHOW_FOR_ALL_USERS标志</span></span><br><span class="line">    <span class="comment">// 或者该Activity所属的userId是否是当前userId，即非当前用户的Activity不可见</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">canShowChild</span> <span class="operator">=</span> wc.showToCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mChildren.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据WindowContainer是否可见，决定该WC应该被插入Task的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minPosition</span> <span class="operator">=</span> (canShowChild) ? computeMinUserPosition(<span class="number">0</span>, size) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxPosition</span> <span class="operator">=</span> (canShowChild) ? size : computeMaxUserPosition(size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.5.2.1] 检查该WindowContainer是否是永远处于Task最上层</span></span><br><span class="line">    <span class="keyword">if</span> (!wc.isAlwaysOnTop()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有应该永远处于最上层的WC放在Task的最上层</span></span><br><span class="line">        <span class="keyword">while</span> (maxPosition &gt; minPosition) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mChildren.get(maxPosition - <span class="number">1</span>).isAlwaysOnTop()) <span class="keyword">break</span>;</span><br><span class="line">            --maxPosition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当该WC可以处于POSITION_BOTTOM且minPosition也是0时，返回POSITION_BOTTOM</span></span><br><span class="line">    <span class="comment">// 或者可以处于POSITION_TOP且maxPosition超过目前children数量时，返回POSITION_TOP</span></span><br><span class="line">    <span class="keyword">if</span> (suggestedPosition == POSITION_BOTTOM &amp;&amp; minPosition == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> POSITION_BOTTOM;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suggestedPosition == POSITION_TOP &amp;&amp; maxPosition &gt;= (size - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> POSITION_TOP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挑选一个合适的位置</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.max(suggestedPosition, minPosition), maxPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是通过检查WindowContainer是否可见的属性以及是否应该永远处于最上层来调整该WC应该被插入Task的哪个位置。</p>
<p>当我们ActivityRecord被添加入一个新建的Task时，毫无疑问应该是处于最上层即返回POSITION_TOP。</p>
<h4 id="1-5-2-1-WindowContainer-isAlwaysOnTop"><a href="#1-5-2-1-WindowContainer-isAlwaysOnTop" class="headerlink" title="1.5.2.1 WindowContainer.isAlwaysOnTop"></a>1.5.2.1 WindowContainer.isAlwaysOnTop</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlwaysOnTop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindowingMode == WINDOWING_MODE_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mActivityType == ACTIVITY_TYPE_DREAM) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAlwaysOnTop != ALWAYS_ON_TOP_ON) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">return</span> <span class="variable">mWindowingMode</span> <span class="operator">=</span>= WINDOWING_MODE_FREEFORM</span><br><span class="line">                || mWindowingMode == WINDOWING_MODE_MULTI_WINDOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明如下情况，该WindowContainer应该始终处于所在Task的最上层:</p>
<ol>
<li>window模式为WINDOWING_MODE_PINNED</li>
<li>Activity类型是ACTIVITY_TYPE_DREAM</li>
<li>当mAlwaysOnTop为ALWAYS_ON_TOP_ON，window模式为WINDOWING_MODE_FREEFORM或WINDOWING_MODE_MULTI_WINDOW</li>
</ol>
<h2 id="1-6-WindowContainer-addChild"><a href="#1-6-WindowContainer-addChild" class="headerlink" title="1.6 WindowContainer.addChild"></a>1.6 WindowContainer.addChild</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(E child, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 最后调整index</span></span><br><span class="line">    <span class="keyword">if</span> (index == POSITION_TOP) &#123;</span><br><span class="line">        index = mChildren.size();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == POSITION_BOTTOM) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将child保存在mChildren中的特定位置</span></span><br><span class="line">    mChildren.add(index, child);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.7] 让child保存该WC（即Task）</span></span><br><span class="line">    child.setParent(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@CallSuper: 是Android中特有的注解，如果子类覆盖了同名方法而没有显示调用父类的该方法时就会报错!</p>
</blockquote>
<p>这个也挺简单的，首先最后调整一下index：</p>
<ol>
<li>如果传入的index为POSITION_TOP，则将index设置为当前mChildren的size值，意为将待存入的child保存在mChildren中最后一位（上面）</li>
<li>如果传入的index为POSITION_BOTTOM， 则将index设置为0，意为将待存入的child保存在mChildren中第一位（下面）</li>
</ol>
<p>然后让child(ActivityRecord)保存该WC（即Task）。</p>
<h2 id="1-7-WindowContainer-setParent"><a href="#1-7-WindowContainer-setParent" class="headerlink" title="1.7 WindowContainer.setParent"></a>1.7 WindowContainer.setParent</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(WindowContainer&lt;WindowContainer&gt; parent)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowContainer</span> <span class="variable">oldParent</span> <span class="operator">=</span> mParent;</span><br><span class="line">    mParent = parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mParent.onChildAdded(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ActivityRecord创建时，该值默认为false,只有被调用reparent重设父集时才会被短暂更改为true</span></span><br><span class="line">    <span class="keyword">if</span> (!mReparenting) &#123;</span><br><span class="line">        onSyncReparent(oldParent, mParent);</span><br><span class="line">        <span class="comment">// mDisplayContent此时还是null的，而Task.mDisplayContent就是defaultDisplayContent</span></span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="literal">null</span> &amp;&amp; mParent.mDisplayContent != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;</span><br><span class="line">            <span class="comment">// [1.8] 更改当前WC(ActivityRecord)的DisplayContent</span></span><br><span class="line">            onDisplayChanged(mParent.mDisplayContent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [1.7.1] 当前ActivityRecord的parent有更改</span></span><br><span class="line">        onParentChanged(mParent, oldParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置WC(ActivityRecord)的父集（mParent, 即保存该WC的Task）, 如有必要同步Task中DisplayContent至该WC中。</p>
<h3 id="1-7-1-ActivityRecord-onParentChanged"><a href="#1-7-1-ActivityRecord-onParentChanged" class="headerlink" title="1.7.1 ActivityRecord.onParentChanged"></a>1.7.1 ActivityRecord.onParentChanged</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onParentChanged</span><span class="params">(ConfigurationContainer newParent, ConfigurationContainer oldParent)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">oldTask</span> <span class="operator">=</span> oldParent != <span class="literal">null</span> ? (Task) oldParent : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">newTask</span> <span class="operator">=</span> newParent != <span class="literal">null</span> ? (Task) newParent : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存入ActivityRecord.task中</span></span><br><span class="line">    <span class="built_in">this</span>.task = newTask;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将传入的ConfigurationContainer作为Task，存入ActivityRecord.task中，其余部分暂时先不研究。</p>
<h2 id="1-8-ActivityRecord-onDisplayChanged"><a href="#1-8-ActivityRecord-onDisplayChanged" class="headerlink" title="1.8 ActivityRecord.onDisplayChanged"></a>1.8 ActivityRecord.onDisplayChanged</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDisplayChanged</span><span class="params">(DisplayContent dc)</span> &#123;</span><br><span class="line">    <span class="type">DisplayContent</span> <span class="variable">prevDc</span> <span class="operator">=</span> mDisplayContent;</span><br><span class="line">    <span class="comment">// WindowToken.onDisplayChanged</span></span><br><span class="line">    <span class="built_in">super</span>.onDisplayChanged(dc);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowToken.java:onDisplayChanged</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDisplayChanged</span><span class="params">(DisplayContent dc)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.9] 将WindowToken（ActivityRecord）保存至DisplayContent中</span></span><br><span class="line">    dc.reParentWindowToken(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WindowContainer.onDisplayChanged</span></span><br><span class="line">    <span class="built_in">super</span>.onDisplayChanged(dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowContainer.java:onDisplayChanged</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDisplayChanged</span><span class="params">(DisplayContent dc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayContent != <span class="literal">null</span> &amp;&amp; mDisplayContent.mChangingContainers.remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="comment">// Cancel any change transition queued-up for this container on the old display.</span></span><br><span class="line">        mSurfaceFreezer.unfreeze(getPendingTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    mDisplayContent = dc;</span><br><span class="line">    <span class="keyword">if</span> (dc != <span class="literal">null</span> &amp;&amp; dc != <span class="built_in">this</span>) &#123;</span><br><span class="line">        dc.getPendingTransaction().merge(mPendingTransaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将mChildren中的每个WC的DisplayContent也同步更改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mChildren.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowContainer</span> <span class="variable">child</span> <span class="operator">=</span> mChildren.get(i);</span><br><span class="line">        child.onDisplayChanged(dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mListeners.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        mListeners.get(i).onDisplayChanged(dc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最主要的是理清ActivityRecord、WindowToken、Task和WindowContainer之间的继承关系：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/3_2.png" alt="3-2"></p>
<h2 id="1-9-DisplayContent-reParentWindowToken"><a href="#1-9-DisplayContent-reParentWindowToken" class="headerlink" title="1.9 DisplayContent.reParentWindowToken"></a>1.9 DisplayContent.reParentWindowToken</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reParentWindowToken</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    <span class="comment">// prevDc目前还是null的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">prevDc</span> <span class="operator">=</span> token.getDisplayContent();</span><br><span class="line">    <span class="keyword">if</span> (prevDc == <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prevDc != <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将ActivityRecord添加到该DC中,key为WindowToken的.token值</span></span><br><span class="line">    addWindowToken(token.token, token);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于此时还处于ActivityRecord刚被创建，正在第一次被设置DisplayContent时，所以其DisplayContent此时还是null的。那么就直接将该WindowToken(即ActivityRecord)保存在此DisplayContent中，注意token.token其实是WindowToken.token, 这个值我们之前分析过，是attrs.token,也就是从App进程传入的LocalActivityRecord.</p>
<h2 id="1-10-DisplayContent-addWindowToken"><a href="#1-10-DisplayContent-addWindowToken" class="headerlink" title="1.10 DisplayContent.addWindowToken"></a>1.10 DisplayContent.addWindowToken</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addWindowToken</span><span class="params">(IBinder binder, WindowToken token)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> mWmService.mRoot.getWindowTokenDisplay(token);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将ActivityRecord保存在DisplayContent中，key为WindowToken的token变量，即app传入的LayoutParam中的token</span></span><br><span class="line">    mTokenMap.put(binder, token);</span><br><span class="line">    <span class="comment">// WindowToken（其实是ActivityRecord）的asActivityRecord函数返回值不为null</span></span><br><span class="line">    <span class="keyword">if</span> (token.asActivityRecord() == <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们终于明白了一个ActivityRecord是如何被添加进DisplayContent中了，看到这里是不是似曾相识呢？Bingo, 之前我们的windowToken创建时会抛出一个异常，就是因为这个WindowToken.asActivityRecord返回值为null, 导致DisplayContent中添加该WindowToken时找不到合适layer！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">windowLayerFromType</span> <span class="operator">=</span> mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,</span><br><span class="line">        ownerCanManageAppTokens, roundedCornerOverlay);</span><br><span class="line"><span class="comment">// 所以这里就会抛出异常？？？</span></span><br><span class="line"><span class="keyword">if</span> (windowLayerFromType == APPLICATION_LAYER) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            <span class="string">&quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们知道了，在app的Activity被resume时，早就已经有了其WindowToken（ActivityRecord）被保存在DisplayContent的mTokenMap中。所以回过头我们看WMS.addWindow方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord!</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 所以这里就不会进入了，疑问解除！</span></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>啊哈，异常解除，因为Activity需要resume必须先start, 而start过程中就会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中！</p>
<p>最后附上一张时序图以备忘：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/3_3.png" alt="3-3"></p>
<p>接下来，我们继续看WMS.addWindow的流程：WindowState的创建及其管理。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WMS</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(4)-WindowState创建及移除</title>
    <url>/2022/05/04/WMS(4)-WindowState%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%A7%BB%E9%99%A4/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord!</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// [1.1] 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// [1.2] 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState, key为ViewRoomImpl.W</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将该WindowState保存在其mToken(ActivityRecord)中</span></span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一-WindowState"><a href="#一-WindowState" class="headerlink" title="一. WindowState"></a>一. WindowState</h1><p>WindowState，顾名思义是用于保存窗口状态的类，WindowToke是用于标记窗口身份、对应哪个进程的Activity的类。</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/4_1.png" alt="4-1"></p>
<h2 id="1-1-WindowState的初始化"><a href="#1-1-WindowState的初始化" class="headerlink" title="1.1 WindowState的初始化"></a>1.1 WindowState的初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">        WindowState parentWindow, <span class="type">int</span> appOp, WindowManager.LayoutParams a, <span class="type">int</span> viewVisibility,</span><br><span class="line">        <span class="type">int</span> ownerId, <span class="type">int</span> showUserId, <span class="type">boolean</span> ownerCanAddInternalSystemWindow,</span><br><span class="line">        PowerManagerWrapper powerManagerWrapper) &#123;</span><br><span class="line">    <span class="built_in">super</span>(service);</span><br><span class="line">    <span class="comment">// 创建Transaction，用于和SurfaceFlinger通信</span></span><br><span class="line">    <span class="comment">// mTransactionFactory是实现了Supplier接口的SurfaceControl.Transaction::new</span></span><br><span class="line">    mTmpTransaction = service.mTransactionFactory.get();</span><br><span class="line">    <span class="comment">// mSession就是ViewRootImpl对应的mWindowSession</span></span><br><span class="line">    mSession = s;</span><br><span class="line">    <span class="comment">// mClinet就是ViewRootImpl中的mWindow(即W类的对象)</span></span><br><span class="line">    mClient = c;</span><br><span class="line">    mAppOp = appOp;</span><br><span class="line">    <span class="comment">// mToken即WindowToke,也就是该WindowState对应的ActivityRecord</span></span><br><span class="line">    mToken = token;</span><br><span class="line">    mActivityRecord = mToken.asActivityRecord();</span><br><span class="line">    mOwnerUid = ownerId;</span><br><span class="line">    mShowUserId = showUserId;</span><br><span class="line">    mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow;</span><br><span class="line">    <span class="comment">// 创建WindowId</span></span><br><span class="line">    mWindowId = <span class="keyword">new</span> <span class="title class_">WindowId</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 保存该Activity的View对应的窗口属性</span></span><br><span class="line">    mAttrs.copyFrom(a);</span><br><span class="line">    mLastSurfaceInsets.set(mAttrs.surfaceInsets);</span><br><span class="line">    mViewVisibility = viewVisibility;</span><br><span class="line">    <span class="comment">// mPolicy就是PhoneWindowPolicy</span></span><br><span class="line">    mPolicy = mWmService.mPolicy;</span><br><span class="line">    mContext = mWmService.mContext;</span><br><span class="line">    <span class="comment">// 创建WindowState所处进程的死亡监听</span></span><br><span class="line">    <span class="type">DeathRecipient</span> <span class="variable">deathRecipient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeathRecipient</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建InputApplicationHandle, 将该Window注册进Input系统，以便后续input事件传输</span></span><br><span class="line">    mInputWindowHandle = <span class="keyword">new</span> <span class="title class_">InputWindowHandleWrapper</span>(<span class="keyword">new</span> <span class="title class_">InputWindowHandle</span>(</span><br><span class="line">            mActivityRecord != <span class="literal">null</span></span><br><span class="line">                    ? mActivityRecord.getInputApplicationHandle(<span class="literal">false</span> <span class="comment">/* update */</span>) : <span class="literal">null</span>,</span><br><span class="line">            getDisplayId()));</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// IWindow(ViewRootImpl.W) 建立binder死亡监听</span></span><br><span class="line">        c.asBinder().linkToDeath(deathRecipient, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 当前 Window type仍旧是TYPE_BASE_APPLICATION</span></span><br><span class="line">    <span class="keyword">if</span> (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将baseLayer设置为window类型对应的layer * TYPE_LAYER_MULTIPLIER 再加上一段偏移</span></span><br><span class="line">        <span class="comment">// 即 baseLayer = windowLayer * 10000 + 1000;</span></span><br><span class="line">        mBaseLayer = mPolicy.getWindowLayerLw(<span class="built_in">this</span>)</span><br><span class="line">                * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">        mSubLayer = <span class="number">0</span>;</span><br><span class="line">        mIsChildWindow = <span class="literal">false</span>;</span><br><span class="line">        mLayoutAttached = <span class="literal">false</span>;</span><br><span class="line">        mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">                || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">        mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是输入法或者壁纸窗口，则标记为floating layer.</span></span><br><span class="line">    mIsFloatingLayer = mIsImWindow || mIsWallpaper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActivityRecord != <span class="literal">null</span> &amp;&amp; mActivityRecord.mShowForAllUsers) &#123;</span><br><span class="line">        <span class="comment">// 标记可以为所有用户显示的应用窗口可以在锁屏时显示</span></span><br><span class="line">        mAttrs.flags |= FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建WindowAnimator，用于实现该窗口的动画</span></span><br><span class="line">    mWinAnimator = <span class="keyword">new</span> <span class="title class_">WindowStateAnimator</span>(<span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 非系统进程会有WPC来响应管理该窗口所属进程状态变化</span></span><br><span class="line">    mWpcForDisplayAreaConfigChanges = (s.mPid == MY_PID || s.mPid &lt; <span class="number">0</span>)</span><br><span class="line">            ? <span class="literal">null</span></span><br><span class="line">            : service.mAtmService.getProcessController(s.mPid, s.mUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化WindowState的过程并不复杂：</p>
<ol>
<li>调用SurfaceControl.Transaction::new创建mTmpTransaction</li>
<li>保存来自应用ViewRootImpl中的mWindowSession、mWindow等</li>
<li>保存该WindowState对应window的ActivityRecord</li>
<li>创建WindowId</li>
<li>保存该Activity的View对应的窗口属性</li>
<li>创建InputApplicationHandle，即将该Window注册进Input系统，以便后续input事件传输</li>
<li>建立binder死亡监听,处理该WindowState所属应用进程死亡后资源处理</li>
<li>计算mBaseLayer，mBaseLayer &#x3D; windowLayer(2) * 10000 + 1000;</li>
<li>标记mIsChildWindow、mIsImWindow（输入法窗口）、mIsWallpaper（壁纸窗口）</li>
<li>创建WindowAnimator，用于实现该窗口的动画</li>
<li>获取该pid对应的WindowProcessController</li>
</ol>
<p>这里关于input相关的流程我们后续分析。</p>
<h2 id="1-2-WindowState-attach"><a href="#1-2-WindowState-attach" class="headerlink" title="1.2 WindowState.attach"></a>1.2 WindowState.attach</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">attach</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">&quot;Attaching &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; token=&quot;</span> + mToken);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的，直接交给mSession处理。</p>
<h3 id="1-2-1-Session-windowAddedLocked"><a href="#1-2-1-Session-windowAddedLocked" class="headerlink" title="1.2.1 Session.windowAddedLocked"></a>1.2.1 Session.windowAddedLocked</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">windowAddedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 第一次进入则需要创建mSurfaceSession</span></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.v(TAG_WM, <span class="string">&quot;First window added to &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;, creating SurfaceSession&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建SurfaceSession</span></span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> <span class="title class_">SurfaceSession</span>();</span><br><span class="line">        ProtoLog.i(WM_SHOW_TRANSACTIONS, <span class="string">&quot;  NEW SURFACE SESSION %s&quot;</span>, mSurfaceSession);</span><br><span class="line">        <span class="comment">// 新创建的SurfaceSession后，将此Session保存至WMS中的mSessions集合中</span></span><br><span class="line">        mService.mSessions.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记窗口数量增一</span></span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceSession是用于和SurfaceFlinger通信的，因为Session是单个进程只会持有一个，所以创建SurfaceSession也只会初始化一次。</p>
<blockquote>
<p>创建Session的过程：WindowManagerGlobal.getWindowSession</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;<span class="comment">// WindowManagerGlobal.getWindowSession</span></span><br><span class="line">&gt;&gt;<span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title function_">getWindowSession</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">       <span class="comment">// 单个进程仅会创建一次</span></span><br><span class="line">       <span class="keyword">if</span> (sWindowSession == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ......</span><br><span class="line">               sWindowSession = windowManager.openSession(</span><br><span class="line">               ......</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sWindowSession;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h3 id="1-2-2-创建SurfaceSession"><a href="#1-2-2-创建SurfaceSession" class="headerlink" title="1.2.2 创建SurfaceSession"></a>1.2.2 创建SurfaceSession</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeCreate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SurfaceSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过JNI创建</span></span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接通过JNI创建对应native层对象，关于JNI后续单独出文章分析，有一个最简单的法则：</p>
<p>SurfaceSession所处的包是 “android.view”, 所以对应JNI文件就是:android_view_SurfaceSession.cpp</p>
<h3 id="1-2-3-android-view-SurfaceSession-cpp-nativeCreate"><a href="#1-2-3-android-view-SurfaceSession-cpp-nativeCreate" class="headerlink" title="1.2.3 android_view_SurfaceSession.cpp:nativeCreate"></a>1.2.3 android_view_SurfaceSession.cpp:nativeCreate</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对应创建的是SurfaceComposerClient</span></span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    <span class="comment">// 对象引用计数加一</span></span><br><span class="line">    client-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceSession对应的native层对象就是SurfaceComposerClient！</p>
<h3 id="1-2-4-创建SurfaceComposerClient"><a href="#1-2-4-创建SurfaceComposerClient" class="headerlink" title="1.2.4 创建SurfaceComposerClient"></a>1.2.4 创建SurfaceComposerClient</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SurfaceComposerClient::<span class="built_in">SurfaceComposerClient</span>()</span><br><span class="line">    : <span class="built_in">mStatus</span>(NO_INIT)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记mStatus为NO_INIT，尚未初始化。</p>
<p>回过头看WindowState.attach，这个方法其实就是创建mSurfaceSession并将其保存在WMS.mSessions集合中。而SurfaceSession其实就是对native层SurfaceComposerClient的包装。</p>
<h2 id="1-3-WindowState所属应用进程死亡"><a href="#1-3-WindowState所属应用进程死亡" class="headerlink" title="1.3 WindowState所属应用进程死亡"></a>1.3 WindowState所属应用进程死亡</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binderDied</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">resetSplitScreenResizing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mWmService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">// [1.3.1] 获取WindowState</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> mWmService</span><br><span class="line">                    .windowForClientLocked(mSession, mClient, <span class="literal">false</span>);</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;WIN DEATH: &quot;</span> + win);</span><br><span class="line">            <span class="comment">// 当WindowState尚未被移除时</span></span><br><span class="line">            <span class="keyword">if</span> (win != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> getDisplayContent();</span><br><span class="line">                <span class="comment">// 如果该WindowState是对应Activity的，且WindowState的mChildren中类型为TYPE_BASE_APPLICATION的WindowState</span></span><br><span class="line">                <span class="comment">// 就是保存在WMS中的WindowState</span></span><br><span class="line">                <span class="keyword">if</span> (win.mActivityRecord != <span class="literal">null</span> &amp;&amp; win.mActivityRecord.findMainWindow() == win) &#123;</span><br><span class="line">                    mWmService.mTaskSnapshotController.onAppDied(win.mActivityRecord);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// [1.3.2] 移除该WindowState</span></span><br><span class="line">                win.removeIfPossible(shouldKeepVisibleDeadAppWindow());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHasSurface) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">&quot;!!! LEAK !!! Window removed but surface still valid.&quot;</span>);</span><br><span class="line">                WindowState.<span class="built_in">this</span>.removeIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="comment">// This will happen if the window has already been removed.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-1-WMS-windowForClientLocked"><a href="#1-3-1-WMS-windowForClientLocked" class="headerlink" title="1.3.1 WMS.windowForClientLocked"></a>1.3.1 WMS.windowForClientLocked</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowState <span class="title function_">windowForClientLocked</span><span class="params">(Session session, IWindow client, <span class="type">boolean</span> throwOnError)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> windowForClientLocked(session, client.asBinder(), throwOnError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> WindowState <span class="title function_">windowForClientLocked</span><span class="params">(Session session, IBinder client, <span class="type">boolean</span> throwOnError)</span> &#123;</span><br><span class="line">    <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> mWindowMap.get(client);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.v(TAG_WM, <span class="string">&quot;Looking up client &quot;</span> + client + <span class="string">&quot;: &quot;</span> + win);</span><br><span class="line">    <span class="keyword">if</span> (win == <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; win.mSession != session) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从WMS的mWindowMap中查找client(ViewRootImpl.W)对应的WindowState, 这个是在addWindow时保存的。</p>
<h3 id="1-3-2-WindowState-removeIfPossible"><a href="#1-3-2-WindowState-removeIfPossible" class="headerlink" title="1.3.2 WindowState.removeIfPossible"></a>1.3.2 WindowState.removeIfPossible</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeIfPossible</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// WindowState是WindowContainer的子类，这里是对mChilder中的每一个WindowContainer执行removeIfPossible</span></span><br><span class="line">    <span class="built_in">super</span>.removeIfPossible();</span><br><span class="line">    removeIfPossible(<span class="literal">false</span> <span class="comment">/*keepVisibleDeadWindow*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeIfPossible</span><span class="params">(<span class="type">boolean</span> keepVisibleDeadWindow)</span> &#123;</span><br><span class="line">    <span class="comment">// 标记该WindowState是被移除的</span></span><br><span class="line">    mWindowRemovalAllowed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 应用启动窗口？</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">startingWindow</span> <span class="operator">=</span> mAttrs.type == TYPE_APPLICATION_STARTING;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将该WindowState从Input系统中移除</span></span><br><span class="line">        disposeInputChannel();</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记待移除窗口的可见性</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasVisible</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先确认是否需要运行动画。如果需要，必须推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。</span></span><br><span class="line">        <span class="keyword">if</span> (mHasSurface &amp;&amp; mToken.okToAnimate()) &#123;</span><br><span class="line">            <span class="comment">// 该窗口将被替换，只需要标记相关状态，等待被替换完成即可。</span></span><br><span class="line">            <span class="keyword">if</span> (mWillReplaceWindow) &#123;</span><br><span class="line">                ......</span><br><span class="line">                mAnimatingExit = <span class="literal">true</span>;</span><br><span class="line">                mReplacingRemoveRequested = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录待移除的窗口是否可见</span></span><br><span class="line">            wasVisible = isWinVisibleLw();</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 如果是可见的，需要创建一个窗口退出动画</span></span><br><span class="line">            <span class="keyword">if</span> (wasVisible) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">transit</span> <span class="operator">=</span> (!startingWindow) ? TRANSIT_EXIT : TRANSIT_PREVIEW_DONE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mWinAnimator.applyAnimationLocked(transit, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    mAnimatingExit = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 请求vsync进行动画</span></span><br><span class="line">                    setDisplayLayoutNeeded();</span><br><span class="line">                    mWmService.requestTraversal();</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [1.3.2.1] 将此WindowState移除</span></span><br><span class="line">        removeImmediately();</span><br><span class="line">        <span class="comment">// 移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数</span></span><br><span class="line">        <span class="keyword">if</span> (wasVisible) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContent();</span><br><span class="line">            <span class="keyword">if</span> (displayContent.updateOrientation()) &#123;</span><br><span class="line">                displayContent.sendNewConfiguration();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除窗口后，计算更新焦点窗口</span></span><br><span class="line">        mWmService.updateFocusedWindowLocked(isFocused()</span><br><span class="line">                        ? UPDATE_FOCUS_REMOVING_FOCUS</span><br><span class="line">                        : UPDATE_FOCUS_NORMAL,</span><br><span class="line">                <span class="literal">true</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>窗口所属进程死亡后，需要清理该窗口的WindowState:</p>
<ol>
<li>标记该WindowState是被移除的,mWindowRemovalAllowed置为true</li>
<li>将该WindowState从Input系统中移除</li>
<li>确认是否需要运行动画。如果需要，推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。<ol>
<li>如果是可见的，需要创建并执行一个窗口退出动画</li>
</ol>
</li>
<li>将此WindowState移除</li>
<li>移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数</li>
<li>更新焦点窗口</li>
</ol>
<h4 id="1-3-2-1-WindowState-removeImmediately-移除WindowState"><a href="#1-3-2-1-WindowState-removeImmediately-移除WindowState" class="headerlink" title="1.3.2.1 WindowState.removeImmediately - 移除WindowState"></a>1.3.2.1 WindowState.removeImmediately - 移除WindowState</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeImmediately</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 对所有mChildren执行清理动作</span></span><br><span class="line">    <span class="built_in">super</span>.removeImmediately();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> getDisplayContent();</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 将该Window的窗口属性从DisplayContent中移除</span></span><br><span class="line">    dc.getDisplayPolicy().removeWindowLw(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    disposeInputChannel();</span><br><span class="line">    <span class="comment">// 移除窗口的Surface</span></span><br><span class="line">    mWinAnimator.destroySurfaceLocked(mTmpTransaction);</span><br><span class="line">    mTmpTransaction.apply();</span><br><span class="line">    <span class="comment">// 将此窗口WindowState从Session中移除</span></span><br><span class="line">    mSession.windowRemovedLocked();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解除binder死亡监听</span></span><br><span class="line">        mClient.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制</span></span><br><span class="line">    mWmService.postWindowRemoveCleanupLocked(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除WindowState会执行:</p>
<ol>
<li>对所有mChildren执行清理动作</li>
<li>将该WindowState的窗口属性从DisplayContent中移除</li>
<li>移除窗口的Surface</li>
<li>将此窗口WindowState从Session中移除<ol>
<li>Session中窗口数目减一</li>
<li>如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用</li>
<li>否则将此Session从WMS.mSessions集合中移除</li>
<li>如果存在mSurfaceSession，则同步清理，清理时将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉</li>
</ol>
</li>
<li>执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制</li>
</ol>
<h4 id="1-3-2-2-Session-windowRemovedLocked"><a href="#1-3-2-2-Session-windowRemovedLocked" class="headerlink" title="1.3.2.2 Session.windowRemovedLocked"></a>1.3.2.2 Session.windowRemovedLocked</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">windowRemovedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 窗口数目减一</span></span><br><span class="line">    mNumWindow--;</span><br><span class="line">    killSessionLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">killSessionLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用</span></span><br><span class="line">    <span class="keyword">if</span> (mNumWindow &gt; <span class="number">0</span> || !mClientDead) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将此Session从WMS.mSessions集合中移除</span></span><br><span class="line">    mService.mSessions.remove(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 如果存在mSurfaceSession，则同步清理</span></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不用怀疑，肯定是需要进入native层执行清理动作</span></span><br><span class="line">        mSurfaceSession.kill();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG_WM, <span class="string">&quot;Exception thrown when killing surface session &quot;</span> + mSurfaceSession</span><br><span class="line">                + <span class="string">&quot; in session &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;: &quot;</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    mSurfaceSession = <span class="literal">null</span>;</span><br><span class="line">    mAlertWindowSurfaces.clear();</span><br><span class="line">    mAppOverlaySurfaces.clear();</span><br><span class="line">    setHasOverlayUi(<span class="literal">false</span>);</span><br><span class="line">    cancelAlertWindowNotification();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-3-SurfaceSession-kill-清理SurfaceSession"><a href="#1-3-2-3-SurfaceSession-kill-清理SurfaceSession" class="headerlink" title="1.3.2.3 SurfaceSession.kill - 清理SurfaceSession"></a>1.3.2.3 SurfaceSession.kill - 清理SurfaceSession</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeClient != <span class="number">0</span>) &#123;</span><br><span class="line">        nativeDestroy(mNativeClient);</span><br><span class="line">        mNativeClient = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行native清理动作，将mNativeClient置为0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeDestroy</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="built_in">reinterpret_cast</span>&lt;SurfaceComposerClient*&gt;(ptr);</span><br><span class="line">    client-&gt;<span class="built_in">decStrong</span>((<span class="type">void</span>*)nativeCreate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>native层的清理动作也很简单，将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉即可。</p>
<h1 id="二-小结"><a href="#二-小结" class="headerlink" title="二. 小结"></a>二. 小结</h1><p>回顾下本文涉及类的类图：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/4_2.png" alt="4-2"></p>
<p>之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState:</p>
<ol>
<li>初始化WindowState<ol>
<li>调用SurfaceControl.Transaction::new创建mTmpTransaction</li>
<li>保存来自应用ViewRootImpl中的mWindowSession、mWindow等</li>
<li>保存该WindowState对应window的ActivityRecord</li>
<li>创建WindowId</li>
<li>保存该Activity的View对应的窗口属性</li>
<li>创建InputApplicationHandle，即将该Window注册进Input系统，以便后续input事件传输</li>
<li>建立binder死亡监听,处理该WindowState所属应用进程死亡后资源处理</li>
<li>计算mBaseLayer，mBaseLayer &#x3D; windowLayer(2) * 10000 + 1000;</li>
<li>标记mIsChildWindow、mIsImWindow（输入法窗口）、mIsWallpaper（壁纸窗口）</li>
<li>创建WindowAnimator，用于实现该窗口的动画</li>
<li>获取该pid对应的WindowProcessController</li>
</ol>
</li>
<li>WindowState.attach, 创建SurfaceSession<ol>
<li>SurfaceSession是用于和SurfaceFlinger通信的，因为Session是单个进程只会持有一个，所以创建SurfaceSession也只会初始化一次。</li>
<li>创建SurfaceSession就是创建其对应native层的对象SurfaceComposerClient, 将其mStatus标记为NO_INIT，尚未初始化</li>
</ol>
</li>
<li>保存WindowState至WMS.mTokenMap中, key为ViewRoomImpl.W</li>
<li>将该WindowState保存在其mToken(ActivityRecord的mChildren)中</li>
</ol>
<p>当WindowState对应的进程死亡时，执行相关清理动作:</p>
<ol>
<li>标记该WindowState是被移除的,mWindowRemovalAllowed置为true</li>
<li>将该WindowState从Input系统中移除</li>
<li>确认是否需要运行动画。如果需要，推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。<ol>
<li>如果是可见的，需要创建并执行一个窗口退出动画</li>
</ol>
</li>
<li>将此WindowState移除<ol>
<li>对其所有mChildren执行清理动作</li>
<li>将该WindowState的窗口属性从DisplayContent中移除</li>
<li>移除窗口的Surface</li>
<li>将此窗口WindowState从Session中移除<ol>
<li>Session中窗口数目减一</li>
<li>如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用</li>
<li>否则将此Session从WMS.mSessions集合中移除</li>
<li>如果存在mSurfaceSession，则同步清理，清理时将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉</li>
</ol>
</li>
<li>执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制</li>
</ol>
</li>
<li>移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数</li>
<li>更新焦点窗口</li>
</ol>
<p>这里我们注意到WindowState被销毁时会存在一个窗口动画，那么当WindowState的窗口创建时应该也存在一个窗口动画，对应的应该是我们在WindowState被销毁时的TYPE_APPLICATION_STARTING类型窗口（因为Activity对应窗口尚未创建完毕，那么窗口启动动画应该在另一个准备完毕的窗口执行才行）。</p>
<p>下一篇文章我们就探秘一下应用启动窗口动画。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WMS</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(5)-启动窗口</title>
    <url>/2022/05/05/WMS(5)-%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>前面几篇文章中，我们弄清楚了WMS中比较核心的几个类的作用以及初始化等流程。现在我们看看Activity启动时的启动窗口动画过程，以此为锲子剖析WMS相关流程。</p>
<p>启动窗口，如其名，最合理的地方应该是在Activity启动的时候播放其动画的，回到startActivityInner，开始看:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/5_1.png" alt="5-1"></p>
<span id="more"></span>

<h1 id="一-启动窗口的初始化"><a href="#一-启动窗口的初始化" class="headerlink" title="一. 启动窗口的初始化"></a>一. 启动窗口的初始化</h1><h2 id="1-1-ActivityStarter-startActivityInner"><a href="#1-1-ActivityStarter-startActivityInner" class="headerlink" title="1.1 ActivityStarter.startActivityInner"></a>1.1 ActivityStarter.startActivityInner</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 交给对应Task启动Activity</span></span><br><span class="line">    mTargetRootTask.startActivityLocked(mStartActivity,</span><br><span class="line">            topRootTask != <span class="literal">null</span> ? topRootTask.getTopNonFinishingActivity() : <span class="literal">null</span>, newTask,</span><br><span class="line">            mKeepCurTransition, mOptions, startFromSamePackage);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>在Activity启动过程中，在创建新的Task并将该ActivityRecord保存其中，之后就是将启动Activity的流程转交给Task继续执行.</p>
<h2 id="1-2-Task-startActivityLocked"><a href="#1-2-Task-startActivityLocked" class="headerlink" title="1.2 Task.startActivityLocked"></a>1.2 Task.startActivityLocked</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="meta">@Nullable</span> ActivityRecord focusedTopActivity,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> newTask, <span class="type">boolean</span> keepCurTransition, ActivityOptions options,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> samePackage)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((!isHomeOrRecentsRootTask() || hasActivity()) &amp;&amp; allowMoveToFront) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">doShow</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// ActivityRecord.mLaunchTaskBehind 是用于表明启动该Activity时不需要动画</span></span><br><span class="line">        <span class="comment">// 与options:&quot;android:activity.animType&quot;有关(调用了makeTaskLaunchBehind)</span></span><br><span class="line">        <span class="comment">// 使用了这个标记说明正在启动的Activity将不会显示给用户，而是只能通过最近的任务列表使用</span></span><br><span class="line">        <span class="keyword">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class="line">            <span class="comment">// 显示启动窗口</span></span><br><span class="line">            <span class="comment">// 这里判断上一个task是否存在启动窗口</span></span><br><span class="line">            <span class="type">Task</span> <span class="variable">prevTask</span> <span class="operator">=</span> r.getTask();</span><br><span class="line">            <span class="comment">// 获取当前Task中的上一个具有启动窗口的ActivityRecord</span></span><br><span class="line">            <span class="type">ActivityRecord</span> <span class="variable">prev</span> <span class="operator">=</span> prevTask.topActivityWithStartingWindow();</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前Activity和启动窗口不在同一个task时，不会重用启动窗口</span></span><br><span class="line">                <span class="keyword">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class="line">                    prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前Activity已经显示出来了，也不会重用启动窗口</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (prev.nowVisible) &#123;</span><br><span class="line">                    prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">splashScreenThemeResId</span> <span class="operator">=</span> options != <span class="literal">null</span></span><br><span class="line">                    ? options.getSplashScreenThemeResId() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// [1.3] 显示启动窗口， 我们这里是第一个Activity，不存在启动窗口, 所以prev为null</span></span><br><span class="line">            r.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity),</span><br><span class="line">                    splashScreenThemeResId, samePackage);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// topFocusedActivity是当前展示的前台具有焦点的Activity对应的ActivityRecord</span></span><br><span class="line"><span class="comment">// 这里是判断是否需要切换Task, 当然需要</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTaskSwitch</span><span class="params">(ActivityRecord r, ActivityRecord topFocusedActivity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> topFocusedActivity != <span class="literal">null</span> &amp;&amp; r.getTask() != topFocusedActivity.getTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task中执行Activity的启动主要是：</p>
<ol>
<li>将该Activity对应的ActivityRecord放在该task合适的位置</li>
<li>顺便检查是否需要显示启动窗口，如果需要：<ol>
<li>检查是否可以重用启动窗口：<ol>
<li>当前Activity和启动窗口不在同一个task时，不会重用启动窗口</li>
<li>当前Activity已经显示出来了，也不会重用启动窗口</li>
</ol>
</li>
<li>显示启动窗口</li>
</ol>
</li>
</ol>
<h2 id="1-3-ActivityRecord-showStartingWindow"><a href="#1-3-ActivityRecord-showStartingWindow" class="headerlink" title="1.3 ActivityRecord.showStartingWindow"></a>1.3 ActivityRecord.showStartingWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="type">boolean</span> newTask, <span class="type">boolean</span> taskSwitch,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> splashScreenTheme, <span class="type">boolean</span> samePackage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTaskOverlay) &#123;</span><br><span class="line">        <span class="comment">// 不显示overlay activity的启动窗口, 即始终处于最上层的Activity</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPendingOptions != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mPendingOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">        <span class="comment">// 当Activity动画类型为ANIM_SCENE_TRANSITION时，不显示启动窗口</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CompatibilityInfo</span> <span class="variable">compatInfo</span> <span class="operator">=</span></span><br><span class="line">            mAtmService.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    <span class="comment">// 选择合适的窗口主题</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">resolvedTheme</span> <span class="operator">=</span> evaluateStartingWindowTheme(packageName, theme,</span><br><span class="line">            splashScreenTheme);</span><br><span class="line">    <span class="comment">// [1.4] 添加启动窗口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">shown</span> <span class="operator">=</span> addStartingWindow(packageName, resolvedTheme,</span><br><span class="line">            compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            prev != <span class="literal">null</span> ? prev.appToken : <span class="literal">null</span>, newTask, taskSwitch, isProcessRunning(),</span><br><span class="line">            allowTaskSnapshot(),</span><br><span class="line">            mState.ordinal() &gt;= STARTED.ordinal() &amp;&amp; mState.ordinal() &lt;= STOPPED.ordinal(),</span><br><span class="line">            samePackage);</span><br><span class="line">    <span class="comment">// 成功添加时，标记此ActivityRecord的启动窗口状态为STARTING_WINDOW_SHOWN</span></span><br><span class="line">    <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显示启动窗口首先需要检查是否需要显示，以下两种情况不显示启动窗口：</p>
<ol>
<li>当此Activity为始终处于最上层时</li>
<li>Activity动画类型为ANIM_SCENE_TRANSITION时</li>
</ol>
<p>然后选择合适窗口主题，添加启动窗口并在成功添加时，标记此ActivityRecord的启动窗口状态为STARTING_WINDOW_SHOWN，意为此Activity已经展示了启动窗口。</p>
<h2 id="1-4-ActivityRecord-addStartingWindow"><a href="#1-4-ActivityRecord-addStartingWindow" class="headerlink" title="1.4 ActivityRecord.addStartingWindow"></a>1.4 ActivityRecord.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addStartingWindow</span><span class="params">(String pkg, <span class="type">int</span> resolvedTheme, CompatibilityInfo compatInfo,</span></span><br><span class="line"><span class="params">        CharSequence nonLocalizedLabel, <span class="type">int</span> labelRes, <span class="type">int</span> icon, <span class="type">int</span> logo, <span class="type">int</span> windowFlags,</span></span><br><span class="line"><span class="params">        IBinder transferFrom, <span class="type">boolean</span> newTask, <span class="type">boolean</span> taskSwitch, <span class="type">boolean</span> processRunning,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> allowTaskSnapshot, <span class="type">boolean</span> activityCreated, <span class="type">boolean</span> samePackage)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据当前Activity相关参数配置启动窗口的窗口属性</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">typeParameter</span> <span class="operator">=</span> mWmService.mStartingSurfaceController</span><br><span class="line">            .makeStartingWindowTypeParameter(newTask, taskSwitch, processRunning,</span><br><span class="line">                    allowTaskSnapshot, activityCreated, samePackage);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建启动窗口相关数据</span></span><br><span class="line">    mStartingData = <span class="keyword">new</span> <span class="title class_">SplashScreenStartingData</span>(mWmService, pkg,</span><br><span class="line">            resolvedTheme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            getMergedOverrideConfiguration(), typeParameter);</span><br><span class="line">    <span class="comment">// 转交给WMS的动画处理线程执行启动窗口的动画</span></span><br><span class="line">    scheduleAddStartingWindow();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleAddStartingWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// DEBUG_ENABLE_SHELL_DRAWER是&quot;persist.debug.shell_starting_surface&quot;</span></span><br><span class="line">    <span class="comment">// 该属性默认为true</span></span><br><span class="line">    <span class="keyword">if</span> (StartingSurfaceController.DEBUG_ENABLE_SHELL_DRAWER) &#123;</span><br><span class="line">        <span class="comment">// 执行启动窗口动画</span></span><br><span class="line">        mAddStartingWindow.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是使用postAtFrontOfQueue，会将该动画放在执行队列最前面执行</span></span><br><span class="line">        <span class="keyword">if</span> (!mWmService.mAnimationHandler.hasCallbacks(mAddStartingWindow)) &#123;</span><br><span class="line">            ProtoLog.v(WM_DEBUG_STARTING_WINDOW, <span class="string">&quot;Enqueueing ADD_STARTING&quot;</span>);</span><br><span class="line">            mWmService.mAnimationHandler.postAtFrontOfQueue(mAddStartingWindow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加启动窗口的动作有很多，忽略细节，主要是封装该启动窗口的相关数据保存在SplashScreenStartingData中，然后执行启动窗口动画。</p>
<p>如果是转交给WMS的动画处理线程执行启动窗口的动画，而且是将该动画放在执行队列最前面执行。</p>
<p>至于WMS的mAnimationHandler是在类创建时初始化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WMS.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mAnimationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(AnimationThread.getHandler().getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnimationThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">AnimationThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;android.anim&quot;</span>, THREAD_PRIORITY_DISPLAY, <span class="literal">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以mAnimationHandler执行所在的线程就是”android.anim”线程。</p>
<p>该ActivityRecord中的mAddStartingWindow也是类初始化时创建的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActivityRecord.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AddStartingWindow</span> <span class="variable">mAddStartingWindow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddStartingWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">AddStartingWindow</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-启动窗口的动画"><a href="#二-启动窗口的动画" class="headerlink" title="二. 启动窗口的动画"></a>二. 启动窗口的动画</h1><h2 id="2-1-AddStartingWindow-run"><a href="#2-1-AddStartingWindow-run" class="headerlink" title="2.1 AddStartingWindow.run"></a>2.1 AddStartingWindow.run</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> StartingData startingData;</span><br><span class="line">    <span class="keyword">synchronized</span> (mWmService.mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (mStartingData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 该对象被置null说明启动窗口动画被取消了...</span></span><br><span class="line">            ProtoLog.v(WM_DEBUG_STARTING_WINDOW,</span><br><span class="line">                    <span class="string">&quot;startingData was nulled out before handling&quot;</span></span><br><span class="line">                            + <span class="string">&quot; mAddStartingWindow: %s&quot;</span>, ActivityRecord.<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        startingData = mStartingData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProtoLog.v(WM_DEBUG_STARTING_WINDOW, <span class="string">&quot;Add starting %s: startingData=%s&quot;</span>,</span><br><span class="line">            <span class="built_in">this</span>, startingData);</span><br><span class="line"></span><br><span class="line">    WindowManagerPolicy.<span class="type">StartingSurface</span> <span class="variable">surface</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [2.2] 创建启动窗口Surface</span></span><br><span class="line">        surface = startingData.createStartingSurface(ActivityRecord.<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Exception when adding starting window&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">abort</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mWmService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">// 如果mStartingData现在被置null了，说明窗口成功创建并被添加了</span></span><br><span class="line">            <span class="keyword">if</span> (mStartingData == <span class="literal">null</span>) &#123;</span><br><span class="line">                ProtoLog.v(WM_DEBUG_STARTING_WINDOW, <span class="string">&quot;Aborted starting %s: startingData=%s&quot;</span>,</span><br><span class="line">                        ActivityRecord.<span class="built_in">this</span>, mStartingData);</span><br><span class="line"></span><br><span class="line">                mStartingWindow = <span class="literal">null</span>;</span><br><span class="line">                mStartingData = <span class="literal">null</span>;</span><br><span class="line">                abort = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将创建的启动窗口surface赋值给mStartingSurface</span></span><br><span class="line">                mStartingSurface = surface;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">            <span class="comment">// 如果启动窗口动画中止，则移除该Surface</span></span><br><span class="line">            surface.remove(<span class="literal">false</span> <span class="comment">/* prepareAnimation */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AddStartingWindow就是一个runnable, 执行的时候先判断当前启动窗口是否仍需要，如果需要就创建启动窗口的Surface，如果启动窗口被中止，则移除创建的Surface.</p>
<h2 id="2-2-StartingData-createStartingSurface"><a href="#2-2-StartingData-createStartingSurface" class="headerlink" title="2.2 StartingData.createStartingSurface"></a>2.2 StartingData.createStartingSurface</h2><p>ActivityRecord中的mStartingData就是SplashScreenStartingData类型的对象。SplashScreenStartingData是StartingData的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">StartingSurface <span class="title function_">createStartingSurface</span><span class="params">(ActivityRecord activity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mService.mStartingSurfaceController.createSplashScreenStartingSurface(</span><br><span class="line">            activity, mPkg, mTheme, mCompatInfo, mNonLocalizedLabel, mLabelRes, mIcon,</span><br><span class="line">            mLogo, mWindowFlags, mMergedOverrideConfiguration,</span><br><span class="line">            activity.getDisplayContent().getDisplayId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过WMS中的mStartingSurfaceController来创建StartingSurface, mStartingSurfaceController是在WMS初始化的时候创建，用来管理创建和释放启动窗口Surface。</p>
<h2 id="2-3-StartingSurfaceController-createSplashScreenStartingSurface"><a href="#2-3-StartingSurfaceController-createSplashScreenStartingSurface" class="headerlink" title="2.3 StartingSurfaceController.createSplashScreenStartingSurface"></a>2.3 StartingSurfaceController.createSplashScreenStartingSurface</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StartingSurface <span class="title function_">createSplashScreenStartingSurface</span><span class="params">(ActivityRecord activity, String packageName,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="type">int</span> labelRes,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> icon, <span class="type">int</span> logo, <span class="type">int</span> windowFlags, Configuration overrideConfig, <span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">// 这里的task是ActivityRecord中新创建的task</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> activity.getTask();</span><br><span class="line">        <span class="comment">// 注意activity.token其实就是ActivityRecord.Token， 在ActivityRecord初始化时有分析，作为该ActivityRecord本身</span></span><br><span class="line">        <span class="comment">// [2.4] mTaskOrganizerController.addStartingWindow</span></span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span> &amp;&amp; mService.mAtmService.mTaskOrganizerController.addStartingWindow(</span><br><span class="line">                task, activity.token, theme, <span class="literal">null</span> <span class="comment">/* taskSnapshot */</span>)) &#123;</span><br><span class="line">            <span class="comment">// 最终创建的Surface是ShellStartingSurface.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShellStartingSurface</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终创建的Surface是ShellStartingSurface.</p>
<h2 id="2-4-TaskOrganizerController-addStartingWindow"><a href="#2-4-TaskOrganizerController-addStartingWindow" class="headerlink" title="2.4 TaskOrganizerController.addStartingWindow"></a>2.4 TaskOrganizerController.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addStartingWindow</span><span class="params">(Task task, IBinder appToken, <span class="type">int</span> launchTheme,</span></span><br><span class="line"><span class="params">        TaskSnapshot taskSnapshot)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">rootTask</span> <span class="operator">=</span> task.getRootTask();</span><br><span class="line">    <span class="keyword">if</span> (rootTask == <span class="literal">null</span> || rootTask.mTaskOrganizer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskOrganizerState</span> <span class="variable">state</span> <span class="operator">=</span></span><br><span class="line">            mTaskOrganizerStates.get(rootTask.mTaskOrganizer.asBinder());</span><br><span class="line">    <span class="comment">// 通过TaskOrganizerState执行添加动作</span></span><br><span class="line">    state.addStartingWindow(task, appToken, launchTheme, taskSnapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaskOrganizerState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskOrganizerCallbacks mOrganizer;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(Task t, IBinder appToken, <span class="type">int</span> launchTheme,</span></span><br><span class="line"><span class="params">        TaskSnapshot taskSnapshot)</span> &#123;</span><br><span class="line">    mOrganizer.addStartingWindow(t, appToken, launchTheme, taskSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaskOrganizerCallbacks</span></span><br><span class="line"><span class="keyword">final</span> ITaskOrganizer mTaskOrganizer;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(Task task, IBinder appToken, <span class="type">int</span> launchTheme,</span></span><br><span class="line"><span class="params">        TaskSnapshot taskSnapshot)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StartingWindowInfo</span> <span class="variable">info</span> <span class="operator">=</span> task.getStartingWindowInfo();</span><br><span class="line">    <span class="keyword">if</span> (launchTheme != <span class="number">0</span>) &#123;</span><br><span class="line">        info.splashScreenThemeResId = launchTheme;</span><br><span class="line">    &#125;</span><br><span class="line">    info.mTaskSnapshot = taskSnapshot;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 交给ITaskOrganizer执行，appToken就是ActivityRecord.token, 即ActivityRecord.Token类的对象</span></span><br><span class="line">        mTaskOrganizer.addStartingWindow(info, appToken);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Exception sending onTaskStart callback&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有点绕，我们看看mTaskOrganizer是什么,看看TaskOrganizerCallbacks和TaskOrganizerState的初始化可以知道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TaskOrganizerCallbacks(ITaskOrganizer taskOrg,</span><br><span class="line">        Consumer&lt;Runnable&gt; deferTaskOrgCallbacksConsumer) &#123;</span><br><span class="line">    mDeferTaskOrgCallbacksConsumer = deferTaskOrgCallbacksConsumer;</span><br><span class="line">    <span class="comment">// mTaskOrganizer是该类对象初始化时传入的ITaskOrganizer</span></span><br><span class="line">    mTaskOrganizer = taskOrg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskOrganizerState(ITaskOrganizer organizer, <span class="type">int</span> uid) &#123;</span><br><span class="line">    <span class="keyword">final</span> Consumer&lt;Runnable&gt; deferTaskOrgCallbacksConsumer =</span><br><span class="line">            mDeferTaskOrgCallbacksConsumer != <span class="literal">null</span></span><br><span class="line">                    ? mDeferTaskOrgCallbacksConsumer</span><br><span class="line">                    : mService.mWindowManager.mAnimator::addAfterPrepareSurfacesRunnable;</span><br><span class="line">    mOrganizer = <span class="keyword">new</span> <span class="title class_">TaskOrganizerCallbacks</span>(organizer, deferTaskOrgCallbacksConsumer);</span><br><span class="line">    mDeathRecipient = <span class="keyword">new</span> <span class="title class_">DeathRecipient</span>(organizer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        organizer.asBinder().linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;TaskOrganizer failed to register death recipient&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mUid = uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以mTaskOrganizer还是TaskOrganizerState初始化时传入的。那么TaskOrganizerState是怎么初始化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TaskOrganizerController.java#121</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ParceledListSlice&lt;TaskAppearedInfo&gt; <span class="title function_">registerTaskOrganizer</span><span class="params">(ITaskOrganizer organizer)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (!mTaskOrganizerStates.containsKey(organizer.asBinder())) &#123;</span><br><span class="line">                mTaskOrganizers.add(organizer);</span><br><span class="line">                mTaskOrganizerStates.put(organizer.asBinder(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TaskOrganizerState</span>(organizer, uid));</span><br><span class="line">            &#125;</span><br><span class="line">            .......</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以是有其他进程调用了TaskOrganizerController的registerTaskOrganizer将该成员注册了，而这里的方法仅有TaskOrganizer.java#72调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission(android.Manifest.permission.MANAGE_ACTIVITY_TASKS)</span></span><br><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> List&lt;TaskAppearedInfo&gt; <span class="title function_">registerOrganizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTaskOrganizerController.registerTaskOrganizer(mInterface).getList();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ITaskOrganizer</span> <span class="variable">mInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ITaskOrganizer</span>.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(StartingWindowInfo windowInfo,</span></span><br><span class="line"><span class="params">            IBinder appToken)</span> &#123;</span><br><span class="line">        mExecutor.execute(() -&gt; TaskOrganizer.<span class="built_in">this</span>.addStartingWindow(windowInfo, appToken));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BinderThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(<span class="meta">@NonNull</span> StartingWindowInfo info,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IBinder appToken)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>所以这个是将启动窗口的信息通过binder调用，添加到实现TaskOrganizer的addStartingWindow方法的其他进程了，并非是系统进程管控。</p>
<p>总的来说AddStartingWindow.run这个就是做了两件事：</p>
<ol>
<li>创建启动窗口Surface， 即ShellStartingSurface</li>
<li>将启动窗口信息通过binder调用传递给实现TaskOrganizer的进程</li>
</ol>
<p>这里的流程和R的差异有点大，推测是Google希望启动窗口可以交给Launcher或者SystemUI实现，而不是由framework的system_server进程来管控。</p>
<p>搜索SystemUI源码可以发现，继承TaskOrganizer的类有一个：ShellTaskOrganizer!</p>
<h2 id="2-5-ShellTaskOrganizer-addStartingWindow"><a href="#2-5-ShellTaskOrganizer-addStartingWindow" class="headerlink" title="2.5 ShellTaskOrganizer.addStartingWindow"></a>2.5 ShellTaskOrganizer.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(StartingWindowInfo info, IBinder appToken)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartingWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">        mStartingWindow.addStartingWindow(info, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来Google还真是将启动窗口交给SystemUI模块了。</p>
<h1 id="三-SystemUI负责的启动窗口"><a href="#三-SystemUI负责的启动窗口" class="headerlink" title="三. SystemUI负责的启动窗口"></a>三. SystemUI负责的启动窗口</h1><p>上面我们知道一个Activity启动后，从App进程交给SystemServer处理，在创建该Activity的ActivityRecord, 并将其保存在对应的Task之后，会在需要的时候开始启动窗口的播放。</p>
<p>启动窗口在Android S上是交给SystemUI进程负责了，在以前是交给SystemServer的“android.anim”线程处理。</p>
<p>关于R上SystemUI的ShellTaskOrganizer这一块涉及到<a href="https://github.com/google/dagger">Dagger2, 是一款基于 Java 注解来实现的在编译阶段完成依赖注入的开源库</a>的使用，这里先不展开讲了，感兴趣的可以自行研究。</p>
<p>ShellTaskOrganizer中的mStartingWindow是StartingWindowController类对象。</p>
<h2 id="3-1-StartingWindowController-addStartingWindow"><a href="#3-1-StartingWindowController-addStartingWindow" class="headerlink" title="3.1 StartingWindowController.addStartingWindow"></a>3.1 StartingWindowController.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(StartingWindowInfo windowInfo, IBinder appToken)</span> &#123;</span><br><span class="line">    mSplashScreenExecutor.execute(() -&gt; &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;addStartingWindow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suggestionType</span> <span class="operator">=</span> mStartingWindowTypeAlgorithm.getSuggestedWindowType(</span><br><span class="line">                windowInfo);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RunningTaskInfo</span> <span class="variable">runningTaskInfo</span> <span class="operator">=</span> windowInfo.taskInfo;</span><br><span class="line">        <span class="keyword">if</span> (mTaskLaunchingCallback != <span class="literal">null</span> &amp;&amp; shouldSendToListener(suggestionType)) &#123;</span><br><span class="line">            mTaskLaunchingCallback.accept(runningTaskInfo.taskId, suggestionType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suggestionType == STARTING_WINDOW_TYPE_SPLASH_SCREEN) &#123;</span><br><span class="line">            mStartingSurfaceDrawer.addSplashScreenStartingWindow(windowInfo, appToken,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/* emptyView */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suggestionType == STARTING_WINDOW_TYPE_EMPTY_SPLASH_SCREEN) &#123;</span><br><span class="line">            mStartingSurfaceDrawer.addSplashScreenStartingWindow(windowInfo, appToken,</span><br><span class="line">                    <span class="literal">true</span> <span class="comment">/* emptyView */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suggestionType == STARTING_WINDOW_TYPE_SNAPSHOT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TaskSnapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> windowInfo.mTaskSnapshot;</span><br><span class="line">            mStartingSurfaceDrawer.makeTaskSnapshotWindow(windowInfo, appToken,</span><br><span class="line">                    snapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/* suggestionType == STARTING_WINDOW_TYPE_NONE */</span> &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t add a staring window.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据启动窗口类型选择不同的启动窗口，这里我们假设是STARTING_WINDOW_TYPE_SPLASH_SCREEN类型。</p>
<h2 id="3-2-StartingSurfaceDrawer-addSplashScreenStartingWindow"><a href="#3-2-StartingSurfaceDrawer-addSplashScreenStartingWindow" class="headerlink" title="3.2 StartingSurfaceDrawer.addSplashScreenStartingWindow"></a>3.2 StartingSurfaceDrawer.addSplashScreenStartingWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addSplashScreenStartingWindow</span><span class="params">(StartingWindowInfo windowInfo, IBinder appToken,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> emptyView)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">RunningTaskInfo</span> <span class="variable">taskInfo</span> <span class="operator">=</span> windowInfo.taskInfo;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityInfo</span> <span class="variable">activityInfo</span> <span class="operator">=</span> taskInfo.topActivityInfo;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> mContext;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取启动窗口显示view的资源id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] splashscreenContentResId = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 这里的R是 &quot;import com.android.internal.R;&quot; 说明是framework/res中的资源</span></span><br><span class="line">    getWindowResFromContext(context, a -&gt; &#123;</span><br><span class="line">        splashscreenContentResId[<span class="number">0</span>] =</span><br><span class="line">                a.getResourceId(R.styleable.Window_windowSplashscreenContent, <span class="number">0</span>);</span><br><span class="line">        showWallpaper[<span class="number">0</span>] = a.getBoolean(R.styleable.Window_windowShowWallpaper, <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PhoneWindow</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(context);</span><br><span class="line">    win.setIsStartingWindow(<span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    win.setType(WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line">    ......</span><br><span class="line">    win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">            WindowManager.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> win.getAttributes();</span><br><span class="line">    <span class="comment">// 这里的appToken就是一路传递过来的待启动的activity的appToken,即ActivityRecord.Token类的对象</span></span><br><span class="line">    params.token = appToken;</span><br><span class="line">    params.packageName = activityInfo.packageName;</span><br><span class="line">    ......</span><br><span class="line">    params.setTitle(<span class="string">&quot;Splash Screen &quot;</span> + activityInfo.packageName);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SplashScreenViewSupplier</span> <span class="variable">viewSupplier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SplashScreenViewSupplier</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">setViewSynchronized</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取启动窗口的ContentView</span></span><br><span class="line">        <span class="comment">// SplashScreenViewSupplier.get必须要等待其被调用setView之后才会返回，否则会阻塞等待</span></span><br><span class="line">        <span class="type">SplashScreenView</span> <span class="variable">contentView</span> <span class="operator">=</span> viewSupplier.get();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 设置启动窗口View内容</span></span><br><span class="line">        win.setContentView(contentView);</span><br><span class="line">        contentView.cacheRootWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [3.3] 创建启动窗口对应的View</span></span><br><span class="line">    mSplashscreenContentDrawer.createContentView(context, emptyView,</span><br><span class="line">            splashscreenContentResId[<span class="number">0</span>], activityInfo, taskId, viewSupplier::setView);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> win.getDecorView();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowManager</span> <span class="variable">wm</span> <span class="operator">=</span> mContext.getSystemService(WindowManager.class);</span><br><span class="line">    <span class="comment">// 将启动窗口的View添加进WMS,创建对应的WindowState</span></span><br><span class="line">    postAddWindow(taskId, appToken, view, wm, params);</span><br><span class="line">    <span class="comment">// 请求Vsync,下一帧时调用setViewSynchronized，设置启动窗口View内容</span></span><br><span class="line">    mChoreographer.postCallback(CALLBACK_INSETS_ANIMATION, setViewSynchronized, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postAddWindow</span><span class="params">(<span class="type">int</span> taskId, IBinder appToken, View view, WindowManager wm,</span></span><br><span class="line"><span class="params">        WindowManager.LayoutParams params)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// WMS用来创建启动窗口对应的WindowState</span></span><br><span class="line">    <span class="comment">// 注意LayoutParams中的token是待启动的activity的appToken,即ActivityRecord.Token类的对象</span></span><br><span class="line">    wm.addView(view, params);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建启动窗口对应的PhoneWindow以及设置相关的参数，并将启动窗口的DecorView和窗口属性通过binder传给WMS用来创建对应的WindowState，最后通过Choreographer请求vsync，在下一帧的时候设置该启动窗口的内容。</p>
<h2 id="3-3-SplashscreenContentDrawer-createContentView"><a href="#3-3-SplashscreenContentDrawer-createContentView" class="headerlink" title="3.3 SplashscreenContentDrawer.createContentView"></a>3.3 SplashscreenContentDrawer.createContentView</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createContentView</span><span class="params">(Context context, <span class="type">boolean</span> emptyView, <span class="type">int</span> splashScreenResId,</span></span><br><span class="line"><span class="params">        ActivityInfo info, <span class="type">int</span> taskId, Consumer&lt;SplashScreenView&gt; consumer)</span> &#123;</span><br><span class="line">    mSplashscreenWorkerHandler.post(() -&gt; &#123;</span><br><span class="line">        SplashScreenView contentView;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// [3.3.1] 制作启动窗口显示的view</span></span><br><span class="line">            contentView = SplashscreenContentDrawer.makeSplashscreenContent(</span><br><span class="line">                    context, splashScreenResId);</span><br><span class="line">            <span class="comment">// Android S之后这个一般都是null的</span></span><br><span class="line">            <span class="keyword">if</span> (contentView == <span class="literal">null</span>) &#123;</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;makeSplashScreenContentView&quot;</span>);</span><br><span class="line">                <span class="comment">// emptyView是false的</span></span><br><span class="line">                <span class="keyword">if</span> (emptyView) &#123;</span><br><span class="line">                    contentView = makeEmptySplashScreenContentView(context);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// [3.3.2] 最后启动窗口的contentView是在这里创建的</span></span><br><span class="line">                    contentView = makeSplashScreenContentView(context, info);</span><br><span class="line">                &#125;</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;failed creating starting window content at taskId: &quot;</span></span><br><span class="line">                    + taskId, e);</span><br><span class="line">            contentView = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [3.4] consumer是传入的viewSupplier::setView</span></span><br><span class="line">        consumer.accept(contentView);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是创建启动窗口显示的内容，首先通过SplashscreenContentDrawer创建SplashScreenView.</p>
<h3 id="3-3-1-SplashscreenContentDrawer-makeSplashscreenContent"><a href="#3-3-1-SplashscreenContentDrawer-makeSplashscreenContent" class="headerlink" title="3.3.1 SplashscreenContentDrawer.makeSplashscreenContent"></a>3.3.1 SplashscreenContentDrawer.makeSplashscreenContent</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SplashScreenView <span class="title function_">makeSplashscreenContent</span><span class="params">(Context ctx,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> splashscreenContentResId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前systemui的sdk版本</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">targetSdkVersion</span> <span class="operator">=</span> ctx.getApplicationInfo().targetSdkVersion;</span><br><span class="line">    <span class="comment">// Andriod S之后不支持Window_SplashscreenContent了</span></span><br><span class="line">    <span class="keyword">if</span> (targetSdkVersion &gt;= Build.VERSION_CODES.S) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Andriod S之后不支持Window_windowSplashscreenContent了.</p>
<h3 id="3-3-2-SplashscreenContentDrawer-makeSplashScreenContentView"><a href="#3-3-2-SplashscreenContentDrawer-makeSplashScreenContentView" class="headerlink" title="3.3.2 SplashscreenContentDrawer.makeSplashScreenContentView"></a>3.3.2 SplashscreenContentDrawer.makeSplashScreenContentView</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SplashScreenView <span class="title function_">makeSplashScreenContentView</span><span class="params">(Context context, ActivityInfo ai)</span> &#123;</span><br><span class="line">    <span class="comment">// 重置View相关配置</span></span><br><span class="line">    updateDensity();</span><br><span class="line">    <span class="comment">// 重置窗口相关属性至mTmpAttrs中保存</span></span><br><span class="line">    getWindowAttrs(context, mTmpAttrs);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StartingWindowViewBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartingWindowViewBuilder</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> animationDuration;</span><br><span class="line">    Drawable iconDrawable;</span><br><span class="line">    <span class="comment">// mReplaceIcon默认是R.styleable.Window_windowSplashScreenAnimatedIcon</span></span><br><span class="line">    <span class="keyword">if</span> (mTmpAttrs.mReplaceIcon != <span class="literal">null</span>) &#123;</span><br><span class="line">        iconDrawable = mTmpAttrs.mReplaceIcon;</span><br><span class="line">        animationDuration = Math.max(<span class="number">0</span>,</span><br><span class="line">                Math.min(mTmpAttrs.mAnimationDuration, mMaxAnimatableIconDuration));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iconDrawable = mIconProvider.getIconForUI(</span><br><span class="line">                ai, getUserHandleForUid(ai.applicationInfo.uid));</span><br><span class="line">        <span class="keyword">if</span> (iconDrawable == <span class="literal">null</span>) &#123;</span><br><span class="line">            iconDrawable = context.getPackageManager().getDefaultActivityIcon();</span><br><span class="line">        &#125;</span><br><span class="line">        animationDuration = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择启动窗口背景颜色</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeBGColor</span> <span class="operator">=</span> peekWindowBGColor(context);</span><br><span class="line">    <span class="comment">// [3.3.3] 创建SplashScreenView</span></span><br><span class="line">    <span class="keyword">return</span> builder</span><br><span class="line">            .setContext(context)</span><br><span class="line">            .setWindowBGColor(themeBGColor)</span><br><span class="line">            .setIconDrawable(iconDrawable)</span><br><span class="line">            .setIconAnimationDuration(animationDuration)</span><br><span class="line">            .setBrandingDrawable(mTmpAttrs.mBrandingImage)</span><br><span class="line">            .setIconBackground(mTmpAttrs.mIconBgColor).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先重置相关配置属性，然后根据默认配置创建SplashScreenView。</p>
<h3 id="3-3-3-StartingWindowViewBuilder-build"><a href="#3-3-3-StartingWindowViewBuilder-build" class="headerlink" title="3.3.3 StartingWindowViewBuilder.build"></a>3.3.3 StartingWindowViewBuilder.build</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SplashScreenView <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// mIconDrawable必须不为空且是AdaptiveIconDrawable的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!processAdaptiveIcon() &amp;&amp; mIconDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">&quot;The icon is not an AdaptiveIconDrawable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        createIconDrawable(mIconDrawable, mIconSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">iconSize</span> <span class="operator">=</span> mFinalIconDrawable != <span class="literal">null</span> ? (<span class="type">int</span>) (mIconSize * mScale) : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 填充SplashScreenView内容</span></span><br><span class="line">    mCachedResult = fillViewWithIcon(mContext, iconSize, mFinalIconDrawable);</span><br><span class="line">    mBuildComplete = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> mCachedResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也仅仅是检查了下mIconDrawable是否为AdaptiveIconDrawable的实例，如果不是则重新创建一个。然后使用fillViewWithIcon填充内容，创建SplashScreenView.</p>
<h3 id="3-3-4-StartingWindowViewBuilder-fillViewWithIcon"><a href="#3-3-4-StartingWindowViewBuilder-fillViewWithIcon" class="headerlink" title="3.3.4 StartingWindowViewBuilder.fillViewWithIcon"></a>3.3.4 StartingWindowViewBuilder.fillViewWithIcon</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SplashScreenView <span class="title function_">fillViewWithIcon</span><span class="params">(Context context,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> iconSize, Drawable iconDrawable)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;fillViewWithIcon&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> SplashScreenView.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SplashScreenView</span>.Builder(context);</span><br><span class="line">    builder.setIconSize(iconSize).setBackgroundColor(mThemeColor)</span><br><span class="line">            .setIconBackground(mIconBackground);</span><br><span class="line">    <span class="keyword">if</span> (iconDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.setCenterViewDrawable(iconDrawable);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.setAnimationDurationMillis(mIconAnimationDuration);</span><br><span class="line">    <span class="keyword">if</span> (mBrandingDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.setBrandingDrawable(mBrandingDrawable, mBrandingImageWidth,</span><br><span class="line">                mBrandingImageHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.3.5 实例化SplashScreenView</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SplashScreenView</span> <span class="variable">splashScreenView</span> <span class="operator">=</span> builder.build();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">&quot;fillViewWithIcon surfaceWindowView &quot;</span> + splashScreenView);</span><br><span class="line">    &#125;</span><br><span class="line">    splashScreenView.makeSystemUIColorsTransparent();</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    <span class="keyword">return</span> splashScreenView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置待创建的SplashScreenView相关的内容，如主题颜色、图标背景色、图标动画时长、三方应用的图标等等，然后通过build构建SplashScreenView.</p>
<h3 id="3-3-5-SplashScreenView-Builder-build"><a href="#3-3-5-SplashScreenView-Builder-build" class="headerlink" title="3.3.5 SplashScreenView.Builder.build"></a>3.3.5 SplashScreenView.Builder.build</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SplashScreenView <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;SplashScreenView#build&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SplashScreenView</span> <span class="variable">view</span> <span class="operator">=</span> (SplashScreenView)</span><br><span class="line">            layoutInflater.inflate(R.layout.splash_screen_view, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    ......</span><br><span class="line">    view.mIconView = view.findViewById(R.id.splashscreen_icon_view);</span><br><span class="line">    view.mBrandingImageView = view.findViewById(R.id.splashscreen_branding_view);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 设置icon图像</span></span><br><span class="line">    <span class="keyword">if</span> (mIconDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        view.mIconView.setBackground(mIconDrawable);</span><br><span class="line">        view.initIconAnimation(mIconDrawable,</span><br><span class="line">                mIconAnimationDuration != <span class="literal">null</span> ? mIconAnimationDuration.toMillis() : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 设置brand图像</span></span><br><span class="line">    <span class="keyword">if</span> (mBrandingImageHeight &gt; <span class="number">0</span> &amp;&amp; mBrandingImageWidth &gt; <span class="number">0</span> &amp;&amp; mBrandingDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        view.mBrandingImageView.setBackground(mBrandingDrawable);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SplashScreenView是继承FrameLayout的，通过LayoutInflater实例化splash_screen_view作为其内容布局:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.window.SplashScreenView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/splashscreen_icon_view&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/splash_screen_view_icon_description&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/splashscreen_branding_view&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal|bottom&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/splash_screen_view_branding_description&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.window.SplashScreenView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个非常简单，就是两个View, 所以说启动窗口的显示内容就是两个图标（如果有图标对应的image不为null,则会显示）。</p>
<h2 id="3-4-SplashScreenViewSupplier-setView"><a href="#3-4-SplashScreenViewSupplier-setView" class="headerlink" title="3.4 SplashScreenViewSupplier.setView"></a>3.4 SplashScreenViewSupplier.setView</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SplashScreenViewSupplier</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;SplashScreenView&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> SplashScreenView mView;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsViewSet;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(SplashScreenView view)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存SplashScreenView并通知其他线程继续执行get</span></span><br><span class="line">            mView = view;</span><br><span class="line">            mIsViewSet = <span class="literal">true</span>;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> SplashScreenView <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mIsViewSet) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类的主要作用就是将SplashScreenView的创建交给与使用线程不同的线程。</p>
<h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四.小结"></a>四.小结</h1><p>来一张流程图回顾下启动窗口被添加的过程:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/5_2.png" alt="5-2"></p>
<p>虽然启动窗口对应的View和内容是通过SystemUI创建的，但是其还是被WMS归属为待启动的Activity的Task中的一员。究其原因还是其窗口属性中的token是该Activity对应的ActivityRecord.Token。SystemUI创建启动窗口的内容后，会在下一帧来时将该View添加到WMS中，然后WMS就会在addWindow里创建对应的WindowState。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WMS</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(6)-焦点窗口的更新</title>
    <url>/2022/05/06/WMS(6)-%E7%84%A6%E7%82%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>这篇文章中我们重点关注焦点窗口的更新，所谓焦点窗口就是当前选择的窗口。在Android里可以通过下面的adb命令来查看当前的焦点窗口: </p>
<blockquote>
<p>adb shell dumpsys window |grep -iE “mCurr*”</p>
</blockquote>
<p>我们知道一个实体显示器对应一个DisplayId, 相应的有一个DisplayContent，如同我们人眼或者相机的对焦，同一时刻只能有一个焦点，那么对应一个Display一般来说也只有一个焦点窗口了。</p>
<p>我们之前一直分析的WMS.addWindow，在应用进程调用setView传入对应窗口属性之后，当然也会有焦点窗口的重新计算了：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord!</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState, key为ViewRoomImpl.W</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        <span class="comment">// 和应用窗口权限有关，后续分析</span></span><br><span class="line">        win.initAppOpsState();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将该WindowState保存在其mToken(ActivityRecord)中</span></span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 标记焦点窗口是否更新</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">focusChanged</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// [1.1] 检查该窗口是否可以接收input事件</span></span><br><span class="line">        <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">            <span class="comment">// [1.2] 更新焦点窗口</span></span><br><span class="line">            focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">                imMayMove = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// [2.1] 如果焦点窗口有更新，也需要更新input相关设置</span></span><br><span class="line">        <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">            displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 该窗口成功被添加或者是可见的而且当前display需要更新方向时，更新display相关配置</span></span><br><span class="line">        <span class="keyword">if</span> (win.isVisibleOrAdding() &amp;&amp; displayContent.updateOrientation()) &#123;</span><br><span class="line">            displayContent.sendNewConfiguration();</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一-焦点窗口更新"><a href="#一-焦点窗口更新" class="headerlink" title="一. 焦点窗口更新"></a>一. 焦点窗口更新</h1><p>应用的第一个addWindow应该是启动窗口的，所以我们以启动窗口为例分析焦点窗口更新。</p>
<h2 id="1-1-WindowState-canReceiveKeys"><a href="#1-1-WindowState-canReceiveKeys" class="headerlink" title="1.1 WindowState.canReceiveKeys"></a>1.1 WindowState.canReceiveKeys</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canReceiveKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> canReceiveKeys(<span class="literal">false</span> <span class="comment">/* fromUserTouch */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReceiveKeys</span><span class="params">(<span class="type">boolean</span> fromUserTouch)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.1.1] 检查该窗口是否可见</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">canReceiveKeys</span> <span class="operator">=</span> isVisibleOrAdding()</span><br><span class="line">            &amp;&amp; (mViewVisibility == View.VISIBLE) &amp;&amp; !mRemoveOnExit</span><br><span class="line">            &amp;&amp; ((mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// [1.1.2] 确认该ActivityRecord是否可聚焦</span></span><br><span class="line">            &amp;&amp; (mActivityRecord == <span class="literal">null</span> || mActivityRecord.windowsAreFocusable(fromUserTouch))</span><br><span class="line">            <span class="comment">// [1.1.3] 判断该WindowState是否允许接收input事件</span></span><br><span class="line">            &amp;&amp; canReceiveTouchInput();</span><br><span class="line">    <span class="keyword">if</span> (!canReceiveKeys) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除非用户有意触摸显示器，否则不允许不受信任的虚拟显示接收input事件</span></span><br><span class="line">    <span class="keyword">return</span> fromUserTouch || getDisplayContent().isOnTop()</span><br><span class="line">            || getDisplayContent().isTrusted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里检查了一堆参数，我们一一分析：</p>
<ol>
<li>isVisibleOrAdding(): 判断当前窗口是否可见或者被添加</li>
<li>mViewVisibility &#x3D;&#x3D; View.VISIBLE: 窗口可见属性为VISIBLE</li>
<li>!mRemoveOnExit: 该窗口没有移除或者退出</li>
<li>((mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) &#x3D;&#x3D; 0): 该窗口的属性不带有FLAG_NOT_FOCUSABLE，是可聚焦的</li>
<li>(mActivityRecord &#x3D;&#x3D; null || mActivityRecord.windowsAreFocusable(fromUserTouch)):该窗口不是Activity对应的窗口，如果是那么需要满足windowsAreFocusable</li>
<li>canReceiveTouchInput(): 该窗口可以接收touch事件</li>
</ol>
<p>只有当上述条件都满足且窗口所处的DisplayContent是最上层的并且该Display是受信任的，该窗口才可能接收事件。</p>
<h3 id="1-1-1-WindowState-isVisibleOrAdding"><a href="#1-1-1-WindowState-isVisibleOrAdding" class="headerlink" title="1.1.1 WindowState.isVisibleOrAdding"></a>1.1.1 WindowState.isVisibleOrAdding</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isVisibleOrAdding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 该窗口不一定对应Activity,比如启动窗口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">atoken</span> <span class="operator">=</span> mActivityRecord;</span><br><span class="line">    <span class="keyword">return</span> (mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility == View.VISIBLE))</span><br><span class="line">            &amp;&amp; isVisibleByPolicy() &amp;&amp; !isParentWindowHidden()</span><br><span class="line">            &amp;&amp; (atoken == <span class="literal">null</span> || atoken.mVisibleRequested)</span><br><span class="line">            &amp;&amp; !mAnimatingExit &amp;&amp; !mDestroying;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isVisibleByPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断mPolicyVisibility中的POLICY_VISIBILITY_ALL位是否被设置了</span></span><br><span class="line">    <span class="comment">// mPolicyVisibility默认就是POLICY_VISIBILITY_ALL</span></span><br><span class="line">    <span class="keyword">return</span> (mPolicyVisibility &amp; POLICY_VISIBILITY_ALL) == POLICY_VISIBILITY_ALL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isParentWindowHidden</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前窗口的父窗口是否被隐藏了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">parent</span> <span class="operator">=</span> getParentWindow();</span><br><span class="line">    <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; parent.mHidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断该窗口是否可见或者处于被添加状态。</p>
<ol>
<li>(mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility &#x3D;&#x3D; View.VISIBLE))：<ol>
<li>mHasSurface：该窗口是否有对应Surface，该Surface会在该窗口对应的启动或退出动画时创建</li>
<li>(!mRelayoutCalled &amp;&amp; mViewVisibility &#x3D;&#x3D; View.VISIBLE):<ol>
<li>!mRelayoutCalled: 该窗口被调用了relayoutWindow</li>
<li>mViewVisibility &#x3D;&#x3D; View.VISIBLE: 窗口View属性对应的是VISIBLE</li>
</ol>
</li>
<li>如果该窗口已经有Surface或者没有被relayoutWindow但窗口可见属性是VISIBLE的时</li>
</ol>
</li>
<li>isVisibleByPolicy()：判断mPolicyVisibility中的POLICY_VISIBILITY_ALL位都被设置了</li>
<li>!isParentWindowHidden(): 判断父窗口没有被隐藏</li>
<li>(atoken &#x3D;&#x3D; null || atoken.mVisibleRequested)：<ol>
<li>atoken &#x3D;&#x3D; null：该窗口不对应ActivityRecord</li>
<li>atoken.mVisibleRequested: 如果对应，需要mVisibleRequested被设置为true</li>
<li>!mAnimatingExit：该窗口当前没有执行退出动画</li>
<li>!mDestroying：该窗口没有被销毁</li>
</ol>
</li>
</ol>
<h3 id="1-1-2-ActivityRecord-windowsAreFocusable"><a href="#1-1-2-ActivityRecord-windowsAreFocusable" class="headerlink" title="1.1.2 ActivityRecord.windowsAreFocusable"></a>1.1.2 ActivityRecord.windowsAreFocusable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">windowsAreFocusable</span><span class="params">(<span class="type">boolean</span> fromUserTouch)</span> &#123;</span><br><span class="line">    <span class="comment">// fromUserTouch为false</span></span><br><span class="line">    <span class="keyword">if</span> (!fromUserTouch &amp;&amp; mTargetSdk &lt; Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> getPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">topFocusedAppOfMyProcess</span> <span class="operator">=</span></span><br><span class="line">                mWmService.mRoot.mTopFocusedAppByProcess.get(pid);</span><br><span class="line">        <span class="keyword">if</span> (topFocusedAppOfMyProcess != <span class="literal">null</span> &amp;&amp; topFocusedAppOfMyProcess != <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 对于Q以下的应用程序，每个进程只能有一个具有聚焦窗口的应用程序，因为以往的应用程序可能无法用于多聚焦系统</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确认该ActivityRecord是否已经attach了</span></span><br><span class="line">    <span class="comment">// isAttached是其父类的父类WindowContainer中的方法，用于判断该ActivityRecord的parent的DisplayArea是否为null</span></span><br><span class="line">    <span class="keyword">return</span> (canReceiveKeys() || isAlwaysFocusable()) &amp;&amp; isAttached();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canReceiveKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 确定该ActivityRecord对应的窗口配置是否允许接收input事件</span></span><br><span class="line">    <span class="keyword">return</span> getWindowConfiguration().canReceiveKeys()</span><br><span class="line">            &amp;&amp; (task == <span class="literal">null</span> || task.getWindowConfiguration().canReceiveKeys());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAlwaysFocusable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (info.flags &amp; FLAG_ALWAYS_FOCUSABLE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>windowsAreFocusable用于判断该ActivityRecord对应窗口是否可以接收input事件。</p>
<h3 id="1-1-3-WindowState-canReceiveTouchInput"><a href="#1-1-3-WindowState-canReceiveTouchInput" class="headerlink" title="1.1.3 WindowState.canReceiveTouchInput"></a>1.1.3 WindowState.canReceiveTouchInput</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canReceiveTouchInput</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityRecord == <span class="literal">null</span>  || mActivityRecord.getTask() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !mActivityRecord.getTask().getRootTask().shouldIgnoreInput()</span><br><span class="line">            &amp;&amp; mActivityRecord.mVisibleRequested</span><br><span class="line">            &amp;&amp; !isRecentsAnimationConsumingAppInput();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到如果是非ActivityRecord对应的Window那么直接返回true，如果该ActivityRecord还没有被加入task也直接返回true.</p>
<ol>
<li>!mActivityRecord.getTask().getRootTask().shouldIgnoreInput()：该ActivityRecord的task所处的rootTask没有被设置忽略input事件</li>
<li>mActivityRecord.mVisibleRequested: 该ActivityRecord被设置了VISIBLE</li>
<li>!isRecentsAnimationConsumingAppInput():该窗口没有作为最近任务窗口的动画的一部分时</li>
</ol>
<h2 id="1-2-WMS-updateFocusedWindowLocked"><a href="#1-2-WMS-updateFocusedWindowLocked" class="headerlink" title="1.2 WMS.updateFocusedWindowLocked"></a>1.2 WMS.updateFocusedWindowLocked</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">updateFocusedWindowLocked</span><span class="params">(<span class="type">int</span> mode, <span class="type">boolean</span> updateInputWindows)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;wmUpdateFocus&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> mRoot.updateFocusedWindowLocked(mode, updateInputWindows);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的mode是UPDATE_FOCUS_WILL_ASSIGN_LAYERS，而且updateInputWindows为false. WMS.mRoot就是RootWindowContainer.</p>
<h2 id="1-3-RootWindowContainer-updateFocusedWindowLocked"><a href="#1-3-RootWindowContainer-updateFocusedWindowLocked" class="headerlink" title="1.3 RootWindowContainer.updateFocusedWindowLocked"></a>1.3 RootWindowContainer.updateFocusedWindowLocked</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">updateFocusedWindowLocked</span><span class="params">(<span class="type">int</span> mode, <span class="type">boolean</span> updateInputWindows)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先清除mTopFocusedAppByProcess中的元素：ArrayMap&lt;Integer, ActivityRecord&gt; mTopFocusedAppByProcess</span></span><br><span class="line">    mTopFocusedAppByProcess.clear();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">topFocusedDisplayId</span> <span class="operator">=</span> INVALID_DISPLAY;</span><br><span class="line">    <span class="comment">// 遍历所有DisplayContent, 并依次更新焦点窗口, 注意这里是倒序更新计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mChildren.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> mChildren.get(i);</span><br><span class="line">        <span class="comment">// [1.4] 更新单个DisplayContent的焦点窗口</span></span><br><span class="line">        changed |= dc.updateFocusedWindowLocked(mode, updateInputWindows, topFocusedDisplayId);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">newFocus</span> <span class="operator">=</span> dc.mCurrentFocus;</span><br><span class="line">        <span class="comment">// DC存在新的焦点窗口时</span></span><br><span class="line">        <span class="keyword">if</span> (newFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pidOfNewFocus</span> <span class="operator">=</span> newFocus.mSession.mPid;</span><br><span class="line">            <span class="comment">// 将新焦点窗口的ActivityRecord保存在mTopFocusedAppByProcess中</span></span><br><span class="line">            <span class="keyword">if</span> (mTopFocusedAppByProcess.get(pidOfNewFocus) == <span class="literal">null</span>) &#123;</span><br><span class="line">                mTopFocusedAppByProcess.put(pidOfNewFocus, newFocus.mActivityRecord);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新topFocusedDisplayId为该DC的DisplayId</span></span><br><span class="line">            <span class="keyword">if</span> (topFocusedDisplayId == INVALID_DISPLAY) &#123;</span><br><span class="line">                topFocusedDisplayId = dc.getDisplayId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (topFocusedDisplayId == INVALID_DISPLAY &amp;&amp; dc.mFocusedApp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 即使应用窗口还没有准备好(未附加进程或未添加窗口)，具有焦点应用的顶部显示仍然应该是焦点顶部显示</span></span><br><span class="line">            topFocusedDisplayId = dc.getDisplayId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (topFocusedDisplayId == INVALID_DISPLAY) &#123;</span><br><span class="line">        topFocusedDisplayId = DEFAULT_DISPLAY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当焦点所处的display有变化时</span></span><br><span class="line">    <span class="keyword">if</span> (mTopFocusedDisplayId != topFocusedDisplayId) &#123;</span><br><span class="line">        mTopFocusedDisplayId = topFocusedDisplayId;</span><br><span class="line">        <span class="comment">// [2.1] 通知input系统更新displayId</span></span><br><span class="line">        mWmService.mInputManager.setFocusedDisplay(topFocusedDisplayId);</span><br><span class="line">        <span class="comment">// 将PhoneWindowManager中的mTopFocusedDisplayId更新为新焦点窗口所处的DisplayId</span></span><br><span class="line">        mWmService.mPolicy.setTopFocusedDisplay(topFocusedDisplayId);</span><br><span class="line">        ProtoLog.d(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;New topFocusedDisplayId=%d&quot;</span>, topFocusedDisplayId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算更新焦点窗口是对所有DisplayContent的依次计算更新焦点窗口。首先清除mTopFocusedAppByProcess中的元素，然后依次更新所有DisplayContent的焦点窗口。</p>
<h2 id="1-4-DisplayContent-updateFocusedWindowLocked"><a href="#1-4-DisplayContent-updateFocusedWindowLocked" class="headerlink" title="1.4 DisplayContent.updateFocusedWindowLocked"></a>1.4 DisplayContent.updateFocusedWindowLocked</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">updateFocusedWindowLocked</span><span class="params">(<span class="type">int</span> mode, <span class="type">boolean</span> updateInputWindows,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> topFocusedDisplayId)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.4.1] 计算当前DisplayContent的焦点窗口，注意传入的topFocusedDisplayId是INVALID_DISPLAY</span></span><br><span class="line">    <span class="type">WindowState</span> <span class="variable">newFocus</span> <span class="operator">=</span> findFocusedWindowIfNeeded(topFocusedDisplayId);</span><br><span class="line">    <span class="comment">// 如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentFocus == newFocus) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">imWindowChanged</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">imWindow</span> <span class="operator">=</span> mInputMethodWindow;</span><br><span class="line">    <span class="comment">// 如果当前存在输入法窗口，这里我们先假设不存在</span></span><br><span class="line">    <span class="keyword">if</span> (imWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProtoLog.d(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;Changing focus from %s to %s displayId=%d Callers=%s&quot;</span>,</span><br><span class="line">            mCurrentFocus, newFocus, getDisplayId(), Debug.getCallers(<span class="number">4</span>));</span><br><span class="line">    <span class="comment">// 更新焦点窗口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">oldFocus</span> <span class="operator">=</span> mCurrentFocus;</span><br><span class="line">    mCurrentFocus = newFocus;</span><br><span class="line">    <span class="comment">// 如果新的焦点窗口不为null</span></span><br><span class="line">    <span class="keyword">if</span> (newFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">        mWinAddedSinceNullFocus.clear();</span><br><span class="line">        mWinRemovedSinceNullFocus.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newFocus.canReceiveKeys()) &#123;</span><br><span class="line">            <span class="comment">// 隐式地显示一个窗口将导致取消调度</span></span><br><span class="line">            <span class="comment">// 这是为了防止有人暂停调度但忘记resume</span></span><br><span class="line">            newFocus.mToken.paused = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [1.4.2] 通知其他模组焦点窗口更新了,主要是更新两个Task的阴影</span></span><br><span class="line">    onWindowFocusChanged(oldFocus, newFocus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.4.3] 更新DisplayPolicy中相关参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">focusChanged</span> <span class="operator">=</span> getDisplayPolicy().focusChangedLw(oldFocus, newFocus);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((focusChanged &amp; FINISH_LAYOUT_REDO_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 焦点的变化导致需要做一个布局， SystemUI状态栏或者导航栏可见性有变化了</span></span><br><span class="line">        <span class="comment">// 将参数mLayoutNeeded置位true</span></span><br><span class="line">        setLayoutNeeded();</span><br><span class="line">        <span class="comment">// 这里传入的mode为UPDATE_FOCUS_WILL_ASSIGN_LAYERS</span></span><br><span class="line">        <span class="keyword">if</span> (mode == UPDATE_FOCUS_PLACING_SURFACES) &#123;</span><br><span class="line">            performLayout(<span class="literal">true</span> <span class="comment">/*initial*/</span>, updateInputWindows);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == UPDATE_FOCUS_REMOVING_FOCUS) &#123;</span><br><span class="line">            mWmService.mRoot.performSurfacePlacement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI</span></span><br><span class="line">    scheduleToastWindowsTimeoutIfNeededLocked(oldFocus, newFocus);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 记录新焦点窗口</span></span><br><span class="line">    mLastFocus = mCurrentFocus;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DisplayContent更新焦点窗口的流程如下:</p>
<ol>
<li>计算当前DisplayContent的焦点窗口</li>
<li>如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作</li>
<li>如果当前存在输入法窗口,执行相关操作(后续分析输入法窗口)</li>
<li>更新焦点窗口，保存在mCurrentFocus中<ol>
<li>清空mWinAddedSinceNullFocus、mWinRemovedSinceNullFocus</li>
</ol>
</li>
<li>通知其他模组焦点窗口更新了,主要是更新两个Task（当前焦点窗口和新的焦点窗口所处的Task）的阴影</li>
<li>更新DisplayPolicy中相关参数<ol>
<li>更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性</li>
</ol>
</li>
<li>如果因焦点窗口变化导致SystemUI状态栏或者导航栏可见性有变化了，将参数mLayoutNeeded置位true</li>
<li>将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI</li>
<li>记录新焦点窗口，保存在mLastFocus中</li>
</ol>
<h3 id="1-4-1-DisplayContent-findFocusedWindowIfNeeded"><a href="#1-4-1-DisplayContent-findFocusedWindowIfNeeded" class="headerlink" title="1.4.1 DisplayContent.findFocusedWindowIfNeeded"></a>1.4.1 DisplayContent.findFocusedWindowIfNeeded</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WindowState <span class="title function_">findFocusedWindowIfNeeded</span><span class="params">(<span class="type">int</span> topFocusedDisplayId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mWmService.mPerDisplayFocusEnabled || topFocusedDisplayId == INVALID_DISPLAY)</span><br><span class="line">                ? findFocusedWindow() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowState <span class="title function_">findFocusedWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    mTmpWindow = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// [1.4.1.1] 从上到下遍历所有的ActivityRecord，并对每一个执行mFindFocusedWindow方法</span></span><br><span class="line">    forAllWindows(mFindFocusedWindow, <span class="literal">true</span> <span class="comment">/* traverseTopToBottom */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTmpWindow == <span class="literal">null</span>) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;findFocusedWindow: No focusable windows, display=%d&quot;</span>,</span><br><span class="line">                getDisplayId());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mTmpWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的mFindFocusedWindow其实是一个函数: ToBooleanFunction<WindowState> mFindFocusedWindow, 这里又是使用了函数式编程的方法。我们先看forAllWindows方法，这个是被继承的祖父类WindowContainer中的方法。</WindowState></p>
<h4 id="1-4-1-1-WindowContainer-forAllWindows"><a href="#1-4-1-1-WindowContainer-forAllWindows" class="headerlink" title="1.4.1.1 WindowContainer.forAllWindows"></a>1.4.1.1 WindowContainer.forAllWindows</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">forAllWindows</span><span class="params">(ToBooleanFunction&lt;WindowState&gt; callback, <span class="type">boolean</span> traverseTopToBottom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (traverseTopToBottom) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mChildren.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildren.get(i).forAllWindows(callback, traverseTopToBottom)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildren.get(i).forAllWindows(callback, traverseTopToBottom)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对该WindowContainer的mChildren中的每一个元素执行forAllWindows，调用callback。traverseTopToBottom参数如果为true，则按z顺序从上到下遍历层次结构，否则从下到上遍历。如果因为传入的函数callback执行后的返回值为true,那么会中止遍历直接返回true。</p>
<p>回顾下DisplayContent的类图:</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/6_1.png" alt="6-1"></p>
<p>可以看到DisplayContent的是从WindowContainer<WindowContainer>一路继承下来的，所以其mChildren就是 WindowList<DisplayArea>。</DisplayArea></WindowContainer></p>
<p>而DisplayArea也是继承了WindowContainer，所以到底这个DisplayContent里存储了什么元素呢？ 回到之前我们研究过的DisplayContent的创建 <em><strong>WMS(2)-WMS中RootDisplayArea的创建</strong></em>， 在这里我们知道DisplayContent的mChildren中存储的是DisplayArea的对象，所以而DisplayArea又是继承了WindowContainer，然而DisplayArea中的mChildren存储的是ActivityRecord或者WindowState.</p>
<h4 id="1-4-1-2-WindowState-forAllWindows"><a href="#1-4-1-2-WindowState-forAllWindows" class="headerlink" title="1.4.1.2 WindowState.forAllWindows"></a>1.4.1.2 WindowState.forAllWindows</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">forAllWindows</span><span class="params">(ToBooleanFunction&lt;WindowState&gt; callback, <span class="type">boolean</span> traverseTopToBottom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildren.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// The window has no children so we just return it.</span></span><br><span class="line">        <span class="keyword">return</span> applyInOrderWithImeWindows(callback, traverseTopToBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (traverseTopToBottom) &#123;</span><br><span class="line">        <span class="keyword">return</span> forAllWindowTopToBottom(callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> forAllWindowBottomToTop(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们假设该mChildren为null:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">applyInOrderWithImeWindows</span><span class="params">(ToBooleanFunction&lt;WindowState&gt; callback,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> traverseTopToBottom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (traverseTopToBottom) &#123;</span><br><span class="line">        <span class="comment">// applyImeWindowsIfNeeded是用于处理输入法窗口的，暂时先不管。</span></span><br><span class="line">        <span class="keyword">if</span> (applyImeWindowsIfNeeded(callback, traverseTopToBottom)</span><br><span class="line">                <span class="comment">// [1.5] 对该Window执行传入的函数,即mFindFocusedWindow</span></span><br><span class="line">                || callback.apply(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback.apply(<span class="built_in">this</span>)</span><br><span class="line">                || applyImeWindowsIfNeeded(callback, traverseTopToBottom)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-DisplayContent-onWindowFocusChanged"><a href="#1-4-2-DisplayContent-onWindowFocusChanged" class="headerlink" title="1.4.2 DisplayContent.onWindowFocusChanged"></a>1.4.2 DisplayContent.onWindowFocusChanged</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(WindowState oldFocus, WindowState newFocus)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">focusedTask</span> <span class="operator">=</span> newFocus != <span class="literal">null</span> ? newFocus.getTask() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">unfocusedTask</span> <span class="operator">=</span> oldFocus != <span class="literal">null</span> ? oldFocus.getTask() : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果是同一个task就不需要额外动作</span></span><br><span class="line">    <span class="keyword">if</span> (focusedTask == unfocusedTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知新的焦点窗口所处的Task有焦点了</span></span><br><span class="line">    <span class="keyword">if</span> (focusedTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        focusedTask.onWindowFocusChanged(<span class="literal">true</span> <span class="comment">/* hasFocus */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 之前焦点窗口所处的Task失去焦点</span></span><br><span class="line">    <span class="keyword">if</span> (unfocusedTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        unfocusedTask.onWindowFocusChanged(<span class="literal">false</span> <span class="comment">/* hasFocus */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从WindowState中拿到的Task其实是其对应的ActivityRecord所在的Task：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowState.java</span></span><br><span class="line">Task <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mActivityRecord != <span class="literal">null</span> ? mActivityRecord.getTask() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityRecord.java</span></span><br><span class="line">Task <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个ActivityRecord.task就是 <em><strong>WMS(3)-ActivityRecord和WindowToken</strong></em> 中 [1.7.1]里赋值的，其实就是该ActivityRecord的mParent（创建的新Task）。</p>
<h4 id="1-4-2-1-Task-onWindowFocusChanged"><a href="#1-4-2-1-Task-onWindowFocusChanged" class="headerlink" title="1.4.2.1 Task.onWindowFocusChanged"></a>1.4.2.1 Task.onWindowFocusChanged</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(<span class="type">boolean</span> hasFocus)</span> &#123;</span><br><span class="line">    updateShadowsRadius(hasFocus, getSyncTransaction());</span><br><span class="line">    <span class="comment">// TODO(b/180525887): Un-comment once there is resolution on the bug.</span></span><br><span class="line">    <span class="comment">// dispatchTaskInfoChangedIfNeeded(false /* force */);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateShadowsRadius</span><span class="params">(<span class="type">boolean</span> taskIsFocused,</span></span><br><span class="line"><span class="params">        SurfaceControl.Transaction pendingTransaction)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!mWmService.mRenderShadowsInCompositor || !isRootTask()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据窗口模式和任务焦点状态更新阴影的长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">newShadowRadius</span> <span class="operator">=</span> getShadowRadius(taskIsFocused);</span><br><span class="line">    <span class="keyword">if</span> (mShadowRadius != newShadowRadius) &#123;</span><br><span class="line">        mShadowRadius = newShadowRadius;</span><br><span class="line">        pendingTransaction.setShadowRadius(getSurfaceControl(), mShadowRadius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据该task是否持有焦点来更新阴影，后续研究</p>
<h3 id="1-4-3-DisplayPolicy-focusChangedLw"><a href="#1-4-3-DisplayPolicy-focusChangedLw" class="headerlink" title="1.4.3 DisplayPolicy.focusChangedLw"></a>1.4.3 DisplayPolicy.focusChangedLw</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">focusChangedLw</span><span class="params">(WindowState lastFocus, WindowState newFocus)</span> &#123;</span><br><span class="line">    mFocusedWindow = newFocus;</span><br><span class="line">    mLastFocusedWindow = lastFocus;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayContent.isDefaultDisplay) &#123;</span><br><span class="line">        <span class="comment">// 更新PhoneWindowManager中相关参数，就是更新DisplayFoldController中的mFocusedApp(焦点窗口包名)</span></span><br><span class="line">        mService.mPolicy.onDefaultDisplayFocusChangedLw(newFocus);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新SystemUi的可见与否，比如状态栏等，后续研究</span></span><br><span class="line">    <span class="keyword">if</span> (updateSystemUiVisibilityLw()) &#123;</span><br><span class="line">        <span class="comment">// 如果导航栏已经被隐藏或显示，需要做另一个布局传递来更新窗口</span></span><br><span class="line">        <span class="keyword">return</span> FINISH_LAYOUT_REDO_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里更新DisplayPolicy中存储的焦点窗口相关信息，包括更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性。</p>
<h2 id="1-5-DisplayContent-mFindFocusedWindow"><a href="#1-5-DisplayContent-mFindFocusedWindow" class="headerlink" title="1.5 DisplayContent.mFindFocusedWindow"></a>1.5 DisplayContent.mFindFocusedWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ToBooleanFunction&lt;WindowState&gt; mFindFocusedWindow = w -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">focusedApp</span> <span class="operator">=</span> mFocusedApp;</span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS, <span class="string">&quot;Looking for focus: %s, flags=%d, canReceive=%b, reason=%s&quot;</span>,</span><br><span class="line">            w, w.mAttrs.flags, w.canReceiveKeys(),</span><br><span class="line">            w.canReceiveKeysReason(<span class="literal">false</span> <span class="comment">/* fromUserTouch */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查该窗口是否可以接收input事件</span></span><br><span class="line">    <span class="comment">// 无法接收输入事件的窗口没有资格作为焦点窗口</span></span><br><span class="line">    <span class="keyword">if</span> (!w.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> w.mActivityRecord;</span><br><span class="line">    <span class="comment">// 如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了</span></span><br><span class="line">    <span class="keyword">if</span> (focusedApp == <span class="literal">null</span>) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_FOCUS_LIGHT,</span><br><span class="line">                <span class="string">&quot;findFocusedWindow: focusedApp=null using new focus @ %s&quot;</span>, w);</span><br><span class="line">        mTmpWindow = w;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口</span></span><br><span class="line">    <span class="keyword">if</span> (!focusedApp.windowsAreFocusable()) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;findFocusedWindow: focusedApp windows not&quot;</span></span><br><span class="line">                + <span class="string">&quot; focusable using new focus @ %s&quot;</span>, w);</span><br><span class="line">        mTmpWindow = w;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有app的token, 找到第一个符合要求的作为焦点窗口(从上到下遍历所有的ActivityRecord,所以第一个符合的token对应窗口Z轴最大)</span></span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="literal">null</span> &amp;&amp; w.mAttrs.type != TYPE_APPLICATION_STARTING) &#123;</span><br><span class="line">        <span class="comment">// WindowState对应的有Activity, 而且类型不能是启动窗口</span></span><br><span class="line">        <span class="comment">// [1.6] 对比计算Z轴大小</span></span><br><span class="line">        <span class="keyword">if</span> (focusedApp.compareTo(activity) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前焦点窗口Z轴比该Activity窗口大</span></span><br><span class="line">            ProtoLog.v(WM_DEBUG_FOCUS_LIGHT,</span><br><span class="line">                    <span class="string">&quot;findFocusedWindow: Reached focused app=%s&quot;</span>, focusedApp);</span><br><span class="line">            mTmpWindow = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了新的焦点窗口，暂存在mTmpWindow中</span></span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;findFocusedWindow: Found new focus @ %s&quot;</span>, w);</span><br><span class="line">    mTmpWindow = w;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新焦点窗口的步骤也不复杂：</p>
<ol>
<li>遍历该DisplayContent中mChildren中的所有DisplayArea</li>
<li>依次对比DisplayArea中的mChildren集合里面的Window(ActivityRecord或WindowState)<ol>
<li>检查该Window是否符合要求</li>
<li>无法接收输入事件的窗口没有资格作为焦点窗口</li>
<li>如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了</li>
<li>如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口</li>
<li>遍历所有app的token, 找到第一个符合要求的作为焦点窗口<ol>
<li>WindowState对应的有Activity, 而且类型不能是启动窗口</li>
<li>该Activity窗口Z轴比当前焦点窗口大</li>
<li>更新mTmpWindow为当前Activity窗口，否则置为null</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="1-6-ActivityRecord-compareTo"><a href="#1-6-ActivityRecord-compareTo" class="headerlink" title="1.6 ActivityRecord.compareTo"></a>1.6 ActivityRecord.compareTo</h2><p>ActivityRecord其实是调用了父类WindowContainer中的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(WindowContainer other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该Activity的mParent是同一个，那么就对比两个在其中所处的位置</span></span><br><span class="line">    <span class="comment">// 序号就代表了Z轴，可以理解为序号大的在上层，盖住序号小的</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span> &amp;&amp; mParent == other.mParent) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowList&lt;WindowContainer&gt; list = mParent.mChildren;</span><br><span class="line">        <span class="keyword">return</span> list.indexOf(<span class="built_in">this</span>) &gt; list.indexOf(other) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个WindowContainer不是同一个mParent, 那么先找到z轴最大的包含两个WC的父容器，然后对比z轴大小</span></span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;WindowContainer&gt; thisParentChain = mTmpChain1;</span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;WindowContainer&gt; otherParentChain = mTmpChain2;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [1.6.1] 获取当前WindowContainer的所有父容器</span></span><br><span class="line">        getParents(thisParentChain);</span><br><span class="line">        other.getParents(otherParentChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到z轴最大的且包含两个WC的父容器</span></span><br><span class="line">        <span class="type">WindowContainer</span> <span class="variable">commonAncestor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WindowContainer</span> <span class="variable">thisTop</span> <span class="operator">=</span> thisParentChain.peekLast();</span><br><span class="line">        <span class="type">WindowContainer</span> <span class="variable">otherTop</span> <span class="operator">=</span> otherParentChain.peekLast();</span><br><span class="line">        <span class="keyword">while</span> (thisTop != <span class="literal">null</span> &amp;&amp; otherTop != <span class="literal">null</span> &amp;&amp; thisTop == otherTop) &#123;</span><br><span class="line">            <span class="comment">// 移除拿到最后一个父容器</span></span><br><span class="line">            commonAncestor = thisParentChain.removeLast();</span><br><span class="line">            otherParentChain.removeLast();</span><br><span class="line">            thisTop = thisParentChain.peekLast();</span><br><span class="line">            otherTop = otherParentChain.peekLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子容器总是被认为比父容器大，所以如果将一个容器与另一个容器的父容器进行比较，那么无论如何都是子容器更大。</span></span><br><span class="line">        <span class="keyword">if</span> (commonAncestor == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commonAncestor == other) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各自对比两个WC在Z轴最大的父容器中的位置</span></span><br><span class="line">        <span class="keyword">final</span> WindowList&lt;WindowContainer&gt; list = commonAncestor.mChildren;</span><br><span class="line">        <span class="keyword">return</span> list.indexOf(thisParentChain.peekLast()) &gt; list.indexOf(otherParentChain.peekLast())</span><br><span class="line">                ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mTmpChain1.clear();</span><br><span class="line">        mTmpChain2.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将WC的整个结构理解为树形结构，对比两个WC的Z轴大小就是对比这两个WC与最近的共同父节点的距离大小，距离越大，说明Z轴越大。</p>
<h3 id="1-6-1-WindowContainer-getParents"><a href="#1-6-1-WindowContainer-getParents" class="headerlink" title="1.6.1 WindowContainer.getParents"></a>1.6.1 WindowContainer.getParents</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getParents</span><span class="params">(LinkedList&lt;WindowContainer&gt; parents)</span> &#123;</span><br><span class="line">    parents.clear();</span><br><span class="line">    <span class="type">WindowContainer</span> <span class="variable">current</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parents.addLast(current);</span><br><span class="line">        current = current.mParent;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依次遍历，将该WindowContainer的所有mParent添加到队列中.</p>
<h1 id="二-小结"><a href="#二-小结" class="headerlink" title="二. 小结"></a>二. 小结</h1><p>总的来说，更新焦点窗口就是对所有DisplayContent倒序遍历，依次计算新的焦点窗口：</p>
<ol>
<li>计算当前DisplayContent的焦点窗口<ol>
<li>遍历该DisplayContent中mChildren中的所有DisplayArea</li>
<li>依次对比DisplayArea中的mChildren集合里面的Window(ActivityRecord或WindowState)<ol>
<li>检查该Window是否符合要求</li>
<li>无法接收输入事件的窗口没有资格作为焦点窗口</li>
<li>如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了</li>
<li>如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口</li>
<li>遍历所有app的token, 找到第一个符合要求的作为焦点窗口<ol>
<li>WindowState对应的有Activity, 而且类型不能是启动窗口</li>
<li>该Activity窗口Z轴比当前焦点窗口大</li>
<li>更新mTmpWindow为当前Activity窗口，否则置为null</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作</li>
<li>如果当前存在输入法窗口,执行相关操作(后续分析输入法窗口)</li>
<li>更新焦点窗口，保存在mCurrentFocus中<ol>
<li>清空mWinAddedSinceNullFocus、mWinRemovedSinceNullFocus</li>
</ol>
</li>
<li>通知其他模组焦点窗口更新了,主要是更新两个Task（当前焦点窗口和新的焦点窗口所处的Task）的阴影</li>
<li>更新DisplayPolicy中相关参数<ol>
<li>更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性</li>
</ol>
</li>
<li>如果因焦点窗口变化导致SystemUI状态栏或者导航栏可见性有变化了，将参数mLayoutNeeded置位true</li>
<li>将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI</li>
<li>记录新焦点窗口，保存在mLastFocus中</li>
</ol>
<h2 id="2-1-通知input系统更新焦点窗口"><a href="#2-1-通知input系统更新焦点窗口" class="headerlink" title="2.1 通知input系统更新焦点窗口"></a>2.1 通知input系统更新焦点窗口</h2><p>在WMS计算更新完焦点窗口之后，需要同步通知给input系统:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [2.1] 如果焦点窗口有更新，也需要更新input相关设置</span></span><br><span class="line"><span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">    displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus,</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很自然就有疑问，窗口可大可小，不同的窗口层叠起来，input系统是如何判断分发事件到正确的窗口呢？ 接下来我们先看看应用窗口和input的关系。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WMS</tag>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(7)-窗口和InputChannel的联系</title>
    <url>/2022/05/07/WMS(7)-%E7%AA%97%E5%8F%A3%E5%92%8CInputChannel%E7%9A%84%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文集中研究input和窗口的关系, 特别是input系统是如何将事件传给正确的窗口进程的。</p>
<p>在Activity的resume过程中，会通过ViewRootImpl.setView向WMS传递其窗口信息，我们还是从这里入手：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">// 创建InputChannel</span></span><br><span class="line">            <span class="type">InputChannel</span> <span class="variable">inputChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// INPUT_FEATURE_NO_INPUT_CHANNEL 的意思是该窗口不接受input事件</span></span><br><span class="line">            <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                    &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 仅仅是实例化InputChannel， 啥也没有做</span></span><br><span class="line">                inputChannel = <span class="keyword">new</span> <span class="title class_">InputChannel</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            .......</span><br><span class="line">                <span class="comment">// 将InputChannel传入WMS中, 我们先进入看这个</span></span><br><span class="line">                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(), userId,</span><br><span class="line">                        mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets,</span><br><span class="line">                        mTempControls);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 处理后续</span></span><br><span class="line">            <span class="keyword">if</span> (inputChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// [3.1] 创建InputEventReceiver用于接收Input事件</span></span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> <span class="title class_">WindowInputEventReceiver</span>(inputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WMS.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// attrs就是上面ViewRootImpl中的mWindowAttributes</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">openInputChannels</span> <span class="operator">=</span> (outInputChannel != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">            <span class="comment">// [1.1] 初始化InputChanel</span></span><br><span class="line">            win.openInputChannel(outInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意初始化InputChannel是在WindowState之后，也是通过其openInputChannel的。</p>
<h1 id="一-InputChannel的初始化和Dispose"><a href="#一-InputChannel的初始化和Dispose" class="headerlink" title="一. InputChannel的初始化和Dispose"></a>一. InputChannel的初始化和Dispose</h1><h2 id="1-1-WindowState-openInputChannel"><a href="#1-1-WindowState-openInputChannel" class="headerlink" title="1.1 WindowState.openInputChannel"></a>1.1 WindowState.openInputChannel</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">openInputChannel</span><span class="params">(InputChannel outInputChannel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Window already has an input channel.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取名称: 数字+窗口包名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getName();</span><br><span class="line">    <span class="comment">// [1.2] 通过InputManager创建InputChannel</span></span><br><span class="line">    mInputChannel = mWmService.mInputManager.createInputChannel(name);</span><br><span class="line">    <span class="comment">// 注意这里的token, 后面会发现其实是native创建的BBinder</span></span><br><span class="line">    mInputChannelToken = mInputChannel.getToken();</span><br><span class="line">    <span class="comment">// mInputWindowHandle是WindowState初始化时创建的</span></span><br><span class="line">    mInputWindowHandle.setToken(mInputChannelToken);</span><br><span class="line">    <span class="comment">// 将该InputChannel和WindowState作为KV对保存</span></span><br><span class="line">    mWmService.mInputToWindowMap.put(mInputChannelToken, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// [2.1] 将创建的InputChannel拷贝到outInputChannel中， 这个outInputChannel就是应用进程中创建的InputChannel</span></span><br><span class="line">        mInputChannel.copyTo(outInputChannel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the window died visible, we setup a fake input channel, so that taps</span></span><br><span class="line">        <span class="comment">// can still detected by input monitor channel, and we can relaunch the app.</span></span><br><span class="line">        <span class="comment">// Create fake event receiver that simply reports all events as handled.</span></span><br><span class="line">        mDeadWindowEventReceiver = <span class="keyword">new</span> <span class="title class_">DeadWindowEventReceiver</span>(mInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-InputManagerService-createInputChannel"><a href="#1-2-InputManagerService-createInputChannel" class="headerlink" title="1.2 InputManagerService.createInputChannel"></a>1.2 InputManagerService.createInputChannel</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel <span class="title function_">nativeCreateInputChannel</span><span class="params">(<span class="type">long</span> ptr, String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> InputChannel <span class="title function_">createInputChannel</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeCreateInputChannel(mPtr, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过JNI由native层创建InputChannel。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com_android_server_input_InputManagerService.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">nativeCreateInputChannel</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jstring nameObj)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="built_in">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">nameChars</span><span class="params">(env, nameObj)</span></span>;</span><br><span class="line">    std::string name = nameChars.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">// [1.3] 创建Native层的InputChannel</span></span><br><span class="line">    base::Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; inputChannel = im-&gt;<span class="built_in">createInputChannel</span>(env, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inputChannel.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::string message = inputChannel.<span class="built_in">error</span>().<span class="built_in">message</span>();</span><br><span class="line">        message += <span class="built_in">StringPrintf</span>(<span class="string">&quot; Status=%d&quot;</span>, inputChannel.<span class="built_in">error</span>().<span class="built_in">code</span>());</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.4] 通过JNI调用java层函数，创建java对象InputChannel</span></span><br><span class="line">    jobject inputChannelObj =</span><br><span class="line">            <span class="built_in">android_view_InputChannel_createJavaObject</span>(env, std::<span class="built_in">move</span>(*inputChannel));</span><br><span class="line">    <span class="keyword">if</span> (!inputChannelObj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.5] 注册资源回收处理的回调函数</span></span><br><span class="line">    <span class="built_in">android_view_InputChannel_setDisposeCallback</span>(env, inputChannelObj,</span><br><span class="line">            handleInputChannelDisposed, im);</span><br><span class="line">    <span class="keyword">return</span> inputChannelObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-NativeInputManager-createInputChannel"><a href="#1-3-NativeInputManager-createInputChannel" class="headerlink" title="1.3 NativeInputManager.createInputChannel"></a>1.3 NativeInputManager.createInputChannel</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com_android_server_input_InputManagerService.cpp</span></span><br><span class="line">base::Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; NativeInputManager::<span class="built_in">createInputChannel</span>(</span><br><span class="line">        JNIEnv* <span class="comment">/* env */</span>, <span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="comment">// [1.3.1] 交给InputDispatcher</span></span><br><span class="line">    <span class="keyword">return</span> mInputManager-&gt;<span class="built_in">getDispatcher</span>()-&gt;<span class="built_in">createInputChannel</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InputManager.cpp</span></span><br><span class="line"><span class="function">sp&lt;InputDispatcherInterface&gt; <span class="title">InputManager::getDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于InputDispatcher的初始化后续单独分析。</p>
<h3 id="1-3-1-InputDispatcher-createInputChannel"><a href="#1-3-1-InputDispatcher-createInputChannel" class="headerlink" title="1.3.1 InputDispatcher.createInputChannel"></a>1.3.1 InputDispatcher.createInputChannel</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InputTransport.cpp</span></span><br><span class="line">Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; InputDispatcher::<span class="built_in">createInputChannel</span>(<span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;InputChannel&gt; serverChannel;</span><br><span class="line">    std::unique_ptr&lt;InputChannel&gt; clientChannel;</span><br><span class="line">    <span class="comment">// [1.3.2] InputChannel是成对存在的</span></span><br><span class="line">    <span class="type">status_t</span> result = InputChannel::<span class="built_in">openInputChannelPair</span>(name, serverChannel, clientChannel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">return</span> base::<span class="built_in">Error</span>(result) &lt;&lt; <span class="string">&quot;Failed to open input channel pair with name &quot;</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        <span class="type">const</span> sp&lt;IBinder&gt;&amp; token = serverChannel-&gt;<span class="built_in">getConnectionToken</span>();</span><br><span class="line">        <span class="type">int</span> fd = serverChannel-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">        <span class="comment">// 创建Connection, 用于记录此次连接行为</span></span><br><span class="line">        sp&lt;Connection&gt; connection =</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">Connection</span>(std::<span class="built_in">move</span>(serverChannel), <span class="literal">false</span> <span class="comment">/*monitor*/</span>, mIdGenerator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mConnectionsByToken.<span class="built_in">find</span>(token) != mConnectionsByToken.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Created a new connection, but the token %p is already known&quot;</span>, token.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将此次连接行为保存在mConnectionsByToken中</span></span><br><span class="line">        mConnectionsByToken.<span class="built_in">emplace</span>(token, connection);</span><br><span class="line">        <span class="comment">// 利用bind绑定回调函数，顺便固定回调时的第二个参数为token</span></span><br><span class="line">        std::function&lt;<span class="type">int</span>(<span class="type">int</span> events)&gt; callback = std::<span class="built_in">bind</span>(&amp;InputDispatcher::handleReceiveCallback,</span><br><span class="line">                                                            <span class="keyword">this</span>, std::placeholders::_1, token);</span><br><span class="line">        <span class="comment">// 将文件描述符添加进Looper, 这样有事件时会回调handleReceiveCallback</span></span><br><span class="line">        mLooper-&gt;<span class="built_in">addFd</span>(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, <span class="keyword">new</span> <span class="built_in">LooperEventCallback</span>(callback), <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒Looper以执行</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">    <span class="comment">// 返回客户端InputChannel</span></span><br><span class="line">    <span class="keyword">return</span> clientChannel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Native层的InputChannel其实就是利用socket创建了一对套接字，分别作为服务端和客户端，并将服务端的token作为key，存入作为记录此次InputChannel的Connection至mConnectionsByToken中。其后利用bind绑定handleReceiveCallback作为回调函数（注意这里固定了其第二个参数为当前的token），然后将服务端的文件描述符存入mLooper中。最后唤醒mLooper。</p>
<p>注意这里的mLooper是InputDispatcher初始化时创建的：</p>
<blockquote>
<p>mLooper &#x3D; new Looper(false);</p>
</blockquote>
<p>所以这里InputChannel中的服务端就是用来分发input事件的，而客户端的InputChannel应该就需要传给对应的应用进程了。</p>
<h3 id="1-3-2-InputChannel-openInputChannelPair"><a href="#1-3-2-InputChannel-openInputChannelPair" class="headerlink" title="1.3.2 InputChannel.openInputChannelPair"></a>1.3.2 InputChannel.openInputChannelPair</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputChannel::openInputChannelPair</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            std::unique_ptr&lt;InputChannel&gt;&amp; outServerChannel,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            std::unique_ptr&lt;InputChannel&gt;&amp; outClientChannel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 原来InputChannel之所以需要成对是因为这里是通过socket实现的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">socketpair</span>(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="type">status_t</span> result = -errno;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;channel &#x27;%s&#x27; ~ Could not create socket pair.  errno=%s(%d)&quot;</span>, name.<span class="built_in">c_str</span>(),</span><br><span class="line">              <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        outServerChannel.<span class="built_in">reset</span>();</span><br><span class="line">        outClientChannel.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    sp&lt;IBinder&gt; token = <span class="keyword">new</span> <span class="built_in">BBinder</span>();</span><br><span class="line"></span><br><span class="line">    std::string serverChannelName = name + <span class="string">&quot; (server)&quot;</span>;</span><br><span class="line">    android::<span class="function">base::unique_fd <span class="title">serverFd</span><span class="params">(sockets[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="comment">// [1.3.3] 创建native层的InputChannel对象</span></span><br><span class="line">    outServerChannel = InputChannel::<span class="built_in">create</span>(serverChannelName, std::<span class="built_in">move</span>(serverFd), token);</span><br><span class="line"></span><br><span class="line">    std::string clientChannelName = name + <span class="string">&quot; (client)&quot;</span>;</span><br><span class="line">    android::<span class="function">base::unique_fd <span class="title">clientFd</span><span class="params">(sockets[<span class="number">1</span>])</span></span>;</span><br><span class="line">    outClientChannel = InputChannel::<span class="built_in">create</span>(clientChannelName, std::<span class="built_in">move</span>(clientFd), token);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>socketpair()函数用于创建一对无名的、相互连接的套接字。如果函数成功，则返回0，创建好的套接字分别是sockets[0]和sockets[1]；否则返回-1，错误码保存于errno中。</p>
<ol>
<li>这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sockets[0]中写，从sockets[1]中读；或者从sockets[1]中写，从sockets[0]中读； </li>
<li>如果往一个套接字(如sockets[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sockets[1])上读成功； </li>
<li>读、写操作可以位于同一个进程，也可以分别位于不同的进程。因为sockets[0]和sockets[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。</li>
</ol>
<h3 id="1-3-3-InputChannel-create"><a href="#1-3-3-InputChannel-create" class="headerlink" title="1.3.3 InputChannel.create"></a>1.3.3 InputChannel.create</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;InputChannel&gt; <span class="title">InputChannel::create</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   android::base::unique_fd fd, sp&lt;IBinder&gt; token)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> result = <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;channel &#x27;%s&#x27; ~ Could not make socket non-blocking: %s&quot;</span>, name.<span class="built_in">c_str</span>(),</span><br><span class="line">                         <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// using &#x27;new&#x27; to access a non-public constructor</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;InputChannel&gt;(<span class="keyword">new</span> <span class="built_in">InputChannel</span>(name, std::<span class="built_in">move</span>(fd), token));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputChannel::<span class="built_in">InputChannel</span>(<span class="type">const</span> std::string name, android::base::unique_fd fd, sp&lt;IBinder&gt; token)</span><br><span class="line">      : <span class="built_in">mName</span>(std::<span class="built_in">move</span>(name)), <span class="built_in">mFd</span>(std::<span class="built_in">move</span>(fd)), <span class="built_in">mToken</span>(std::<span class="built_in">move</span>(token)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_CHANNEL_LIFECYCLE) &#123;</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">&quot;Input channel constructed: name=&#x27;%s&#x27;, fd=%d&quot;</span>, <span class="built_in">getName</span>().<span class="built_in">c_str</span>(), <span class="built_in">getFd</span>().<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>native层的InputChannel原来就是一对套接字，分成server端和client端，用于跨进程通信。</p>
<h2 id="1-4-android-view-InputChannel-createJavaObject"><a href="#1-4-android-view-InputChannel-createJavaObject" class="headerlink" title="1.4 android_view_InputChannel_createJavaObject"></a>1.4 android_view_InputChannel_createJavaObject</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android_view_InputChannel.cpp#123</span></span><br><span class="line"><span class="function">jobject <span class="title">android_view_InputChannel_createJavaObject</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   std::unique_ptr&lt;InputChannel&gt; inputChannel)</span> </span>&#123;</span><br><span class="line">    std::string name = inputChannel-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    <span class="comment">// 创建NativeInputChannel</span></span><br><span class="line">    jlong ptr = <span class="built_in">android_view_InputChannel_createInputChannel</span>(env, std::<span class="built_in">move</span>(inputChannel));</span><br><span class="line">    <span class="comment">// 初始化java层的InputChannel</span></span><br><span class="line">    <span class="comment">// gInputChannelClassInfo.mCtor =&gt; &quot;&lt;init&gt;&quot;;</span></span><br><span class="line">    <span class="comment">// 调用java层InputChannel的构造函数，生成对象</span></span><br><span class="line">    jobject javaInputChannel =</span><br><span class="line">            env-&gt;<span class="built_in">NewObject</span>(gInputChannelClassInfo.clazz, gInputChannelClassInfo.mCtor);</span><br><span class="line">    <span class="keyword">if</span> (!javaInputChannel) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to create a Java InputChannel for channel %s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gInputChannelClassInfo.mSetNativeInputChannel =&gt; &quot;setNativeInputChannel&quot;</span></span><br><span class="line">    <span class="comment">// [1.4.1] 调用setNativeInputChannel函数设置ptr</span></span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(javaInputChannel, gInputChannelClassInfo.mSetNativeInputChannel, ptr);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionOccurred</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to set native ptr to the Java InputChannel for channel %s.&quot;</span>,</span><br><span class="line">              inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回java层的InputChannel对象</span></span><br><span class="line">    <span class="keyword">return</span> javaInputChannel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_view_InputChannel_createInputChannel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env, std::unique_ptr&lt;InputChannel&gt; inputChannel)</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;NativeInputChannel&gt; nativeInputChannel =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;NativeInputChannel&gt;(std::<span class="built_in">move</span>(inputChannel));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(nativeInputChannel.<span class="built_in">release</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NativeInputChannel::<span class="built_in">NativeInputChannel</span>(std::unique_ptr&lt;InputChannel&gt; inputChannel)</span><br><span class="line">      : <span class="built_in">mInputChannel</span>(std::<span class="built_in">move</span>(inputChannel)), <span class="built_in">mDisposeCallback</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>经过<a href="#131-inputdispatchercreateinputchannel">1.3</a>我们知道这里传入的InputChannel其实是一对socket中代表客户端的那个, 先通过std::move将InputChannel存入新创建的NativeInputChannel对象中，然后通过JNI构造出java层的InputChannel，在调用其setNativeInputChannel，将NativeInputChannel保存在其mPtr中。</p>
<h3 id="1-4-1-InputChannel-setNativeInputChannel"><a href="#1-4-1-InputChannel-setNativeInputChannel" class="headerlink" title="1.4.1 InputChannel.setNativeInputChannel"></a>1.4.1 InputChannel.setNativeInputChannel</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNativeInputChannel</span><span class="params">(<span class="type">long</span> nativeChannel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeChannel == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Attempting to set native input channel to null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Already has native input channel.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">&quot;setNativeInputChannel : &quot;</span> +  String.format(<span class="string">&quot;%x&quot;</span>, nativeChannel));</span><br><span class="line">    &#125;</span><br><span class="line">    sRegistry.registerNativeAllocation(<span class="built_in">this</span>, nativeChannel);</span><br><span class="line">    mPtr = nativeChannel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以java层的InputChannel里的mPtr是对应NativeInputChannel对象的。</p>
<h2 id="1-5-android-view-InputChannel-setDisposeCallback"><a href="#1-5-android-view-InputChannel-setDisposeCallback" class="headerlink" title="1.5 android_view_InputChannel_setDisposeCallback"></a>1.5 android_view_InputChannel_setDisposeCallback</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android_view_InputChannel.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">android_view_InputChannel_setDisposeCallback</span><span class="params">(JNIEnv* env, jobject inputChannelObj,</span></span></span><br><span class="line"><span class="params"><span class="function">        InputChannelObjDisposeCallback callback, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过java层InputChannel中存储的mPtr找到对应的NativeInputChannel</span></span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">            <span class="built_in">android_view_InputChannel_getNativeInputChannel</span>(env, inputChannelObj);</span><br><span class="line">    <span class="keyword">if</span> (!nativeInputChannel || !nativeInputChannel-&gt;<span class="built_in">getInputChannel</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Cannot set dispose callback because input channel object has not been initialized.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// [1.5.1] 这里的data就是NativeInputManager</span></span><br><span class="line">        nativeInputChannel-&gt;<span class="built_in">setDisposeCallback</span>(callback, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> NativeInputChannel* <span class="title">android_view_InputChannel_getNativeInputChannel</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject inputChannelObj)</span> </span>&#123;</span><br><span class="line">    jlong longPtr = env-&gt;<span class="built_in">GetLongField</span>(inputChannelObj, gInputChannelClassInfo.mPtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;NativeInputChannel*&gt;(longPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-NativeInputChannel-setDisposeCallback"><a href="#1-5-1-NativeInputChannel-setDisposeCallback" class="headerlink" title="1.5.1 NativeInputChannel.setDisposeCallback"></a>1.5.1 NativeInputChannel.setDisposeCallback</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputChannel::setDisposeCallback</span><span class="params">(InputChannelObjDisposeCallback callback, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    mDisposeCallback = callback;</span><br><span class="line">    mDisposeData = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将回调函数和相关参数保存起来， 当进程死亡，或者窗口被销毁时，会主动调用InputChannel.dispose()回收资源，最后就会调用到NativeInputChannel.dispose了。</p>
<h3 id="1-5-2-NativeInputChannel-dispose"><a href="#1-5-2-NativeInputChannel-dispose" class="headerlink" title="1.5.2 NativeInputChannel.dispose"></a>1.5.2 NativeInputChannel.dispose</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputChannel::dispose</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInputChannel) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDisposeCallback) &#123;</span><br><span class="line">        <span class="comment">// [1.5.3] 调用回调函数handleInputChannelDisposed</span></span><br><span class="line">        <span class="built_in">mDisposeCallback</span>(env, obj, mInputChannel, mDisposeData);</span><br><span class="line">        mDisposeCallback = <span class="literal">nullptr</span>;</span><br><span class="line">        mDisposeData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputChannel.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-3-handleInputChannelDisposed"><a href="#1-5-3-handleInputChannelDisposed" class="headerlink" title="1.5.3 handleInputChannelDisposed"></a>1.5.3 handleInputChannelDisposed</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handleInputChannelDisposed</span><span class="params">(JNIEnv* env, jobject <span class="comment">/* inputChannelObj */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> std::shared_ptr&lt;InputChannel&gt;&amp; inputChannel,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="built_in">static_cast</span>&lt;NativeInputManager*&gt;(data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;Input channel object &#x27;%s&#x27; was disposed without first being removed with &quot;</span></span><br><span class="line">          <span class="string">&quot;the input manager!&quot;</span>,</span><br><span class="line">          inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 移除连接</span></span><br><span class="line">    im-&gt;<span class="built_in">removeInputChannel</span>(env, inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputManager::removeInputChannel</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">const</span> sp&lt;IBinder&gt;&amp; connectionToken)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">return</span> mInputManager-&gt;<span class="built_in">getDispatcher</span>()-&gt;<span class="built_in">removeInputChannel</span>(connectionToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-4-InputDispatcher-removeInputChannel"><a href="#1-5-4-InputDispatcher-removeInputChannel" class="headerlink" title="1.5.4 InputDispatcher.removeInputChannel"></a>1.5.4 InputDispatcher.removeInputChannel</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputDispatcher::removeInputChannel</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; connectionToken)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="type">status_t</span> status = <span class="built_in">removeInputChannelLocked</span>(connectionToken, <span class="literal">false</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputDispatcher::removeInputChannelLocked</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; connectionToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">bool</span> notify)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过token找到对应的Connection</span></span><br><span class="line">    sp&lt;Connection&gt; connection = <span class="built_in">getConnectionLocked</span>(connectionToken);</span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection can be removed via socket hang up or an explicit call to &#x27;removeInputChannel&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [1.5.4.1] 将该Connection从集合中移除</span></span><br><span class="line">    <span class="built_in">removeConnectionLocked</span>(connection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;monitor) &#123;</span><br><span class="line">        <span class="built_in">removeMonitorChannelLocked</span>(connectionToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将对应服务端Socket描述符从mLooper中移除，这样就不会接收到事件了</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">removeFd</span>(connection-&gt;inputChannel-&gt;<span class="built_in">getFd</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> currentTime = <span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">abortBrokenDispatchCycleLocked</span>(currentTime, connection, notify);</span><br><span class="line">    <span class="comment">// 标记该Connection为ZOMBIE状态</span></span><br><span class="line">    connection-&gt;status = Connection::STATUS_ZOMBIE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移除InputChannel的工作也不多，将Connection从直接保存的集合中移除，顺便将其中保存的服务端Socket描述符从mLooper中移除即可。最后标记被移除的Connection状态为ZOMBIE状态。</p>
<h4 id="1-5-4-1-InputDispatcher-removeConnectionLocked"><a href="#1-5-4-1-InputDispatcher-removeConnectionLocked" class="headerlink" title="1.5.4.1 InputDispatcher.removeConnectionLocked"></a>1.5.4.1 InputDispatcher.removeConnectionLocked</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::removeConnectionLocked</span><span class="params">(<span class="type">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    mAnrTracker.<span class="built_in">eraseToken</span>(connection-&gt;inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">    <span class="comment">// 将该连接从mConnectionsByToken中移除</span></span><br><span class="line">    mConnectionsByToken.<span class="built_in">erase</span>(connection-&gt;inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接将该Connection从mConnectionsByToken和mAnrTracker中移除即可。</p>
<h1 id="二-应用进程InputChannel的来源"><a href="#二-应用进程InputChannel的来源" class="headerlink" title="二. 应用进程InputChannel的来源"></a>二. 应用进程InputChannel的来源</h1><p>通过 <a href="#%E4%B8%80-inputchannel%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Cdispose">InputChannel的初始化</a> 我们知道InputChannel的Native实现就是一对Socket，其中服务端作为input事件分发者被加入InputDispatcher的Looper中，客户端会被存入NativeInputChannel中，而后通过JNI存入java层的InputChannel的mPtr中，但是这里java层的InputChannel还是处于SystemServer进程，还没有看到应用进程InputChannel是如何被赋值的。</p>
<p>接下来我们先研究下InputChannel的拷贝。</p>
<h2 id="2-1-InputChannel-copyTo"><a href="#2-1-InputChannel-copyTo" class="headerlink" title="2.1 InputChannel.copyTo"></a>2.1 InputChannel.copyTo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(InputChannel outParameter)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (outParameter == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;outParameter must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outParameter.mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Other object already has a native input channel.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 nativeDup</span></span><br><span class="line">    <span class="comment">// setNativeInputChannel我们已经分析过了就不在赘述，重点看nativeDup函数</span></span><br><span class="line">    outParameter.setNativeInputChannel(nativeDup(mPtr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeDup</span><span class="params">(<span class="type">long</span> channel)</span>;</span><br></pre></td></tr></table></figure>

<p>这里思考一下为什么不直接将mPtr赋值给outParameter的mPtr呢？</p>
<h2 id="2-2-android-view-InputChannel-nativeDup"><a href="#2-2-android-view-InputChannel-nativeDup" class="headerlink" title="2.2 android_view_InputChannel_nativeDup"></a>2.2 android_view_InputChannel_nativeDup</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android_view_InputChannel.cpp#123</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_view_InputChannel_nativeDup</span><span class="params">(JNIEnv* env, jobject obj, jlong channel)</span> </span>&#123;</span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;NativeInputChannel*&gt;(channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nativeInputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;InputChannel has no valid NativeInputChannel&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;InputChannel&gt; inputChannel = nativeInputChannel-&gt;<span class="built_in">getInputChannel</span>();</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;NativeInputChannel has no corresponding InputChannel&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.3 调用native层的InputChannel.dup函数</span></span><br><span class="line">    std::unique_ptr&lt;InputChannel&gt; dupInputChannel = inputChannel-&gt;<span class="built_in">dup</span>();</span><br><span class="line">    <span class="keyword">if</span> (dupInputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::string message = android::base::<span class="built_in">StringPrintf</span>(</span><br><span class="line">                <span class="string">&quot;Could not duplicate input channel %s&quot;</span>, inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新的NativeInputChannel对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(<span class="keyword">new</span> <span class="built_in">NativeInputChannel</span>(std::<span class="built_in">move</span>(dupInputChannel)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>android_view_InputChannel_nativeDup的作用就是根据传入的java层InputChannel创建一个新的NativeInputChannel作为客户端socket, 与服务端Socket的InputChannel对应。</p>
<h2 id="2-3-InputChannel-dup"><a href="#2-3-InputChannel-dup" class="headerlink" title="2.3 InputChannel.dup"></a>2.3 InputChannel.dup</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;InputChannel&gt; <span class="title">InputChannel::dup</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.3.1 dupFd创建一个新的文件描述符，但是执行同一个文件</span></span><br><span class="line">    <span class="function">base::unique_fd <span class="title">newFd</span><span class="params">(dupFd())</span></span>;</span><br><span class="line">    <span class="comment">// 根据新的文件描述符创建新的InputChannel对象</span></span><br><span class="line">    <span class="keyword">return</span> InputChannel::<span class="built_in">create</span>(<span class="built_in">getName</span>(), std::<span class="built_in">move</span>(newFd), <span class="built_in">getConnectionToken</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-InputChannel-dupFd"><a href="#2-3-1-InputChannel-dupFd" class="headerlink" title="2.3.1 InputChannel.dupFd"></a>2.3.1 InputChannel.dupFd</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">base::unique_fd <span class="title">InputChannel::dupFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getFp返回的就是该InputChannel的mFd</span></span><br><span class="line">    <span class="comment">// ::dup 的作用是复制文件描述符，使多个文件描述符指向同一个文件</span></span><br><span class="line">    android::<span class="function">base::unique_fd <span class="title">newFd</span><span class="params">(::dup(getFd()))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!newFd.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not duplicate fd %i for channel %s: %s&quot;</span>, <span class="built_in">getFd</span>().<span class="built_in">get</span>(), <span class="built_in">getName</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">              <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> hitFdLimit = errno == EMFILE || errno == ENFILE;</span><br><span class="line">        <span class="comment">// If this process is out of file descriptors, then throwing that might end up exploding</span></span><br><span class="line">        <span class="comment">// on the other side of a binder call, which isn&#x27;t really helpful.</span></span><br><span class="line">        <span class="comment">// Better to just crash here and hope that the FD leak is slow.</span></span><br><span class="line">        <span class="comment">// Other failures could be client errors, so we still propagate those back to the caller.</span></span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(hitFdLimit, <span class="string">&quot;Too many open files, could not duplicate input channel %s&quot;</span>,</span><br><span class="line">                            <span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dupFd是通过 ::dup(int oldFd) 函数复制文件描述符，使新的文件描述符指向参数描述符指向的同一个文件。</p>
<h2 id="2-4-Binder通信中AIDL里的out标记"><a href="#2-4-Binder通信中AIDL里的out标记" class="headerlink" title="2.4 Binder通信中AIDL里的out标记"></a>2.4 Binder通信中AIDL里的out标记</h2><p>看完了InputChannel的copyTo函数，我们知道该函数就是在native层创建了新的NativeInputChannel，但是还是和之前客户端InputChannel一样指向同一个Socket描述符，这样服务端Socket发的消息会同步传给信息的InputChannel了。</p>
<p>但是这里我们还是没有看到应用进程的InputChannel是如何被赋值的，在WMS.addWindow函数中，outInputChannel在被mInputChannel.copyTo函数赋值后，就没有继续使用过了。这里我们就要看到应用进程和WMS通信的桥梁Session的AIDL文件定义了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IWindowSession.aidl</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addToDisplay</span><span class="params">(IWindow window, in WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        in <span class="type">int</span> viewVisibility, in <span class="type">int</span> layerStackId, in InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        out InputChannel outInputChannel, out InsetsState insetsState,</span></span><br><span class="line"><span class="params">        out InsetsSourceControl[] activeControls)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addToDisplayAsUser</span><span class="params">(IWindow window, in WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        in <span class="type">int</span> viewVisibility, in <span class="type">int</span> layerStackId, in <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        in InsetsState requestedVisibility, out InputChannel outInputChannel,</span></span><br><span class="line"><span class="params">        out InsetsState insetsState, out InsetsSourceControl[] activeControls)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addToDisplayWithoutInputChannel</span><span class="params">(IWindow window, in WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        in <span class="type">int</span> viewVisibility, in <span class="type">int</span> layerStackId, out InsetsState insetsState)</span>;</span><br></pre></td></tr></table></figure>

<p>毫无意外，所有的InputChannel都是被标记了out标签，这样binder回调时会将该参数回传给调用进程，即应用进程。 这样一来一个WindowState对应一对Socket，分成服务端和客户端，服务端Socket的描述符被存入InputDispatcher的mConnectionsByToken，也被添加到其mLooper中用于转发Input事件至客户端Socket中。而客户端Socket又被dup函数复制成两份NativeInputChannel, 一份存在WindowState的mInputChannel中，另一份通过Binder调用存入应用进程的ViewRootImpl的WindowInputEventReceiver对象中。</p>
<h1 id="三-应用进程注册接听Input事件"><a href="#三-应用进程注册接听Input事件" class="headerlink" title="三. 应用进程注册接听Input事件"></a>三. 应用进程注册接听Input事件</h1><p>在ViewRootImpl.setView函数中，当应用进程通过binder调用addToDisplayAsUser获得被复制的InputChannel后，会通过该InputChannel创建WindowInputEventReceiver。</p>
<h2 id="3-1-WindowInputEventReceiver初始化"><a href="#3-1-WindowInputEventReceiver初始化" class="headerlink" title="3.1 WindowInputEventReceiver初始化"></a>3.1 WindowInputEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">InputEventReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WindowInputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(inputChannel, looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowInputEventReceiver是继承了InputEventReceiver的，这里的构造函数也仅仅是将传入的参数继续调用给父类的构造函数。</p>
<h2 id="3-2-InputEventReceiver初始化"><a href="#3-2-InputEventReceiver初始化" class="headerlink" title="3.2 InputEventReceiver初始化"></a>3.2 InputEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;inputChannel must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInputChannel = inputChannel;</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 3.3 通过JNI创建native层的对象</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;InputEventReceiver&gt;(<span class="built_in">this</span>),</span><br><span class="line">            inputChannel, mMessageQueue);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeInit</span><span class="params">(WeakReference&lt;InputEventReceiver&gt; receiver,</span></span><br><span class="line"><span class="params">        InputChannel inputChannel, MessageQueue messageQueue)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-android-view-InputEventReceiver-cpp-nativeInit"><a href="#3-3-android-view-InputEventReceiver-cpp-nativeInit" class="headerlink" title="3.3 android_view_InputEventReceiver.cpp:nativeInit"></a>3.3 android_view_InputEventReceiver.cpp:nativeInit</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android_view_InputEventReceiver.cpp#486</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过java层的InputChannel转成Native层的InputChannel</span></span><br><span class="line">    std::shared_ptr&lt;InputChannel&gt; inputChannel =</span><br><span class="line">            <span class="built_in">android_view_InputChannel_getInputChannel</span>(env, inputChannelObj);</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;InputChannel is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过java层的MessageQueue转成Native层的MessageQueue</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = <span class="built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;MessageQueue is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.4 创建NativeInputEventReceiver</span></span><br><span class="line">    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> <span class="built_in">NativeInputEventReceiver</span>(env,</span><br><span class="line">            receiverWeak, inputChannel, messageQueue);</span><br><span class="line">    <span class="comment">// 3.5 调用初始化</span></span><br><span class="line">    <span class="type">status_t</span> status = receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        std::string message =</span><br><span class="line">                android::base::<span class="built_in">StringPrintf</span>(<span class="string">&quot;Failed to initialize input event receiver.  status=%d&quot;</span>,</span><br><span class="line">                                            status);</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;<span class="built_in">incStrong</span>(gInputEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-NativeInputEventReceiver初始化"><a href="#3-4-NativeInputEventReceiver初始化" class="headerlink" title="3.4 NativeInputEventReceiver初始化"></a>3.4 NativeInputEventReceiver初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">NativeInputEventReceiver::<span class="built_in">NativeInputEventReceiver</span>(</span><br><span class="line">        JNIEnv* env, jobject receiverWeak, <span class="type">const</span> std::shared_ptr&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue)</span><br><span class="line">      : <span class="built_in">mReceiverWeakGlobal</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(receiverWeak)),</span><br><span class="line">        <span class="built_in">mInputConsumer</span>(inputChannel),</span><br><span class="line">        <span class="built_in">mMessageQueue</span>(messageQueue),</span><br><span class="line">        <span class="built_in">mBatchedInputEventPending</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mFdEvents</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kDebugDispatchCycle) &#123;</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">&quot;channel &#x27;%s&#x27; ~ Initializing input event receiver.&quot;</span>, <span class="built_in">getInputChannelName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化NativeInputEventReceiver</p>
<h2 id="3-5-NativeInputEventReceiver-initialize"><a href="#3-5-NativeInputEventReceiver-initialize" class="headerlink" title="3.5 NativeInputEventReceiver.initialize"></a>3.5 NativeInputEventReceiver.initialize</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputEventReceiver::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ALOOPER_EVENT_INPUT = 1 &lt;&lt; 0;</span></span><br><span class="line">    <span class="built_in">setFdEvents</span>(ALOOPER_EVENT_INPUT);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputEventReceiver::setFdEvents</span><span class="params">(<span class="type">int</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时mFdEvents还只是0</span></span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="type">int</span> fd = mInputConsumer.<span class="built_in">getChannel</span>()-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            <span class="comment">// 将InputChannel中的客户端Socket的文件描述符加入的Looper中监听</span></span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">addFd</span>(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">removeFd</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里设置文件描述符，将作为客户端InputChannel的Socket的描述符添加到该应用进程的主线程Looper中（ViewRootImpl.setView是主线程才能被调用的）。</p>
<h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四. 小结"></a>四. 小结</h1><p>WindowState和InputChannel的相关流程图如下：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/7_1.png" alt="7-1"></p>
<p>InputChannel的Native实现就是一对Socket，其中服务端作为input事件分发者被加入InputDispatcher的Looper中，客户端会被存入NativeInputChannel中。一个WindowState对应一对Socket，分成服务端和客户端，服务端Socket的描述符被存入InputDispatcher的mConnectionsByToken，也被添加到其mLooper中用于转发Input事件至客户端Socket中。而客户端Socket又被dup函数复制成两份NativeInputChannel, 一份存在WindowState的mInputChannel中，另一份通过Binder调用存入应用进程的ViewRootImpl的WindowInputEventReceiver对象中。</p>
<p>接下来我们看看input事件是如何传给正确的窗口进程的。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
        <category>Input</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WMS</tag>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(8)-窗口信息传递给Input系统</title>
    <url>/2022/05/08/WMS(8)-%E7%AA%97%E5%8F%A3%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E7%BB%99Input%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上文中，我们知道了应用View和窗口与input系统交互通道InputChannel的打通过程。有了通信通道，就可以通过这个来通信，将input事件传递给应用程序。很自然的，input系统中必须要保存代表该应用窗口的对象，用于识别以及分发事件。</p>
<p>还记得我们初始化WindowState时，有创建过一个InputWindowHandleWrapper类的对象，当时我们认为是将该Window注册进input系统：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建InputApplicationHandle, 将该Window注册进Input系统，以便后续input事件传输</span></span><br><span class="line">mInputWindowHandle = <span class="keyword">new</span> <span class="title class_">InputWindowHandleWrapper</span>(<span class="keyword">new</span> <span class="title class_">InputWindowHandle</span>(</span><br><span class="line">        mActivityRecord != <span class="literal">null</span></span><br><span class="line">                ? mActivityRecord.getInputApplicationHandle(<span class="literal">false</span> <span class="comment">/* update */</span>) : <span class="literal">null</span>,</span><br><span class="line">        getDisplayId()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityRecord.java</span></span><br><span class="line"><span class="meta">@NonNull</span> InputApplicationHandle <span class="title function_">getInputApplicationHandle</span><span class="params">(<span class="type">boolean</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputApplicationHandle == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建InputApplicationHandle, 这里的appToken是IApplicationToken.Stub的子类对象，是ActivityRecord初始化时创建的</span></span><br><span class="line">        mInputApplicationHandle = <span class="keyword">new</span> <span class="title class_">InputApplicationHandle</span>(appToken, toString(),</span><br><span class="line">                mInputDispatchingTimeoutMillis);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mInputApplicationHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看看这里InputWindowHandleWrapper、InputWindowHandle、InputApplicationHandle等相关类的类图：</p>
<p><img src="/images/WMS%E7%B3%BB%E5%88%97/8_1.png" alt="8-1"></p>
<p>可以看到这里InputWindowHandle类中包含该Window的大小和位置、可触碰区域(touchableRegion)等等信息，这些信息是什么时候更新的呢？回到我们之前研究过的焦点窗口的更新一文，在WMS.addWindow中创建WindowState的对象并且更新焦点窗口后，会更新input相关信息:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WMS.addWindow</span></span><br><span class="line"><span class="comment">// 如果焦点窗口有更新，也需要更新input相关设置</span></span><br><span class="line"><span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">    <span class="comment">// [1.1] 设置输入焦点窗口信息</span></span><br><span class="line">    displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus,</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1.2] 更新输入窗口信息</span></span><br><span class="line">displayContent.getInputMonitor().updateInputWindowsLw(<span class="literal">false</span> <span class="comment">/*force*/</span>);</span><br></pre></td></tr></table></figure>

<p>这里我们加上mCurrentFocus就是此次新创建的WindowState.</p>
<h1 id="一-更新窗口信息"><a href="#一-更新窗口信息" class="headerlink" title="一. 更新窗口信息"></a>一. 更新窗口信息</h1><h2 id="1-1-InputMonitor-setInputFocusLw"><a href="#1-1-InputMonitor-setInputFocusLw" class="headerlink" title="1.1 InputMonitor.setInputFocusLw"></a>1.1 InputMonitor.setInputFocusLw</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setInputFocusLw</span><span class="params">(WindowState newWindow, <span class="type">boolean</span> updateInputWindows)</span> &#123;</span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;Input focus has changed to %s display=%d&quot;</span>,</span><br><span class="line">            newWindow, mDisplayId);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">focus</span> <span class="operator">=</span> newWindow != <span class="literal">null</span> ? newWindow.mInputChannelToken : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (focus == mInputFocus) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newWindow != <span class="literal">null</span> &amp;&amp; newWindow.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">// 隐式地显示一个窗口将导致取消调度, 为了防止错误，如果有人暂停调度但忘记resume</span></span><br><span class="line">        newWindow.mToken.paused = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记mUpdateInputWindowsNeeded为true</span></span><br><span class="line">    setUpdateInputWindowsNeededLw();</span><br><span class="line">    <span class="comment">// 此时传入的updateInputWindows为false, 表明不是此时更新信息的</span></span><br><span class="line">    <span class="keyword">if</span> (updateInputWindows) &#123;</span><br><span class="line">        updateInputWindowsLw(<span class="literal">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUpdateInputWindowsNeededLw</span><span class="params">()</span> &#123;</span><br><span class="line">    mUpdateInputWindowsNeeded = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是判断新的窗口是否与当前输入焦点窗口一致，如果不一致，则标记mUpdateInputWindowsNeeded为true，表明需要更新输入窗口了。</p>
<h2 id="1-2-InputMonitor-updateInputWindowsLw"><a href="#1-2-InputMonitor-updateInputWindowsLw" class="headerlink" title="1.2 InputMonitor.updateInputWindowsLw"></a>1.2 InputMonitor.updateInputWindowsLw</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateInputWindowsLw</span><span class="params">(<span class="type">boolean</span> force)</span> &#123;</span><br><span class="line">    <span class="comment">// mUpdateInputWindowsNeeded 在[1.1]中就被标记为true了</span></span><br><span class="line">    <span class="keyword">if</span> (!force &amp;&amp; !mUpdateInputWindowsNeeded) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduleUpdateInputWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleUpdateInputWindows</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前input对应的Display设备被移除时，无需处理</span></span><br><span class="line">    <span class="keyword">if</span> (mDisplayRemoved) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mUpdateInputWindowsPending默认是false</span></span><br><span class="line">    <span class="comment">// 用于标记当前是否有存在尚未执行的 mUpdateInputWindows</span></span><br><span class="line">    <span class="keyword">if</span> (!mUpdateInputWindowsPending) &#123;</span><br><span class="line">        mUpdateInputWindowsPending = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// [1.3] 将输入窗口信息交给&quot;android.anim&quot;线程处理，mHandler=&gt;WMS.mAnimationHandler</span></span><br><span class="line">        mHandler.post(mUpdateInputWindows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先判断是否需要执行更新（mUpdateInputWindowsNeeded变量），如果需要则将更新操作交给”android.anim”线程处理。</p>
<h2 id="1-3-InputMonitor-UpdateInputWindows-run"><a href="#1-3-InputMonitor-UpdateInputWindows-run" class="headerlink" title="1.3 InputMonitor.UpdateInputWindows.run"></a>1.3 InputMonitor.UpdateInputWindows.run</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">// 执行输入窗口信息更新，将变量恢复</span></span><br><span class="line">        mUpdateInputWindowsPending = <span class="literal">false</span>;</span><br><span class="line">        mUpdateInputWindowsNeeded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDisplayRemoved) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用可能接收输入的所有窗口的信息填充输入窗口列表</span></span><br><span class="line">        <span class="comment">// 作为一个优化，可以尝试修剪窗口列表，但这是困难的，因为只有native代码知道哪个窗口当前有触摸焦点。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果滑动过程中有拖拽，提供一个伪窗口来捕获拖拽输入，为了方便分析这里加上是非拖拽</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDrag</span> <span class="operator">=</span> mService.mDragDropController.dragDropActiveLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [1.4] 在默认Display中添加所有窗口</span></span><br><span class="line">        mUpdateInputForAllWindowsConsumer.updateInputWindows(inDrag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在”android.anim”线程处理时，首先将标记变量恢复为false, 表示可以接收下一次输入窗口更新了。接下来就是在默认Display中添加所有窗口了。</p>
<h2 id="1-4-InputMonitor-UpdateInputForAllWindowsConsumer-updateInputWindows"><a href="#1-4-InputMonitor-UpdateInputForAllWindowsConsumer-updateInputWindows" class="headerlink" title="1.4 InputMonitor.UpdateInputForAllWindowsConsumer.updateInputWindows"></a>1.4 InputMonitor.UpdateInputForAllWindowsConsumer.updateInputWindows</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInputWindows</span><span class="params">(<span class="type">boolean</span> inDrag)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;updateInputWindows&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取对应的InputConsumer</span></span><br><span class="line">    mPipInputConsumer = getInputConsumer(INPUT_CONSUMER_PIP);</span><br><span class="line">    mWallpaperInputConsumer = getInputConsumer(INPUT_CONSUMER_WALLPAPER);</span><br><span class="line">    mRecentsAnimationInputConsumer = getInputConsumer(INPUT_CONSUMER_RECENTS_ANIMATION);</span><br><span class="line">    <span class="comment">// 判断对应InputConsumer是否为null</span></span><br><span class="line">    mAddPipInputConsumerHandle = mPipInputConsumer != <span class="literal">null</span>;</span><br><span class="line">    mAddWallpaperInputConsumerHandle = mWallpaperInputConsumer != <span class="literal">null</span>;</span><br><span class="line">    mAddRecentsAnimationInputConsumerHandle = mRecentsAnimationInputConsumer != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    mDisableWallpaperTouchEvents = <span class="literal">false</span>;</span><br><span class="line">    mInDrag = inDrag;</span><br><span class="line">    <span class="comment">// mInputConsumers 中所有的InputConsumer都调用hide隐藏</span></span><br><span class="line">    resetInputConsumers(mInputTransaction);</span><br><span class="line">    mRecentsAnimationFocusOverride = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// [1.5] 从上到下（Z轴大到小）遍历该DisplayContent中所有的WindowState</span></span><br><span class="line">    <span class="comment">// 依次执行UpdateInputForAllWindowsConsumer.accept</span></span><br><span class="line">    mDisplayContent.forAllWindows(<span class="built_in">this</span>, <span class="literal">true</span> <span class="comment">/* traverseTopToBottom */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRecentsAnimationFocusOverride) &#123;</span><br><span class="line">        requestFocus(mRecentsAnimationInputConsumer.mWindowHandle.token,</span><br><span class="line">                mRecentsAnimationInputConsumer.mName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// [1.6] 将焦点窗口信息更新给input系统</span></span><br><span class="line">        updateInputFocusRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mUpdateInputWindowsImmediately一般为false</span></span><br><span class="line">    <span class="keyword">if</span> (!mUpdateInputWindowsImmediately) &#123;</span><br><span class="line">        mDisplayContent.getPendingTransaction().merge(mInputTransaction);</span><br><span class="line">        mDisplayContent.scheduleAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputConsumerImpl <span class="title function_">getInputConsumer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mInputConsumers.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InputConsumer总共有四种:</p>
<ol>
<li>INPUT_CONSUMER_PIP: “pip_input_consumer”, 用于pip</li>
<li>INPUT_CONSUMER_NAVIGATION: “nav_input_consumer”，用于导航栏</li>
<li>INPUT_CONSUMER_WALLPAPER: “wallpaper_input_consumer”，用于壁纸</li>
<li>INPUT_CONSUMER_RECENTS_ANIMATION: “recents_animation_input_consumer”，用于多任务</li>
</ol>
<p>更新输入窗口的步骤如下:</p>
<ol>
<li>重置InputConsumer，将所有consumer都调用hide</li>
<li>从上到下（Z轴大到小）遍历该DisplayContent中所有的WindowState，依次执行UpdateInputForAllWindowsConsumer.accept<ol>
<li>这个accept就是计算更新窗口信息，比如可触碰区域的计算</li>
<li>通过SurfaceControl传递窗口信息给SurfaceFlinger，在native层生成对应的InputWindowHandle</li>
</ol>
</li>
<li>如果有最近任务栏动画，则调用requestFocus更新多任务焦点；否则调用updateInputFocusRequest更新输入焦点请求</li>
</ol>
<h2 id="1-5-InputMonitor-UpdateInputForAllWindowsConsumer-accept"><a href="#1-5-InputMonitor-UpdateInputForAllWindowsConsumer-accept" class="headerlink" title="1.5 InputMonitor.UpdateInputForAllWindowsConsumer.accept"></a>1.5 InputMonitor.UpdateInputForAllWindowsConsumer.accept</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(WindowState w)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里假设传入的WindowState是addWindow中新创建的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">InputWindowHandleWrapper</span> <span class="variable">inputWindowHandle</span> <span class="operator">=</span> w.mInputWindowHandle;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 注册事件拦截信息</span></span><br><span class="line">    mService.mKeyInterceptionInfoForToken.put(w.mInputChannelToken,</span><br><span class="line">            w.getKeyInterceptionInfo());</span><br><span class="line">    <span class="comment">// [1.5.1] mWinAnimator是WindowState初始化时构建的WindowStateAnimator对象</span></span><br><span class="line">    <span class="keyword">if</span> (w.mWinAnimator.hasSurface()) &#123;</span><br><span class="line">        <span class="comment">// [1.5.2] 计算更新该窗口的信息</span></span><br><span class="line">        populateInputWindowHandle(inputWindowHandle, w);</span><br><span class="line">        <span class="comment">// [1.5.3] 通知对应Surface更新窗口信息</span></span><br><span class="line">        setInputWindowInfoIfNeeded(mInputTransaction,</span><br><span class="line">                w.mWinAnimator.mSurfaceController.mSurfaceControl, inputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-1-WindowStateAnimator-hasSurface"><a href="#1-5-1-WindowStateAnimator-hasSurface" class="headerlink" title="1.5.1 WindowStateAnimator.hasSurface"></a>1.5.1 WindowStateAnimator.hasSurface</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowStateAnimator.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasSurface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// mSurfaceController是WindowSurfaceController的对象</span></span><br><span class="line">    <span class="keyword">return</span> mSurfaceController != <span class="literal">null</span> &amp;&amp; mSurfaceController.hasSurface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowSurfaceController.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasSurface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// SurfaceControl对象，在WindowSurfaceController初始化时构建</span></span><br><span class="line">    <span class="keyword">return</span> mSurfaceControl != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowStateAnimator中的mSurfaceController是WindowSurfaceController的对象，在其对应的Window被调用relayoutWindow时通过winAnimator.createSurfaceLocked(win.mAttrs.type)创建的。 而relayoutWindow则是三方应用进程接收到Vsync信号之后，调用对应的ViewRootImpl中的performTraversals在通过Session通知到WMS执行的。在这里我们假设”android.anim”线程更新所有输入窗口时，这个新建的WindowState已经被调用过了relayoutWindow，存在Surface。</p>
<h3 id="1-5-2-InputMonitor-populateInputWindowHandle"><a href="#1-5-2-InputMonitor-populateInputWindowHandle" class="headerlink" title="1.5.2 InputMonitor.populateInputWindowHandle"></a>1.5.2 InputMonitor.populateInputWindowHandle</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">populateInputWindowHandle</span><span class="params">(<span class="keyword">final</span> InputWindowHandleWrapper inputWindowHandle,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> WindowState w)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加一个窗口到可输入事件的窗口列表中</span></span><br><span class="line">    <span class="comment">// 设置窗口相关信息到inputWindowHandle中</span></span><br><span class="line">    inputWindowHandle.setInputApplicationHandle(w.mActivityRecord != <span class="literal">null</span></span><br><span class="line">            ? w.mActivityRecord.getInputApplicationHandle(<span class="literal">false</span> <span class="comment">/* update */</span>) : <span class="literal">null</span>);</span><br><span class="line">    inputWindowHandle.setToken(w.mInputChannelToken);</span><br><span class="line">    <span class="comment">// 设置该窗口的input超时时长，如果该WindowState对应Activity，这个时长就是5s</span></span><br><span class="line">    inputWindowHandle.setDispatchingTimeoutMillis(w.getInputDispatchingTimeoutMillis());</span><br><span class="line">    inputWindowHandle.setTouchOcclusionMode(w.getTouchOcclusionMode());</span><br><span class="line">    inputWindowHandle.setInputFeatures(w.mAttrs.inputFeatures);</span><br><span class="line">    inputWindowHandle.setPaused(w.mActivityRecord != <span class="literal">null</span> &amp;&amp; w.mActivityRecord.paused);</span><br><span class="line">    inputWindowHandle.setVisible(w.isVisible());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置是否可聚焦</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">focusable</span> <span class="operator">=</span> w.canReceiveKeys()</span><br><span class="line">            &amp;&amp; (mService.mPerDisplayFocusEnabled || mDisplayContent.isOnTop());</span><br><span class="line">    inputWindowHandle.setFocusable(focusable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含壁纸</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasWallpaper</span> <span class="operator">=</span> mDisplayContent.mWallpaperController.isWallpaperTarget(w)</span><br><span class="line">            &amp;&amp; !mService.mPolicy.isKeyguardShowing()</span><br><span class="line">            &amp;&amp; !mDisableWallpaperTouchEvents;</span><br><span class="line">    inputWindowHandle.setHasWallpaper(hasWallpaper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">frame</span> <span class="operator">=</span> w.getFrame();</span><br><span class="line">    <span class="comment">// 设置该窗口的位置和大小</span></span><br><span class="line">    inputWindowHandle.setFrame(frame.left, frame.top, frame.right, frame.bottom);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Surface insets 被硬编码为在所有方向上都是相同的，所以这里仅需一个参数</span></span><br><span class="line">    inputWindowHandle.setSurfaceInset(w.mAttrs.surfaceInsets.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缩放窗口，输入坐标需要反向缩放，将屏幕上的内容映射到UI中实际触摸的内容</span></span><br><span class="line">    inputWindowHandle.setScaleFactor(w.mGlobalScale != <span class="number">1f</span> ? (<span class="number">1f</span> / w.mGlobalScale) : <span class="number">1f</span>);</span><br><span class="line">    <span class="comment">// [1.5.2.1] 计算窗口可触摸区域</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> w.getSurfaceTouchableRegion(mTmpRegion, w.mAttrs.flags);</span><br><span class="line">    <span class="comment">// 将计算得到的可触摸区域保存在inputWindowHandle中</span></span><br><span class="line">    inputWindowHandle.setTouchableRegion(mTmpRegion);</span><br><span class="line">    inputWindowHandle.setLayoutParamsFlags(flags);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-1-WindowState-getSurfaceTouchableRegion"><a href="#1-5-2-1-WindowState-getSurfaceTouchableRegion" class="headerlink" title="1.5.2.1 WindowState.getSurfaceTouchableRegion"></a>1.5.2.1 WindowState.getSurfaceTouchableRegion</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSurfaceTouchableRegion</span><span class="params">(Region region, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断该WindowState是否包含FLAG_NOT_TOUCH_MODAL和FLAG_NOT_FOCUSABLE，表明该窗口无法接收input以及无法作为焦点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">modal</span> <span class="operator">=</span> (flags &amp; (FLAG_NOT_TOUCH_MODAL | FLAG_NOT_FOCUSABLE)) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (modal) &#123;</span><br><span class="line">        flags |= FLAG_NOT_TOUCH_MODAL;</span><br><span class="line">        <span class="keyword">if</span> (mActivityRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// [1.5.2.2] 将外部接触限制在活动根任务区域</span></span><br><span class="line">            updateRegionForModalActivityWindow(region);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 首先给一个足够大的可触摸区域，因为它是触摸模态</span></span><br><span class="line">            <span class="comment">// 窗口可能会在显示器上移动，所以可触摸区域应该足够大，以确保它覆盖整个显示器，无论它移动到哪里</span></span><br><span class="line">            <span class="comment">// 比如启动窗口</span></span><br><span class="line">            getDisplayContent().getBounds(mTmpRect);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">dw</span> <span class="operator">=</span> mTmpRect.width();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">dh</span> <span class="operator">=</span> mTmpRect.height();</span><br><span class="line">            region.set(-dw, -dh, dw + dw, dh + dh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将计算得到的窗口可触摸区域减去其不可触碰的区域</span></span><br><span class="line">        subtractTouchExcludeRegionIfNeeded(region);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not modal</span></span><br><span class="line">        getTouchableRegion(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为基于Surface的坐标, 因为Android中坐标原点在左上角，Y轴正方向向下，X轴正方向向右</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">frame</span> <span class="operator">=</span> mWindowFrames.mFrame;</span><br><span class="line">    <span class="keyword">if</span> (frame.left != <span class="number">0</span> || frame.top != <span class="number">0</span>) &#123;</span><br><span class="line">        region.translate(-frame.left, -frame.top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>FLAG_NOT_TOUCH_MODAL: 允许窗口外的任何指针事件被发送到它后面的窗口, 即使这个窗口是可聚焦的。否则（不带此标志），窗口将消耗所有指针事件本身，而不管它们是否在窗口内。</li>
<li>FLAG_NOT_FOCUSABLE: 标记这个窗口永远不能接收触摸事件</li>
</ol>
<p>Android中坐标原点在左上角，Y轴正方向向下，X轴正方向向右，所以计算的窗口可触摸区域需要转换为基于Surface的坐标。</p>
<h4 id="1-5-2-2-WindowState-updateRegionForModalActivityWindow"><a href="#1-5-2-2-WindowState-updateRegionForModalActivityWindow" class="headerlink" title="1.5.2.2 WindowState.updateRegionForModalActivityWindow"></a>1.5.2.2 WindowState.updateRegionForModalActivityWindow</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRegionForModalActivityWindow</span><span class="params">(Region outRegion)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取内部边界的letterbox可触摸区域（一般不会设置的，这个就是&lt;activity&gt;中的android:maxAspectRatio属性）</span></span><br><span class="line">    mActivityRecord.getLetterboxInnerBounds(mTmpRect);</span><br><span class="line">    <span class="comment">// 假设此时mTmpRect为empty的</span></span><br><span class="line">    <span class="keyword">if</span> (mTmpRect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// [1.5.2.3] 获取该ActivityRecord的View边界</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">transformedBounds</span> <span class="operator">=</span> mActivityRecord.getFixedRotationTransformDisplayBounds();</span><br><span class="line">        <span class="keyword">if</span> (transformedBounds != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Task与显示的方向相同，所以旋转的边界应该被选择为可触摸区域。当表面层将区域转换为显示空间时，方向是一致的。</span></span><br><span class="line">            mTmpRect.set(transformedBounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果这是一个模态窗口，我们需要dismiss它如果它不是全屏，触摸发生在显示内容的窗口之外</span></span><br><span class="line">            <span class="comment">// 这意味着我们需要拦截窗口外的触摸。与窗口(任务或根任务)相关联的dim layer将给一个界限，因为它们将用于显示dim layer</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> getTask();</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// [1.5.2.4] 通过该WindowState所在Task获取该窗口的可触摸区域</span></span><br><span class="line">                task.getDimBounds(mTmpRect);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getRootTask() != <span class="literal">null</span>) &#123;</span><br><span class="line">                getRootTask().getDimBounds(mTmpRect);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前窗口是freeform窗口模式时，调整区域大小</span></span><br><span class="line">    adjustRegionInFreefromWindowMode(mTmpRect);</span><br><span class="line">    <span class="comment">// 将计算后的可触摸区域大小复制给outRegion使用</span></span><br><span class="line">    outRegion.set(mTmpRect);</span><br><span class="line">    <span class="comment">// 根据坐标系调整RootTask边界大小</span></span><br><span class="line">    cropRegionToRootTaskBoundsIfNeeded(outRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityRecord.getLetterboxInnerBounds是获取内部边界的letterbox可触摸区域;一般不会设置的，这个就是<activity>中的android:maxAspectRatio属性。</activity></p>
<p>至于freeform模式的窗口调整区域大小以及根据坐标系调整RootTask边界，感兴趣的可以继续研究。这里仅须知道窗口的可触摸区域是怎么拿到的即可。</p>
<h4 id="1-5-2-3-ActivityRecord-getFixedRotationTransformDisplayBounds"><a href="#1-5-2-3-ActivityRecord-getFixedRotationTransformDisplayBounds" class="headerlink" title="1.5.2.3 ActivityRecord.getFixedRotationTransformDisplayBounds"></a>1.5.2.3 ActivityRecord.getFixedRotationTransformDisplayBounds</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Rect <span class="title function_">getFixedRotationTransformDisplayBounds</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isFixedRotationTransforming()</span><br><span class="line">            ? mFixedRotationTransformState.mRotatedOverrideConfiguration.windowConfiguration</span><br><span class="line">                    .getBounds()</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFixedRotationTransforming</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mFixedRotationTransformState != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mFixedRotationTransformState.mIsTransforming;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mFixedRotationTransformState是当手机方向旋转之后就会生成的， 这里我们假设没有发生旋转。</p>
<h4 id="1-5-2-4-Task-getDimBounds"><a href="#1-5-2-4-Task-getDimBounds" class="headerlink" title="1.5.2.4 Task.getDimBounds"></a>1.5.2.4 Task.getDimBounds</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getDimBounds</span><span class="params">(Rect out)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前task是RootTask, 那么直接返回其边界大小</span></span><br><span class="line">    <span class="keyword">if</span> (isRootTask()) &#123;</span><br><span class="line">        getBounds(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">rootTask</span> <span class="operator">=</span> getRootTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> rootTask.getDisplayContent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">dockedResizing</span> <span class="operator">=</span> displayContent != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; displayContent.mDividerControllerLocked.isResizing();</span><br><span class="line">    <span class="comment">// 判断该Task的WindowMode是否是Freeform模式，如果是，则找到该Task中最大的可见的区域</span></span><br><span class="line">    <span class="keyword">if</span> (inFreeformWindowingMode()) &#123;</span><br><span class="line">        <span class="type">boolean</span>[] foundTop = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PooledConsumer</span> <span class="variable">c</span> <span class="operator">=</span> PooledLambda.obtainConsumer(Task::getMaxVisibleBounds,</span><br><span class="line">                PooledLambda.__(ActivityRecord.class), out, foundTop);</span><br><span class="line">        forAllActivities(c);</span><br><span class="line">        c.recycle();</span><br><span class="line">        <span class="keyword">if</span> (foundTop[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前task和父容器边界不匹配(此状态发生在回到home最小化task时)，假设是匹配的</span></span><br><span class="line">    <span class="keyword">if</span> (!matchParentBounds()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dockedResizing) &#123;</span><br><span class="line">            rootTask.getBounds(out);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rootTask.getBounds(mTmpRect);</span><br><span class="line">            <span class="comment">// 取两个边界的交集</span></span><br><span class="line">            mTmpRect.intersect(getBounds());</span><br><span class="line">            out.set(mTmpRect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 边界直接用当前task边界</span></span><br><span class="line">        out.set(getBounds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>窗口模式有如下7种：</p>
<table>
<thead>
<tr>
<th>窗口模式</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>WINDOWING_MODE_UNDEFINED</td>
<td>0</td>
<td>当前窗口模式尚未定义</td>
</tr>
<tr>
<td>WINDOWING_MODE_FULLSCREEN</td>
<td>1</td>
<td>占据屏幕或父容器的整个区域</td>
</tr>
<tr>
<td>WINDOWING_MODE_PINNED</td>
<td>2</td>
<td>总是在顶部(总是可见, 覆盖它的父容器中的其他兄弟容器)</td>
</tr>
<tr>
<td>WINDOWING_MODE_SPLIT_SCREEN_PRIMARY</td>
<td>3</td>
<td>驱动屏幕处于分屏模式的主容器</td>
</tr>
<tr>
<td>WINDOWING_MODE_SPLIT_SCREEN_SECONDARY</td>
<td>4</td>
<td>在分屏模式下，紧邻WINDOWING_MODE_SPLIT_SCREEN_PRIMARY容器的容器</td>
</tr>
<tr>
<td>WINDOWING_MODE_FREEFORM</td>
<td>5</td>
<td>可以在其父容器内自由调整大小，如悬浮窗</td>
</tr>
<tr>
<td>WINDOWING_MODE_MULTI_WINDOW</td>
<td>6</td>
<td>窗口管理器中没有表示属性的通用多窗口</td>
</tr>
</tbody></table>
<p>获取Task的边界大小的过程如下:</p>
<ol>
<li>如果当前Task就是RootTask, 那么直接返回该Task的边界</li>
<li>判断该Task的WindowMode是否是Freeform模式，如果是，则找到该Task中最大的可见的区域并返回</li>
<li>当前Task和父容器边界不匹配时<ol>
<li>如果该Task被最小化时，直接返回该Task的RootTask的边界</li>
<li>否则获取RootTask边界与当前Task边界的交集并返回</li>
</ol>
</li>
<li>当前Task和父容器边界匹配时<ol>
<li>直接返回该Task的边界</li>
</ol>
</li>
</ol>
<h3 id="1-5-3-InputMonitor-setInputWindowInfoIfNeeded"><a href="#1-5-3-InputMonitor-setInputWindowInfoIfNeeded" class="headerlink" title="1.5.3 InputMonitor.setInputWindowInfoIfNeeded"></a>1.5.3 InputMonitor.setInputWindowInfoIfNeeded</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setInputWindowInfoIfNeeded</span><span class="params">(SurfaceControl.Transaction t, SurfaceControl sc,</span></span><br><span class="line"><span class="params">        InputWindowHandleWrapper inputWindowHandle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INPUT) &#123;</span><br><span class="line">        Slog.d(TAG_WM, <span class="string">&quot;Update InputWindowHandle: &quot;</span> + inputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 [1.5.2] 有更新内容，所以isChanged必然返回true</span></span><br><span class="line">    <span class="keyword">if</span> (inputWindowHandle.isChanged()) &#123;</span><br><span class="line">        <span class="comment">// [1.5.4] 更新给Surface</span></span><br><span class="line">        inputWindowHandle.applyChangesToSurface(t, sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-4-InputWindowHandleWrapper-applyChangesToSurface"><a href="#1-5-4-InputWindowHandleWrapper-applyChangesToSurface" class="headerlink" title="1.5.4 InputWindowHandleWrapper.applyChangesToSurface"></a>1.5.4 InputWindowHandleWrapper.applyChangesToSurface</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyChangesToSurface</span><span class="params">(<span class="meta">@NonNull</span> SurfaceControl.Transaction t, <span class="meta">@NonNull</span> SurfaceControl sc)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.5.5] 通过Transaction传递信息</span></span><br><span class="line">    t.setInputWindowInfo(sc, mHandle);</span><br><span class="line">    mChanged = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-5-SurfaceControl-Transaction-setInputWindowInfo"><a href="#1-5-5-SurfaceControl-Transaction-setInputWindowInfo" class="headerlink" title="1.5.5 SurfaceControl.Transaction.setInputWindowInfo"></a>1.5.5 SurfaceControl.Transaction.setInputWindowInfo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transaction <span class="title function_">setInputWindowInfo</span><span class="params">(SurfaceControl sc, InputWindowHandle handle)</span> &#123;</span><br><span class="line">    <span class="comment">// 确认该SurfaceControl没有被释放</span></span><br><span class="line">    checkPreconditions(sc);</span><br><span class="line">    <span class="comment">// [1.5.6] 通知给SurfaceFlinger</span></span><br><span class="line">    nativeSetInputWindowInfo(mNativeObject, sc.mNativeObject, handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeSetInputWindowInfo</span><span class="params">(<span class="type">long</span> transactionObj, <span class="type">long</span> nativeObject,</span></span><br><span class="line"><span class="params">        InputWindowHandle handle)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-6-android-view-SurfaceControl-nativeSetInputWindowInfo"><a href="#1-5-6-android-view-SurfaceControl-nativeSetInputWindowInfo" class="headerlink" title="1.5.6 android_view_SurfaceControl.nativeSetInputWindowInfo"></a>1.5.6 android_view_SurfaceControl.nativeSetInputWindowInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeSetInputWindowInfo</span><span class="params">(JNIEnv* env, jclass clazz, jlong transactionObj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong nativeObject, jobject inputWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> transaction = <span class="built_in">reinterpret_cast</span>&lt;SurfaceComposerClient::Transaction*&gt;(transactionObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.5.6.1] 根据传入的InputWindowHandle获取NativeInputWindowHandle</span></span><br><span class="line">    sp&lt;NativeInputWindowHandle&gt; handle = <span class="built_in">android_view_InputWindowHandle_getHandle</span>(</span><br><span class="line">            env, inputWindow);</span><br><span class="line">    <span class="comment">// [1.5.6.2] 更新NativeInputWindowHandle信息</span></span><br><span class="line">    handle-&gt;<span class="built_in">updateInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ctrl = <span class="built_in">reinterpret_cast</span>&lt;SurfaceControl *&gt;(nativeObject);</span><br><span class="line">    <span class="comment">// [1.5.6.3] 通知给SurfaceFligner</span></span><br><span class="line">    transaction-&gt;<span class="built_in">setInputWindowInfo</span>(ctrl, *handle-&gt;<span class="built_in">getInfo</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-6-1-android-hardware-input-InputWindowHandle-android-view-InputWindowHandle-getHandle"><a href="#1-5-6-1-android-hardware-input-InputWindowHandle-android-view-InputWindowHandle-getHandle" class="headerlink" title="1.5.6.1 android_hardware_input_InputWindowHandle.android_view_InputWindowHandle_getHandle"></a>1.5.6.1 android_hardware_input_InputWindowHandle.android_view_InputWindowHandle_getHandle</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;NativeInputWindowHandle&gt; <span class="title">android_view_InputWindowHandle_getHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env, jobject inputWindowHandleObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inputWindowHandleObj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(gHandleMutex);</span><br><span class="line">    <span class="comment">// 获取inputWindowHandle中对应的ptr, 该ptr就对应NativeInputWindowHandle</span></span><br><span class="line">    jlong ptr = env-&gt;<span class="built_in">GetLongField</span>(inputWindowHandleObj, gInputWindowHandleClassInfo.ptr);</span><br><span class="line">    NativeInputWindowHandle* handle;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        handle = <span class="built_in">reinterpret_cast</span>&lt;NativeInputWindowHandle*&gt;(ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果该ptr为0，那就创建一个NativeInputWindowHandle并赋值给java层的ptr中</span></span><br><span class="line">        jweak objWeak = env-&gt;<span class="built_in">NewWeakGlobalRef</span>(inputWindowHandleObj);</span><br><span class="line">        handle = <span class="keyword">new</span> <span class="built_in">NativeInputWindowHandle</span>(objWeak);</span><br><span class="line">        handle-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span>*)android_view_InputWindowHandle_getHandle);</span><br><span class="line">        env-&gt;<span class="built_in">SetLongField</span>(inputWindowHandleObj, gInputWindowHandleClassInfo.ptr,</span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(handle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-6-2-NativeInputWindowHandle-updateInfo"><a href="#1-5-6-2-NativeInputWindowHandle-updateInfo" class="headerlink" title="1.5.6.2 NativeInputWindowHandle.updateInfo"></a>1.5.6.2 NativeInputWindowHandle.updateInfo</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">NativeInputWindowHandle::updateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mInfo.touchableRegion.<span class="built_in">clear</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 更新可触碰区域</span></span><br><span class="line">    jobject regionObj = env-&gt;<span class="built_in">GetObjectField</span>(obj,</span><br><span class="line">            gInputWindowHandleClassInfo.touchableRegion);</span><br><span class="line">    <span class="keyword">if</span> (regionObj) &#123;</span><br><span class="line">        <span class="keyword">for</span> (graphics::RegionIterator <span class="built_in">it</span>(env, regionObj); !it.<span class="built_in">isDone</span>(); it.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            ARect rect = it.<span class="built_in">getRect</span>();</span><br><span class="line">            mInfo.<span class="built_in">addTouchableRegion</span>(<span class="built_in">Rect</span>(rect.left, rect.top, rect.right, rect.bottom));</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(regionObj);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是将java层InputWindowHandle里的信息同步给NativeInputWindowHandle.</p>
<h4 id="1-5-6-3-SurfaceComposerClient-Transaction-setInputWindowInfo"><a href="#1-5-6-3-SurfaceComposerClient-Transaction-setInputWindowInfo" class="headerlink" title="1.5.6.3 SurfaceComposerClient::Transaction.setInputWindowInfo"></a>1.5.6.3 SurfaceComposerClient::Transaction.setInputWindowInfo</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SurfaceComposerClient::Transaction&amp; SurfaceComposerClient::Transaction::<span class="built_in">setInputWindowInfo</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;SurfaceControl&gt;&amp; sc,</span><br><span class="line">        <span class="type">const</span> InputWindowInfo&amp; info) &#123;</span><br><span class="line">    <span class="comment">// 根据SurfaceControl获取对应的layer状态</span></span><br><span class="line">    <span class="type">layer_state_t</span>* s = <span class="built_in">getLayerState</span>(sc);</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        mStatus = BAD_INDEX;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将InputWindowInfo转成InputWindowHandle存在layer中</span></span><br><span class="line">    s-&gt;inputHandle = <span class="keyword">new</span> <span class="built_in">InputWindowHandle</span>(info);</span><br><span class="line">    <span class="comment">// 标记该layer输入信息有更改</span></span><br><span class="line">    s-&gt;what |= <span class="type">layer_state_t</span>::eInputInfoChanged;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是将窗口相关信息存入了SurfaceFling中，至于怎么传输的，为什么需要这些信息，我们后续研究WMS的窗口和SurfaceFlinger的关系时分析。</p>
<h2 id="1-6-InputMonitor-updateInputFocusRequest"><a href="#1-6-InputMonitor-updateInputFocusRequest" class="headerlink" title="1.6 InputMonitor.updateInputFocusRequest"></a>1.6 InputMonitor.updateInputFocusRequest</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInputFocusRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">focus</span> <span class="operator">=</span> mDisplayContent.mCurrentFocus;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">focusToken</span> <span class="operator">=</span> focus != <span class="literal">null</span> ? focus.mInputChannelToken : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    requestFocus(focusToken, focus.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">requestFocus</span><span class="params">(IBinder focusToken, String windowName)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mInputFocus = focusToken;</span><br><span class="line">    <span class="comment">// 通过Transaction更新input系统中的焦点窗口</span></span><br><span class="line">    mInputTransaction.setFocusedWindow(mInputFocus, windowName, mDisplayId);</span><br><span class="line">    EventLog.writeEvent(LOGTAG_INPUT_FOCUS, <span class="string">&quot;Focus request &quot;</span> + windowName,</span><br><span class="line">            <span class="string">&quot;reason=UpdateInputWindows&quot;</span>);</span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;Focus requested for window=%s&quot;</span>, windowName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意mInputTransaction其实还是SurfaceControl.Transaction类， 在InputMonitor初始化时创建的:</p>
<blockquote>
<p>mInputTransaction &#x3D; mService.mTransactionFactory.get();</p>
</blockquote>
<h2 id="1-6-1-SurfaceControl-setFocusedWindow"><a href="#1-6-1-SurfaceControl-setFocusedWindow" class="headerlink" title="1.6.1 SurfaceControl.setFocusedWindow"></a>1.6.1 SurfaceControl.setFocusedWindow</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Transaction <span class="title function_">setFocusedWindow</span><span class="params">(<span class="meta">@NonNull</span> IBinder token, String windowName,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    nativeSetFocusedWindow(mNativeObject, token,  windowName,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* focusedToken */</span>, <span class="literal">null</span> <span class="comment">/* focusedWindowName */</span>, displayId);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeSetFocusedWindow</span><span class="params">(<span class="type">long</span> transactionObj, IBinder toToken,</span></span><br><span class="line"><span class="params">        String windowName, IBinder focusedToken, String focusedWindowName, <span class="type">int</span> displayId)</span>;</span><br></pre></td></tr></table></figure>

<p>通过JNI调用到native层：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeSetFocusedWindow</span><span class="params">(JNIEnv* env, jclass clazz, jlong transactionObj,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   jobject toTokenObj, jstring windowNameJstr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   jobject focusedTokenObj, jstring focusedWindowNameJstr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   jint displayId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> transaction = <span class="built_in">reinterpret_cast</span>&lt;SurfaceComposerClient::Transaction*&gt;(transactionObj);</span><br><span class="line">    <span class="keyword">if</span> (toTokenObj == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// toTokenObj就是mInputChannelToken</span></span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">toToken</span><span class="params">(ibinderForJavaObject(env, toTokenObj))</span></span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    FocusRequest request;</span><br><span class="line">    request.token = toToken;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    transaction-&gt;<span class="built_in">setFocusedWindow</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line">SurfaceComposerClient::Transaction&amp; SurfaceComposerClient::Transaction::<span class="built_in">setFocusedWindow</span>(</span><br><span class="line">        <span class="type">const</span> FocusRequest&amp; request) &#123;</span><br><span class="line">    mInputWindowCommands.focusRequests.<span class="built_in">push_back</span>(request);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将传入的焦点窗口的mInputChannelToken和其他信息打包封装在FocusRequest中，存入SurfaceComposerClient的mInputWindowCommands.focusRequests集合中。</p>
<p>那么这个mInputWindowCommands.focusRequests是什么时候使用的呢，当调用SurfaceControl.Transaction.apply()函数时，会通过binder将该Transaction的所有信息传递给SurfaceFlinger进程（sf-&gt;setTransactionState接口），SurfaceFlinger接收到该Transaction后将其保存在mTransactionQueue队列中。然后在下一次Vsync信号来临时，即onMessageInvalidate函数中，将Transaction从mTransactionQeue中提取出来存入mPendingTransactionQueues队列中，于此同时调用addInputWindowCommands将该Transaction中的inputWindowHandles保存在SurfaceFlinger的mInputWindowCommands中，之后就调用updateInputFlinger()将mInputWindowCommands中的focusRequests更新到InputFlinger中。</p>
<h3 id="1-6-2-SurfaceFlinger-updateInputFlinger"><a href="#1-6-2-SurfaceFlinger-updateInputFlinger" class="headerlink" title="1.6.2 SurfaceFlinger.updateInputFlinger"></a>1.6.2 SurfaceFlinger.updateInputFlinger</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::updateInputFlinger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">if</span> (!mInputFlinger) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可视区域有更新或者输入信息更改需要通知InputFlinger</span></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty || mInputInfoChanged) &#123;</span><br><span class="line">        mInputInfoChanged = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// [2.1] 更新窗口输入信息至InputFlinger</span></span><br><span class="line">        <span class="built_in">updateInputWindowInfo</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInputWindowCommands.syncInputWindows) &#123;</span><br><span class="line">        <span class="comment">// If the caller requested to sync input windows, but there are no</span></span><br><span class="line">        <span class="comment">// changes to input windows, notify immediately.</span></span><br><span class="line">        <span class="built_in">setInputWindowsFinished</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有focusRequests，依次通知给InputFlinger更新焦点窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; focusRequest : mInputWindowCommands.focusRequests) &#123;</span><br><span class="line">        <span class="comment">// [3.1] 将焦点窗口同步更新给InputFlinger</span></span><br><span class="line">        mInputFlinger-&gt;<span class="built_in">setFocusedWindow</span>(focusRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    mInputWindowCommands.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-Window信息更新至InputFlinger"><a href="#二-Window信息更新至InputFlinger" class="headerlink" title="二. Window信息更新至InputFlinger"></a>二. Window信息更新至InputFlinger</h1><p>上面我们分析了窗口的信息的收集过程，重点是可触碰区域的计算，现在我们分析一下窗口信息传递给InputFlinger的过程。</p>
<h2 id="2-1-SurfaceFlinger-updateInputWindowInfo"><a href="#2-1-SurfaceFlinger-updateInputWindowInfo" class="headerlink" title="2.1 SurfaceFlinger.updateInputWindowInfo"></a>2.1 SurfaceFlinger.updateInputWindowInfo</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::updateInputWindowInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;InputWindowInfo&gt; inputInfos;</span><br><span class="line">    <span class="comment">// mDrawingState我们之前有过分析，这里存储了所有需要更新的图层集</span></span><br><span class="line">    <span class="comment">// 遍历所有的图层，依次计算该layer的输入窗口信息</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 2.2 在计算屏幕边界时，忽略透明区域， 因为它可能导致不必要的偏移量</span></span><br><span class="line">        <span class="comment">// 将计算结果保存在inputInfos中, 每次都是添加到队列尾部</span></span><br><span class="line">        inputInfos.<span class="built_in">push_back</span>(layer-&gt;<span class="built_in">fillInputInfo</span>(display));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3 将计算结果传递给InputFlinger</span></span><br><span class="line">    mInputFlinger-&gt;<span class="built_in">setInputWindows</span>(inputInfos,</span><br><span class="line">                               mInputWindowCommands.syncInputWindows ? mSetInputWindowsListener</span><br><span class="line">                                                                     : <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是遍历所有的需要更新的Layer, 依次计算该Layer对应的窗口可触摸区域，将结果保存在InputWindowInfo的Vector中，然后通过Binder传给InputFlinger进程。</p>
<p>注意这里对layer的遍历是沿着Z轴反方向的，也就是从上到下的遍历顺序。layer在上面，存入inputInfos队列前面。</p>
<h2 id="2-2-Layer-fillInputInfo"><a href="#2-2-Layer-fillInputInfo" class="headerlink" title="2.2 Layer.fillInputInfo"></a>2.2 Layer.fillInputInfo</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">InputWindowInfo <span class="title">Layer::fillInputInfo</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; display)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    InputWindowInfo info = mDrawingState.inputInfo;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [2.2.1] 再次计算可触摸区域</span></span><br><span class="line">    <span class="built_in">fillInputFrameInfo</span>(info, toPhysicalDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该窗口是否可见</span></span><br><span class="line">    info.visible = <span class="built_in">hasInputInfo</span>() ? <span class="built_in">canReceiveInput</span>() : <span class="built_in">isVisible</span>();</span><br><span class="line">    info.alpha = <span class="built_in">getAlpha</span>();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据显示屏再次计算可触摸区域以及其他相关信息。</p>
<h3 id="2-2-1-Layer-fillInputFrameInfo"><a href="#2-2-1-Layer-fillInputFrameInfo" class="headerlink" title="2.2.1 Layer.fillInputFrameInfo"></a>2.2.1 Layer.fillInputFrameInfo</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::fillInputFrameInfo</span><span class="params">(InputWindowInfo&amp; info, <span class="type">const</span> ui::Transform&amp; toPhysicalDisplay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变换图层大小到屏幕空间</span></span><br><span class="line">    Rect layerBounds = info.portalToDisplayId == ADISPLAY_ID_NONE</span><br><span class="line">            ? <span class="built_in">getInputBounds</span>()</span><br><span class="line">            : info.touchableRegion.<span class="built_in">getBounds</span>();</span><br><span class="line">    ......</span><br><span class="line">    ui::Transform layerToDisplay = <span class="built_in">getInputTransform</span>();</span><br><span class="line">    <span class="comment">// 将窗口坐标转换为非旋转显示坐标的转换</span></span><br><span class="line">    ui::Transform t = toPhysicalDisplay * layerToDisplay;</span><br><span class="line">    ......</span><br><span class="line">    ui::Transform inverseTransform = t.<span class="built_in">inverse</span>();</span><br><span class="line">    Rect nonTransformedBounds = inverseTransform.<span class="built_in">transform</span>(transformedLayerBounds);</span><br><span class="line">    vec2 translation = t.<span class="built_in">transform</span>(nonTransformedBounds.left, nonTransformedBounds.top);</span><br><span class="line">    <span class="function">ui::Transform <span class="title">inputTransform</span><span class="params">(t)</span></span>;</span><br><span class="line">    inputTransform.<span class="built_in">set</span>(translation.x, translation.y);</span><br><span class="line">    info.transform = inputTransform.<span class="built_in">inverse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要将裁剪的图层边界发送到屏幕边界，因为图层可以被裁剪</span></span><br><span class="line">    <span class="comment">// frame应该是用户在屏幕上看到的区域，被用于遮挡检测</span></span><br><span class="line">    transformedLayerBounds.<span class="built_in">intersect</span>(screenBounds, &amp;transformedLayerBounds);</span><br><span class="line">    info.frameLeft = transformedLayerBounds.left;</span><br><span class="line">    info.frameTop = transformedLayerBounds.top;</span><br><span class="line">    info.frameRight = transformedLayerBounds.right;</span><br><span class="line">    info.frameBottom = transformedLayerBounds.bottom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对于框架屏幕位置定位可触摸区域，并将其限制在框架边界</span></span><br><span class="line">    info.touchableRegion = inputTransform.<span class="built_in">transform</span>(info.touchableRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们在WMS中有计算过可触摸区域，但通过SurfaceFlinger还是需要更加Display实际大小等加工一下，确定最终窗口的可触摸区域。</p>
<p>这里的计算过程就不展开分析了，感兴趣的可以自行研究。</p>
<h2 id="2-3-InputFlinger-setInputWindows"><a href="#2-3-InputFlinger-setInputWindows" class="headerlink" title="2.3 InputFlinger.setInputWindows"></a>2.3 InputFlinger.setInputWindows</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">binder::Status <span class="title">InputManager::setInputWindows</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;InputWindowInfo&gt;&amp; infos,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;ISetInputWindowsListener&gt;&amp; setInputWindowsListener)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int32_t</span>, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&gt; handlesPerDisplay;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; handles;</span><br><span class="line">    <span class="comment">// 将从SF传过来的InputWindowInfo信息打包成BinderWindowHandle</span></span><br><span class="line">    <span class="comment">// 存入对应DisplayId的InputWindowHandle集合中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info : infos) &#123;</span><br><span class="line">        <span class="comment">// 注意这里是emplace，每次都是插入队列头部，相当于将infos中元素反向排列了</span></span><br><span class="line">        handlesPerDisplay.<span class="built_in">emplace</span>(info.displayId, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;());</span><br><span class="line">        handlesPerDisplay[info.displayId].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">BinderWindowHandle</span>(info));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.4 交给InputDispatcher处理</span></span><br><span class="line">    mDispatcher-&gt;<span class="built_in">setInputWindows</span>(handlesPerDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setInputWindowsListener) &#123;</span><br><span class="line">        setInputWindowsListener-&gt;<span class="built_in">onSetInputWindowsFinished</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binder::Status::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BinderWindowHandle就是个包装类，继承了InputWindowHandle，并且重写了updateInfo, 内部只有一个InputWindowHandle的成员变量。这是为了避免后续不小心更新窗口信息。</p>
<p>这里将从SF传过来的InputWindowInfo信息打包成BinderWindowHandle，存入对应DisplayId的InputWindowHandle集合中，然后交给InputDispatcher处理。</p>
<h2 id="2-4-InputDispatcher-setInputWindows"><a href="#2-4-InputDispatcher-setInputWindows" class="headerlink" title="2.4 InputDispatcher.setInputWindows"></a>2.4 InputDispatcher.setInputWindows</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::setInputWindows</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::unordered_map&lt;<span class="type">int32_t</span>, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&gt;&amp; handlesPerDisplay)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [displayId, handles] : handlesPerDisplay) &#123;</span><br><span class="line">            <span class="built_in">setInputWindowsLocked</span>(handles, displayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒轮询循环，可能需要做出新的输入分派选择</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对所有的Display依次更新输入窗口信息, 然后唤醒轮询循环，做出新的输入分派选择。</p>
<h2 id="2-5-InputDispatcher-setInputWindowsLocked"><a href="#2-5-InputDispatcher-setInputWindowsLocked" class="headerlink" title="2.5 InputDispatcher.setInputWindowsLocked"></a>2.5 InputDispatcher.setInputWindowsLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::setInputWindowsLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; inputWindowHandles, <span class="type">int32_t</span> displayId)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取当前所有的输入窗口handle用于relase</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; oldWindowHandles = <span class="built_in">getWindowHandlesLocked</span>(displayId);</span><br><span class="line">    <span class="comment">// 更新输入窗口信息列表，就是将新窗口输入信息保存在mWindowHandlesByDisplay中</span></span><br><span class="line">    <span class="built_in">updateWindowHandlesForDisplayLocked</span>(inputWindowHandles, displayId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 确认windowHandles列表中包含焦点窗口，如果不存在找上一次的焦点窗口作为当前焦点</span></span><br><span class="line">    std::optional&lt;FocusResolver::FocusChanges&gt; changes =</span><br><span class="line">            mFocusResolver.<span class="built_in">setInputWindows</span>(displayId, windowHandles);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; oldWindowHandle : oldWindowHandles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getWindowHandleLocked</span>(oldWindowHandle) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 将不在展示的窗口信息释放掉，节省资源</span></span><br><span class="line">            oldWindowHandle-&gt;<span class="built_in">releaseChannel</span>();</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::updateWindowHandlesForDisplayLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; inputWindowHandles, <span class="type">int32_t</span> displayId)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; newHandles;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; handle : inputWindowHandles) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> ((oldHandlesById.<span class="built_in">find</span>(handle-&gt;<span class="built_in">getId</span>()) != oldHandlesById.<span class="built_in">end</span>()) &amp;&amp;</span><br><span class="line">                (oldHandlesById.<span class="built_in">at</span>(handle-&gt;<span class="built_in">getId</span>())-&gt;<span class="built_in">getToken</span>() == handle-&gt;<span class="built_in">getToken</span>())) &#123;</span><br><span class="line">            <span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; oldHandle = oldHandlesById.<span class="built_in">at</span>(handle-&gt;<span class="built_in">getId</span>());</span><br><span class="line">            oldHandle-&gt;<span class="built_in">updateFrom</span>(handle);</span><br><span class="line">            newHandles.<span class="built_in">push_back</span>(oldHandle);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// push_back是向队列尾部添加元素</span></span><br><span class="line">            newHandles.<span class="built_in">push_back</span>(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存新的窗口输入信息至mWindowHandlesByDisplay中.</span></span><br><span class="line">    mWindowHandlesByDisplay[displayId] = newHandles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是更新窗口输入信息至mWindowHandlesByDisplay，将不在展示的窗口信息释放掉，节省资源。</p>
<h1 id="三-更新InputFlinger的焦点窗口"><a href="#三-更新InputFlinger的焦点窗口" class="headerlink" title="三. 更新InputFlinger的焦点窗口"></a>三. 更新InputFlinger的焦点窗口</h1><p>SurfaceFlinger通过binder将焦点窗口同步更新给InputFlinger。</p>
<h2 id="3-1-InputFlinger-setFocusedWindow"><a href="#3-1-InputFlinger-setFocusedWindow" class="headerlink" title="3.1 InputFlinger.setFocusedWindow"></a>3.1 InputFlinger.setFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">binder::Status <span class="title">InputManager::setFocusedWindow</span><span class="params">(<span class="type">const</span> FocusRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [3.2] 交给InputDispatcher更新焦点窗口</span></span><br><span class="line">    mDispatcher-&gt;<span class="built_in">setFocusedWindow</span>(request);</span><br><span class="line">    <span class="keyword">return</span> binder::Status::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-InputDispatcher-setFocusedWindow"><a href="#3-2-InputDispatcher-setFocusedWindow" class="headerlink" title="3.2 InputDispatcher.setFocusedWindow"></a>3.2 InputDispatcher.setFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::setFocusedWindow</span><span class="params">(<span class="type">const</span> FocusRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        <span class="comment">// [3.3] 获取当前display中所有的窗口输入信息，交给FocusResolver更新焦点窗口</span></span><br><span class="line">        std::optional&lt;FocusResolver::FocusChanges&gt; changes =</span><br><span class="line">                mFocusResolver.<span class="built_in">setFocusedWindow</span>(request, <span class="built_in">getWindowHandlesLocked</span>(request.displayId));</span><br><span class="line">        <span class="keyword">if</span> (changes) &#123;</span><br><span class="line">            <span class="comment">// 响应焦点窗口更新</span></span><br><span class="line">            <span class="built_in">onFocusChangedLocked</span>(*changes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="comment">// Wake up poll loop since it may need to make new input dispatching choices.</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-FocusResolver-setFocusedWindow"><a href="#3-3-FocusResolver-setFocusedWindow" class="headerlink" title="3.3 FocusResolver.setFocusedWindow"></a>3.3 FocusResolver.setFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::optional&lt;FocusResolver::FocusChanges&gt; <span class="title">FocusResolver::setFocusedWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> FocusRequest&amp; request, <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; windows)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> displayId = request.displayId;</span><br><span class="line">    <span class="comment">// 如果当前焦点窗口就是需要设置的窗口，直接返回</span></span><br><span class="line">    <span class="type">const</span> sp&lt;IBinder&gt; currentFocus = <span class="built_in">getFocusedWindowToken</span>(displayId);</span><br><span class="line">    <span class="keyword">if</span> (currentFocus == request.token) &#123;</span><br><span class="line">        <span class="built_in">ALOGD_IF</span>(DEBUG_FOCUS,</span><br><span class="line">                 <span class="string">&quot;setFocusedWindow %s on display %&quot;</span> PRId32 <span class="string">&quot; ignored, reason: already focused&quot;</span>,</span><br><span class="line">                 request.windowName.<span class="built_in">c_str</span>(), displayId);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理焦点请求，即具有焦点令牌的请求。这些请求不是持久的。如果窗口不再可聚焦，焦点返回到先前聚焦的窗口</span></span><br><span class="line">    <span class="comment">// 在[1.6.1] SurfaceControl.setFocusedWindow实际传入的focusedToken是null的，这里我们也假设为null好了</span></span><br><span class="line">    <span class="keyword">if</span> (request.focusedToken) &#123;</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查传入的待聚焦的窗口是否可聚焦且在windows列表中</span></span><br><span class="line">    Focusability result = <span class="built_in">isTokenFocusable</span>(request.token, windows);</span><br><span class="line">    <span class="comment">// 响应焦点请求</span></span><br><span class="line">    mFocusRequestByDisplay[displayId] = request;</span><br><span class="line">    mLastFocusResultByDisplay[displayId] = result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == Focusability::OK) &#123;</span><br><span class="line">        <span class="comment">// [3.4] 更新焦点窗口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">updateFocusedWindow</span>(displayId, <span class="string">&quot;setFocusedWindow&quot;</span>, request.token,</span><br><span class="line">                                   request.windowName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求的窗口当前不能聚焦。等待窗口变成可聚焦的，但从当前窗口移除焦点，以便输入事件可以进入挂起队列，并在窗口变成聚焦时发送到窗口。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">updateFocusedWindow</span>(displayId, <span class="string">&quot;Waiting for window because &quot;</span> + NamedEnum::<span class="built_in">string</span>(result),</span><br><span class="line">                               <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前焦点窗口就是需要设置的窗口，直接返回。然后检查传入的待聚焦的窗口是否可聚焦且在windows列表中， 更新mFocusRequestByDisplay和mLastFocusResultByDisplay，最后无论待更新的焦点窗口是否可聚焦，都更新焦点窗口，即将焦点窗口token（对应InputChannel的token）保存在mFocusedWindowTokenByDisplay中。</p>
<h2 id="3-4-FocusResolver-updateFocusedWindow"><a href="#3-4-FocusResolver-updateFocusedWindow" class="headerlink" title="3.4 FocusResolver.updateFocusedWindow"></a>3.4 FocusResolver.updateFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::optional&lt;FocusResolver::FocusChanges&gt; <span class="title">FocusResolver::updateFocusedWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> displayId, <span class="type">const</span> std::string&amp; reason, <span class="type">const</span> sp&lt;IBinder&gt;&amp; newFocus,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; tokenName)</span> </span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; oldFocus = <span class="built_in">getFocusedWindowToken</span>(displayId);</span><br><span class="line">    <span class="keyword">if</span> (newFocus == oldFocus) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newFocus) &#123;</span><br><span class="line">        mFocusedWindowTokenByDisplay[displayId] = &#123;tokenName, newFocus&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFocusedWindowTokenByDisplay.<span class="built_in">erase</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#123;oldFocus, newFocus, displayId, reason&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将焦点窗口token（对应InputChannel的token，即InputChannel初始化时创建的BBinder）保存在mFocusedWindowTokenByDisplay中。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，WMS上层创建WindowState之后，如果该窗口可以接收input事件就需要更新焦点窗口，其后更新输入窗口信息给Input系统。注意这里涉及了三个模块：System_server(WMS)，InputFlinger和SurfaceFlinger。之所以需要SurfaceFlinger，一是需要借助SurfaceControl通道通信，更重要的是，需要通过SurfaceFlinger进一步去计算窗口的信息，如可触摸区域、可见区域等等。在SurfaceFlinger计算完毕后，通过Binder调用将窗口信息封装成InputWindowInfo传给InputFlinger，InputFlinger将传过来的InputWindowInfo信息打包成BinderWindowHandle存入mWindowHandlesByDisplay中。</p>
<p>接下来我们看看一次触摸事件分发给窗口的流程作为Input事件和Window的结束语。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
        <category>Input</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WMS</tag>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>WMS(9)-Input事件分发给窗口的过程</title>
    <url>/2022/05/09/WMS(9)-Input%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%BB%99%E7%AA%97%E5%8F%A3%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<div style="page-break-after: always;"></div>

<p><strong>以下分析基于Android S.</strong></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在前面两篇文章中我们打通了应用进程和Input进程，这两者通过一对名为InputChannel实际是通过socket实现的通道来通信。然后我们又梳理了窗口信息是如何更新并传递给Input进程的。现在我们简单梳理一下一次触摸事件分发给窗口的过程。</p>
<p>事件要分发，首先是需要找到被分发的事件和对应的目标窗口。</p>
<span id="more"></span>

<h1 id="一-查找Input事件的目标窗口"><a href="#一-查找Input事件的目标窗口" class="headerlink" title="一. 查找Input事件的目标窗口"></a>一. 查找Input事件的目标窗口</h1><p>Input事件是显示屏驱动收到中断后通知给InputReader，由其打包交给InputDispatcher分发的，我们直接看InputDispatcher的MotionEvent分发过程。</p>
<h2 id="1-1-InputDispatcher-dispatchMotionLocked"><a href="#1-1-InputDispatcher-dispatchMotionLocked" class="headerlink" title="1.1 InputDispatcher.dispatchMotionLocked"></a>1.1 InputDispatcher.dispatchMotionLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputDispatcher::dispatchMotionLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime, std::shared_ptr&lt;MotionEntry&gt; entry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        DropReason* dropReason, <span class="type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 通过输入源确认是否为点击触摸事件</span></span><br><span class="line">    <span class="type">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;</span><br><span class="line">    <span class="comment">// 输入事件的目标窗口集合</span></span><br><span class="line">    std::vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="comment">// 触摸屏事件</span></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">// [1.2] 找到此次触摸事件的目标窗口    </span></span><br><span class="line">        injectionResult =</span><br><span class="line">                <span class="built_in">findTouchedWindowTargetsLocked</span>(currentTime, *entry, inputTargets, nextWakeupTime,</span><br><span class="line">                                               &amp;conflictingPointerActions);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [2.1] Input事件的分发</span></span><br><span class="line">    <span class="built_in">dispatchEventLocked</span>(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android的输入源有如下几种：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AINPUT_SOURCE_CLASS_NONE</td>
<td>0</td>
<td>未定义，交给应用自行处理</td>
</tr>
<tr>
<td>AINPUT_SOURCE_CLASS_BUTTON</td>
<td>1</td>
<td>按键之类的设备</td>
</tr>
<tr>
<td>AINPUT_SOURCE_CLASS_POINTER</td>
<td>2</td>
<td>输入源是一个与显示器相关联的指向设备，如触摸屏</td>
</tr>
<tr>
<td>AINPUT_SOURCE_CLASS_NAVIGATION</td>
<td>4</td>
<td>输入源轨迹球导航设备</td>
</tr>
<tr>
<td>AINPUT_SOURCE_CLASS_POSITION</td>
<td>8</td>
<td>输入源是与显示器无关的绝对定位装置，如触控板</td>
</tr>
<tr>
<td>AINPUT_SOURCE_CLASS_JOYSTICK</td>
<td>16</td>
<td>输入源是一个操纵杆，摇杆设备</td>
</tr>
</tbody></table>
<p>当然，MotionEvent肯定是来自AINPUT_SOURCE_CLASS_POINTER了。</p>
<h2 id="1-2-InputDispatcher-findTouchedWindowTargetsLocked"><a href="#1-2-InputDispatcher-findTouchedWindowTargetsLocked" class="headerlink" title="1.2 InputDispatcher.findTouchedWindowTargetsLocked"></a>1.2 InputDispatcher.findTouchedWindowTargetsLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">InputEventInjectionResult <span class="title">InputDispatcher::findTouchedWindowTargetsLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span> currentTime, <span class="type">const</span> MotionEntry&amp; entry, std::vector&lt;InputTarget&gt;&amp; inputTargets,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span>* nextWakeupTime, <span class="type">bool</span>* outConflictingPointerActions)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;InputWindowHandle&gt; newTouchedWindowHandle;</span><br><span class="line">    ......</span><br><span class="line">    TouchState tempTouchState;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">bool</span> isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN;</span><br><span class="line">    <span class="comment">// 区分是否为新的手势事件（区别与ACTION_MOVE）</span></span><br><span class="line">    <span class="type">bool</span> newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN ||</span><br><span class="line">                    maskedAction == AMOTION_EVENT_ACTION_SCROLL || isHoverAction);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (newGesture || (isSplit &amp;&amp; maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) &#123;</span><br><span class="line">        <span class="type">int32_t</span> x;</span><br><span class="line">        <span class="type">int32_t</span> y;</span><br><span class="line">        ......</span><br><span class="line">            <span class="comment">// 获取此次触摸事件在屏幕坐标中的位置</span></span><br><span class="line">            x = <span class="built_in">int32_t</span>(entry.pointerCoords[pointerIndex].<span class="built_in">getAxisValue</span>(AMOTION_EVENT_AXIS_X));</span><br><span class="line">            y = <span class="built_in">int32_t</span>(entry.pointerCoords[pointerIndex].<span class="built_in">getAxisValue</span>(AMOTION_EVENT_AXIS_Y));</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// [1.3] 根据触摸事件的坐标找到可触摸的窗口</span></span><br><span class="line">        newTouchedWindowHandle =</span><br><span class="line">                <span class="built_in">findTouchedWindowAtLocked</span>(displayId, x, y, &amp;tempTouchState,</span><br><span class="line">                                          isDown <span class="comment">/*addOutsideTargets*/</span>, <span class="literal">true</span> <span class="comment">/*addPortalWindows*/</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (newTouchedWindowHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// [1.4] 将找到的目标窗口存入TouchState中</span></span><br><span class="line">            tempTouchState.<span class="built_in">addOrUpdateWindow</span>(newTouchedWindowHandle, targetFlags, pointerIds);</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 依次遍历找到的目标窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> TouchedWindow&amp; touchedWindow : tempTouchState.windows) &#123;</span><br><span class="line">        <span class="comment">// [1.5] 将找到的目标窗口存入inputTargets中</span></span><br><span class="line">        <span class="built_in">addWindowTargetLocked</span>(touchedWindow.windowHandle, touchedWindow.targetFlags,</span><br><span class="line">                              touchedWindow.pointerIds, inputTargets);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-InputDispatcher-findTouchedWindowAtLocked"><a href="#1-3-InputDispatcher-findTouchedWindowAtLocked" class="headerlink" title="1.3 InputDispatcher.findTouchedWindowAtLocked"></a>1.3 InputDispatcher.findTouchedWindowAtLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;InputWindowHandle&gt; <span class="title">InputDispatcher::findTouchedWindowAtLocked</span><span class="params">(<span class="type">int32_t</span> displayId, <span class="type">int32_t</span> x,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">int32_t</span> y, TouchState* touchState,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">bool</span> addOutsideTargets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">bool</span> addPortalWindows,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">bool</span> ignoreDragWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [1.3.1] 从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; windowHandles = <span class="built_in">getWindowHandlesLocked</span>(displayId);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle : windowHandles) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;<span class="built_in">getInfo</span>();</span><br><span class="line">        <span class="keyword">if</span> (windowInfo-&gt;displayId == displayId) &#123;</span><br><span class="line">            <span class="keyword">auto</span> flags = windowInfo-&gt;flags;</span><br><span class="line">            <span class="comment">// 首先窗口必须是可见的，不可见窗口无法接收input事件</span></span><br><span class="line">            <span class="keyword">if</span> (windowInfo-&gt;visible) &#123;</span><br><span class="line">                <span class="comment">// 窗口必须不携带NOT_TOUCHABLE的flag</span></span><br><span class="line">                <span class="keyword">if</span> (!flags.<span class="built_in">test</span>(InputWindowInfo::Flag::NOT_TOUCHABLE)) &#123;</span><br><span class="line">                    <span class="type">bool</span> isTouchModal = !flags.<span class="built_in">test</span>(InputWindowInfo::Flag::NOT_FOCUSABLE) &amp;&amp;</span><br><span class="line">                            !flags.<span class="built_in">test</span>(InputWindowInfo::Flag::NOT_TOUCH_MODAL);</span><br><span class="line">                    <span class="comment">// [1.3.2] 判断坐标是否位于该窗口内或者该窗口是TOUCH_MODAL的</span></span><br><span class="line">                    <span class="keyword">if</span> (isTouchModal || windowInfo-&gt;<span class="built_in">touchableRegionContainsPoint</span>(x, y)) &#123;</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="comment">// 找到的第一个窗口直接返回</span></span><br><span class="line">                        <span class="keyword">return</span> windowHandle;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息，依次遍历，判断窗口是否可见，不可见窗口无法接收input事件。如果可见，在判断窗口是否携带NOT_TOUCHABLE的flag。如果不携带，只要触摸事件的坐标位于该窗口的可触摸区域内，就返回该窗口。</p>
<p>注意getWindowHandlesLocked拿到的窗口是有顺序的，index越小，Z轴越大。因为在<strong>SurfaceFlinger.updateInputWindowInfo时我们遍历layer的顺序是沿着Z轴反向遍历的</strong>。那么窗口在上面的会存储在mWindowHandlesByDisplay中对应队列的前面，所以这里只需要找到第一个窗口返回即可。</p>
<h3 id="1-3-1-InputDispatcher-getWindowHandlesLocked"><a href="#1-3-1-InputDispatcher-getWindowHandlesLocked" class="headerlink" title="1.3.1 InputDispatcher.getWindowHandlesLocked"></a>1.3.1 InputDispatcher.getWindowHandlesLocked</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; InputDispatcher::<span class="built_in">getWindowHandlesLocked</span>(</span><br><span class="line">        <span class="type">int32_t</span> displayId) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; EMPTY_WINDOW_HANDLES;</span><br><span class="line">    <span class="keyword">auto</span> it = mWindowHandlesByDisplay.<span class="built_in">find</span>(displayId);</span><br><span class="line">    <span class="keyword">return</span> it != mWindowHandlesByDisplay.<span class="built_in">end</span>() ? it-&gt;second : EMPTY_WINDOW_HANDLES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息（WMS中addWindow后添加的）。</p>
<h3 id="1-3-2-InputWindowInfo-touchableRegionContainsPoint"><a href="#1-3-2-InputWindowInfo-touchableRegionContainsPoint" class="headerlink" title="1.3.2 InputWindowInfo.touchableRegionContainsPoint"></a>1.3.2 InputWindowInfo.touchableRegionContainsPoint</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputWindowInfo::touchableRegionContainsPoint</span><span class="params">(<span class="type">int32_t</span> x, <span class="type">int32_t</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> touchableRegion.<span class="built_in">contains</span>(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断该窗口的可触摸区域是否包含此坐标点。</p>
<h2 id="1-4-TouchState-addOrUpdateWindow"><a href="#1-4-TouchState-addOrUpdateWindow" class="headerlink" title="1.4 TouchState.addOrUpdateWindow"></a>1.4 TouchState.addOrUpdateWindow</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TouchState::addOrUpdateWindow</span><span class="params">(<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle, <span class="type">int32_t</span> targetFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   BitSet32 pointerIds)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 封装成TouchedWindow存入windows队列的末尾</span></span><br><span class="line">    TouchedWindow touchedWindow;</span><br><span class="line">    touchedWindow.windowHandle = windowHandle;</span><br><span class="line">    touchedWindow.targetFlags = targetFlags;</span><br><span class="line">    touchedWindow.pointerIds = pointerIds;</span><br><span class="line">    windows.<span class="built_in">push_back</span>(touchedWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将找到的目标窗口封装成TouchedWindow存入TouchState.windows队列的末尾。</p>
<h2 id="1-5-InputDispatcher-addWindowTargetLocked"><a href="#1-5-InputDispatcher-addWindowTargetLocked" class="headerlink" title="1.5 InputDispatcher.addWindowTargetLocked"></a>1.5 InputDispatcher.addWindowTargetLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::addWindowTargetLocked</span><span class="params">(<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int32_t</span> targetFlags, BitSet32 pointerIds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            std::vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用find_if函数，查找inputTargets中inputChannel的token和传入的窗口token一致的InputTarget</span></span><br><span class="line">    std::vector&lt;InputTarget&gt;::iterator it =</span><br><span class="line">            std::<span class="built_in">find_if</span>(inputTargets.<span class="built_in">begin</span>(), inputTargets.<span class="built_in">end</span>(),</span><br><span class="line">                         [&amp;windowHandle](<span class="type">const</span> InputTarget&amp; inputTarget) &#123;</span><br><span class="line">                             <span class="keyword">return</span> inputTarget.inputChannel-&gt;<span class="built_in">getConnectionToken</span>() ==</span><br><span class="line">                                     windowHandle-&gt;<span class="built_in">getToken</span>();</span><br><span class="line">                         &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;<span class="built_in">getInfo</span>();</span><br><span class="line">    <span class="comment">// 当it是指向inputTargets.end()时，说明inputTargets中不存在和传入的窗口token一致的InputTarget对象</span></span><br><span class="line">    <span class="keyword">if</span> (it == inputTargets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// 创建新的InputTarget，对应传入的窗口，放在inputTargets队列的末尾</span></span><br><span class="line">        InputTarget inputTarget;</span><br><span class="line">        std::shared_ptr&lt;InputChannel&gt; inputChannel =</span><br><span class="line">                <span class="built_in">getInputChannelLocked</span>(windowHandle-&gt;<span class="built_in">getToken</span>());</span><br><span class="line">        <span class="keyword">if</span> (inputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Window %s already unregistered input channel&quot;</span>, windowHandle-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inputTarget.inputChannel = inputChannel;</span><br><span class="line">        inputTarget.flags = targetFlags;</span><br><span class="line">        inputTarget.globalScaleFactor = windowInfo-&gt;globalScaleFactor;</span><br><span class="line">        inputTarget.displaySize =</span><br><span class="line">                <span class="built_in">vec2</span>(windowHandle-&gt;<span class="built_in">getInfo</span>()-&gt;displayWidth, windowHandle-&gt;<span class="built_in">getInfo</span>()-&gt;displayHeight);</span><br><span class="line">        inputTargets.<span class="built_in">push_back</span>(inputTarget);</span><br><span class="line">        it = inputTargets.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOG_ASSERT</span>(it-&gt;flags == targetFlags);</span><br><span class="line">    <span class="built_in">ALOG_ASSERT</span>(it-&gt;globalScaleFactor == windowInfo-&gt;globalScaleFactor);</span><br><span class="line">    <span class="comment">// 将pointerIds存入InputTarget, 顺便将transform存入pointerTransforms中，以方便做转换</span></span><br><span class="line">    it-&gt;<span class="built_in">addPointers</span>(pointerIds, windowInfo-&gt;transform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也是比较简单的一个函数，首先使用find_if函数，查找inputTargets中inputChannel的token和传入的窗口token一致的InputTarget，如果不存在就根据传入的窗口信息windowHandle创键新的InputTarget并存入inputTargets队列的末尾。</p>
<h1 id="二-Input事件分发"><a href="#二-Input事件分发" class="headerlink" title="二. Input事件分发"></a>二. Input事件分发</h1><h2 id="2-1-InputDispatcher-dispatchEventLocked"><a href="#2-1-InputDispatcher-dispatchEventLocked" class="headerlink" title="2.1 InputDispatcher.dispatchEventLocked"></a>2.1 InputDispatcher.dispatchEventLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::dispatchEventLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          std::shared_ptr&lt;EventEntry&gt; eventEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 这里通过JNI调用到PowerManagerService, 更新自动灭屏的时间，这样触碰屏幕后自动灭屏就重新开始计时了    </span></span><br><span class="line">    <span class="built_in">pokeUserActivityLocked</span>(*eventEntry);</span><br><span class="line">    <span class="comment">// 依次遍历所有的目标窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> InputTarget&amp; inputTarget : inputTargets) &#123;</span><br><span class="line">        <span class="comment">// [2.1.1] 拿到目标窗口InputChannel对应的Connection</span></span><br><span class="line">        sp&lt;Connection&gt; connection =</span><br><span class="line">                <span class="built_in">getConnectionLocked</span>(inputTarget.inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// [2.2] 准备分发</span></span><br><span class="line">            <span class="built_in">prepareDispatchCycleLocked</span>(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FOCUS) &#123;</span><br><span class="line">                <span class="built_in">ALOGD</span>(<span class="string">&quot;Dropping event delivery to target with channel &#x27;%s&#x27; because it &quot;</span></span><br><span class="line">                      <span class="string">&quot;is no longer registered with the input dispatcher.&quot;</span>,</span><br><span class="line">                      inputTarget.inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-1-InputDispatcher-getConnectionLocked"><a href="#2-1-1-InputDispatcher-getConnectionLocked" class="headerlink" title="2.1.1 InputDispatcher.getConnectionLocked"></a>2.1.1 InputDispatcher.getConnectionLocked</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;Connection&gt; <span class="title">InputDispatcher::getConnectionLocked</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; inputConnectionToken)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputConnectionToken == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, connection] : mConnectionsByToken) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == inputConnectionToken) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入的token就是InputChannel初始化时创建BBinder, 而InputChannel创建完成后会生成Connection存入mConnectionsByToken，这个发生在InputDispatcher::createInputChannel中。</p>
<h2 id="2-2-InputDispatcher-prepareDispatchCycleLocked"><a href="#2-2-InputDispatcher-prepareDispatchCycleLocked" class="headerlink" title="2.2 InputDispatcher.prepareDispatchCycleLocked"></a>2.2 InputDispatcher.prepareDispatchCycleLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::prepareDispatchCycleLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> sp&lt;Connection&gt;&amp; connection,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 std::shared_ptr&lt;EventEntry&gt; eventEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> InputTarget&amp; inputTarget)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将Input事件和对应分发的连接作为一次分发事件存入Input分发队列</span></span><br><span class="line">    <span class="built_in">enqueueDispatchEntriesLocked</span>(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::enqueueDispatchEntriesLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">const</span> sp&lt;Connection&gt;&amp; connection,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   std::shared_ptr&lt;EventEntry&gt; eventEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">const</span> InputTarget&amp; inputTarget)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 判断该连接是否存在input事件待分发</span></span><br><span class="line">    <span class="type">bool</span> wasEmpty = connection-&gt;outboundQueue.<span class="built_in">empty</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">enqueueDispatchEntryLocked</span>(connection, eventEntry, inputTarget,</span><br><span class="line">                            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 如果出站队列之前为空，则启动调度周期</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// [2.3] 启动input事件分发</span></span><br><span class="line">        <span class="built_in">startDispatchCycleLocked</span>(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-InputDispatcher-startDispatchCycleLocked"><a href="#2-3-InputDispatcher-startDispatchCycleLocked" class="headerlink" title="2.3 InputDispatcher.startDispatchCycleLocked"></a>2.3 InputDispatcher.startDispatchCycleLocked</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::startDispatchCycleLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// InputChannel连接正常，将待分发队列里的事件一一分发</span></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 每次都取第一个事件，保证先进先出</span></span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.<span class="built_in">front</span>();</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">const</span> EventEntry&amp; eventEntry = *(dispatchEntry-&gt;eventEntry);</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry.type) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> EventEntry::Type::MOTION: &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// [2.4] 发布input事件，将input事件所有信息都发出去</span></span><br><span class="line">                status = connection-&gt;inputPublisher</span><br><span class="line">                            .<span class="built_in">publishMotionEvent</span>(......);</span><br><span class="line">                ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当InputChannel对应的连接正常，则将待分发队列里的事件一一分发，每次都取outboundQueue中的第一个事件，保证先进先出。</p>
<p>Connection中的InputPublisher就是Connection初始化时创建的InputPublisher。</p>
<h2 id="2-4-InputPublisher-publishMotionEvent"><a href="#2-4-InputPublisher-publishMotionEvent" class="headerlink" title="2.4 InputPublisher.publishMotionEvent"></a>2.4 InputPublisher.publishMotionEvent</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputPublisher::publishMotionEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> seq, <span class="type">int32_t</span> eventId, <span class="type">int32_t</span> deviceId, <span class="type">int32_t</span> source, <span class="type">int32_t</span> displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::array&lt;<span class="type">uint8_t</span>, <span class="number">32</span>&gt; hmac, <span class="type">int32_t</span> action, <span class="type">int32_t</span> actionButton, <span class="type">int32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> edgeFlags, <span class="type">int32_t</span> metaState, <span class="type">int32_t</span> buttonState,</span></span></span><br><span class="line"><span class="params"><span class="function">        MotionClassification classification, <span class="type">const</span> ui::Transform&amp; transform, <span class="type">float</span> xPrecision,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">float</span> yPrecision, <span class="type">float</span> xCursorPosition, <span class="type">float</span> yCursorPosition, <span class="type">int32_t</span> displayWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> displayHeight, <span class="type">nsecs_t</span> downTime, <span class="type">nsecs_t</span> eventTime, <span class="type">uint32_t</span> pointerCount,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> PointerProperties* pointerProperties, <span class="type">const</span> PointerCoords* pointerCoords)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将input事件封装成InputMessage</span></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::Type::MOTION;</span><br><span class="line">    ......</span><br><span class="line">    msg.body.motion.eventTime = eventTime;</span><br><span class="line">    msg.body.motion.pointerCount = pointerCount;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 交给InputChannel将input事件通知给应用进程</span></span><br><span class="line">    <span class="keyword">return</span> mChannel-&gt;<span class="built_in">sendMessage</span>(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将input事件封装成InputMessage, 在交给InputChannel将input事件通知给应用进程.</p>
<h2 id="2-5-InputChannel-sendMessage"><a href="#2-5-InputChannel-sendMessage" class="headerlink" title="2.5 InputChannel.sendMessage"></a>2.5 InputChannel.sendMessage</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputChannel::sendMessage</span><span class="params">(<span class="type">const</span> InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> msgLength = msg-&gt;<span class="built_in">size</span>();</span><br><span class="line">    InputMessage cleanMsg;</span><br><span class="line">    msg-&gt;<span class="built_in">getSanitizedCopy</span>(&amp;cleanMsg);</span><br><span class="line">    <span class="type">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 交给Socket进行通信</span></span><br><span class="line">        nWrite = ::<span class="built_in">send</span>(<span class="built_in">getFd</span>(), &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过InputChannel, 此次的input事件就通知给了目标窗口所在进程。回忆一下，我们应用进程中注册该InputChannel对的Socket文件描述符是在NativeInputEventReceiver中的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputEventReceiver::setFdEvents</span><span class="params">(<span class="type">int</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="type">int</span> fd = mInputConsumer.<span class="built_in">getChannel</span>()-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            <span class="comment">// 将InputChannel中的客户端Socket的文件描述符加入的Looper中监听</span></span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">addFd</span>(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">removeFd</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们应用进程收到该socket文件描述符消息时，会调用NativeInputEventReceiver::handleEvent函数了（Looper机制）。</p>
<h1 id="三-应用进程收到Input事件"><a href="#三-应用进程收到Input事件" class="headerlink" title="三. 应用进程收到Input事件"></a>三. 应用进程收到Input事件</h1><h2 id="3-1-NativeInputEventReceiver-handleEvent"><a href="#3-1-NativeInputEventReceiver-handleEvent" class="headerlink" title="3.1 NativeInputEventReceiver.handleEvent"></a>3.1 NativeInputEventReceiver.handleEvent</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NativeInputEventReceiver::handleEvent</span><span class="params">(<span class="type">int</span> receiveFd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line">        <span class="comment">// [3.2] 消费此次input事件</span></span><br><span class="line">        <span class="type">status_t</span> status = <span class="built_in">consumeEvents</span>(env, <span class="literal">false</span> <span class="comment">/*consumeBatches*/</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;handleReceiveCallback&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status == OK || status == NO_MEMORY ? KEEP_CALLBACK : REMOVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-NativeInputEventReceiver-consumeEvents"><a href="#3-2-NativeInputEventReceiver-consumeEvents" class="headerlink" title="3.2 NativeInputEventReceiver.consumeEvents"></a>3.2 NativeInputEventReceiver.consumeEvents</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputEventReceiver::consumeEvents</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> consumeBatches, <span class="type">nsecs_t</span> frameTime, <span class="type">bool</span>* outConsumedBatch)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        <span class="comment">// [3.3] 将接收到的数据封装成InputEvent</span></span><br><span class="line">        <span class="type">status_t</span> status = mInputConsumer.<span class="built_in">consume</span>(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!skipCallbacks) &#123;</span><br><span class="line">            ......</span><br><span class="line">            jobject inputEventObj;</span><br><span class="line">            <span class="keyword">switch</span> (inputEvent-&gt;<span class="built_in">getType</span>()) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">case</span> AINPUT_EVENT_TYPE_MOTION: &#123;</span><br><span class="line">                    MotionEvent* motionEvent = <span class="built_in">static_cast</span>&lt;MotionEvent*&gt;(inputEvent);</span><br><span class="line">                    <span class="keyword">if</span> ((motionEvent-&gt;<span class="built_in">getAction</span>() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;</span><br><span class="line">                        *outConsumedBatch = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 通过JNI创建java层的MotionEvent对象</span></span><br><span class="line">                    inputEventObj = <span class="built_in">android_view_MotionEvent_obtainAsCopy</span>(env, motionEvent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;        </span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">                <span class="comment">// [3.4] 通过JNI调用dispatchInputEvent将Input事件分发给应用java层的View</span></span><br><span class="line">                env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 此次Input事件使用之后就回收</span></span><br><span class="line">                env-&gt;<span class="built_in">DeleteLocalRef</span>(inputEventObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumeEvents就是接收socket数据，将input事件封装成对应类型的对象，如触摸事件对应MotionEvent，按键事件对应KeyEvent. 然后通过JNI创建对应java层的input事件对象，最后调用InputEventReceiver.dispatchInputEvent将Input事件分发给应用java层的View。</p>
<h2 id="3-3-InputConsumer-consume"><a href="#3-3-InputConsumer-consume" class="headerlink" title="3.3 InputConsumer.consume"></a>3.3 InputConsumer.consume</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputConsumer::consume</span><span class="params">(InputEventFactoryInterface* factory, <span class="type">bool</span> consumeBatches,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">nsecs_t</span> frameTime, <span class="type">uint32_t</span>* outSeq, InputEvent** outEvent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    *outSeq = <span class="number">0</span>;</span><br><span class="line">    *outEvent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!*outEvent) &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="comment">// [3.3.1] 通过recv函数接收Socket数据</span></span><br><span class="line">            <span class="type">status_t</span> result = mChannel-&gt;<span class="built_in">receiveMessage</span>(&amp;mMsg);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">switch</span> (mMsg.header.type) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> InputMessage::Type::MOTION: &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 创建MotionEvent</span></span><br><span class="line">                MotionEvent* motionEvent = factory-&gt;<span class="built_in">createMotionEvent</span>();</span><br><span class="line">                <span class="keyword">if</span> (!motionEvent) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">                <span class="comment">// 更新触摸状态信息</span></span><br><span class="line">                <span class="built_in">updateTouchState</span>(mMsg);</span><br><span class="line">                <span class="comment">// 使用收到的InputMessage填充创建的MotionEvent</span></span><br><span class="line">                <span class="built_in">initializeMotionEvent</span>(motionEvent, &amp;mMsg);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先在InputChannel中通过recv函数接收来自Input系统的Socket数据(InputMessage), 然后根据input类型分别封装成对应的input事件，比如MotionEvent、KeyEvent等。</p>
<h3 id="3-3-1-InputChannel-receiveMessage"><a href="#3-3-1-InputChannel-receiveMessage" class="headerlink" title="3.3.1 InputChannel.receiveMessage"></a>3.3.1 InputChannel.receiveMessage</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputChannel::receiveMessage</span><span class="params">(InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 通过recv函数接收Socket数据</span></span><br><span class="line">        nRead = ::<span class="built_in">recv</span>(<span class="built_in">getFd</span>(), msg, <span class="built_in">sizeof</span>(InputMessage), MSG_DONTWAIT);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过recv函数接收Socket数据, 还原成InputMessage.</p>
<h2 id="3-4-WindowInputEventReceiver-dispatchInputEvent"><a href="#3-4-WindowInputEventReceiver-dispatchInputEvent" class="headerlink" title="3.4 WindowInputEventReceiver.dispatchInputEvent"></a>3.4 WindowInputEventReceiver.dispatchInputEvent</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchInputEvent</span><span class="params">(<span class="type">int</span> seq, InputEvent event)</span> &#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里JNI注册的InputEventReceiver其实是ViewRootImpl中的WindowInputEventReceiver, 所以onInputEvent其实是调用了被Override的子类函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WindowInputEventReceiver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInputEvent</span><span class="params">(InputEvent event)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        enqueueInputEvent(event, <span class="built_in">this</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面将事件分发给对应的View组件的过程，其实也不难猜测，因为View是树形结构，只需要前序遍历该树找到input事件坐标所在的最叶子节点的View，如果该View消耗了此次事件，也就是设置了对应的Listener并实现了接口返回true, 那么该事件就不继续分发了。否则沿着树形结构依次遍历父View，看是否需要使用该事件。</p>
<p>到这里，Input和窗口的关系分析就告一段落了。接下来分析窗口对应的View和SurfaceFlinger通信过程。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>WMS</category>
        <category>Input</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>WMS</tag>
        <tag>Input</tag>
      </tags>
  </entry>
</search>
