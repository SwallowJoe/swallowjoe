<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vulkan入门(1)-环境配置</title>
    <url>/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是介绍如何在 ubuntu 机器上安装并编译Vulkan程序。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://vulkan.lunarg.com/doc/sdk/1.2.170.0/linux/getting_started.html">https://vulkan.lunarg.com/doc/sdk/1.2.170.0/linux/getting_started.html</a></li>
<li><a href="https://github.com/google/glog">https://github.com/google/glog</a></li>
<li>[pkg-config的用法]<a href="https://www.cnblogs.com/chris-cp/p/3580002.html">https://www.cnblogs.com/chris-cp/p/3580002.html</a></li>
<li>[解决&#x2F;usr&#x2F;local&#x2F;lib&#x2F;libglog.so.0: error adding symbols: DSO missing from command line]<a href="https://blog.csdn.net/u010987458/article/details/72235408">https://blog.csdn.net/u010987458/article/details/72235408</a></li>
<li><a href="https://www.glfw.org/docs/3.3/build_guide.html#build_link_cmake_package">https://www.glfw.org/docs/3.3/build_guide.html#build_link_cmake_package</a></li>
<li>[GLFW]<a href="https://www.glfw.org/">https://www.glfw.org/</a></li>
<li>[GLM]<a href="https://github.com/g-truc/glm">https://github.com/g-truc/glm</a></li>
</ol>
<h1 id="一-准备环境"><a href="#一-准备环境" class="headerlink" title="一. 准备环境"></a>一. 准备环境</h1><h2 id="1-1-开发环境"><a href="#1-1-开发环境" class="headerlink" title="1.1 开发环境"></a>1.1 开发环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get dist-upgrade</span><br><span class="line">sudo apt-get install libglm-dev cmake libxcb-dri3-0 libxcb-present0 libpciaccess0 libpng-dev libxcb-keysyms1-dev libxcb-dri3-dev libx11-dev  libmirclient-dev libwayland-dev libxrandr-dev libxcb-ewmh-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install git libpython2.7</span><br></pre></td></tr></table></figure>

<h2 id="1-2-下载-SDK"><a href="#1-2-下载-SDK" class="headerlink" title="1.2 下载 SDK"></a>1.2 下载 SDK</h2><p>官方网站：<a href="https://vulkan.lunarg.com/">https://vulkan.lunarg.com/</a> 下载SDK包：vulkan-sdk.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/Program</span><br><span class="line">mkdir vulkan</span><br><span class="line">cd vulkan</span><br><span class="line">tar zxf $HOME/Downloads/vulkan-sdk.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压后的文件目录如下：</p>
<table>
<thead>
<tr>
<th>文件夹</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x86_64&#x2F;bin</td>
<td>Vulkan工具和命令</td>
</tr>
<tr>
<td>x86_64&#x2F;include&#x2F;vulkan</td>
<td>编译链接头文件</td>
</tr>
<tr>
<td>x86_64&#x2F;lib</td>
<td>Vulkan加载程序库和layer运行时库</td>
</tr>
<tr>
<td>x86_64&#x2F;etc&#x2F;explicit_layer.d</td>
<td>.json 用于Vulkan验证层的清单文件</td>
</tr>
<tr>
<td>config</td>
<td>样本层设置文件，系统配置说明</td>
</tr>
<tr>
<td>doc</td>
<td>Khronos SPIRV，Vulkan，Loader和WSI规范</td>
</tr>
<tr>
<td>examples</td>
<td>Vulkan程序示例</td>
</tr>
<tr>
<td>samples</td>
<td>Vulkan的示例代码</td>
</tr>
<tr>
<td>source</td>
<td>glslang和所选Vulkan组件的源和调试库</td>
</tr>
</tbody></table>
<h2 id="1-3-安装SDK"><a href="#1-3-安装SDK" class="headerlink" title="1.3 安装SDK"></a>1.3 安装SDK</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/Program/vulkan/1.2.170.0/setup-env.sh</span><br><span class="line"></span><br><span class="line">export VULKAN_SDK=~/vulkan/1.2.170.0/x86_64</span><br><span class="line">export PATH=$VULKAN_SDK/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$VULKAN_SDK/lib:$LD_LIBRARY_PATH</span><br><span class="line">export VK_LAYER_PATH=$VULKAN_SDK/etc/explicit_layer.d</span><br></pre></td></tr></table></figure>

<p>大功告成，检查一下：输入vulkaninfo<br><a href="mailto:&#117;&#98;&#117;&#x6e;&#116;&#117;&#64;&#49;&#56;&#x2e;&#48;&#x34;&#x4c;">&#117;&#98;&#117;&#x6e;&#116;&#117;&#64;&#49;&#56;&#x2e;&#48;&#x34;&#x4c;</a> ~  vulkaninfo<br>Cannot create Vulkan instance.<br>&#x2F;home&#x2F;lunarg&#x2F;sdk-build&#x2F;Vulkan-Tools&#x2F;vulkaninfo&#x2F;vulkaninfo.c:921: failed with VK_ERROR_INCOMPATIBLE_DRIVER</p>
<p>wtf, 发生了什么？等等，貌似我们没有检查是否安装了驱动。。。</p>
<h2 id="1-4-安装驱动"><a href="#1-4-安装驱动" class="headerlink" title="1.4 安装驱动"></a>1.4 安装驱动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:oibaf/graphics-drivers</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br><span class="line">apt install libvulkan1 mesa-vulkan-drivers vulkan-utils</span><br><span class="line"></span><br><span class="line">// 或者试试：</span><br><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install nvidia-graphics-drivers-396 nvidia-settings vulkan vulkan-utils</span><br></pre></td></tr></table></figure>
<p>检查一下：输入vulkaninfo</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_1.png" alt="图片"></p>
<p>或者：vulkaninfo –html , 在当前目录生成 vulkaninfo.html 文件，用浏览器打开，可以看到更多信息</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_2.png" alt="图片"></p>
<h2 id="1-5-运行示例程序"><a href="#1-5-运行示例程序" class="headerlink" title="1.5. 运行示例程序"></a>1.5. 运行示例程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Program/vulkan/1.1.160.0/examples</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>make成功后会在当前目录生成：</p>
<p><img src="/./images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_3.png" alt="图片"></p>
<p>运行示例程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./vkcube</span><br></pre></td></tr></table></figure>

<p><img src="/./images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_4.png" alt="图片"></p>
<p>一个旋转的立方体～</p>
<h1 id="二-GLFW-安装"><a href="#二-GLFW-安装" class="headerlink" title="二. GLFW 安装"></a>二. GLFW 安装</h1><p>Vulkan本身是一个与平台无关的API，不包括用于创建显示渲染结果的窗口的工具。 为了从Vulkan的跨平台优势中受益并避免X11的限制，我们将使用GLFW库来创建一个支持Windows，Linux和MacOS的窗口。<br>还有其他可用于此目的的库，如SDL，但GLFW的优势在于它除了窗口创建之外，还抽象了Vulkan中一些其他特定于平台的东西。<br>我们将从源代码安装GLFW而不是使用软件包，因为Vulkan支持需要最新版本。 可以在官方网站上找到这些来源。<br>将源代码解压缩到一个方便的目录，并使用CMakeLists.txt等文件打开目录中的终端。</p>
<p>github地址：<a href="https://github.com/glfw/glfw">https://github.com/glfw/glfw</a><br>解压后进入其主目录：cmake .<br>有报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- Looking <span class="keyword">for</span> shmat - found</span><br><span class="line">-- Found X11: /usr/lib/x86_64-linux-gnu/libX11.so</span><br><span class="line">CMake Error at CMakeLists.txt:<span class="number">220</span> (message):</span><br><span class="line">  The Xinerama headers were not found</span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also <span class="string">&quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeOutput.log&quot;</span>.</span><br><span class="line">See also <span class="string">&quot;/home/jh/Program/vulkan/glfw-master/CMakeFiles/CMakeError.log&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>缺少环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ~/Program/vulkan/glfw-master  sudo apt-get install libsdl2-dev</span><br></pre></td></tr></table></figure>

<p>然后重新: cmake .</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">🦄  ~/Program/vulkan/glfw-master  cmake .</span><br><span class="line">-- Could NOT find <span class="title function_">Doxygen</span> <span class="params">(missing: DOXYGEN_EXECUTABLE)</span> </span><br><span class="line">-- Using X11 <span class="keyword">for</span> window creation</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/jh/Program/vulkan/glfw-master</span><br></pre></td></tr></table></figure>
<p>濡染没有报错，但这个也是没有成功的：缺少Doxygen<br>sudo apt-get install doxygen</p>
<p>重新: cmake .<br>最后: make<br>成功后：sudo make install</p>
<h1 id="三-GLM-安装"><a href="#三-GLM-安装" class="headerlink" title="三. GLM 安装"></a>三. GLM 安装</h1><p>与DirectX 12不同，Vulkan不包含用于线性代数运算的库，因此我们必须下载一个。<br>GLM是一个很好的库，设计用于图形API，也常用于OpenGL。<br>它是一个只有头的库，可以从libglm-dev包安装：</p>
<p>sudo apt install libglm-dev</p>
<h1 id="四-手动编译示例代码"><a href="#四-手动编译示例代码" class="headerlink" title="四. 手动编译示例代码"></a>四. 手动编译示例代码</h1><h2 id="4-1-在编译示例代码的时候老是报错，找不到vulkan头文件。"><a href="#4-1-在编译示例代码的时候老是报错，找不到vulkan头文件。" class="headerlink" title="4.1 在编译示例代码的时候老是报错，找不到vulkan头文件。"></a>4.1 在编译示例代码的时候老是报错，找不到vulkan头文件。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o main main.cpp -lglfw3</span><br><span class="line">In file included from main.cpp:2:</span><br><span class="line">/usr/local/include/GLFW/glfw3.h:215:12: fatal error: vulkan/vulkan.h: 没有那个文件或目录</span><br><span class="line">   #include &lt;vulkan/vulkan.h&gt;</span><br><span class="line">            ^~~~~~~~~~~~~~~~~</span><br><span class="line">compilation terminated.</span><br></pre></td></tr></table></figure>

<p>当然是环境设置的问题：需要将头文件等拷贝到对应system文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Program/vulkan/1.2.170.0/x86_64</span><br><span class="line">sudo cp -r include/vulkan/ /usr/local/include/</span><br><span class="line">sudo cp -P lib/libvulkan.so* /usr/local/lib/</span><br><span class="line">sudo cp lib/libVkLayer_*.so /usr/local/lib/</span><br><span class="line">sudo mkdir -p /usr/local/share/vulkan/explicit_layer.d</span><br><span class="line">sudo cp etc/explicit_layer.d/VkLayer_*.json /usr/local/share/vulkan/explicit_layer.d    </span><br><span class="line"></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<h2 id="4-2-error-adding-symbols-DSO-missing-from-command-line"><a href="#4-2-error-adding-symbols-DSO-missing-from-command-line" class="headerlink" title="4.2 error adding symbols: DSO missing from command line"></a>4.2 error adding symbols: DSO missing from command line</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">g++ -std=c++17 -I/home/jh/Program/vulkan/1.1.160.0/x86_64/include -o VulkanTest main.cpp -L/home/jh/Program/vulkan/1.1.160.0/x86_64/lib -lvulkan -lglfw3</span><br><span class="line">/usr/bin/ld: //usr/local/lib/libglfw3.a(vulkan.c.o): undefined reference to symbol &#x27;dlclose@@GLIBC_2.2.5&#x27;</span><br><span class="line">/usr/bin/ld: //lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command line</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">make: *** [Makefile:8：VulkanTest] 错误 1</span><br></pre></td></tr></table></figure>

<p>cd &#x2F;usr&#x2F;lib&#x2F;<br>ll |grep -iE “liblog”<br>没有文件</p>
<p><a href="https://github.com/google/glog">https://github.com/google/glog</a><br>下载解压, 进入解压后的主目录，执行：<br>.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install</p>
<p>如果报错：autogen.sh: 5: autogen.sh: autoreconf: not found<br>sudo apt-get install autoconf<br>sudo apt-get install automake<br>sudo apt-get install libtool</p>
<p>重新执行：.&#x2F;autogen.sh &amp;&amp; .&#x2F;configure &amp;&amp; make &amp;&amp; make install<br>可能还有权限问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- Up-to-date: /usr/local/include/GLFW</span><br><span class="line">CMake Error at cmake_install.cmake:41 (file):</span><br><span class="line">  file INSTALL cannot set permissions on &quot;/usr/local/include/GLFW&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">make: *** [Makefile:118：install] 错误 1</span><br></pre></td></tr></table></figure>
<p>执行：<br>cd ..<br>chmod a+x glog-master -R<br>cd glog-master<br>make &amp;&amp; make install</p>
<p>okay,现在可以在Makefile文件中添加：-lglog</p>
<p>重新 make 还是会存在这个问题，笔者查阅各种资料，大部分指明在Makefile中加入 -ldl 即可，尝试后失败。<br>最后发现是 Makefile 文件写的有问题，改成如[#5.2]即可.</p>
<h2 id="4-3-运行示例"><a href="#4-3-运行示例" class="headerlink" title="4.3 运行示例"></a>4.3 运行示例</h2><p>make 成功后，会在当前目录生成 VulkanTest 可执行文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./VulkanTest</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="/./images/Vulkan%E5%85%A5%E9%97%A8-1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Vulkan_1_5.png" alt="图片"></p>
<h1 id="五-主要代码"><a href="#五-主要代码" class="headerlink" title="五. 主要代码"></a>五. 主要代码</h1><h2 id="5-1-main-cpp"><a href="#5-1-main-cpp" class="headerlink" title="5.1 main.cpp"></a>5.1 main.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_RADIANS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_DEPTH_ZERO_TO_ONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/vec4.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/mat4x4.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Vulkan window&quot;</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> extensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; extensionCount &lt;&lt; <span class="string">&quot; extensions supported&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    glm::mat4 matrix;</span><br><span class="line">    glm::vec4 vec;</span><br><span class="line">    <span class="keyword">auto</span> test = matrix * vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-Makefile"><a href="#5-2-Makefile" class="headerlink" title="5.2 Makefile"></a>5.2 Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64</span><br><span class="line"></span><br><span class="line">CFLAGS = -std=c++17 -I<span class="variable">$(VULKAN_SDK_PATH)</span>/<span class="keyword">include</span></span><br><span class="line">LDFLAGS = -L<span class="variable">$(VULKAN_SDK_PATH)</span>/lib -lvulkan `pkg-config --static --libs glfw3`</span><br><span class="line">LDFLAGS += -ldl</span><br><span class="line"></span><br><span class="line"><span class="section">VulkanTest: main.cpp</span></span><br><span class="line">	g++ <span class="variable">$(CFLAGS)</span> -o VulkanTest main.cpp <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: VulkanTest</span></span><br><span class="line">    LD_LIBRARY_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/lib</span><br><span class="line">        VK_LAYER_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/etc/explicit_layer.d ./VulkanTest</span><br><span class="line"></span><br><span class="line"><span class="section">clean:rm -f VulkanTest</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图像引擎</category>
      </categories>
      <tags>
        <tag>Vulkan</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan入门(2)-创建Vulkan示例及验证层</title>
    <url>/2022/02/26/Vulkan%E5%85%A5%E9%97%A8-2-%E5%88%9B%E5%BB%BAVulkan%E7%A4%BA%E4%BE%8B%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%B1%82/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文主要是实现Vulkan Tutorial.pdf文档中的Base Code, Instance和Validation Layers部分。</p>
<span id="more"></span>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://github.com/KhronosGroup/Vulkan-Docs">https://github.com/KhronosGroup/Vulkan-Docs</a></li>
<li><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateInstance">https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#vkCreateInstance</a></li>
<li><a href="https://github.com/SaschaWillems/Vulkan/blob/master/base/vulkanexamplebase.h">https://github.com/SaschaWillems/Vulkan/blob/master/base/vulkanexamplebase.h</a></li>
</ol>
<h1 id="一-创建-vulkan-实例"><a href="#一-创建-vulkan-实例" class="headerlink" title="一. 创建 vulkan 实例"></a>一. 创建 vulkan 实例</h1><h2 id="1-1-创建-Window-实例"><a href="#1-1-创建-Window-实例" class="headerlink" title="1.1 创建 Window 实例"></a>1.1 创建 Window 实例</h2><p>先创建个 window 窗口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步一定是先初始化GLFW库.</span></span><br><span class="line">    <span class="built_in">glfwInit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为GLFW最初是为创建OpenGL上下文而设计的，</span></span><br><span class="line">    <span class="comment">// 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变</span></span><br><span class="line">    <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GLFW_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    <span class="comment">// GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)</span></span><br><span class="line">    window = <span class="built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, WINDOW_TITLE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-创建-Vulkan-实例"><a href="#1-2-创建-Vulkan-实例" class="headerlink" title="1.2 创建 Vulkan 实例"></a>1.2 创建 Vulkan 实例</h2><ol>
<li>创建 VkApplicationInfo 结构体变量，参数可选</li>
<li>创建 VkInstanceCreateInfo 结构体变量，必须指明<ol>
<li>使用 GLFW (glfwGetRequiredInstanceExtensions) 创建 glfwExtensions, 以便为GLFW窗口创建Vulkan surface</li>
</ol>
</li>
<li>调用 vkCreateInstance, 创建 vulkan 实例</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo</span></span><br><span class="line">    <span class="comment">// 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化</span></span><br><span class="line">    VkApplicationInfo appInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vulkan中的许多结构要求在sType成员中明确指定类型。 </span></span><br><span class="line">    <span class="comment">// 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。</span></span><br><span class="line">    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;</span><br><span class="line"></span><br><span class="line">    appInfo.pApplicationName = <span class="string">&quot;Hello Triangle&quot;</span>;</span><br><span class="line">    appInfo.applicationVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    appInfo.pEngineName = <span class="string">&quot;No Engine&quot;</span>;</span><br><span class="line">    appInfo.engineVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    appInfo.apiVersion = VK_API_VERSION_1_1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Vulkan中的很多信息都是通过结构而不是函数参数传递的，</span></span><br><span class="line">    <span class="comment">// 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。</span></span><br><span class="line">    <span class="comment">// VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 </span></span><br><span class="line">    VkInstanceCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span><br><span class="line">    createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    createInfo.pApplicationInfo = &amp;appInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前两个参数很简单。 </span></span><br><span class="line">    <span class="comment">// Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。</span></span><br><span class="line">    <span class="comment">// GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo</span></span><br><span class="line">    <span class="type">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** glfwExtensions;</span><br><span class="line">    <span class="comment">// 返回GLFW所需的Vulkan实例扩展。</span></span><br><span class="line">    <span class="comment">// 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 </span></span><br><span class="line">    <span class="comment">// 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。</span></span><br><span class="line">    <span class="comment">// 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。</span></span><br><span class="line">    glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">    createInfo.enabledExtensionCount = glfwExtensionCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// createInfo.ppEnabledLayerNames = glfwExtensions;</span></span><br><span class="line">    <span class="comment">// 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped)</span></span><br><span class="line">    <span class="comment">// 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。</span></span><br><span class="line">    createInfo.ppEnabledExtensionNames = glfwExtensions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体的最后两个成员确定要启用的全局验证层。</span></span><br><span class="line">    createInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)</span></span><br><span class="line">    VkResult res = <span class="built_in">vkCreateInstance</span>(&amp;createInfo, <span class="literal">nullptr</span>, &amp;instance);</span><br><span class="line">    <span class="keyword">if</span> (res != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create instance!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二-验证层-Validation-layers"><a href="#二-验证层-Validation-layers" class="headerlink" title="二. 验证层(Validation layers)"></a>二. 验证层(Validation layers)</h1><h2 id="2-1-什么是-Validation-layers？"><a href="#2-1-什么是-Validation-layers？" class="headerlink" title="2.1 什么是 Validation layers？"></a>2.1 什么是 Validation layers？</h2><p>Vulkan API围绕最小驱动程序开销的想法而设计，该目标的一个表现形式是默认情况下API中的错误检查非常有限。<br>即使是将枚举设置为不正确的值或将空指针传递给所需参数这样简单的错误通常也不会被显式处理，只会导致崩溃或未定义的行为。<br>这一点，笔者已经深刻体会到了，(╯﹏╰)<br>因为Vulkan要求你对你所做的一切都非常明确，所以很容易犯很多小错误，例如使用新的GPU功能而忘记在逻辑设备创建时请求它。</p>
<p>但是，这并不意味着无法将这些检查添加到API中。<br>Vulkan为这种称为验证层的系统引入了一个优雅的系统: Validation layers.<br>验证层是可选组件，它挂接到Vulkan函数调用以应用其他操作。 </p>
<p>验证层中的常见操作是：</p>
<ol>
<li>根据规范检查参数值以检测误用</li>
<li>跟踪对象的创建和销毁以查找资源泄漏</li>
<li>通过跟踪调用的线程来检查线程安全性</li>
<li>将每个调用及其参数记录到标准输出方便调试</li>
<li>跟踪Vulkan要求进行性能分析和重放</li>
</ol>
<h2 id="2-2-Validation-layers示例"><a href="#2-2-Validation-layers示例" class="headerlink" title="2.2 Validation layers示例"></a>2.2 Validation layers示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkInstanceCreateInfo* pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks* pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkInstance* instance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCreateInfo == <span class="literal">nullptr</span> || instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;Null pointer passed to required parameter!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> VK_ERROR_INITIALIZATION_FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">real_vkCreateInstance</span>(pCreateInfo, pAllocator, instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面的vkCreateInstance中的if语句。官方文档上如此说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这些验证层可以自由堆叠，以包含您感兴趣的所有调试功能。</span><br><span class="line">您可以简单地为调试版本启用验证层，并为发布版本完全禁用它们，这将为您提供两全其美的优势！</span><br><span class="line">Vulkan没有内置任何验证层，但LunarG Vulkan SDK提供了一组很好的层来检查常见错误。</span><br><span class="line">它们也是完全开源的，因此您可以检查它们检查和贡献的错误类型。</span><br><span class="line">使用验证层是避免应用程序因意外依赖未定义行为而破坏不同驱动程序的最佳方法。</span><br><span class="line">验证层只有在已安装到系统上时才能使用。</span><br><span class="line">例如，LunarG验证层仅适用于安装了Vulkan SDK的PC。</span><br><span class="line">Vulkan中以前有两种不同类型的验证层：实例和设备特定。</span><br><span class="line">我们的想法是，实例层只会检查与全局Vulkan对象（如实例）相关的调用，而设备特定层只会检查与特定GPU相关的调用。</span><br><span class="line">现在已弃用特定于设备的层，这意味着实例验证层适用于所有Vulkan调用。</span><br><span class="line">规范文档仍建议您在设备级别启用验证层以及兼容性，这是某些实现所需的。</span><br></pre></td></tr></table></figure>

<h2 id="2-3-启用验证层"><a href="#2-3-启用验证层" class="headerlink" title="2.3 启用验证层"></a>2.3 启用验证层</h2><p>如何启用Vulkan SDK提供的标准诊断层? 就像扩展一样，需要通过指定其名称来启用验证层。<br>所有有用的标准验证都捆绑在SDK中包含的层中，称为VK_LAYER_KHRONOS_validation。<br>让我们首先向程序添加两个配置变量，以指定要启用的层以及是否启用它们。 我已经选择将该值作为程序是否在调试模式下编译。<br>NDEBUG宏是C ++标准的一部分，意味着“不调试”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; validationLayers = &#123;</span><br><span class="line">    <span class="string">&quot;VK_LAYER_KHRONOS_validation&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-消息回调"><a href="#2-4-消息回调" class="headerlink" title="2.4 消息回调"></a>2.4 消息回调</h2><p>仅启用这些层并没有多大帮助，因为它们目前无法将调试消息中继回我们的程序。<br>要接收这些消息，我们必须设置一个带回调的调试信使，这需要VK_EXT_debug_utils扩展。<br>我们将首先创建一个getRequiredExtensions函数，根据是否启用验证层返回所需的扩展名列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">getRequiredExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>** glfwExtensions;</span><br><span class="line">    glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">extensions</span><span class="params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">        extensions.<span class="built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> extensions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GLFW指定的扩展始终是必需的，但有条件地添加了调试信使扩展(VK_EXT_debug_utils)。<br>请注意，在这里使用了VK_EXT_DEBUG_UTILS_EXTENSION_NAME宏，它等于文字字符串“VK_EXT_debug_utils”。 使用此宏可以避免拼写错误。<br>我们现在可以在createInstance中使用此函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> extensions = <span class="built_in">getRequiredExtensions</span>();</span><br><span class="line">createInfo.enabledExtensionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(extensions.<span class="built_in">size</span>());</span><br><span class="line">createInfo.ppEnabledExtensionNames = extensions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-调试回调函数-debugCallback"><a href="#2-4-1-调试回调函数-debugCallback" class="headerlink" title="2.4.1 调试回调函数 debugCallback"></a>2.4.1 调试回调函数 debugCallback</h3><p>现在让我们看一下调试回调函数的样子。<br>使用PFN_vkDebugUtilsMessengerCallbackEXT原型添加一个名为debugCallback的新静态成员函数。<br>VKAPI_ATTR和VKAPI_CALL确保该函数具有Vulkan调用它的正确签名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="title">debugCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* pUserData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VK_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个参数: VkDebugUtilsMessageSeverityFlagBitsEXT 指明了消息的严重程度<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT：诊断消息<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT：信息性消息，如创建资源<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT：有关行为的消息不一定是错误，但很可能是应用程序中的错误<br>•VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT：有关无效行为的消息，可能导致崩溃<br>可以根据这个参数过滤所需的信息。</li>
<li>第二个参数: VkDebugUtilsMessageTypeFlagsEXT 指明了消息的类型<br>•VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT：发生了与规范或性能无关的某些事件<br>•VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT：发生了违反规范或表明可能存在错误的事情<br>•VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT：潜在的非最佳使用Vulkan</li>
<li>第三个参数: VkDebugUtilsMessengerCallbackDataEXT 这个结构体包含了消息更多的细节内容<br>•pMessage：调试消息为以空字符结尾的字符串<br>•pObjects：与消息相关的Vulkan对象句柄数组<br>•object Count：数组中的对象数</li>
<li>第四个参数: pUserData 包含在回调设置期间指定的指针，并允许您将自己的数据传递给它。</li>
</ol>
<p>回调返回一个布尔值，指示是否应该中止触发验证层消息的Vulkan调用。<br>如果回调返回true，则调用将因VK_ERROR_VALIDATION_FAILED_EXT错误而中止。<br>这通常仅用于测试验证层本身，因此应始终返回VK_FALSE。</p>
<h3 id="2-4-2-注册调试回调"><a href="#2-4-2-注册调试回调" class="headerlink" title="2.4.2 注册调试回调"></a>2.4.2 注册调试回调</h3><p>在Vulkan中, 调试回调也是通过需要显式创建和销毁的句柄来管理的。 这样的回调是debug message的一部分，可以根据需要设置尽可能多的回调。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在成员变量中添加：VkDebugUtilsMessengerEXT</span></span><br><span class="line">VkDebugUtilsMessengerEXT debugMessenger;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">createInstance</span>();</span><br><span class="line">    <span class="built_in">setupDebugMessenger</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupDebugMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableValidationLayers) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;</span><br><span class="line">    createInfo.messageSeverity =</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;</span><br><span class="line">    createInfo.messageType =</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |</span><br><span class="line">        VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;</span><br><span class="line">    <span class="comment">// 指定消息回调函数</span></span><br><span class="line">    createInfo.pfnUserCallback = debugCallback;</span><br><span class="line">    createInfo.pUserData = <span class="literal">nullptr</span>; <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>messageSeverity字段允许指定要为其调用回调的所有类型的严重性。<br>在这里指定了除VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT之外的所有类型，以接收有关可能问题的通知，同时省略详细的一般调试信息。<br>类似地，messageType字段可以过滤通知回调的消息类型。 在这里启用了所有类型。<br>最后，pfnUserCallback字段指定回调函数的指针。可以选择将指针传递给pUserData字段，该字段将通过pUserData参数传递给回调函数。<br>例如，可以使用它来传递指向HelloTriangleApplication类的指针。</p>
<p>应该将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。<br>然而因为这个function是一个扩展函数，它不会自动加载。<br>必须使用vkGetInstanceProcAddr查找其地址。 创建代理函数，然后在处理它，如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">CreateDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*</span></span></span><br><span class="line"><span class="params"><span class="function">    pDebugMessenger)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT)</span><br><span class="line">    <span class="built_in">vkGetInstanceProcAddr</span>(instance,<span class="string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以在 setupDebugMessenger 中调用此函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setupDebugMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableValidationLayers) <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 实例化DebugUtilsMessengerEXT</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="literal">nullptr</span>,</span><br><span class="line">        &amp;debugMessenger) != VK_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to set up debug messenger!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后注意，既然有 vkCreateXXX, 就需要显示调用 vkDestroyXXX 哦！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDebugUtilsMessengerEXT debugMessenger, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    VkAllocationCallbacks* pAllocator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT)</span><br><span class="line">    <span class="built_in">vkGetInstanceProcAddr</span>(instance, <span class="string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">func</span>(instance, debugMessenger, pAllocator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你忘了调用DestroyDebugUtilsMessengerEXT去销毁debugMessenger，在关闭窗口的时候就会打印如下信息:</p>
<p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-2-%E5%88%9B%E5%BB%BAVulkan%E7%A4%BA%E4%BE%8B%E5%8F%8A%E9%AA%8C%E8%AF%81%E5%B1%82/Vulkan_2_1.png" alt="图片"></p>
<h1 id="三-代码"><a href="#三-代码" class="headerlink" title="三. 代码"></a>三. 代码</h1><h2 id="3-1-Makefile"><a href="#3-1-Makefile" class="headerlink" title="3.1 Makefile"></a>3.1 Makefile</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.1.160.0/x86_64</span><br><span class="line"></span><br><span class="line">CFLAGS = -std=c++17 -I<span class="variable">$(VULKAN_SDK_PATH)</span>/<span class="keyword">include</span></span><br><span class="line">LDFLAGS = -L<span class="variable">$(VULKAN_SDK_PATH)</span>/lib -lvulkan `pkg-config --static --libs glfw3`</span><br><span class="line">LDFLAGS += -ldl</span><br><span class="line"></span><br><span class="line"><span class="section">HelloTriangleApplication: main.cpp</span></span><br><span class="line">	g++ <span class="variable">$(CFLAGS)</span> -o HelloTriangleApplication main.cpp <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: test clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">test: HelloTriangleApplication</span></span><br><span class="line">    LD_LIBRARY_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/lib</span><br><span class="line">        VK_LAYER_PATH=<span class="variable">$(VULKAN_SDK_PATH)</span>/etc/explicit_layer.d ./HelloTriangleApplication</span><br><span class="line"></span><br><span class="line"><span class="section">clean:rm -f HelloTriangleApplication</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-main-cpp"><a href="#3-2-main-cpp" class="headerlink" title="3.2 main.cpp"></a>3.2 main.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * #include &lt;vulkan/vulkan.h&gt; // vulkan 头文件</span></span><br><span class="line"><span class="comment"> * 使用下面两行替换 vulkan头文件</span></span><br><span class="line"><span class="comment"> *   #define GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="comment"> *   #include &lt;GLFW/glfw3.h&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  GLFW 会自动加载 vulkan 头文件的。</span></span><br><span class="line"><span class="comment"> * GLFW是一个开源，多平台的库，用于桌面上的OpenGL，OpenGL ES和Vulkan开发。 </span></span><br><span class="line"><span class="comment"> * 它提供了一个简单的API，用于创建窗口，上下文和曲面，接收输入和事件。</span></span><br><span class="line"><span class="comment"> * GLFW是用C语言编写的，并且使用X Window系统（例如Linux和FreeBSD）对Windows，macOS和许多类Unix系统提供原生支持。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLFW_INCLUDE_VULKAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// 包含用于报告错误的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// 用于资源管理部分中的lambda函数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// cstdlib: EXIT_FAILURE, EXIT_SUCCESS</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> enableValidationLayers = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloTriangleApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">initWindow</span>();</span><br><span class="line">        <span class="built_in">initVulkan</span>();</span><br><span class="line">        <span class="built_in">mainLoop</span>();</span><br><span class="line">        <span class="built_in">cleanup</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> WIDTH = <span class="number">800</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> HEIGHT = <span class="number">600</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * WINDOW_TITLE = <span class="string">&quot;Vulkan&quot;</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步一定是先初始化GLFW库.</span></span><br><span class="line">        <span class="built_in">glfwInit</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为GLFW最初是为创建OpenGL上下文而设计的，</span></span><br><span class="line">        <span class="comment">// 所以我们需要告诉它不要通过后续调用创建OpenGL上下文：GLFW_NO_API</span></span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_CLIENT_API, GLFW_NO_API);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为处理大小可变的窗口比较复杂，暂时先让窗口不可变</span></span><br><span class="line">        <span class="built_in">glfwWindowHint</span>(GLFW_RESIZABLE, GLFW_FALSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建窗口</span></span><br><span class="line">        <span class="comment">// GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)</span></span><br><span class="line">        window = <span class="built_in">glfwCreateWindow</span>(WIDTH, HEIGHT, WINDOW_TITLE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">checkAvailableExtensions</span>();</span><br><span class="line">        <span class="built_in">createInstance</span>();</span><br><span class="line">        <span class="comment">// 创建DEBUG消息回调</span></span><br><span class="line">        <span class="built_in">setupDebugMessenger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setupDebugMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!enableValidationLayers) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;;</span><br><span class="line">        createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;</span><br><span class="line">        createInfo.messageSeverity =</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;</span><br><span class="line">        createInfo.messageType =</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |</span><br><span class="line">            VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指定消息回调函数</span></span><br><span class="line">        createInfo.pfnUserCallback = debugCallback;</span><br><span class="line">        createInfo.pUserData = <span class="literal">nullptr</span>; <span class="comment">// 可选</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化DebugUtilsMessengerEXT</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CreateDebugUtilsMessengerEXT</span>(instance, &amp;createInfo, <span class="literal">nullptr</span>,</span><br><span class="line">                &amp;debugMessenger) != VK_SUCCESS) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to set up debug messenger!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">checkAvailableExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> extensionCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="function">std::vector&lt;VkExtensionProperties&gt; <span class="title">extensions</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceExtensionProperties</span>(<span class="literal">nullptr</span>, &amp;extensionCount, extensions.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;available extensions:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; extension : extensions) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; extension.extensionName &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkValidationLayerSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> layerCount;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;VkLayerProperties&gt; <span class="title">availableLayers</span><span class="params">(layerCount)</span></span>;</span><br><span class="line">        <span class="built_in">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* layerName : validationLayers) &#123;</span><br><span class="line">            <span class="comment">//bool layerFound = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layerProperties : availableLayers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//layerFound = true;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 验证层，检验VK_LAYER_KHRONOS_validation</span></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers &amp;&amp; !<span class="built_in">checkValidationLayerSupport</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;validation layers requested, but not available!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个实例首先必须填写一个包含有关我们应用程序的信息的结构: VkApplicationInfo</span></span><br><span class="line">        <span class="comment">// 这些数据在技术上是可选的，但它可以为驱动程序提供一些有用的信息，以便针对我们的特定应用进行优化</span></span><br><span class="line">        VkApplicationInfo appInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulkan中的许多结构要求在sType成员中明确指定类型。 </span></span><br><span class="line">        <span class="comment">// 这也是具有pNext成员的许多结构中的一个，该成员可以在将来指向扩展信息。</span></span><br><span class="line">        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;</span><br><span class="line"></span><br><span class="line">        appInfo.pApplicationName = <span class="string">&quot;Hello Triangle&quot;</span>;</span><br><span class="line">        appInfo.applicationVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        appInfo.pEngineName = <span class="string">&quot;No Engine&quot;</span>;</span><br><span class="line">        appInfo.engineVersion = <span class="built_in">VK_MAKE_VERSION</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        appInfo.apiVersion = VK_API_VERSION_1_1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Vulkan中的很多信息都是通过结构而不是函数参数传递的，</span></span><br><span class="line">        <span class="comment">// 我们必须再填充一个结构体 VkInstanceCreateInfo 来为创建实例提供足够的信息。</span></span><br><span class="line">        <span class="comment">// VkInstanceCreateInfo结构是必须指明的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。 </span></span><br><span class="line">        VkInstanceCreateInfo createInfo = &#123;&#125;;</span><br><span class="line">        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;</span><br><span class="line">        createInfo.pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        createInfo.pApplicationInfo = &amp;appInfo;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 前两个参数很简单。 </span></span><br><span class="line"><span class="comment">        // Vulkan是一个与平台无关的API，这意味着需要一个与窗口系统接口的扩展。</span></span><br><span class="line"><span class="comment">        // GLFW有一个方便的内置函数，它返回它需要做的扩展，我们可以传递给结构体：VkInstanceCreateInfo</span></span><br><span class="line"><span class="comment">        uint32_t glfwExtensionCount = 0;</span></span><br><span class="line"><span class="comment">        const char** glfwExtensions;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">        // 返回GLFW所需的Vulkan实例扩展。</span></span><br><span class="line"><span class="comment">        // 此函数返回GLFW所需的Vulkan实例扩展名的数组，以便为GLFW窗口创建Vulkan surface。 </span></span><br><span class="line"><span class="comment">        // 如果成功，列表将始终包含`VK_KHR_surface`，因此如果您不需要任何其他扩展，则可以将此列表直接传递给`VkInstanceCreateInfo`结构。</span></span><br><span class="line"><span class="comment">        // 如果机器上没有Vulkan，则此函数返回“NULL”并生成 GLFW_API_UNAVAILABLE错误。</span></span><br><span class="line"><span class="comment">        glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // 笔者曾在这里栽了个跟头，写错了。如上写，编译不出问题，但运行时会报 Segmentation fault (core dumped)</span></span><br><span class="line"><span class="comment">        // 打印堆栈，看了半天，才发现的，引以为戒，不过这两变量名字很像。</span></span><br><span class="line"><span class="comment">        createInfo.ppEnabledLayerNames = glfwExtensions;</span></span><br><span class="line"><span class="comment">        createInfo.ppEnabledExtensionNames = glfwExtensions;</span></span><br><span class="line"><span class="comment">        createInfo.enabledExtensionCount = glfwExtensionCount;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 返回GLFW所需的Vulkan实例扩展, 支持消息回调</span></span><br><span class="line">        <span class="keyword">auto</span> extensions = <span class="built_in">getRequiredExtensions</span>();</span><br><span class="line">        createInfo.enabledExtensionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(extensions.<span class="built_in">size</span>());</span><br><span class="line">        createInfo.ppEnabledExtensionNames = extensions.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构体的最后两个成员确定要启用的全局验证层。</span></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">            createInfo.enabledLayerCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(validationLayers.<span class="built_in">size</span>());</span><br><span class="line">            createInfo.ppEnabledLayerNames = validationLayers.<span class="built_in">data</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createInfo.enabledLayerCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)</span></span><br><span class="line">        VkResult res = <span class="built_in">vkCreateInstance</span>(&amp;createInfo, <span class="literal">nullptr</span>, &amp;instance);</span><br><span class="line">        <span class="keyword">if</span> (res != VK_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create instance!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加一个事件循环, 使应用程序保持运行直到发生错误或窗口关闭</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class="line">            <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 vulkan 中推荐在创建的资源不需要后主动释放</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放debugMessenger(VkDebugUtilsMessengerEXT, 用于打印调试信息)</span></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">            <span class="built_in">DestroyDebugUtilsMessengerEXT</span>(instance, debugMessenger, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在 vulkan 中资源一般都是 vkCreateXXX 创建，由 vkDestroyXXX 或 vkFreeXXX 释放.</span></span><br><span class="line">        <span class="built_in">vkDestroyInstance</span>(instance, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此函数会破坏指定的窗口及其上下文。 在调用此函数时，不会为该窗口调用其他回调。</span></span><br><span class="line">        <span class="comment">// 如果指定窗口的上下文在主线程上是最新的，则在销毁之前将其分离。</span></span><br><span class="line">        <span class="built_in">glfwDestroyWindow</span>(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此功能会释放所有剩余的窗口和光标并释放任何其他已分配的资源。 </span></span><br><span class="line">        <span class="comment">// 调用此函数后，必须再次成功调用@ref glfwInit，然后才能使用大多数GLFW函数。</span></span><br><span class="line">        <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于消息回调Message Callback</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">getRequiredExtensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> glfwExtensionCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>** glfwExtensions;</span><br><span class="line">        glfwExtensions = <span class="built_in">glfwGetRequiredInstanceExtensions</span>(&amp;glfwExtensionCount);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; <span class="title">extensions</span><span class="params">(glfwExtensions, glfwExtensions + glfwExtensionCount)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (enableValidationLayers) &#123;</span><br><span class="line">            extensions.<span class="built_in">push_back</span>(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> extensions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印debug信息</span></span><br><span class="line">    <span class="function"><span class="type">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="title">debugCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessageTypeFlagsEXT messageType,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> VkDebugUtilsMessengerCallbackDataEXT* pCallbackData,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* pUserData)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;validation layer: &quot;</span> &lt;&lt; pCallbackData-&gt;pMessage&lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> VK_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 VkDebugUtilsMessengerEXT 对象debugMessenger</span></span><br><span class="line">    <span class="function">VkResult <span class="title">CreateDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">        VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT*</span></span></span><br><span class="line"><span class="params"><span class="function">        pDebugMessenger)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结构体 VkDebugUtilsMessengerEXT 传递给vkCreateDebugUtilsMessengerEXT函数以创建VkDebugUtilsMessengerEXT对象。 </span></span><br><span class="line">        <span class="comment">// 然而因为这个function是一个扩展函数，它不会自动加载。</span></span><br><span class="line">        <span class="comment">// 必须使用vkGetInstanceProcAddr查找其地址。</span></span><br><span class="line">        <span class="keyword">auto</span> func = (PFN_vkCreateDebugUtilsMessengerEXT)</span><br><span class="line">        <span class="built_in">vkGetInstanceProcAddr</span>(instance,<span class="string">&quot;vkCreateDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">func</span>(instance, pCreateInfo, pAllocator, pDebugMessenger);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> VK_ERROR_EXTENSION_NOT_PRESENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁VkDebugUtilsMessengerEXT</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DestroyDebugUtilsMessengerEXT</span><span class="params">(VkInstance instance,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDebugUtilsMessengerEXT debugMessenger, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">        VkAllocationCallbacks* pAllocator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> func = (PFN_vkDestroyDebugUtilsMessengerEXT)</span><br><span class="line">        <span class="built_in">vkGetInstanceProcAddr</span>(instance, <span class="string">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (func != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">func</span>(instance, debugMessenger, pAllocator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window实例</span></span><br><span class="line">    GLFWwindow* window;</span><br><span class="line">    <span class="comment">// Vulkan实例</span></span><br><span class="line">    VkInstance instance;</span><br><span class="line">    <span class="comment">// DEBUG消息回调</span></span><br><span class="line">    VkDebugUtilsMessengerEXT debugMessenger;</span><br><span class="line">    <span class="comment">// 验证层</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; validationLayers = &#123;</span><br><span class="line">        <span class="string">&quot;VK_LAYER_KHRONOS_validation&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HelloTriangleApplication app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        app.<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
