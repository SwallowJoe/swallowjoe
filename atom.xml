<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwallowJoe的博客</title>
  
  <subtitle>Be a real go-getter,&lt;br&gt;NEVER SETTLE!</subtitle>
  <link href="https://swallowjoe.github.io/atom.xml" rel="self"/>
  
  <link href="https://swallowjoe.github.io/"/>
  <updated>2022-06-18T09:50:47.407Z</updated>
  <id>https://swallowjoe.github.io/</id>
  
  <author>
    <name>SwallowJoe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WMS(9)-Input事件分发给窗口的过程</title>
    <link href="https://swallowjoe.github.io/2022/05/09/WMS(9)-Input%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%BB%99%E7%AA%97%E5%8F%A3%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://swallowjoe.github.io/2022/05/09/WMS(9)-Input%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%BB%99%E7%AA%97%E5%8F%A3%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2022-05-08T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:47.407Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在前面两篇文章中我们打通了应用进程和Input进程，这两者通过一对名为InputChannel实际是通过socket实现的通道来通信。然后我们又梳理了窗口信息是如何更新并传递给Input进程的。现在我们简单梳理一下一次触摸事件分发给窗口的过程。</p><p>事件要分发，首先是需要找到被分发的事件和对应的目标窗口。</p><h1 id="一-查找Input事件的目标窗口"><a href="#一-查找Input事件的目标窗口" class="headerlink" title="一. 查找Input事件的目标窗口"></a>一. 查找Input事件的目标窗口</h1><p>Input事件是显示屏驱动收到中断后通知给InputReader，由其打包交给InputDispatcher分发的，我们直接看InputDispatcher的MotionEvent分发过程。</p><h2 id="1-1-InputDispatcher-dispatchMotionLocked"><a href="#1-1-InputDispatcher-dispatchMotionLocked" class="headerlink" title="1.1 InputDispatcher.dispatchMotionLocked"></a>1.1 InputDispatcher.dispatchMotionLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputDispatcher::dispatchMotionLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime, std::shared_ptr&lt;MotionEntry&gt; entry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        DropReason* dropReason, <span class="type">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 通过输入源确认是否为点击触摸事件</span></span><br><span class="line">    <span class="type">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;</span><br><span class="line">    <span class="comment">// 输入事件的目标窗口集合</span></span><br><span class="line">    std::vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="comment">// 触摸屏事件</span></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">// [1.2] 找到此次触摸事件的目标窗口    </span></span><br><span class="line">        injectionResult =</span><br><span class="line">                <span class="built_in">findTouchedWindowTargetsLocked</span>(currentTime, *entry, inputTargets, nextWakeupTime,</span><br><span class="line">                                               &amp;conflictingPointerActions);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [2.1] Input事件的分发</span></span><br><span class="line">    <span class="built_in">dispatchEventLocked</span>(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android的输入源有如下几种：</p><table><thead><tr><th>名称</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>AINPUT_SOURCE_CLASS_NONE</td><td>0</td><td>未定义，交给应用自行处理</td></tr><tr><td>AINPUT_SOURCE_CLASS_BUTTON</td><td>1</td><td>按键之类的设备</td></tr><tr><td>AINPUT_SOURCE_CLASS_POINTER</td><td>2</td><td>输入源是一个与显示器相关联的指向设备，如触摸屏</td></tr><tr><td>AINPUT_SOURCE_CLASS_NAVIGATION</td><td>4</td><td>输入源轨迹球导航设备</td></tr><tr><td>AINPUT_SOURCE_CLASS_POSITION</td><td>8</td><td>输入源是与显示器无关的绝对定位装置，如触控板</td></tr><tr><td>AINPUT_SOURCE_CLASS_JOYSTICK</td><td>16</td><td>输入源是一个操纵杆，摇杆设备</td></tr></tbody></table><p>当然，MotionEvent肯定是来自AINPUT_SOURCE_CLASS_POINTER了。</p><h2 id="1-2-InputDispatcher-findTouchedWindowTargetsLocked"><a href="#1-2-InputDispatcher-findTouchedWindowTargetsLocked" class="headerlink" title="1.2 InputDispatcher.findTouchedWindowTargetsLocked"></a>1.2 InputDispatcher.findTouchedWindowTargetsLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputEventInjectionResult <span class="title">InputDispatcher::findTouchedWindowTargetsLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span> currentTime, <span class="type">const</span> MotionEntry&amp; entry, std::vector&lt;InputTarget&gt;&amp; inputTargets,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span>* nextWakeupTime, <span class="type">bool</span>* outConflictingPointerActions)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;InputWindowHandle&gt; newTouchedWindowHandle;</span><br><span class="line">    ......</span><br><span class="line">    TouchState tempTouchState;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">bool</span> isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN;</span><br><span class="line">    <span class="comment">// 区分是否为新的手势事件（区别与ACTION_MOVE）</span></span><br><span class="line">    <span class="type">bool</span> newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN ||</span><br><span class="line">                    maskedAction == AMOTION_EVENT_ACTION_SCROLL || isHoverAction);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (newGesture || (isSplit &amp;&amp; maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) &#123;</span><br><span class="line">        <span class="type">int32_t</span> x;</span><br><span class="line">        <span class="type">int32_t</span> y;</span><br><span class="line">        ......</span><br><span class="line">            <span class="comment">// 获取此次触摸事件在屏幕坐标中的位置</span></span><br><span class="line">            x = <span class="built_in">int32_t</span>(entry.pointerCoords[pointerIndex].<span class="built_in">getAxisValue</span>(AMOTION_EVENT_AXIS_X));</span><br><span class="line">            y = <span class="built_in">int32_t</span>(entry.pointerCoords[pointerIndex].<span class="built_in">getAxisValue</span>(AMOTION_EVENT_AXIS_Y));</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// [1.3] 根据触摸事件的坐标找到可触摸的窗口</span></span><br><span class="line">        newTouchedWindowHandle =</span><br><span class="line">                <span class="built_in">findTouchedWindowAtLocked</span>(displayId, x, y, &amp;tempTouchState,</span><br><span class="line">                                          isDown <span class="comment">/*addOutsideTargets*/</span>, <span class="literal">true</span> <span class="comment">/*addPortalWindows*/</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (newTouchedWindowHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// [1.4] 将找到的目标窗口存入TouchState中</span></span><br><span class="line">            tempTouchState.<span class="built_in">addOrUpdateWindow</span>(newTouchedWindowHandle, targetFlags, pointerIds);</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 依次遍历找到的目标窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> TouchedWindow&amp; touchedWindow : tempTouchState.windows) &#123;</span><br><span class="line">        <span class="comment">// [1.5] 将找到的目标窗口存入inputTargets中</span></span><br><span class="line">        <span class="built_in">addWindowTargetLocked</span>(touchedWindow.windowHandle, touchedWindow.targetFlags,</span><br><span class="line">                              touchedWindow.pointerIds, inputTargets);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-InputDispatcher-findTouchedWindowAtLocked"><a href="#1-3-InputDispatcher-findTouchedWindowAtLocked" class="headerlink" title="1.3 InputDispatcher.findTouchedWindowAtLocked"></a>1.3 InputDispatcher.findTouchedWindowAtLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;InputWindowHandle&gt; <span class="title">InputDispatcher::findTouchedWindowAtLocked</span><span class="params">(<span class="type">int32_t</span> displayId, <span class="type">int32_t</span> x,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">int32_t</span> y, TouchState* touchState,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">bool</span> addOutsideTargets,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">bool</span> addPortalWindows,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                 <span class="type">bool</span> ignoreDragWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [1.3.1] 从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; windowHandles = <span class="built_in">getWindowHandlesLocked</span>(displayId);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle : windowHandles) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;<span class="built_in">getInfo</span>();</span><br><span class="line">        <span class="keyword">if</span> (windowInfo-&gt;displayId == displayId) &#123;</span><br><span class="line">            <span class="keyword">auto</span> flags = windowInfo-&gt;flags;</span><br><span class="line">            <span class="comment">// 首先窗口必须是可见的，不可见窗口无法接收input事件</span></span><br><span class="line">            <span class="keyword">if</span> (windowInfo-&gt;visible) &#123;</span><br><span class="line">                <span class="comment">// 窗口必须不携带NOT_TOUCHABLE的flag</span></span><br><span class="line">                <span class="keyword">if</span> (!flags.<span class="built_in">test</span>(InputWindowInfo::Flag::NOT_TOUCHABLE)) &#123;</span><br><span class="line">                    <span class="type">bool</span> isTouchModal = !flags.<span class="built_in">test</span>(InputWindowInfo::Flag::NOT_FOCUSABLE) &amp;&amp;</span><br><span class="line">                            !flags.<span class="built_in">test</span>(InputWindowInfo::Flag::NOT_TOUCH_MODAL);</span><br><span class="line">                    <span class="comment">// [1.3.2] 判断坐标是否位于该窗口内或者该窗口是TOUCH_MODAL的</span></span><br><span class="line">                    <span class="keyword">if</span> (isTouchModal || windowInfo-&gt;<span class="built_in">touchableRegionContainsPoint</span>(x, y)) &#123;</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="comment">// 找到的第一个窗口直接返回</span></span><br><span class="line">                        <span class="keyword">return</span> windowHandle;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息，依次遍历，判断窗口是否可见，不可见窗口无法接收input事件。如果可见，在判断窗口是否携带NOT_TOUCHABLE的flag。如果不携带，只要触摸事件的坐标位于该窗口的可触摸区域内，就返回该窗口。</p><p>注意getWindowHandlesLocked拿到的窗口是有顺序的，index越小，Z轴越大。因为在<strong>SurfaceFlinger.updateInputWindowInfo时我们遍历layer的顺序是沿着Z轴反向遍历的</strong>。那么窗口在上面的会存储在mWindowHandlesByDisplay中对应队列的前面，所以这里只需要找到第一个窗口返回即可。</p><h3 id="1-3-1-InputDispatcher-getWindowHandlesLocked"><a href="#1-3-1-InputDispatcher-getWindowHandlesLocked" class="headerlink" title="1.3.1 InputDispatcher.getWindowHandlesLocked"></a>1.3.1 InputDispatcher.getWindowHandlesLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; InputDispatcher::<span class="built_in">getWindowHandlesLocked</span>(</span><br><span class="line">        <span class="type">int32_t</span> displayId) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; EMPTY_WINDOW_HANDLES;</span><br><span class="line">    <span class="keyword">auto</span> it = mWindowHandlesByDisplay.<span class="built_in">find</span>(displayId);</span><br><span class="line">    <span class="keyword">return</span> it != mWindowHandlesByDisplay.<span class="built_in">end</span>() ? it-&gt;second : EMPTY_WINDOW_HANDLES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从mWindowHandlesByDisplay中拿到当前该display中所有的窗口信息（WMS中addWindow后添加的）。</p><h3 id="1-3-2-InputWindowInfo-touchableRegionContainsPoint"><a href="#1-3-2-InputWindowInfo-touchableRegionContainsPoint" class="headerlink" title="1.3.2 InputWindowInfo.touchableRegionContainsPoint"></a>1.3.2 InputWindowInfo.touchableRegionContainsPoint</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InputWindowInfo::touchableRegionContainsPoint</span><span class="params">(<span class="type">int32_t</span> x, <span class="type">int32_t</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> touchableRegion.<span class="built_in">contains</span>(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断该窗口的可触摸区域是否包含此坐标点。</p><h2 id="1-4-TouchState-addOrUpdateWindow"><a href="#1-4-TouchState-addOrUpdateWindow" class="headerlink" title="1.4 TouchState.addOrUpdateWindow"></a>1.4 TouchState.addOrUpdateWindow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TouchState::addOrUpdateWindow</span><span class="params">(<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle, <span class="type">int32_t</span> targetFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   BitSet32 pointerIds)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 封装成TouchedWindow存入windows队列的末尾</span></span><br><span class="line">    TouchedWindow touchedWindow;</span><br><span class="line">    touchedWindow.windowHandle = windowHandle;</span><br><span class="line">    touchedWindow.targetFlags = targetFlags;</span><br><span class="line">    touchedWindow.pointerIds = pointerIds;</span><br><span class="line">    windows.<span class="built_in">push_back</span>(touchedWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将找到的目标窗口封装成TouchedWindow存入TouchState.windows队列的末尾。</p><h2 id="1-5-InputDispatcher-addWindowTargetLocked"><a href="#1-5-InputDispatcher-addWindowTargetLocked" class="headerlink" title="1.5 InputDispatcher.addWindowTargetLocked"></a>1.5 InputDispatcher.addWindowTargetLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::addWindowTargetLocked</span><span class="params">(<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int32_t</span> targetFlags, BitSet32 pointerIds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            std::vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用find_if函数，查找inputTargets中inputChannel的token和传入的窗口token一致的InputTarget</span></span><br><span class="line">    std::vector&lt;InputTarget&gt;::iterator it =</span><br><span class="line">            std::<span class="built_in">find_if</span>(inputTargets.<span class="built_in">begin</span>(), inputTargets.<span class="built_in">end</span>(),</span><br><span class="line">                         [&amp;windowHandle](<span class="type">const</span> InputTarget&amp; inputTarget) &#123;</span><br><span class="line">                             <span class="keyword">return</span> inputTarget.inputChannel-&gt;<span class="built_in">getConnectionToken</span>() ==</span><br><span class="line">                                     windowHandle-&gt;<span class="built_in">getToken</span>();</span><br><span class="line">                         &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;<span class="built_in">getInfo</span>();</span><br><span class="line">    <span class="comment">// 当it是指向inputTargets.end()时，说明inputTargets中不存在和传入的窗口token一致的InputTarget对象</span></span><br><span class="line">    <span class="keyword">if</span> (it == inputTargets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// 创建新的InputTarget，对应传入的窗口，放在inputTargets队列的末尾</span></span><br><span class="line">        InputTarget inputTarget;</span><br><span class="line">        std::shared_ptr&lt;InputChannel&gt; inputChannel =</span><br><span class="line">                <span class="built_in">getInputChannelLocked</span>(windowHandle-&gt;<span class="built_in">getToken</span>());</span><br><span class="line">        <span class="keyword">if</span> (inputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Window %s already unregistered input channel&quot;</span>, windowHandle-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inputTarget.inputChannel = inputChannel;</span><br><span class="line">        inputTarget.flags = targetFlags;</span><br><span class="line">        inputTarget.globalScaleFactor = windowInfo-&gt;globalScaleFactor;</span><br><span class="line">        inputTarget.displaySize =</span><br><span class="line">                <span class="built_in">vec2</span>(windowHandle-&gt;<span class="built_in">getInfo</span>()-&gt;displayWidth, windowHandle-&gt;<span class="built_in">getInfo</span>()-&gt;displayHeight);</span><br><span class="line">        inputTargets.<span class="built_in">push_back</span>(inputTarget);</span><br><span class="line">        it = inputTargets.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOG_ASSERT</span>(it-&gt;flags == targetFlags);</span><br><span class="line">    <span class="built_in">ALOG_ASSERT</span>(it-&gt;globalScaleFactor == windowInfo-&gt;globalScaleFactor);</span><br><span class="line">    <span class="comment">// 将pointerIds存入InputTarget, 顺便将transform存入pointerTransforms中，以方便做转换</span></span><br><span class="line">    it-&gt;<span class="built_in">addPointers</span>(pointerIds, windowInfo-&gt;transform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也是比较简单的一个函数，首先使用find_if函数，查找inputTargets中inputChannel的token和传入的窗口token一致的InputTarget，如果不存在就根据传入的窗口信息windowHandle创键新的InputTarget并存入inputTargets队列的末尾。</p><h1 id="二-Input事件分发"><a href="#二-Input事件分发" class="headerlink" title="二. Input事件分发"></a>二. Input事件分发</h1><h2 id="2-1-InputDispatcher-dispatchEventLocked"><a href="#2-1-InputDispatcher-dispatchEventLocked" class="headerlink" title="2.1 InputDispatcher.dispatchEventLocked"></a>2.1 InputDispatcher.dispatchEventLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::dispatchEventLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          std::shared_ptr&lt;EventEntry&gt; eventEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::vector&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 这里通过JNI调用到PowerManagerService, 更新自动灭屏的时间，这样触碰屏幕后自动灭屏就重新开始计时了    </span></span><br><span class="line">    <span class="built_in">pokeUserActivityLocked</span>(*eventEntry);</span><br><span class="line">    <span class="comment">// 依次遍历所有的目标窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> InputTarget&amp; inputTarget : inputTargets) &#123;</span><br><span class="line">        <span class="comment">// [2.1.1] 拿到目标窗口InputChannel对应的Connection</span></span><br><span class="line">        sp&lt;Connection&gt; connection =</span><br><span class="line">                <span class="built_in">getConnectionLocked</span>(inputTarget.inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// [2.2] 准备分发</span></span><br><span class="line">            <span class="built_in">prepareDispatchCycleLocked</span>(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FOCUS) &#123;</span><br><span class="line">                <span class="built_in">ALOGD</span>(<span class="string">&quot;Dropping event delivery to target with channel &#x27;%s&#x27; because it &quot;</span></span><br><span class="line">                      <span class="string">&quot;is no longer registered with the input dispatcher.&quot;</span>,</span><br><span class="line">                      inputTarget.inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-InputDispatcher-getConnectionLocked"><a href="#2-1-1-InputDispatcher-getConnectionLocked" class="headerlink" title="2.1.1 InputDispatcher.getConnectionLocked"></a>2.1.1 InputDispatcher.getConnectionLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;Connection&gt; <span class="title">InputDispatcher::getConnectionLocked</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; inputConnectionToken)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputConnectionToken == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, connection] : mConnectionsByToken) &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == inputConnectionToken) &#123;</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入的token就是InputChannel初始化时创建BBinder, 而InputChannel创建完成后会生成Connection存入mConnectionsByToken，这个发生在InputDispatcher::createInputChannel中。</p><h2 id="2-2-InputDispatcher-prepareDispatchCycleLocked"><a href="#2-2-InputDispatcher-prepareDispatchCycleLocked" class="headerlink" title="2.2 InputDispatcher.prepareDispatchCycleLocked"></a>2.2 InputDispatcher.prepareDispatchCycleLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::prepareDispatchCycleLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> sp&lt;Connection&gt;&amp; connection,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 std::shared_ptr&lt;EventEntry&gt; eventEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">const</span> InputTarget&amp; inputTarget)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将Input事件和对应分发的连接作为一次分发事件存入Input分发队列</span></span><br><span class="line">    <span class="built_in">enqueueDispatchEntriesLocked</span>(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::enqueueDispatchEntriesLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">const</span> sp&lt;Connection&gt;&amp; connection,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   std::shared_ptr&lt;EventEntry&gt; eventEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">const</span> InputTarget&amp; inputTarget)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 判断该连接是否存在input事件待分发</span></span><br><span class="line">    <span class="type">bool</span> wasEmpty = connection-&gt;outboundQueue.<span class="built_in">empty</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">enqueueDispatchEntryLocked</span>(connection, eventEntry, inputTarget,</span><br><span class="line">                            InputTarget::FLAG_DISPATCH_AS_IS);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 如果出站队列之前为空，则启动调度周期</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// [2.3] 启动input事件分发</span></span><br><span class="line">        <span class="built_in">startDispatchCycleLocked</span>(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-InputDispatcher-startDispatchCycleLocked"><a href="#2-3-InputDispatcher-startDispatchCycleLocked" class="headerlink" title="2.3 InputDispatcher.startDispatchCycleLocked"></a>2.3 InputDispatcher.startDispatchCycleLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::startDispatchCycleLocked</span><span class="params">(<span class="type">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// InputChannel连接正常，将待分发队列里的事件一一分发</span></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 每次都取第一个事件，保证先进先出</span></span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.<span class="built_in">front</span>();</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">const</span> EventEntry&amp; eventEntry = *(dispatchEntry-&gt;eventEntry);</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry.type) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> EventEntry::Type::MOTION: &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// [2.4] 发布input事件，将input事件所有信息都发出去</span></span><br><span class="line">                status = connection-&gt;inputPublisher</span><br><span class="line">                            .<span class="built_in">publishMotionEvent</span>(......);</span><br><span class="line">                ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当InputChannel对应的连接正常，则将待分发队列里的事件一一分发，每次都取outboundQueue中的第一个事件，保证先进先出。</p><p>Connection中的InputPublisher就是Connection初始化时创建的InputPublisher。</p><h2 id="2-4-InputPublisher-publishMotionEvent"><a href="#2-4-InputPublisher-publishMotionEvent" class="headerlink" title="2.4 InputPublisher.publishMotionEvent"></a>2.4 InputPublisher.publishMotionEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputPublisher::publishMotionEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> seq, <span class="type">int32_t</span> eventId, <span class="type">int32_t</span> deviceId, <span class="type">int32_t</span> source, <span class="type">int32_t</span> displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::array&lt;<span class="type">uint8_t</span>, <span class="number">32</span>&gt; hmac, <span class="type">int32_t</span> action, <span class="type">int32_t</span> actionButton, <span class="type">int32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> edgeFlags, <span class="type">int32_t</span> metaState, <span class="type">int32_t</span> buttonState,</span></span></span><br><span class="line"><span class="params"><span class="function">        MotionClassification classification, <span class="type">const</span> ui::Transform&amp; transform, <span class="type">float</span> xPrecision,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">float</span> yPrecision, <span class="type">float</span> xCursorPosition, <span class="type">float</span> yCursorPosition, <span class="type">int32_t</span> displayWidth,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> displayHeight, <span class="type">nsecs_t</span> downTime, <span class="type">nsecs_t</span> eventTime, <span class="type">uint32_t</span> pointerCount,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> PointerProperties* pointerProperties, <span class="type">const</span> PointerCoords* pointerCoords)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将input事件封装成InputMessage</span></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::Type::MOTION;</span><br><span class="line">    ......</span><br><span class="line">    msg.body.motion.eventTime = eventTime;</span><br><span class="line">    msg.body.motion.pointerCount = pointerCount;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 交给InputChannel将input事件通知给应用进程</span></span><br><span class="line">    <span class="keyword">return</span> mChannel-&gt;<span class="built_in">sendMessage</span>(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将input事件封装成InputMessage, 在交给InputChannel将input事件通知给应用进程.</p><h2 id="2-5-InputChannel-sendMessage"><a href="#2-5-InputChannel-sendMessage" class="headerlink" title="2.5 InputChannel.sendMessage"></a>2.5 InputChannel.sendMessage</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputChannel::sendMessage</span><span class="params">(<span class="type">const</span> InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> msgLength = msg-&gt;<span class="built_in">size</span>();</span><br><span class="line">    InputMessage cleanMsg;</span><br><span class="line">    msg-&gt;<span class="built_in">getSanitizedCopy</span>(&amp;cleanMsg);</span><br><span class="line">    <span class="type">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 交给Socket进行通信</span></span><br><span class="line">        nWrite = ::<span class="built_in">send</span>(<span class="built_in">getFd</span>(), &amp;cleanMsg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过InputChannel, 此次的input事件就通知给了目标窗口所在进程。回忆一下，我们应用进程中注册该InputChannel对的Socket文件描述符是在NativeInputEventReceiver中的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputEventReceiver::setFdEvents</span><span class="params">(<span class="type">int</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="type">int</span> fd = mInputConsumer.<span class="built_in">getChannel</span>()-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            <span class="comment">// 将InputChannel中的客户端Socket的文件描述符加入的Looper中监听</span></span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">addFd</span>(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">removeFd</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们应用进程收到该socket文件描述符消息时，会调用NativeInputEventReceiver::handleEvent函数了（Looper机制）。</p><h1 id="三-应用进程收到Input事件"><a href="#三-应用进程收到Input事件" class="headerlink" title="三. 应用进程收到Input事件"></a>三. 应用进程收到Input事件</h1><h2 id="3-1-NativeInputEventReceiver-handleEvent"><a href="#3-1-NativeInputEventReceiver-handleEvent" class="headerlink" title="3.1 NativeInputEventReceiver.handleEvent"></a>3.1 NativeInputEventReceiver.handleEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NativeInputEventReceiver::handleEvent</span><span class="params">(<span class="type">int</span> receiveFd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line">        <span class="comment">// [3.2] 消费此次input事件</span></span><br><span class="line">        <span class="type">status_t</span> status = <span class="built_in">consumeEvents</span>(env, <span class="literal">false</span> <span class="comment">/*consumeBatches*/</span>, <span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;handleReceiveCallback&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> status == OK || status == NO_MEMORY ? KEEP_CALLBACK : REMOVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-NativeInputEventReceiver-consumeEvents"><a href="#3-2-NativeInputEventReceiver-consumeEvents" class="headerlink" title="3.2 NativeInputEventReceiver.consumeEvents"></a>3.2 NativeInputEventReceiver.consumeEvents</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputEventReceiver::consumeEvents</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> consumeBatches, <span class="type">nsecs_t</span> frameTime, <span class="type">bool</span>* outConsumedBatch)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        <span class="comment">// [3.3] 将接收到的数据封装成InputEvent</span></span><br><span class="line">        <span class="type">status_t</span> status = mInputConsumer.<span class="built_in">consume</span>(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!skipCallbacks) &#123;</span><br><span class="line">            ......</span><br><span class="line">            jobject inputEventObj;</span><br><span class="line">            <span class="keyword">switch</span> (inputEvent-&gt;<span class="built_in">getType</span>()) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">case</span> AINPUT_EVENT_TYPE_MOTION: &#123;</span><br><span class="line">                    MotionEvent* motionEvent = <span class="built_in">static_cast</span>&lt;MotionEvent*&gt;(inputEvent);</span><br><span class="line">                    <span class="keyword">if</span> ((motionEvent-&gt;<span class="built_in">getAction</span>() &amp; AMOTION_EVENT_ACTION_MOVE) &amp;&amp; outConsumedBatch) &#123;</span><br><span class="line">                        *outConsumedBatch = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 通过JNI创建java层的MotionEvent对象</span></span><br><span class="line">                    inputEventObj = <span class="built_in">android_view_MotionEvent_obtainAsCopy</span>(env, motionEvent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;        </span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">                <span class="comment">// [3.4] 通过JNI调用dispatchInputEvent将Input事件分发给应用java层的View</span></span><br><span class="line">                env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 此次Input事件使用之后就回收</span></span><br><span class="line">                env-&gt;<span class="built_in">DeleteLocalRef</span>(inputEventObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumeEvents就是接收socket数据，将input事件封装成对应类型的对象，如触摸事件对应MotionEvent，按键事件对应KeyEvent. 然后通过JNI创建对应java层的input事件对象，最后调用InputEventReceiver.dispatchInputEvent将Input事件分发给应用java层的View。</p><h2 id="3-3-InputConsumer-consume"><a href="#3-3-InputConsumer-consume" class="headerlink" title="3.3 InputConsumer.consume"></a>3.3 InputConsumer.consume</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputConsumer::consume</span><span class="params">(InputEventFactoryInterface* factory, <span class="type">bool</span> consumeBatches,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">nsecs_t</span> frameTime, <span class="type">uint32_t</span>* outSeq, InputEvent** outEvent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    *outSeq = <span class="number">0</span>;</span><br><span class="line">    *outEvent = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!*outEvent) &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="comment">// [3.3.1] 通过recv函数接收Socket数据</span></span><br><span class="line">            <span class="type">status_t</span> result = mChannel-&gt;<span class="built_in">receiveMessage</span>(&amp;mMsg);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">switch</span> (mMsg.header.type) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> InputMessage::Type::MOTION: &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// 创建MotionEvent</span></span><br><span class="line">                MotionEvent* motionEvent = factory-&gt;<span class="built_in">createMotionEvent</span>();</span><br><span class="line">                <span class="keyword">if</span> (!motionEvent) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">                <span class="comment">// 更新触摸状态信息</span></span><br><span class="line">                <span class="built_in">updateTouchState</span>(mMsg);</span><br><span class="line">                <span class="comment">// 使用收到的InputMessage填充创建的MotionEvent</span></span><br><span class="line">                <span class="built_in">initializeMotionEvent</span>(motionEvent, &amp;mMsg);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先在InputChannel中通过recv函数接收来自Input系统的Socket数据(InputMessage), 然后根据input类型分别封装成对应的input事件，比如MotionEvent、KeyEvent等。</p><h3 id="3-3-1-InputChannel-receiveMessage"><a href="#3-3-1-InputChannel-receiveMessage" class="headerlink" title="3.3.1 InputChannel.receiveMessage"></a>3.3.1 InputChannel.receiveMessage</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputChannel::receiveMessage</span><span class="params">(InputMessage* msg)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 通过recv函数接收Socket数据</span></span><br><span class="line">        nRead = ::<span class="built_in">recv</span>(<span class="built_in">getFd</span>(), msg, <span class="built_in">sizeof</span>(InputMessage), MSG_DONTWAIT);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过recv函数接收Socket数据, 还原成InputMessage.</p><h2 id="3-4-WindowInputEventReceiver-dispatchInputEvent"><a href="#3-4-WindowInputEventReceiver-dispatchInputEvent" class="headerlink" title="3.4 WindowInputEventReceiver.dispatchInputEvent"></a>3.4 WindowInputEventReceiver.dispatchInputEvent</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchInputEvent</span><span class="params">(<span class="type">int</span> seq, InputEvent event)</span> &#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里JNI注册的InputEventReceiver其实是ViewRootImpl中的WindowInputEventReceiver, 所以onInputEvent其实是调用了被Override的子类函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowInputEventReceiver.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onInputEvent</span><span class="params">(InputEvent event)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        enqueueInputEvent(event, <span class="built_in">this</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面将事件分发给对应的View组件的过程，其实也不难猜测，因为View是树形结构，只需要前序遍历该树找到input事件坐标所在的最叶子节点的View，如果该View消耗了此次事件，也就是设置了对应的Listener并实现了接口返回true, 那么该事件就不继续分发了。否则沿着树形结构依次遍历父View，看是否需要使用该事件。</p><p>到这里，Input和窗口的关系分析就告一段落了。接下来分析窗口对应的View和SurfaceFlinger通信过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    <category term="Input" scheme="https://swallowjoe.github.io/categories/Android/WMS/Input/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
    <category term="Input" scheme="https://swallowjoe.github.io/tags/Input/"/>
    
  </entry>
  
  <entry>
    <title>WMS(8)-窗口信息传递给Input系统</title>
    <link href="https://swallowjoe.github.io/2022/05/08/WMS(8)-%E7%AA%97%E5%8F%A3%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E7%BB%99Input%E7%B3%BB%E7%BB%9F/"/>
    <id>https://swallowjoe.github.io/2022/05/08/WMS(8)-%E7%AA%97%E5%8F%A3%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92%E7%BB%99Input%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-05-07T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:43.054Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上文中，我们知道了应用View和窗口与input系统交互通道InputChannel的打通过程。有了通信通道，就可以通过这个来通信，将input事件传递给应用程序。很自然的，input系统中必须要保存代表该应用窗口的对象，用于识别以及分发事件。</p><p>还记得我们初始化WindowState时，有创建过一个InputWindowHandleWrapper类的对象，当时我们认为是将该Window注册进input系统：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建InputApplicationHandle, 将该Window注册进Input系统，以便后续input事件传输</span></span><br><span class="line">mInputWindowHandle = <span class="keyword">new</span> <span class="title class_">InputWindowHandleWrapper</span>(<span class="keyword">new</span> <span class="title class_">InputWindowHandle</span>(</span><br><span class="line">        mActivityRecord != <span class="literal">null</span></span><br><span class="line">                ? mActivityRecord.getInputApplicationHandle(<span class="literal">false</span> <span class="comment">/* update */</span>) : <span class="literal">null</span>,</span><br><span class="line">        getDisplayId()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityRecord.java</span></span><br><span class="line"><span class="meta">@NonNull</span> InputApplicationHandle <span class="title function_">getInputApplicationHandle</span><span class="params">(<span class="type">boolean</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputApplicationHandle == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建InputApplicationHandle, 这里的appToken是IApplicationToken.Stub的子类对象，是ActivityRecord初始化时创建的</span></span><br><span class="line">        mInputApplicationHandle = <span class="keyword">new</span> <span class="title class_">InputApplicationHandle</span>(appToken, toString(),</span><br><span class="line">                mInputDispatchingTimeoutMillis);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mInputApplicationHandle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看看这里InputWindowHandleWrapper、InputWindowHandle、InputApplicationHandle等相关类的类图：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/8_1.png" alt="8-1"></p><p>可以看到这里InputWindowHandle类中包含该Window的大小和位置、可触碰区域(touchableRegion)等等信息，这些信息是什么时候更新的呢？回到我们之前研究过的焦点窗口的更新一文，在WMS.addWindow中创建WindowState的对象并且更新焦点窗口后，会更新input相关信息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WMS.addWindow</span></span><br><span class="line"><span class="comment">// 如果焦点窗口有更新，也需要更新input相关设置</span></span><br><span class="line"><span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">    <span class="comment">// [1.1] 设置输入焦点窗口信息</span></span><br><span class="line">    displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus,</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [1.2] 更新输入窗口信息</span></span><br><span class="line">displayContent.getInputMonitor().updateInputWindowsLw(<span class="literal">false</span> <span class="comment">/*force*/</span>);</span><br></pre></td></tr></table></figure><p>这里我们加上mCurrentFocus就是此次新创建的WindowState.</p><h1 id="一-更新窗口信息"><a href="#一-更新窗口信息" class="headerlink" title="一. 更新窗口信息"></a>一. 更新窗口信息</h1><h2 id="1-1-InputMonitor-setInputFocusLw"><a href="#1-1-InputMonitor-setInputFocusLw" class="headerlink" title="1.1 InputMonitor.setInputFocusLw"></a>1.1 InputMonitor.setInputFocusLw</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setInputFocusLw</span><span class="params">(WindowState newWindow, <span class="type">boolean</span> updateInputWindows)</span> &#123;</span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;Input focus has changed to %s display=%d&quot;</span>,</span><br><span class="line">            newWindow, mDisplayId);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">focus</span> <span class="operator">=</span> newWindow != <span class="literal">null</span> ? newWindow.mInputChannelToken : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (focus == mInputFocus) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newWindow != <span class="literal">null</span> &amp;&amp; newWindow.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="comment">// 隐式地显示一个窗口将导致取消调度, 为了防止错误，如果有人暂停调度但忘记resume</span></span><br><span class="line">        newWindow.mToken.paused = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记mUpdateInputWindowsNeeded为true</span></span><br><span class="line">    setUpdateInputWindowsNeededLw();</span><br><span class="line">    <span class="comment">// 此时传入的updateInputWindows为false, 表明不是此时更新信息的</span></span><br><span class="line">    <span class="keyword">if</span> (updateInputWindows) &#123;</span><br><span class="line">        updateInputWindowsLw(<span class="literal">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUpdateInputWindowsNeededLw</span><span class="params">()</span> &#123;</span><br><span class="line">    mUpdateInputWindowsNeeded = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是判断新的窗口是否与当前输入焦点窗口一致，如果不一致，则标记mUpdateInputWindowsNeeded为true，表明需要更新输入窗口了。</p><h2 id="1-2-InputMonitor-updateInputWindowsLw"><a href="#1-2-InputMonitor-updateInputWindowsLw" class="headerlink" title="1.2 InputMonitor.updateInputWindowsLw"></a>1.2 InputMonitor.updateInputWindowsLw</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateInputWindowsLw</span><span class="params">(<span class="type">boolean</span> force)</span> &#123;</span><br><span class="line">    <span class="comment">// mUpdateInputWindowsNeeded 在[1.1]中就被标记为true了</span></span><br><span class="line">    <span class="keyword">if</span> (!force &amp;&amp; !mUpdateInputWindowsNeeded) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduleUpdateInputWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleUpdateInputWindows</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前input对应的Display设备被移除时，无需处理</span></span><br><span class="line">    <span class="keyword">if</span> (mDisplayRemoved) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mUpdateInputWindowsPending默认是false</span></span><br><span class="line">    <span class="comment">// 用于标记当前是否有存在尚未执行的 mUpdateInputWindows</span></span><br><span class="line">    <span class="keyword">if</span> (!mUpdateInputWindowsPending) &#123;</span><br><span class="line">        mUpdateInputWindowsPending = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// [1.3] 将输入窗口信息交给&quot;android.anim&quot;线程处理，mHandler=&gt;WMS.mAnimationHandler</span></span><br><span class="line">        mHandler.post(mUpdateInputWindows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断是否需要执行更新（mUpdateInputWindowsNeeded变量），如果需要则将更新操作交给”android.anim”线程处理。</p><h2 id="1-3-InputMonitor-UpdateInputWindows-run"><a href="#1-3-InputMonitor-UpdateInputWindows-run" class="headerlink" title="1.3 InputMonitor.UpdateInputWindows.run"></a>1.3 InputMonitor.UpdateInputWindows.run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">// 执行输入窗口信息更新，将变量恢复</span></span><br><span class="line">        mUpdateInputWindowsPending = <span class="literal">false</span>;</span><br><span class="line">        mUpdateInputWindowsNeeded = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDisplayRemoved) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用可能接收输入的所有窗口的信息填充输入窗口列表</span></span><br><span class="line">        <span class="comment">// 作为一个优化，可以尝试修剪窗口列表，但这是困难的，因为只有native代码知道哪个窗口当前有触摸焦点。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果滑动过程中有拖拽，提供一个伪窗口来捕获拖拽输入，为了方便分析这里加上是非拖拽</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">inDrag</span> <span class="operator">=</span> mService.mDragDropController.dragDropActiveLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [1.4] 在默认Display中添加所有窗口</span></span><br><span class="line">        mUpdateInputForAllWindowsConsumer.updateInputWindows(inDrag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在”android.anim”线程处理时，首先将标记变量恢复为false, 表示可以接收下一次输入窗口更新了。接下来就是在默认Display中添加所有窗口了。</p><h2 id="1-4-InputMonitor-UpdateInputForAllWindowsConsumer-updateInputWindows"><a href="#1-4-InputMonitor-UpdateInputForAllWindowsConsumer-updateInputWindows" class="headerlink" title="1.4 InputMonitor.UpdateInputForAllWindowsConsumer.updateInputWindows"></a>1.4 InputMonitor.UpdateInputForAllWindowsConsumer.updateInputWindows</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInputWindows</span><span class="params">(<span class="type">boolean</span> inDrag)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;updateInputWindows&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取对应的InputConsumer</span></span><br><span class="line">    mPipInputConsumer = getInputConsumer(INPUT_CONSUMER_PIP);</span><br><span class="line">    mWallpaperInputConsumer = getInputConsumer(INPUT_CONSUMER_WALLPAPER);</span><br><span class="line">    mRecentsAnimationInputConsumer = getInputConsumer(INPUT_CONSUMER_RECENTS_ANIMATION);</span><br><span class="line">    <span class="comment">// 判断对应InputConsumer是否为null</span></span><br><span class="line">    mAddPipInputConsumerHandle = mPipInputConsumer != <span class="literal">null</span>;</span><br><span class="line">    mAddWallpaperInputConsumerHandle = mWallpaperInputConsumer != <span class="literal">null</span>;</span><br><span class="line">    mAddRecentsAnimationInputConsumerHandle = mRecentsAnimationInputConsumer != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    mDisableWallpaperTouchEvents = <span class="literal">false</span>;</span><br><span class="line">    mInDrag = inDrag;</span><br><span class="line">    <span class="comment">// mInputConsumers 中所有的InputConsumer都调用hide隐藏</span></span><br><span class="line">    resetInputConsumers(mInputTransaction);</span><br><span class="line">    mRecentsAnimationFocusOverride = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// [1.5] 从上到下（Z轴大到小）遍历该DisplayContent中所有的WindowState</span></span><br><span class="line">    <span class="comment">// 依次执行UpdateInputForAllWindowsConsumer.accept</span></span><br><span class="line">    mDisplayContent.forAllWindows(<span class="built_in">this</span>, <span class="literal">true</span> <span class="comment">/* traverseTopToBottom */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRecentsAnimationFocusOverride) &#123;</span><br><span class="line">        requestFocus(mRecentsAnimationInputConsumer.mWindowHandle.token,</span><br><span class="line">                mRecentsAnimationInputConsumer.mName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// [1.6] 将焦点窗口信息更新给input系统</span></span><br><span class="line">        updateInputFocusRequest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mUpdateInputWindowsImmediately一般为false</span></span><br><span class="line">    <span class="keyword">if</span> (!mUpdateInputWindowsImmediately) &#123;</span><br><span class="line">        mDisplayContent.getPendingTransaction().merge(mInputTransaction);</span><br><span class="line">        mDisplayContent.scheduleAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputConsumerImpl <span class="title function_">getInputConsumer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mInputConsumers.get(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputConsumer总共有四种:</p><ol><li>INPUT_CONSUMER_PIP: “pip_input_consumer”, 用于pip</li><li>INPUT_CONSUMER_NAVIGATION: “nav_input_consumer”，用于导航栏</li><li>INPUT_CONSUMER_WALLPAPER: “wallpaper_input_consumer”，用于壁纸</li><li>INPUT_CONSUMER_RECENTS_ANIMATION: “recents_animation_input_consumer”，用于多任务</li></ol><p>更新输入窗口的步骤如下:</p><ol><li>重置InputConsumer，将所有consumer都调用hide</li><li>从上到下（Z轴大到小）遍历该DisplayContent中所有的WindowState，依次执行UpdateInputForAllWindowsConsumer.accept<ol><li>这个accept就是计算更新窗口信息，比如可触碰区域的计算</li><li>通过SurfaceControl传递窗口信息给SurfaceFlinger，在native层生成对应的InputWindowHandle</li></ol></li><li>如果有最近任务栏动画，则调用requestFocus更新多任务焦点；否则调用updateInputFocusRequest更新输入焦点请求</li></ol><h2 id="1-5-InputMonitor-UpdateInputForAllWindowsConsumer-accept"><a href="#1-5-InputMonitor-UpdateInputForAllWindowsConsumer-accept" class="headerlink" title="1.5 InputMonitor.UpdateInputForAllWindowsConsumer.accept"></a>1.5 InputMonitor.UpdateInputForAllWindowsConsumer.accept</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(WindowState w)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里假设传入的WindowState是addWindow中新创建的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">InputWindowHandleWrapper</span> <span class="variable">inputWindowHandle</span> <span class="operator">=</span> w.mInputWindowHandle;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 注册事件拦截信息</span></span><br><span class="line">    mService.mKeyInterceptionInfoForToken.put(w.mInputChannelToken,</span><br><span class="line">            w.getKeyInterceptionInfo());</span><br><span class="line">    <span class="comment">// [1.5.1] mWinAnimator是WindowState初始化时构建的WindowStateAnimator对象</span></span><br><span class="line">    <span class="keyword">if</span> (w.mWinAnimator.hasSurface()) &#123;</span><br><span class="line">        <span class="comment">// [1.5.2] 计算更新该窗口的信息</span></span><br><span class="line">        populateInputWindowHandle(inputWindowHandle, w);</span><br><span class="line">        <span class="comment">// [1.5.3] 通知对应Surface更新窗口信息</span></span><br><span class="line">        setInputWindowInfoIfNeeded(mInputTransaction,</span><br><span class="line">                w.mWinAnimator.mSurfaceController.mSurfaceControl, inputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-1-WindowStateAnimator-hasSurface"><a href="#1-5-1-WindowStateAnimator-hasSurface" class="headerlink" title="1.5.1 WindowStateAnimator.hasSurface"></a>1.5.1 WindowStateAnimator.hasSurface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowStateAnimator.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasSurface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// mSurfaceController是WindowSurfaceController的对象</span></span><br><span class="line">    <span class="keyword">return</span> mSurfaceController != <span class="literal">null</span> &amp;&amp; mSurfaceController.hasSurface();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowSurfaceController.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasSurface</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// SurfaceControl对象，在WindowSurfaceController初始化时构建</span></span><br><span class="line">    <span class="keyword">return</span> mSurfaceControl != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowStateAnimator中的mSurfaceController是WindowSurfaceController的对象，在其对应的Window被调用relayoutWindow时通过winAnimator.createSurfaceLocked(win.mAttrs.type)创建的。 而relayoutWindow则是三方应用进程接收到Vsync信号之后，调用对应的ViewRootImpl中的performTraversals在通过Session通知到WMS执行的。在这里我们假设”android.anim”线程更新所有输入窗口时，这个新建的WindowState已经被调用过了relayoutWindow，存在Surface。</p><h3 id="1-5-2-InputMonitor-populateInputWindowHandle"><a href="#1-5-2-InputMonitor-populateInputWindowHandle" class="headerlink" title="1.5.2 InputMonitor.populateInputWindowHandle"></a>1.5.2 InputMonitor.populateInputWindowHandle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">populateInputWindowHandle</span><span class="params">(<span class="keyword">final</span> InputWindowHandleWrapper inputWindowHandle,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> WindowState w)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加一个窗口到可输入事件的窗口列表中</span></span><br><span class="line">    <span class="comment">// 设置窗口相关信息到inputWindowHandle中</span></span><br><span class="line">    inputWindowHandle.setInputApplicationHandle(w.mActivityRecord != <span class="literal">null</span></span><br><span class="line">            ? w.mActivityRecord.getInputApplicationHandle(<span class="literal">false</span> <span class="comment">/* update */</span>) : <span class="literal">null</span>);</span><br><span class="line">    inputWindowHandle.setToken(w.mInputChannelToken);</span><br><span class="line">    <span class="comment">// 设置该窗口的input超时时长，如果该WindowState对应Activity，这个时长就是5s</span></span><br><span class="line">    inputWindowHandle.setDispatchingTimeoutMillis(w.getInputDispatchingTimeoutMillis());</span><br><span class="line">    inputWindowHandle.setTouchOcclusionMode(w.getTouchOcclusionMode());</span><br><span class="line">    inputWindowHandle.setInputFeatures(w.mAttrs.inputFeatures);</span><br><span class="line">    inputWindowHandle.setPaused(w.mActivityRecord != <span class="literal">null</span> &amp;&amp; w.mActivityRecord.paused);</span><br><span class="line">    inputWindowHandle.setVisible(w.isVisible());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置是否可聚焦</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">focusable</span> <span class="operator">=</span> w.canReceiveKeys()</span><br><span class="line">            &amp;&amp; (mService.mPerDisplayFocusEnabled || mDisplayContent.isOnTop());</span><br><span class="line">    inputWindowHandle.setFocusable(focusable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含壁纸</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasWallpaper</span> <span class="operator">=</span> mDisplayContent.mWallpaperController.isWallpaperTarget(w)</span><br><span class="line">            &amp;&amp; !mService.mPolicy.isKeyguardShowing()</span><br><span class="line">            &amp;&amp; !mDisableWallpaperTouchEvents;</span><br><span class="line">    inputWindowHandle.setHasWallpaper(hasWallpaper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">frame</span> <span class="operator">=</span> w.getFrame();</span><br><span class="line">    <span class="comment">// 设置该窗口的位置和大小</span></span><br><span class="line">    inputWindowHandle.setFrame(frame.left, frame.top, frame.right, frame.bottom);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Surface insets 被硬编码为在所有方向上都是相同的，所以这里仅需一个参数</span></span><br><span class="line">    inputWindowHandle.setSurfaceInset(w.mAttrs.surfaceInsets.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缩放窗口，输入坐标需要反向缩放，将屏幕上的内容映射到UI中实际触摸的内容</span></span><br><span class="line">    inputWindowHandle.setScaleFactor(w.mGlobalScale != <span class="number">1f</span> ? (<span class="number">1f</span> / w.mGlobalScale) : <span class="number">1f</span>);</span><br><span class="line">    <span class="comment">// [1.5.2.1] 计算窗口可触摸区域</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> w.getSurfaceTouchableRegion(mTmpRegion, w.mAttrs.flags);</span><br><span class="line">    <span class="comment">// 将计算得到的可触摸区域保存在inputWindowHandle中</span></span><br><span class="line">    inputWindowHandle.setTouchableRegion(mTmpRegion);</span><br><span class="line">    inputWindowHandle.setLayoutParamsFlags(flags);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-1-WindowState-getSurfaceTouchableRegion"><a href="#1-5-2-1-WindowState-getSurfaceTouchableRegion" class="headerlink" title="1.5.2.1 WindowState.getSurfaceTouchableRegion"></a>1.5.2.1 WindowState.getSurfaceTouchableRegion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSurfaceTouchableRegion</span><span class="params">(Region region, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断该WindowState是否包含FLAG_NOT_TOUCH_MODAL和FLAG_NOT_FOCUSABLE，表明该窗口无法接收input以及无法作为焦点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">modal</span> <span class="operator">=</span> (flags &amp; (FLAG_NOT_TOUCH_MODAL | FLAG_NOT_FOCUSABLE)) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (modal) &#123;</span><br><span class="line">        flags |= FLAG_NOT_TOUCH_MODAL;</span><br><span class="line">        <span class="keyword">if</span> (mActivityRecord != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// [1.5.2.2] 将外部接触限制在活动根任务区域</span></span><br><span class="line">            updateRegionForModalActivityWindow(region);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 首先给一个足够大的可触摸区域，因为它是触摸模态</span></span><br><span class="line">            <span class="comment">// 窗口可能会在显示器上移动，所以可触摸区域应该足够大，以确保它覆盖整个显示器，无论它移动到哪里</span></span><br><span class="line">            <span class="comment">// 比如启动窗口</span></span><br><span class="line">            getDisplayContent().getBounds(mTmpRect);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">dw</span> <span class="operator">=</span> mTmpRect.width();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">dh</span> <span class="operator">=</span> mTmpRect.height();</span><br><span class="line">            region.set(-dw, -dh, dw + dw, dh + dh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将计算得到的窗口可触摸区域减去其不可触碰的区域</span></span><br><span class="line">        subtractTouchExcludeRegionIfNeeded(region);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Not modal</span></span><br><span class="line">        getTouchableRegion(region);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为基于Surface的坐标, 因为Android中坐标原点在左上角，Y轴正方向向下，X轴正方向向右</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">frame</span> <span class="operator">=</span> mWindowFrames.mFrame;</span><br><span class="line">    <span class="keyword">if</span> (frame.left != <span class="number">0</span> || frame.top != <span class="number">0</span>) &#123;</span><br><span class="line">        region.translate(-frame.left, -frame.top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>FLAG_NOT_TOUCH_MODAL: 允许窗口外的任何指针事件被发送到它后面的窗口, 即使这个窗口是可聚焦的。否则（不带此标志），窗口将消耗所有指针事件本身，而不管它们是否在窗口内。</li><li>FLAG_NOT_FOCUSABLE: 标记这个窗口永远不能接收触摸事件</li></ol><p>Android中坐标原点在左上角，Y轴正方向向下，X轴正方向向右，所以计算的窗口可触摸区域需要转换为基于Surface的坐标。</p><h4 id="1-5-2-2-WindowState-updateRegionForModalActivityWindow"><a href="#1-5-2-2-WindowState-updateRegionForModalActivityWindow" class="headerlink" title="1.5.2.2 WindowState.updateRegionForModalActivityWindow"></a>1.5.2.2 WindowState.updateRegionForModalActivityWindow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateRegionForModalActivityWindow</span><span class="params">(Region outRegion)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取内部边界的letterbox可触摸区域（一般不会设置的，这个就是&lt;activity&gt;中的android:maxAspectRatio属性）</span></span><br><span class="line">    mActivityRecord.getLetterboxInnerBounds(mTmpRect);</span><br><span class="line">    <span class="comment">// 假设此时mTmpRect为empty的</span></span><br><span class="line">    <span class="keyword">if</span> (mTmpRect.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// [1.5.2.3] 获取该ActivityRecord的View边界</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Rect</span> <span class="variable">transformedBounds</span> <span class="operator">=</span> mActivityRecord.getFixedRotationTransformDisplayBounds();</span><br><span class="line">        <span class="keyword">if</span> (transformedBounds != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Task与显示的方向相同，所以旋转的边界应该被选择为可触摸区域。当表面层将区域转换为显示空间时，方向是一致的。</span></span><br><span class="line">            mTmpRect.set(transformedBounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果这是一个模态窗口，我们需要dismiss它如果它不是全屏，触摸发生在显示内容的窗口之外</span></span><br><span class="line">            <span class="comment">// 这意味着我们需要拦截窗口外的触摸。与窗口(任务或根任务)相关联的dim layer将给一个界限，因为它们将用于显示dim layer</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> getTask();</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// [1.5.2.4] 通过该WindowState所在Task获取该窗口的可触摸区域</span></span><br><span class="line">                task.getDimBounds(mTmpRect);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getRootTask() != <span class="literal">null</span>) &#123;</span><br><span class="line">                getRootTask().getDimBounds(mTmpRect);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前窗口是freeform窗口模式时，调整区域大小</span></span><br><span class="line">    adjustRegionInFreefromWindowMode(mTmpRect);</span><br><span class="line">    <span class="comment">// 将计算后的可触摸区域大小复制给outRegion使用</span></span><br><span class="line">    outRegion.set(mTmpRect);</span><br><span class="line">    <span class="comment">// 根据坐标系调整RootTask边界大小</span></span><br><span class="line">    cropRegionToRootTaskBoundsIfNeeded(outRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityRecord.getLetterboxInnerBounds是获取内部边界的letterbox可触摸区域;一般不会设置的，这个就是<activity>中的android:maxAspectRatio属性。</activity></p><p>至于freeform模式的窗口调整区域大小以及根据坐标系调整RootTask边界，感兴趣的可以继续研究。这里仅须知道窗口的可触摸区域是怎么拿到的即可。</p><h4 id="1-5-2-3-ActivityRecord-getFixedRotationTransformDisplayBounds"><a href="#1-5-2-3-ActivityRecord-getFixedRotationTransformDisplayBounds" class="headerlink" title="1.5.2.3 ActivityRecord.getFixedRotationTransformDisplayBounds"></a>1.5.2.3 ActivityRecord.getFixedRotationTransformDisplayBounds</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Rect <span class="title function_">getFixedRotationTransformDisplayBounds</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isFixedRotationTransforming()</span><br><span class="line">            ? mFixedRotationTransformState.mRotatedOverrideConfiguration.windowConfiguration</span><br><span class="line">                    .getBounds()</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isFixedRotationTransforming</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mFixedRotationTransformState != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mFixedRotationTransformState.mIsTransforming;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mFixedRotationTransformState是当手机方向旋转之后就会生成的， 这里我们假设没有发生旋转。</p><h4 id="1-5-2-4-Task-getDimBounds"><a href="#1-5-2-4-Task-getDimBounds" class="headerlink" title="1.5.2.4 Task.getDimBounds"></a>1.5.2.4 Task.getDimBounds</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getDimBounds</span><span class="params">(Rect out)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前task是RootTask, 那么直接返回其边界大小</span></span><br><span class="line">    <span class="keyword">if</span> (isRootTask()) &#123;</span><br><span class="line">        getBounds(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">rootTask</span> <span class="operator">=</span> getRootTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> rootTask.getDisplayContent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">dockedResizing</span> <span class="operator">=</span> displayContent != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; displayContent.mDividerControllerLocked.isResizing();</span><br><span class="line">    <span class="comment">// 判断该Task的WindowMode是否是Freeform模式，如果是，则找到该Task中最大的可见的区域</span></span><br><span class="line">    <span class="keyword">if</span> (inFreeformWindowingMode()) &#123;</span><br><span class="line">        <span class="type">boolean</span>[] foundTop = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PooledConsumer</span> <span class="variable">c</span> <span class="operator">=</span> PooledLambda.obtainConsumer(Task::getMaxVisibleBounds,</span><br><span class="line">                PooledLambda.__(ActivityRecord.class), out, foundTop);</span><br><span class="line">        forAllActivities(c);</span><br><span class="line">        c.recycle();</span><br><span class="line">        <span class="keyword">if</span> (foundTop[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前task和父容器边界不匹配(此状态发生在回到home最小化task时)，假设是匹配的</span></span><br><span class="line">    <span class="keyword">if</span> (!matchParentBounds()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dockedResizing) &#123;</span><br><span class="line">            rootTask.getBounds(out);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rootTask.getBounds(mTmpRect);</span><br><span class="line">            <span class="comment">// 取两个边界的交集</span></span><br><span class="line">            mTmpRect.intersect(getBounds());</span><br><span class="line">            out.set(mTmpRect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 边界直接用当前task边界</span></span><br><span class="line">        out.set(getBounds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口模式有如下7种：</p><table><thead><tr><th>窗口模式</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>WINDOWING_MODE_UNDEFINED</td><td>0</td><td>当前窗口模式尚未定义</td></tr><tr><td>WINDOWING_MODE_FULLSCREEN</td><td>1</td><td>占据屏幕或父容器的整个区域</td></tr><tr><td>WINDOWING_MODE_PINNED</td><td>2</td><td>总是在顶部(总是可见, 覆盖它的父容器中的其他兄弟容器)</td></tr><tr><td>WINDOWING_MODE_SPLIT_SCREEN_PRIMARY</td><td>3</td><td>驱动屏幕处于分屏模式的主容器</td></tr><tr><td>WINDOWING_MODE_SPLIT_SCREEN_SECONDARY</td><td>4</td><td>在分屏模式下，紧邻WINDOWING_MODE_SPLIT_SCREEN_PRIMARY容器的容器</td></tr><tr><td>WINDOWING_MODE_FREEFORM</td><td>5</td><td>可以在其父容器内自由调整大小，如悬浮窗</td></tr><tr><td>WINDOWING_MODE_MULTI_WINDOW</td><td>6</td><td>窗口管理器中没有表示属性的通用多窗口</td></tr></tbody></table><p>获取Task的边界大小的过程如下:</p><ol><li>如果当前Task就是RootTask, 那么直接返回该Task的边界</li><li>判断该Task的WindowMode是否是Freeform模式，如果是，则找到该Task中最大的可见的区域并返回</li><li>当前Task和父容器边界不匹配时<ol><li>如果该Task被最小化时，直接返回该Task的RootTask的边界</li><li>否则获取RootTask边界与当前Task边界的交集并返回</li></ol></li><li>当前Task和父容器边界匹配时<ol><li>直接返回该Task的边界</li></ol></li></ol><h3 id="1-5-3-InputMonitor-setInputWindowInfoIfNeeded"><a href="#1-5-3-InputMonitor-setInputWindowInfoIfNeeded" class="headerlink" title="1.5.3 InputMonitor.setInputWindowInfoIfNeeded"></a>1.5.3 InputMonitor.setInputWindowInfoIfNeeded</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setInputWindowInfoIfNeeded</span><span class="params">(SurfaceControl.Transaction t, SurfaceControl sc,</span></span><br><span class="line"><span class="params">        InputWindowHandleWrapper inputWindowHandle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INPUT) &#123;</span><br><span class="line">        Slog.d(TAG_WM, <span class="string">&quot;Update InputWindowHandle: &quot;</span> + inputWindowHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 [1.5.2] 有更新内容，所以isChanged必然返回true</span></span><br><span class="line">    <span class="keyword">if</span> (inputWindowHandle.isChanged()) &#123;</span><br><span class="line">        <span class="comment">// [1.5.4] 更新给Surface</span></span><br><span class="line">        inputWindowHandle.applyChangesToSurface(t, sc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-InputWindowHandleWrapper-applyChangesToSurface"><a href="#1-5-4-InputWindowHandleWrapper-applyChangesToSurface" class="headerlink" title="1.5.4 InputWindowHandleWrapper.applyChangesToSurface"></a>1.5.4 InputWindowHandleWrapper.applyChangesToSurface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applyChangesToSurface</span><span class="params">(<span class="meta">@NonNull</span> SurfaceControl.Transaction t, <span class="meta">@NonNull</span> SurfaceControl sc)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.5.5] 通过Transaction传递信息</span></span><br><span class="line">    t.setInputWindowInfo(sc, mHandle);</span><br><span class="line">    mChanged = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-SurfaceControl-Transaction-setInputWindowInfo"><a href="#1-5-5-SurfaceControl-Transaction-setInputWindowInfo" class="headerlink" title="1.5.5 SurfaceControl.Transaction.setInputWindowInfo"></a>1.5.5 SurfaceControl.Transaction.setInputWindowInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transaction <span class="title function_">setInputWindowInfo</span><span class="params">(SurfaceControl sc, InputWindowHandle handle)</span> &#123;</span><br><span class="line">    <span class="comment">// 确认该SurfaceControl没有被释放</span></span><br><span class="line">    checkPreconditions(sc);</span><br><span class="line">    <span class="comment">// [1.5.6] 通知给SurfaceFlinger</span></span><br><span class="line">    nativeSetInputWindowInfo(mNativeObject, sc.mNativeObject, handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeSetInputWindowInfo</span><span class="params">(<span class="type">long</span> transactionObj, <span class="type">long</span> nativeObject,</span></span><br><span class="line"><span class="params">        InputWindowHandle handle)</span>;</span><br></pre></td></tr></table></figure><h3 id="1-5-6-android-view-SurfaceControl-nativeSetInputWindowInfo"><a href="#1-5-6-android-view-SurfaceControl-nativeSetInputWindowInfo" class="headerlink" title="1.5.6 android_view_SurfaceControl.nativeSetInputWindowInfo"></a>1.5.6 android_view_SurfaceControl.nativeSetInputWindowInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeSetInputWindowInfo</span><span class="params">(JNIEnv* env, jclass clazz, jlong transactionObj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong nativeObject, jobject inputWindow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> transaction = <span class="built_in">reinterpret_cast</span>&lt;SurfaceComposerClient::Transaction*&gt;(transactionObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.5.6.1] 根据传入的InputWindowHandle获取NativeInputWindowHandle</span></span><br><span class="line">    sp&lt;NativeInputWindowHandle&gt; handle = <span class="built_in">android_view_InputWindowHandle_getHandle</span>(</span><br><span class="line">            env, inputWindow);</span><br><span class="line">    <span class="comment">// [1.5.6.2] 更新NativeInputWindowHandle信息</span></span><br><span class="line">    handle-&gt;<span class="built_in">updateInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ctrl = <span class="built_in">reinterpret_cast</span>&lt;SurfaceControl *&gt;(nativeObject);</span><br><span class="line">    <span class="comment">// [1.5.6.3] 通知给SurfaceFligner</span></span><br><span class="line">    transaction-&gt;<span class="built_in">setInputWindowInfo</span>(ctrl, *handle-&gt;<span class="built_in">getInfo</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-6-1-android-hardware-input-InputWindowHandle-android-view-InputWindowHandle-getHandle"><a href="#1-5-6-1-android-hardware-input-InputWindowHandle-android-view-InputWindowHandle-getHandle" class="headerlink" title="1.5.6.1 android_hardware_input_InputWindowHandle.android_view_InputWindowHandle_getHandle"></a>1.5.6.1 android_hardware_input_InputWindowHandle.android_view_InputWindowHandle_getHandle</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;NativeInputWindowHandle&gt; <span class="title">android_view_InputWindowHandle_getHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env, jobject inputWindowHandleObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inputWindowHandleObj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(gHandleMutex);</span><br><span class="line">    <span class="comment">// 获取inputWindowHandle中对应的ptr, 该ptr就对应NativeInputWindowHandle</span></span><br><span class="line">    jlong ptr = env-&gt;<span class="built_in">GetLongField</span>(inputWindowHandleObj, gInputWindowHandleClassInfo.ptr);</span><br><span class="line">    NativeInputWindowHandle* handle;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        handle = <span class="built_in">reinterpret_cast</span>&lt;NativeInputWindowHandle*&gt;(ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果该ptr为0，那就创建一个NativeInputWindowHandle并赋值给java层的ptr中</span></span><br><span class="line">        jweak objWeak = env-&gt;<span class="built_in">NewWeakGlobalRef</span>(inputWindowHandleObj);</span><br><span class="line">        handle = <span class="keyword">new</span> <span class="built_in">NativeInputWindowHandle</span>(objWeak);</span><br><span class="line">        handle-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span>*)android_view_InputWindowHandle_getHandle);</span><br><span class="line">        env-&gt;<span class="built_in">SetLongField</span>(inputWindowHandleObj, gInputWindowHandleClassInfo.ptr,</span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(handle));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-6-2-NativeInputWindowHandle-updateInfo"><a href="#1-5-6-2-NativeInputWindowHandle-updateInfo" class="headerlink" title="1.5.6.2 NativeInputWindowHandle.updateInfo"></a>1.5.6.2 NativeInputWindowHandle.updateInfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">NativeInputWindowHandle::updateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mInfo.touchableRegion.<span class="built_in">clear</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 更新可触碰区域</span></span><br><span class="line">    jobject regionObj = env-&gt;<span class="built_in">GetObjectField</span>(obj,</span><br><span class="line">            gInputWindowHandleClassInfo.touchableRegion);</span><br><span class="line">    <span class="keyword">if</span> (regionObj) &#123;</span><br><span class="line">        <span class="keyword">for</span> (graphics::RegionIterator <span class="built_in">it</span>(env, regionObj); !it.<span class="built_in">isDone</span>(); it.<span class="built_in">next</span>()) &#123;</span><br><span class="line">            ARect rect = it.<span class="built_in">getRect</span>();</span><br><span class="line">            mInfo.<span class="built_in">addTouchableRegion</span>(<span class="built_in">Rect</span>(rect.left, rect.top, rect.right, rect.bottom));</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(regionObj);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将java层InputWindowHandle里的信息同步给NativeInputWindowHandle.</p><h4 id="1-5-6-3-SurfaceComposerClient-Transaction-setInputWindowInfo"><a href="#1-5-6-3-SurfaceComposerClient-Transaction-setInputWindowInfo" class="headerlink" title="1.5.6.3 SurfaceComposerClient::Transaction.setInputWindowInfo"></a>1.5.6.3 SurfaceComposerClient::Transaction.setInputWindowInfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::Transaction&amp; SurfaceComposerClient::Transaction::<span class="built_in">setInputWindowInfo</span>(</span><br><span class="line">        <span class="type">const</span> sp&lt;SurfaceControl&gt;&amp; sc,</span><br><span class="line">        <span class="type">const</span> InputWindowInfo&amp; info) &#123;</span><br><span class="line">    <span class="comment">// 根据SurfaceControl获取对应的layer状态</span></span><br><span class="line">    <span class="type">layer_state_t</span>* s = <span class="built_in">getLayerState</span>(sc);</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        mStatus = BAD_INDEX;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将InputWindowInfo转成InputWindowHandle存在layer中</span></span><br><span class="line">    s-&gt;inputHandle = <span class="keyword">new</span> <span class="built_in">InputWindowHandle</span>(info);</span><br><span class="line">    <span class="comment">// 标记该layer输入信息有更改</span></span><br><span class="line">    s-&gt;what |= <span class="type">layer_state_t</span>::eInputInfoChanged;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是将窗口相关信息存入了SurfaceFling中，至于怎么传输的，为什么需要这些信息，我们后续研究WMS的窗口和SurfaceFlinger的关系时分析。</p><h2 id="1-6-InputMonitor-updateInputFocusRequest"><a href="#1-6-InputMonitor-updateInputFocusRequest" class="headerlink" title="1.6 InputMonitor.updateInputFocusRequest"></a>1.6 InputMonitor.updateInputFocusRequest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateInputFocusRequest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">focus</span> <span class="operator">=</span> mDisplayContent.mCurrentFocus;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">focusToken</span> <span class="operator">=</span> focus != <span class="literal">null</span> ? focus.mInputChannelToken : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    requestFocus(focusToken, focus.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">requestFocus</span><span class="params">(IBinder focusToken, String windowName)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mInputFocus = focusToken;</span><br><span class="line">    <span class="comment">// 通过Transaction更新input系统中的焦点窗口</span></span><br><span class="line">    mInputTransaction.setFocusedWindow(mInputFocus, windowName, mDisplayId);</span><br><span class="line">    EventLog.writeEvent(LOGTAG_INPUT_FOCUS, <span class="string">&quot;Focus request &quot;</span> + windowName,</span><br><span class="line">            <span class="string">&quot;reason=UpdateInputWindows&quot;</span>);</span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;Focus requested for window=%s&quot;</span>, windowName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意mInputTransaction其实还是SurfaceControl.Transaction类， 在InputMonitor初始化时创建的:</p><blockquote><p>mInputTransaction &#x3D; mService.mTransactionFactory.get();</p></blockquote><h2 id="1-6-1-SurfaceControl-setFocusedWindow"><a href="#1-6-1-SurfaceControl-setFocusedWindow" class="headerlink" title="1.6.1 SurfaceControl.setFocusedWindow"></a>1.6.1 SurfaceControl.setFocusedWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Transaction <span class="title function_">setFocusedWindow</span><span class="params">(<span class="meta">@NonNull</span> IBinder token, String windowName,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    nativeSetFocusedWindow(mNativeObject, token,  windowName,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* focusedToken */</span>, <span class="literal">null</span> <span class="comment">/* focusedWindowName */</span>, displayId);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeSetFocusedWindow</span><span class="params">(<span class="type">long</span> transactionObj, IBinder toToken,</span></span><br><span class="line"><span class="params">        String windowName, IBinder focusedToken, String focusedWindowName, <span class="type">int</span> displayId)</span>;</span><br></pre></td></tr></table></figure><p>通过JNI调用到native层：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_SurfaceControl.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeSetFocusedWindow</span><span class="params">(JNIEnv* env, jclass clazz, jlong transactionObj,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   jobject toTokenObj, jstring windowNameJstr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   jobject focusedTokenObj, jstring focusedWindowNameJstr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   jint displayId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> transaction = <span class="built_in">reinterpret_cast</span>&lt;SurfaceComposerClient::Transaction*&gt;(transactionObj);</span><br><span class="line">    <span class="keyword">if</span> (toTokenObj == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// toTokenObj就是mInputChannelToken</span></span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">toToken</span><span class="params">(ibinderForJavaObject(env, toTokenObj))</span></span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    FocusRequest request;</span><br><span class="line">    request.token = toToken;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    transaction-&gt;<span class="built_in">setFocusedWindow</span>(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceComposerClient.cpp</span></span><br><span class="line">SurfaceComposerClient::Transaction&amp; SurfaceComposerClient::Transaction::<span class="built_in">setFocusedWindow</span>(</span><br><span class="line">        <span class="type">const</span> FocusRequest&amp; request) &#123;</span><br><span class="line">    mInputWindowCommands.focusRequests.<span class="built_in">push_back</span>(request);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将传入的焦点窗口的mInputChannelToken和其他信息打包封装在FocusRequest中，存入SurfaceComposerClient的mInputWindowCommands.focusRequests集合中。</p><p>那么这个mInputWindowCommands.focusRequests是什么时候使用的呢，当调用SurfaceControl.Transaction.apply()函数时，会通过binder将该Transaction的所有信息传递给SurfaceFlinger进程（sf-&gt;setTransactionState接口），SurfaceFlinger接收到该Transaction后将其保存在mTransactionQueue队列中。然后在下一次Vsync信号来临时，即onMessageInvalidate函数中，将Transaction从mTransactionQeue中提取出来存入mPendingTransactionQueues队列中，于此同时调用addInputWindowCommands将该Transaction中的inputWindowHandles保存在SurfaceFlinger的mInputWindowCommands中，之后就调用updateInputFlinger()将mInputWindowCommands中的focusRequests更新到InputFlinger中。</p><h3 id="1-6-2-SurfaceFlinger-updateInputFlinger"><a href="#1-6-2-SurfaceFlinger-updateInputFlinger" class="headerlink" title="1.6.2 SurfaceFlinger.updateInputFlinger"></a>1.6.2 SurfaceFlinger.updateInputFlinger</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::updateInputFlinger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">if</span> (!mInputFlinger) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可视区域有更新或者输入信息更改需要通知InputFlinger</span></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty || mInputInfoChanged) &#123;</span><br><span class="line">        mInputInfoChanged = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// [2.1] 更新窗口输入信息至InputFlinger</span></span><br><span class="line">        <span class="built_in">updateInputWindowInfo</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInputWindowCommands.syncInputWindows) &#123;</span><br><span class="line">        <span class="comment">// If the caller requested to sync input windows, but there are no</span></span><br><span class="line">        <span class="comment">// changes to input windows, notify immediately.</span></span><br><span class="line">        <span class="built_in">setInputWindowsFinished</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有focusRequests，依次通知给InputFlinger更新焦点窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; focusRequest : mInputWindowCommands.focusRequests) &#123;</span><br><span class="line">        <span class="comment">// [3.1] 将焦点窗口同步更新给InputFlinger</span></span><br><span class="line">        mInputFlinger-&gt;<span class="built_in">setFocusedWindow</span>(focusRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    mInputWindowCommands.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-Window信息更新至InputFlinger"><a href="#二-Window信息更新至InputFlinger" class="headerlink" title="二. Window信息更新至InputFlinger"></a>二. Window信息更新至InputFlinger</h1><p>上面我们分析了窗口的信息的收集过程，重点是可触碰区域的计算，现在我们分析一下窗口信息传递给InputFlinger的过程。</p><h2 id="2-1-SurfaceFlinger-updateInputWindowInfo"><a href="#2-1-SurfaceFlinger-updateInputWindowInfo" class="headerlink" title="2.1 SurfaceFlinger.updateInputWindowInfo"></a>2.1 SurfaceFlinger.updateInputWindowInfo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::updateInputWindowInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;InputWindowInfo&gt; inputInfos;</span><br><span class="line">    <span class="comment">// mDrawingState我们之前有过分析，这里存储了所有需要更新的图层集</span></span><br><span class="line">    <span class="comment">// 遍历所有的图层，依次计算该layer的输入窗口信息</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 2.2 在计算屏幕边界时，忽略透明区域， 因为它可能导致不必要的偏移量</span></span><br><span class="line">        <span class="comment">// 将计算结果保存在inputInfos中, 每次都是添加到队列尾部</span></span><br><span class="line">        inputInfos.<span class="built_in">push_back</span>(layer-&gt;<span class="built_in">fillInputInfo</span>(display));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3 将计算结果传递给InputFlinger</span></span><br><span class="line">    mInputFlinger-&gt;<span class="built_in">setInputWindows</span>(inputInfos,</span><br><span class="line">                               mInputWindowCommands.syncInputWindows ? mSetInputWindowsListener</span><br><span class="line">                                                                     : <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是遍历所有的需要更新的Layer, 依次计算该Layer对应的窗口可触摸区域，将结果保存在InputWindowInfo的Vector中，然后通过Binder传给InputFlinger进程。</p><p>注意这里对layer的遍历是沿着Z轴反方向的，也就是从上到下的遍历顺序。layer在上面，存入inputInfos队列前面。</p><h2 id="2-2-Layer-fillInputInfo"><a href="#2-2-Layer-fillInputInfo" class="headerlink" title="2.2 Layer.fillInputInfo"></a>2.2 Layer.fillInputInfo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputWindowInfo <span class="title">Layer::fillInputInfo</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; display)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    InputWindowInfo info = mDrawingState.inputInfo;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [2.2.1] 再次计算可触摸区域</span></span><br><span class="line">    <span class="built_in">fillInputFrameInfo</span>(info, toPhysicalDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断该窗口是否可见</span></span><br><span class="line">    info.visible = <span class="built_in">hasInputInfo</span>() ? <span class="built_in">canReceiveInput</span>() : <span class="built_in">isVisible</span>();</span><br><span class="line">    info.alpha = <span class="built_in">getAlpha</span>();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据显示屏再次计算可触摸区域以及其他相关信息。</p><h3 id="2-2-1-Layer-fillInputFrameInfo"><a href="#2-2-1-Layer-fillInputFrameInfo" class="headerlink" title="2.2.1 Layer.fillInputFrameInfo"></a>2.2.1 Layer.fillInputFrameInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::fillInputFrameInfo</span><span class="params">(InputWindowInfo&amp; info, <span class="type">const</span> ui::Transform&amp; toPhysicalDisplay)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 变换图层大小到屏幕空间</span></span><br><span class="line">    Rect layerBounds = info.portalToDisplayId == ADISPLAY_ID_NONE</span><br><span class="line">            ? <span class="built_in">getInputBounds</span>()</span><br><span class="line">            : info.touchableRegion.<span class="built_in">getBounds</span>();</span><br><span class="line">    ......</span><br><span class="line">    ui::Transform layerToDisplay = <span class="built_in">getInputTransform</span>();</span><br><span class="line">    <span class="comment">// 将窗口坐标转换为非旋转显示坐标的转换</span></span><br><span class="line">    ui::Transform t = toPhysicalDisplay * layerToDisplay;</span><br><span class="line">    ......</span><br><span class="line">    ui::Transform inverseTransform = t.<span class="built_in">inverse</span>();</span><br><span class="line">    Rect nonTransformedBounds = inverseTransform.<span class="built_in">transform</span>(transformedLayerBounds);</span><br><span class="line">    vec2 translation = t.<span class="built_in">transform</span>(nonTransformedBounds.left, nonTransformedBounds.top);</span><br><span class="line">    <span class="function">ui::Transform <span class="title">inputTransform</span><span class="params">(t)</span></span>;</span><br><span class="line">    inputTransform.<span class="built_in">set</span>(translation.x, translation.y);</span><br><span class="line">    info.transform = inputTransform.<span class="built_in">inverse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要将裁剪的图层边界发送到屏幕边界，因为图层可以被裁剪</span></span><br><span class="line">    <span class="comment">// frame应该是用户在屏幕上看到的区域，被用于遮挡检测</span></span><br><span class="line">    transformedLayerBounds.<span class="built_in">intersect</span>(screenBounds, &amp;transformedLayerBounds);</span><br><span class="line">    info.frameLeft = transformedLayerBounds.left;</span><br><span class="line">    info.frameTop = transformedLayerBounds.top;</span><br><span class="line">    info.frameRight = transformedLayerBounds.right;</span><br><span class="line">    info.frameBottom = transformedLayerBounds.bottom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对于框架屏幕位置定位可触摸区域，并将其限制在框架边界</span></span><br><span class="line">    info.touchableRegion = inputTransform.<span class="built_in">transform</span>(info.touchableRegion);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们在WMS中有计算过可触摸区域，但通过SurfaceFlinger还是需要更加Display实际大小等加工一下，确定最终窗口的可触摸区域。</p><p>这里的计算过程就不展开分析了，感兴趣的可以自行研究。</p><h2 id="2-3-InputFlinger-setInputWindows"><a href="#2-3-InputFlinger-setInputWindows" class="headerlink" title="2.3 InputFlinger.setInputWindows"></a>2.3 InputFlinger.setInputWindows</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">binder::Status <span class="title">InputManager::setInputWindows</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;InputWindowInfo&gt;&amp; infos,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;ISetInputWindowsListener&gt;&amp; setInputWindowsListener)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int32_t</span>, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&gt; handlesPerDisplay;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; handles;</span><br><span class="line">    <span class="comment">// 将从SF传过来的InputWindowInfo信息打包成BinderWindowHandle</span></span><br><span class="line">    <span class="comment">// 存入对应DisplayId的InputWindowHandle集合中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info : infos) &#123;</span><br><span class="line">        <span class="comment">// 注意这里是emplace，每次都是插入队列头部，相当于将infos中元素反向排列了</span></span><br><span class="line">        handlesPerDisplay.<span class="built_in">emplace</span>(info.displayId, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;());</span><br><span class="line">        handlesPerDisplay[info.displayId].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">BinderWindowHandle</span>(info));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.4 交给InputDispatcher处理</span></span><br><span class="line">    mDispatcher-&gt;<span class="built_in">setInputWindows</span>(handlesPerDisplay);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setInputWindowsListener) &#123;</span><br><span class="line">        setInputWindowsListener-&gt;<span class="built_in">onSetInputWindowsFinished</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binder::Status::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinderWindowHandle就是个包装类，继承了InputWindowHandle，并且重写了updateInfo, 内部只有一个InputWindowHandle的成员变量。这是为了避免后续不小心更新窗口信息。</p><p>这里将从SF传过来的InputWindowInfo信息打包成BinderWindowHandle，存入对应DisplayId的InputWindowHandle集合中，然后交给InputDispatcher处理。</p><h2 id="2-4-InputDispatcher-setInputWindows"><a href="#2-4-InputDispatcher-setInputWindows" class="headerlink" title="2.4 InputDispatcher.setInputWindows"></a>2.4 InputDispatcher.setInputWindows</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::setInputWindows</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::unordered_map&lt;<span class="type">int32_t</span>, std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&gt;&amp; handlesPerDisplay)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [displayId, handles] : handlesPerDisplay) &#123;</span><br><span class="line">            <span class="built_in">setInputWindowsLocked</span>(handles, displayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒轮询循环，可能需要做出新的输入分派选择</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有的Display依次更新输入窗口信息, 然后唤醒轮询循环，做出新的输入分派选择。</p><h2 id="2-5-InputDispatcher-setInputWindowsLocked"><a href="#2-5-InputDispatcher-setInputWindowsLocked" class="headerlink" title="2.5 InputDispatcher.setInputWindowsLocked"></a>2.5 InputDispatcher.setInputWindowsLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::setInputWindowsLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; inputWindowHandles, <span class="type">int32_t</span> displayId)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取当前所有的输入窗口handle用于relase</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; oldWindowHandles = <span class="built_in">getWindowHandlesLocked</span>(displayId);</span><br><span class="line">    <span class="comment">// 更新输入窗口信息列表，就是将新窗口输入信息保存在mWindowHandlesByDisplay中</span></span><br><span class="line">    <span class="built_in">updateWindowHandlesForDisplayLocked</span>(inputWindowHandles, displayId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 确认windowHandles列表中包含焦点窗口，如果不存在找上一次的焦点窗口作为当前焦点</span></span><br><span class="line">    std::optional&lt;FocusResolver::FocusChanges&gt; changes =</span><br><span class="line">            mFocusResolver.<span class="built_in">setInputWindows</span>(displayId, windowHandles);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; oldWindowHandle : oldWindowHandles) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getWindowHandleLocked</span>(oldWindowHandle) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 将不在展示的窗口信息释放掉，节省资源</span></span><br><span class="line">            oldWindowHandle-&gt;<span class="built_in">releaseChannel</span>();</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::updateWindowHandlesForDisplayLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; inputWindowHandles, <span class="type">int32_t</span> displayId)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    std::vector&lt;sp&lt;InputWindowHandle&gt;&gt; newHandles;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; handle : inputWindowHandles) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> ((oldHandlesById.<span class="built_in">find</span>(handle-&gt;<span class="built_in">getId</span>()) != oldHandlesById.<span class="built_in">end</span>()) &amp;&amp;</span><br><span class="line">                (oldHandlesById.<span class="built_in">at</span>(handle-&gt;<span class="built_in">getId</span>())-&gt;<span class="built_in">getToken</span>() == handle-&gt;<span class="built_in">getToken</span>())) &#123;</span><br><span class="line">            <span class="type">const</span> sp&lt;InputWindowHandle&gt;&amp; oldHandle = oldHandlesById.<span class="built_in">at</span>(handle-&gt;<span class="built_in">getId</span>());</span><br><span class="line">            oldHandle-&gt;<span class="built_in">updateFrom</span>(handle);</span><br><span class="line">            newHandles.<span class="built_in">push_back</span>(oldHandle);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// push_back是向队列尾部添加元素</span></span><br><span class="line">            newHandles.<span class="built_in">push_back</span>(handle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存新的窗口输入信息至mWindowHandlesByDisplay中.</span></span><br><span class="line">    mWindowHandlesByDisplay[displayId] = newHandles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是更新窗口输入信息至mWindowHandlesByDisplay，将不在展示的窗口信息释放掉，节省资源。</p><h1 id="三-更新InputFlinger的焦点窗口"><a href="#三-更新InputFlinger的焦点窗口" class="headerlink" title="三. 更新InputFlinger的焦点窗口"></a>三. 更新InputFlinger的焦点窗口</h1><p>SurfaceFlinger通过binder将焦点窗口同步更新给InputFlinger。</p><h2 id="3-1-InputFlinger-setFocusedWindow"><a href="#3-1-InputFlinger-setFocusedWindow" class="headerlink" title="3.1 InputFlinger.setFocusedWindow"></a>3.1 InputFlinger.setFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">binder::Status <span class="title">InputManager::setFocusedWindow</span><span class="params">(<span class="type">const</span> FocusRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [3.2] 交给InputDispatcher更新焦点窗口</span></span><br><span class="line">    mDispatcher-&gt;<span class="built_in">setFocusedWindow</span>(request);</span><br><span class="line">    <span class="keyword">return</span> binder::Status::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-InputDispatcher-setFocusedWindow"><a href="#3-2-InputDispatcher-setFocusedWindow" class="headerlink" title="3.2 InputDispatcher.setFocusedWindow"></a>3.2 InputDispatcher.setFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::setFocusedWindow</span><span class="params">(<span class="type">const</span> FocusRequest&amp; request)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        <span class="comment">// [3.3] 获取当前display中所有的窗口输入信息，交给FocusResolver更新焦点窗口</span></span><br><span class="line">        std::optional&lt;FocusResolver::FocusChanges&gt; changes =</span><br><span class="line">                mFocusResolver.<span class="built_in">setFocusedWindow</span>(request, <span class="built_in">getWindowHandlesLocked</span>(request.displayId));</span><br><span class="line">        <span class="keyword">if</span> (changes) &#123;</span><br><span class="line">            <span class="comment">// 响应焦点窗口更新</span></span><br><span class="line">            <span class="built_in">onFocusChangedLocked</span>(*changes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="comment">// Wake up poll loop since it may need to make new input dispatching choices.</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-FocusResolver-setFocusedWindow"><a href="#3-3-FocusResolver-setFocusedWindow" class="headerlink" title="3.3 FocusResolver.setFocusedWindow"></a>3.3 FocusResolver.setFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;FocusResolver::FocusChanges&gt; <span class="title">FocusResolver::setFocusedWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> FocusRequest&amp; request, <span class="type">const</span> std::vector&lt;sp&lt;InputWindowHandle&gt;&gt;&amp; windows)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int32_t</span> displayId = request.displayId;</span><br><span class="line">    <span class="comment">// 如果当前焦点窗口就是需要设置的窗口，直接返回</span></span><br><span class="line">    <span class="type">const</span> sp&lt;IBinder&gt; currentFocus = <span class="built_in">getFocusedWindowToken</span>(displayId);</span><br><span class="line">    <span class="keyword">if</span> (currentFocus == request.token) &#123;</span><br><span class="line">        <span class="built_in">ALOGD_IF</span>(DEBUG_FOCUS,</span><br><span class="line">                 <span class="string">&quot;setFocusedWindow %s on display %&quot;</span> PRId32 <span class="string">&quot; ignored, reason: already focused&quot;</span>,</span><br><span class="line">                 request.windowName.<span class="built_in">c_str</span>(), displayId);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理焦点请求，即具有焦点令牌的请求。这些请求不是持久的。如果窗口不再可聚焦，焦点返回到先前聚焦的窗口</span></span><br><span class="line">    <span class="comment">// 在[1.6.1] SurfaceControl.setFocusedWindow实际传入的focusedToken是null的，这里我们也假设为null好了</span></span><br><span class="line">    <span class="keyword">if</span> (request.focusedToken) &#123;</span><br><span class="line">        .......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查传入的待聚焦的窗口是否可聚焦且在windows列表中</span></span><br><span class="line">    Focusability result = <span class="built_in">isTokenFocusable</span>(request.token, windows);</span><br><span class="line">    <span class="comment">// 响应焦点请求</span></span><br><span class="line">    mFocusRequestByDisplay[displayId] = request;</span><br><span class="line">    mLastFocusResultByDisplay[displayId] = result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == Focusability::OK) &#123;</span><br><span class="line">        <span class="comment">// [3.4] 更新焦点窗口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">updateFocusedWindow</span>(displayId, <span class="string">&quot;setFocusedWindow&quot;</span>, request.token,</span><br><span class="line">                                   request.windowName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求的窗口当前不能聚焦。等待窗口变成可聚焦的，但从当前窗口移除焦点，以便输入事件可以进入挂起队列，并在窗口变成聚焦时发送到窗口。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">updateFocusedWindow</span>(displayId, <span class="string">&quot;Waiting for window because &quot;</span> + NamedEnum::<span class="built_in">string</span>(result),</span><br><span class="line">                               <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前焦点窗口就是需要设置的窗口，直接返回。然后检查传入的待聚焦的窗口是否可聚焦且在windows列表中， 更新mFocusRequestByDisplay和mLastFocusResultByDisplay，最后无论待更新的焦点窗口是否可聚焦，都更新焦点窗口，即将焦点窗口token（对应InputChannel的token）保存在mFocusedWindowTokenByDisplay中。</p><h2 id="3-4-FocusResolver-updateFocusedWindow"><a href="#3-4-FocusResolver-updateFocusedWindow" class="headerlink" title="3.4 FocusResolver.updateFocusedWindow"></a>3.4 FocusResolver.updateFocusedWindow</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;FocusResolver::FocusChanges&gt; <span class="title">FocusResolver::updateFocusedWindow</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> displayId, <span class="type">const</span> std::string&amp; reason, <span class="type">const</span> sp&lt;IBinder&gt;&amp; newFocus,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::string&amp; tokenName)</span> </span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; oldFocus = <span class="built_in">getFocusedWindowToken</span>(displayId);</span><br><span class="line">    <span class="keyword">if</span> (newFocus == oldFocus) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newFocus) &#123;</span><br><span class="line">        mFocusedWindowTokenByDisplay[displayId] = &#123;tokenName, newFocus&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFocusedWindowTokenByDisplay.<span class="built_in">erase</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#123;oldFocus, newFocus, displayId, reason&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将焦点窗口token（对应InputChannel的token，即InputChannel初始化时创建的BBinder）保存在mFocusedWindowTokenByDisplay中。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总的来说，WMS上层创建WindowState之后，如果该窗口可以接收input事件就需要更新焦点窗口，其后更新输入窗口信息给Input系统。注意这里涉及了三个模块：System_server(WMS)，InputFlinger和SurfaceFlinger。之所以需要SurfaceFlinger，一是需要借助SurfaceControl通道通信，更重要的是，需要通过SurfaceFlinger进一步去计算窗口的信息，如可触摸区域、可见区域等等。在SurfaceFlinger计算完毕后，通过Binder调用将窗口信息封装成InputWindowInfo传给InputFlinger，InputFlinger将传过来的InputWindowInfo信息打包成BinderWindowHandle存入mWindowHandlesByDisplay中。</p><p>接下来我们看看一次触摸事件分发给窗口的流程作为Input事件和Window的结束语。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;上文中，我们知道了应用View和窗口与input系统交互通道InputChannel的打通过程。有了通信通道，就可以通过这个来通信，将input事件传递给应用程序。很自然的，input系统中必须要保存代表该应用窗口的对象，用于识别以及分发事件。&lt;/p&gt;
&lt;p&gt;还记得我们初始化WindowState时，有创建过一个InputWindowHandleWrapper类的对象，当时我们认为是将该Window注册进input系统：&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    <category term="Input" scheme="https://swallowjoe.github.io/categories/Android/WMS/Input/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
    <category term="Input" scheme="https://swallowjoe.github.io/tags/Input/"/>
    
  </entry>
  
  <entry>
    <title>WMS(7)-窗口和InputChannel的联系</title>
    <link href="https://swallowjoe.github.io/2022/05/07/WMS(7)-%E7%AA%97%E5%8F%A3%E5%92%8CInputChannel%E7%9A%84%E8%81%94%E7%B3%BB/"/>
    <id>https://swallowjoe.github.io/2022/05/07/WMS(7)-%E7%AA%97%E5%8F%A3%E5%92%8CInputChannel%E7%9A%84%E8%81%94%E7%B3%BB/</id>
    <published>2022-05-06T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:40.506Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文集中研究input和窗口的关系, 特别是input系统是如何将事件传给正确的窗口进程的。</p><p>在Activity的resume过程中，会通过ViewRootImpl.setView向WMS传递其窗口信息，我们还是从这里入手：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">// 创建InputChannel</span></span><br><span class="line">            <span class="type">InputChannel</span> <span class="variable">inputChannel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// INPUT_FEATURE_NO_INPUT_CHANNEL 的意思是该窗口不接受input事件</span></span><br><span class="line">            <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                    &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 仅仅是实例化InputChannel， 啥也没有做</span></span><br><span class="line">                inputChannel = <span class="keyword">new</span> <span class="title class_">InputChannel</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            .......</span><br><span class="line">                <span class="comment">// 将InputChannel传入WMS中, 我们先进入看这个</span></span><br><span class="line">                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(), userId,</span><br><span class="line">                        mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets,</span><br><span class="line">                        mTempControls);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 处理后续</span></span><br><span class="line">            <span class="keyword">if</span> (inputChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// [3.1] 创建InputEventReceiver用于接收Input事件</span></span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> <span class="title class_">WindowInputEventReceiver</span>(inputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WMS.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// attrs就是上面ViewRootImpl中的mWindowAttributes</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">openInputChannels</span> <span class="operator">=</span> (outInputChannel != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">            <span class="comment">// [1.1] 初始化InputChanel</span></span><br><span class="line">            win.openInputChannel(outInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意初始化InputChannel是在WindowState之后，也是通过其openInputChannel的。</p><h1 id="一-InputChannel的初始化和Dispose"><a href="#一-InputChannel的初始化和Dispose" class="headerlink" title="一. InputChannel的初始化和Dispose"></a>一. InputChannel的初始化和Dispose</h1><h2 id="1-1-WindowState-openInputChannel"><a href="#1-1-WindowState-openInputChannel" class="headerlink" title="1.1 WindowState.openInputChannel"></a>1.1 WindowState.openInputChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">openInputChannel</span><span class="params">(InputChannel outInputChannel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Window already has an input channel.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取名称: 数字+窗口包名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getName();</span><br><span class="line">    <span class="comment">// [1.2] 通过InputManager创建InputChannel</span></span><br><span class="line">    mInputChannel = mWmService.mInputManager.createInputChannel(name);</span><br><span class="line">    <span class="comment">// 注意这里的token, 后面会发现其实是native创建的BBinder</span></span><br><span class="line">    mInputChannelToken = mInputChannel.getToken();</span><br><span class="line">    <span class="comment">// mInputWindowHandle是WindowState初始化时创建的</span></span><br><span class="line">    mInputWindowHandle.setToken(mInputChannelToken);</span><br><span class="line">    <span class="comment">// 将该InputChannel和WindowState作为KV对保存</span></span><br><span class="line">    mWmService.mInputToWindowMap.put(mInputChannelToken, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// [2.1] 将创建的InputChannel拷贝到outInputChannel中， 这个outInputChannel就是应用进程中创建的InputChannel</span></span><br><span class="line">        mInputChannel.copyTo(outInputChannel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the window died visible, we setup a fake input channel, so that taps</span></span><br><span class="line">        <span class="comment">// can still detected by input monitor channel, and we can relaunch the app.</span></span><br><span class="line">        <span class="comment">// Create fake event receiver that simply reports all events as handled.</span></span><br><span class="line">        mDeadWindowEventReceiver = <span class="keyword">new</span> <span class="title class_">DeadWindowEventReceiver</span>(mInputChannel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-InputManagerService-createInputChannel"><a href="#1-2-InputManagerService-createInputChannel" class="headerlink" title="1.2 InputManagerService.createInputChannel"></a>1.2 InputManagerService.createInputChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> InputChannel <span class="title function_">nativeCreateInputChannel</span><span class="params">(<span class="type">long</span> ptr, String name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> InputChannel <span class="title function_">createInputChannel</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeCreateInputChannel(mPtr, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JNI由native层创建InputChannel。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com_android_server_input_InputManagerService.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">nativeCreateInputChannel</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jstring nameObj)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="built_in">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">nameChars</span><span class="params">(env, nameObj)</span></span>;</span><br><span class="line">    std::string name = nameChars.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="comment">// [1.3] 创建Native层的InputChannel</span></span><br><span class="line">    base::Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; inputChannel = im-&gt;<span class="built_in">createInputChannel</span>(env, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!inputChannel.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        std::string message = inputChannel.<span class="built_in">error</span>().<span class="built_in">message</span>();</span><br><span class="line">        message += <span class="built_in">StringPrintf</span>(<span class="string">&quot; Status=%d&quot;</span>, inputChannel.<span class="built_in">error</span>().<span class="built_in">code</span>());</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.4] 通过JNI调用java层函数，创建java对象InputChannel</span></span><br><span class="line">    jobject inputChannelObj =</span><br><span class="line">            <span class="built_in">android_view_InputChannel_createJavaObject</span>(env, std::<span class="built_in">move</span>(*inputChannel));</span><br><span class="line">    <span class="keyword">if</span> (!inputChannelObj) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.5] 注册资源回收处理的回调函数</span></span><br><span class="line">    <span class="built_in">android_view_InputChannel_setDisposeCallback</span>(env, inputChannelObj,</span><br><span class="line">            handleInputChannelDisposed, im);</span><br><span class="line">    <span class="keyword">return</span> inputChannelObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-NativeInputManager-createInputChannel"><a href="#1-3-NativeInputManager-createInputChannel" class="headerlink" title="1.3 NativeInputManager.createInputChannel"></a>1.3 NativeInputManager.createInputChannel</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com_android_server_input_InputManagerService.cpp</span></span><br><span class="line">base::Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; NativeInputManager::<span class="built_in">createInputChannel</span>(</span><br><span class="line">        JNIEnv* <span class="comment">/* env */</span>, <span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="comment">// [1.3.1] 交给InputDispatcher</span></span><br><span class="line">    <span class="keyword">return</span> mInputManager-&gt;<span class="built_in">getDispatcher</span>()-&gt;<span class="built_in">createInputChannel</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InputManager.cpp</span></span><br><span class="line"><span class="function">sp&lt;InputDispatcherInterface&gt; <span class="title">InputManager::getDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于InputDispatcher的初始化后续单独分析。</p><h3 id="1-3-1-InputDispatcher-createInputChannel"><a href="#1-3-1-InputDispatcher-createInputChannel" class="headerlink" title="1.3.1 InputDispatcher.createInputChannel"></a>1.3.1 InputDispatcher.createInputChannel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InputTransport.cpp</span></span><br><span class="line">Result&lt;std::unique_ptr&lt;InputChannel&gt;&gt; InputDispatcher::<span class="built_in">createInputChannel</span>(<span class="type">const</span> std::string&amp; name) &#123;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;InputChannel&gt; serverChannel;</span><br><span class="line">    std::unique_ptr&lt;InputChannel&gt; clientChannel;</span><br><span class="line">    <span class="comment">// [1.3.2] InputChannel是成对存在的</span></span><br><span class="line">    <span class="type">status_t</span> result = InputChannel::<span class="built_in">openInputChannelPair</span>(name, serverChannel, clientChannel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">return</span> base::<span class="built_in">Error</span>(result) &lt;&lt; <span class="string">&quot;Failed to open input channel pair with name &quot;</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line">        <span class="type">const</span> sp&lt;IBinder&gt;&amp; token = serverChannel-&gt;<span class="built_in">getConnectionToken</span>();</span><br><span class="line">        <span class="type">int</span> fd = serverChannel-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">        <span class="comment">// 创建Connection, 用于记录此次连接行为</span></span><br><span class="line">        sp&lt;Connection&gt; connection =</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">Connection</span>(std::<span class="built_in">move</span>(serverChannel), <span class="literal">false</span> <span class="comment">/*monitor*/</span>, mIdGenerator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mConnectionsByToken.<span class="built_in">find</span>(token) != mConnectionsByToken.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Created a new connection, but the token %p is already known&quot;</span>, token.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将此次连接行为保存在mConnectionsByToken中</span></span><br><span class="line">        mConnectionsByToken.<span class="built_in">emplace</span>(token, connection);</span><br><span class="line">        <span class="comment">// 利用bind绑定回调函数，顺便固定回调时的第二个参数为token</span></span><br><span class="line">        std::function&lt;<span class="type">int</span>(<span class="type">int</span> events)&gt; callback = std::<span class="built_in">bind</span>(&amp;InputDispatcher::handleReceiveCallback,</span><br><span class="line">                                                            <span class="keyword">this</span>, std::placeholders::_1, token);</span><br><span class="line">        <span class="comment">// 将文件描述符添加进Looper, 这样有事件时会回调handleReceiveCallback</span></span><br><span class="line">        mLooper-&gt;<span class="built_in">addFd</span>(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, <span class="keyword">new</span> <span class="built_in">LooperEventCallback</span>(callback), <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒Looper以执行</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">    <span class="comment">// 返回客户端InputChannel</span></span><br><span class="line">    <span class="keyword">return</span> clientChannel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Native层的InputChannel其实就是利用socket创建了一对套接字，分别作为服务端和客户端，并将服务端的token作为key，存入作为记录此次InputChannel的Connection至mConnectionsByToken中。其后利用bind绑定handleReceiveCallback作为回调函数（注意这里固定了其第二个参数为当前的token），然后将服务端的文件描述符存入mLooper中。最后唤醒mLooper。</p><p>注意这里的mLooper是InputDispatcher初始化时创建的：</p><blockquote><p>mLooper &#x3D; new Looper(false);</p></blockquote><p>所以这里InputChannel中的服务端就是用来分发input事件的，而客户端的InputChannel应该就需要传给对应的应用进程了。</p><h3 id="1-3-2-InputChannel-openInputChannelPair"><a href="#1-3-2-InputChannel-openInputChannelPair" class="headerlink" title="1.3.2 InputChannel.openInputChannelPair"></a>1.3.2 InputChannel.openInputChannelPair</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputChannel::openInputChannelPair</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            std::unique_ptr&lt;InputChannel&gt;&amp; outServerChannel,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            std::unique_ptr&lt;InputChannel&gt;&amp; outClientChannel)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 原来InputChannel之所以需要成对是因为这里是通过socket实现的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">socketpair</span>(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="type">status_t</span> result = -errno;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;channel &#x27;%s&#x27; ~ Could not create socket pair.  errno=%s(%d)&quot;</span>, name.<span class="built_in">c_str</span>(),</span><br><span class="line">              <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        outServerChannel.<span class="built_in">reset</span>();</span><br><span class="line">        outClientChannel.<span class="built_in">reset</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line">    <span class="built_in">setsockopt</span>(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="built_in">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    sp&lt;IBinder&gt; token = <span class="keyword">new</span> <span class="built_in">BBinder</span>();</span><br><span class="line"></span><br><span class="line">    std::string serverChannelName = name + <span class="string">&quot; (server)&quot;</span>;</span><br><span class="line">    android::<span class="function">base::unique_fd <span class="title">serverFd</span><span class="params">(sockets[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="comment">// [1.3.3] 创建native层的InputChannel对象</span></span><br><span class="line">    outServerChannel = InputChannel::<span class="built_in">create</span>(serverChannelName, std::<span class="built_in">move</span>(serverFd), token);</span><br><span class="line"></span><br><span class="line">    std::string clientChannelName = name + <span class="string">&quot; (client)&quot;</span>;</span><br><span class="line">    android::<span class="function">base::unique_fd <span class="title">clientFd</span><span class="params">(sockets[<span class="number">1</span>])</span></span>;</span><br><span class="line">    outClientChannel = InputChannel::<span class="built_in">create</span>(clientChannelName, std::<span class="built_in">move</span>(clientFd), token);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>socketpair()函数用于创建一对无名的、相互连接的套接字。如果函数成功，则返回0，创建好的套接字分别是sockets[0]和sockets[1]；否则返回-1，错误码保存于errno中。</p><ol><li>这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sockets[0]中写，从sockets[1]中读；或者从sockets[1]中写，从sockets[0]中读； </li><li>如果往一个套接字(如sockets[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sockets[1])上读成功； </li><li>读、写操作可以位于同一个进程，也可以分别位于不同的进程。因为sockets[0]和sockets[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。</li></ol><h3 id="1-3-3-InputChannel-create"><a href="#1-3-3-InputChannel-create" class="headerlink" title="1.3.3 InputChannel.create"></a>1.3.3 InputChannel.create</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;InputChannel&gt; <span class="title">InputChannel::create</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   android::base::unique_fd fd, sp&lt;IBinder&gt; token)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> result = <span class="built_in">fcntl</span>(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;channel &#x27;%s&#x27; ~ Could not make socket non-blocking: %s&quot;</span>, name.<span class="built_in">c_str</span>(),</span><br><span class="line">                         <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// using &#x27;new&#x27; to access a non-public constructor</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;InputChannel&gt;(<span class="keyword">new</span> <span class="built_in">InputChannel</span>(name, std::<span class="built_in">move</span>(fd), token));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InputChannel::<span class="built_in">InputChannel</span>(<span class="type">const</span> std::string name, android::base::unique_fd fd, sp&lt;IBinder&gt; token)</span><br><span class="line">      : <span class="built_in">mName</span>(std::<span class="built_in">move</span>(name)), <span class="built_in">mFd</span>(std::<span class="built_in">move</span>(fd)), <span class="built_in">mToken</span>(std::<span class="built_in">move</span>(token)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_CHANNEL_LIFECYCLE) &#123;</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">&quot;Input channel constructed: name=&#x27;%s&#x27;, fd=%d&quot;</span>, <span class="built_in">getName</span>().<span class="built_in">c_str</span>(), <span class="built_in">getFd</span>().<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>native层的InputChannel原来就是一对套接字，分成server端和client端，用于跨进程通信。</p><h2 id="1-4-android-view-InputChannel-createJavaObject"><a href="#1-4-android-view-InputChannel-createJavaObject" class="headerlink" title="1.4 android_view_InputChannel_createJavaObject"></a>1.4 android_view_InputChannel_createJavaObject</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_InputChannel.cpp#123</span></span><br><span class="line"><span class="function">jobject <span class="title">android_view_InputChannel_createJavaObject</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   std::unique_ptr&lt;InputChannel&gt; inputChannel)</span> </span>&#123;</span><br><span class="line">    std::string name = inputChannel-&gt;<span class="built_in">getName</span>();</span><br><span class="line">    <span class="comment">// 创建NativeInputChannel</span></span><br><span class="line">    jlong ptr = <span class="built_in">android_view_InputChannel_createInputChannel</span>(env, std::<span class="built_in">move</span>(inputChannel));</span><br><span class="line">    <span class="comment">// 初始化java层的InputChannel</span></span><br><span class="line">    <span class="comment">// gInputChannelClassInfo.mCtor =&gt; &quot;&lt;init&gt;&quot;;</span></span><br><span class="line">    <span class="comment">// 调用java层InputChannel的构造函数，生成对象</span></span><br><span class="line">    jobject javaInputChannel =</span><br><span class="line">            env-&gt;<span class="built_in">NewObject</span>(gInputChannelClassInfo.clazz, gInputChannelClassInfo.mCtor);</span><br><span class="line">    <span class="keyword">if</span> (!javaInputChannel) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to create a Java InputChannel for channel %s.&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gInputChannelClassInfo.mSetNativeInputChannel =&gt; &quot;setNativeInputChannel&quot;</span></span><br><span class="line">    <span class="comment">// [1.4.1] 调用setNativeInputChannel函数设置ptr</span></span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(javaInputChannel, gInputChannelClassInfo.mSetNativeInputChannel, ptr);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">ExceptionOccurred</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Failed to set native ptr to the Java InputChannel for channel %s.&quot;</span>,</span><br><span class="line">              inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回java层的InputChannel对象</span></span><br><span class="line">    <span class="keyword">return</span> javaInputChannel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_view_InputChannel_createInputChannel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env, std::unique_ptr&lt;InputChannel&gt; inputChannel)</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;NativeInputChannel&gt; nativeInputChannel =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;NativeInputChannel&gt;(std::<span class="built_in">move</span>(inputChannel));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(nativeInputChannel.<span class="built_in">release</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NativeInputChannel::<span class="built_in">NativeInputChannel</span>(std::unique_ptr&lt;InputChannel&gt; inputChannel)</span><br><span class="line">      : <span class="built_in">mInputChannel</span>(std::<span class="built_in">move</span>(inputChannel)), <span class="built_in">mDisposeCallback</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>经过<a href="#131-inputdispatchercreateinputchannel">1.3</a>我们知道这里传入的InputChannel其实是一对socket中代表客户端的那个, 先通过std::move将InputChannel存入新创建的NativeInputChannel对象中，然后通过JNI构造出java层的InputChannel，在调用其setNativeInputChannel，将NativeInputChannel保存在其mPtr中。</p><h3 id="1-4-1-InputChannel-setNativeInputChannel"><a href="#1-4-1-InputChannel-setNativeInputChannel" class="headerlink" title="1.4.1 InputChannel.setNativeInputChannel"></a>1.4.1 InputChannel.setNativeInputChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNativeInputChannel</span><span class="params">(<span class="type">long</span> nativeChannel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nativeChannel == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Attempting to set native input channel to null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Already has native input channel.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">&quot;setNativeInputChannel : &quot;</span> +  String.format(<span class="string">&quot;%x&quot;</span>, nativeChannel));</span><br><span class="line">    &#125;</span><br><span class="line">    sRegistry.registerNativeAllocation(<span class="built_in">this</span>, nativeChannel);</span><br><span class="line">    mPtr = nativeChannel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以java层的InputChannel里的mPtr是对应NativeInputChannel对象的。</p><h2 id="1-5-android-view-InputChannel-setDisposeCallback"><a href="#1-5-android-view-InputChannel-setDisposeCallback" class="headerlink" title="1.5 android_view_InputChannel_setDisposeCallback"></a>1.5 android_view_InputChannel_setDisposeCallback</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_InputChannel.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">android_view_InputChannel_setDisposeCallback</span><span class="params">(JNIEnv* env, jobject inputChannelObj,</span></span></span><br><span class="line"><span class="params"><span class="function">        InputChannelObjDisposeCallback callback, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过java层InputChannel中存储的mPtr找到对应的NativeInputChannel</span></span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">            <span class="built_in">android_view_InputChannel_getNativeInputChannel</span>(env, inputChannelObj);</span><br><span class="line">    <span class="keyword">if</span> (!nativeInputChannel || !nativeInputChannel-&gt;<span class="built_in">getInputChannel</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Cannot set dispose callback because input channel object has not been initialized.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// [1.5.1] 这里的data就是NativeInputManager</span></span><br><span class="line">        nativeInputChannel-&gt;<span class="built_in">setDisposeCallback</span>(callback, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> NativeInputChannel* <span class="title">android_view_InputChannel_getNativeInputChannel</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject inputChannelObj)</span> </span>&#123;</span><br><span class="line">    jlong longPtr = env-&gt;<span class="built_in">GetLongField</span>(inputChannelObj, gInputChannelClassInfo.mPtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;NativeInputChannel*&gt;(longPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-1-NativeInputChannel-setDisposeCallback"><a href="#1-5-1-NativeInputChannel-setDisposeCallback" class="headerlink" title="1.5.1 NativeInputChannel.setDisposeCallback"></a>1.5.1 NativeInputChannel.setDisposeCallback</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputChannel::setDisposeCallback</span><span class="params">(InputChannelObjDisposeCallback callback, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    mDisposeCallback = callback;</span><br><span class="line">    mDisposeData = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将回调函数和相关参数保存起来， 当进程死亡，或者窗口被销毁时，会主动调用InputChannel.dispose()回收资源，最后就会调用到NativeInputChannel.dispose了。</p><h3 id="1-5-2-NativeInputChannel-dispose"><a href="#1-5-2-NativeInputChannel-dispose" class="headerlink" title="1.5.2 NativeInputChannel.dispose"></a>1.5.2 NativeInputChannel.dispose</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputChannel::dispose</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mInputChannel) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDisposeCallback) &#123;</span><br><span class="line">        <span class="comment">// [1.5.3] 调用回调函数handleInputChannelDisposed</span></span><br><span class="line">        <span class="built_in">mDisposeCallback</span>(env, obj, mInputChannel, mDisposeData);</span><br><span class="line">        mDisposeCallback = <span class="literal">nullptr</span>;</span><br><span class="line">        mDisposeData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputChannel.<span class="built_in">reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-handleInputChannelDisposed"><a href="#1-5-3-handleInputChannelDisposed" class="headerlink" title="1.5.3 handleInputChannelDisposed"></a>1.5.3 handleInputChannelDisposed</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handleInputChannelDisposed</span><span class="params">(JNIEnv* env, jobject <span class="comment">/* inputChannelObj */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> std::shared_ptr&lt;InputChannel&gt;&amp; inputChannel,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="built_in">static_cast</span>&lt;NativeInputManager*&gt;(data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;Input channel object &#x27;%s&#x27; was disposed without first being removed with &quot;</span></span><br><span class="line">          <span class="string">&quot;the input manager!&quot;</span>,</span><br><span class="line">          inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 移除连接</span></span><br><span class="line">    im-&gt;<span class="built_in">removeInputChannel</span>(env, inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputManager::removeInputChannel</span><span class="params">(JNIEnv* <span class="comment">/* env */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="type">const</span> sp&lt;IBinder&gt;&amp; connectionToken)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">return</span> mInputManager-&gt;<span class="built_in">getDispatcher</span>()-&gt;<span class="built_in">removeInputChannel</span>(connectionToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-4-InputDispatcher-removeInputChannel"><a href="#1-5-4-InputDispatcher-removeInputChannel" class="headerlink" title="1.5.4 InputDispatcher.removeInputChannel"></a>1.5.4 InputDispatcher.removeInputChannel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputDispatcher::removeInputChannel</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; connectionToken)</span> </span>&#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        std::scoped_lock _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="type">status_t</span> status = <span class="built_in">removeInputChannelLocked</span>(connectionToken, <span class="literal">false</span> <span class="comment">/*notify*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">InputDispatcher::removeInputChannelLocked</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; connectionToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   <span class="type">bool</span> notify)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过token找到对应的Connection</span></span><br><span class="line">    sp&lt;Connection&gt; connection = <span class="built_in">getConnectionLocked</span>(connectionToken);</span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection can be removed via socket hang up or an explicit call to &#x27;removeInputChannel&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [1.5.4.1] 将该Connection从集合中移除</span></span><br><span class="line">    <span class="built_in">removeConnectionLocked</span>(connection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;monitor) &#123;</span><br><span class="line">        <span class="built_in">removeMonitorChannelLocked</span>(connectionToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将对应服务端Socket描述符从mLooper中移除，这样就不会接收到事件了</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">removeFd</span>(connection-&gt;inputChannel-&gt;<span class="built_in">getFd</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> currentTime = <span class="built_in">now</span>();</span><br><span class="line">    <span class="built_in">abortBrokenDispatchCycleLocked</span>(currentTime, connection, notify);</span><br><span class="line">    <span class="comment">// 标记该Connection为ZOMBIE状态</span></span><br><span class="line">    connection-&gt;status = Connection::STATUS_ZOMBIE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除InputChannel的工作也不多，将Connection从直接保存的集合中移除，顺便将其中保存的服务端Socket描述符从mLooper中移除即可。最后标记被移除的Connection状态为ZOMBIE状态。</p><h4 id="1-5-4-1-InputDispatcher-removeConnectionLocked"><a href="#1-5-4-1-InputDispatcher-removeConnectionLocked" class="headerlink" title="1.5.4.1 InputDispatcher.removeConnectionLocked"></a>1.5.4.1 InputDispatcher.removeConnectionLocked</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InputDispatcher::removeConnectionLocked</span><span class="params">(<span class="type">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    mAnrTracker.<span class="built_in">eraseToken</span>(connection-&gt;inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">    <span class="comment">// 将该连接从mConnectionsByToken中移除</span></span><br><span class="line">    mConnectionsByToken.<span class="built_in">erase</span>(connection-&gt;inputChannel-&gt;<span class="built_in">getConnectionToken</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将该Connection从mConnectionsByToken和mAnrTracker中移除即可。</p><h1 id="二-应用进程InputChannel的来源"><a href="#二-应用进程InputChannel的来源" class="headerlink" title="二. 应用进程InputChannel的来源"></a>二. 应用进程InputChannel的来源</h1><p>通过 <a href="#%E4%B8%80-inputchannel%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Cdispose">InputChannel的初始化</a> 我们知道InputChannel的Native实现就是一对Socket，其中服务端作为input事件分发者被加入InputDispatcher的Looper中，客户端会被存入NativeInputChannel中，而后通过JNI存入java层的InputChannel的mPtr中，但是这里java层的InputChannel还是处于SystemServer进程，还没有看到应用进程InputChannel是如何被赋值的。</p><p>接下来我们先研究下InputChannel的拷贝。</p><h2 id="2-1-InputChannel-copyTo"><a href="#2-1-InputChannel-copyTo" class="headerlink" title="2.1 InputChannel.copyTo"></a>2.1 InputChannel.copyTo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyTo</span><span class="params">(InputChannel outParameter)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (outParameter == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;outParameter must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outParameter.mPtr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Other object already has a native input channel.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.2 nativeDup</span></span><br><span class="line">    <span class="comment">// setNativeInputChannel我们已经分析过了就不在赘述，重点看nativeDup函数</span></span><br><span class="line">    outParameter.setNativeInputChannel(nativeDup(mPtr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeDup</span><span class="params">(<span class="type">long</span> channel)</span>;</span><br></pre></td></tr></table></figure><p>这里思考一下为什么不直接将mPtr赋值给outParameter的mPtr呢？</p><h2 id="2-2-android-view-InputChannel-nativeDup"><a href="#2-2-android-view-InputChannel-nativeDup" class="headerlink" title="2.2 android_view_InputChannel_nativeDup"></a>2.2 android_view_InputChannel_nativeDup</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_InputChannel.cpp#123</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_view_InputChannel_nativeDup</span><span class="params">(JNIEnv* env, jobject obj, jlong channel)</span> </span>&#123;</span><br><span class="line">    NativeInputChannel* nativeInputChannel =</span><br><span class="line">                <span class="built_in">reinterpret_cast</span>&lt;NativeInputChannel*&gt;(channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nativeInputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;InputChannel has no valid NativeInputChannel&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;InputChannel&gt; inputChannel = nativeInputChannel-&gt;<span class="built_in">getInputChannel</span>();</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;NativeInputChannel has no corresponding InputChannel&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.3 调用native层的InputChannel.dup函数</span></span><br><span class="line">    std::unique_ptr&lt;InputChannel&gt; dupInputChannel = inputChannel-&gt;<span class="built_in">dup</span>();</span><br><span class="line">    <span class="keyword">if</span> (dupInputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::string message = android::base::<span class="built_in">StringPrintf</span>(</span><br><span class="line">                <span class="string">&quot;Could not duplicate input channel %s&quot;</span>, inputChannel-&gt;<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建新的NativeInputChannel对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(<span class="keyword">new</span> <span class="built_in">NativeInputChannel</span>(std::<span class="built_in">move</span>(dupInputChannel)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android_view_InputChannel_nativeDup的作用就是根据传入的java层InputChannel创建一个新的NativeInputChannel作为客户端socket, 与服务端Socket的InputChannel对应。</p><h2 id="2-3-InputChannel-dup"><a href="#2-3-InputChannel-dup" class="headerlink" title="2.3 InputChannel.dup"></a>2.3 InputChannel.dup</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;InputChannel&gt; <span class="title">InputChannel::dup</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.3.1 dupFd创建一个新的文件描述符，但是执行同一个文件</span></span><br><span class="line">    <span class="function">base::unique_fd <span class="title">newFd</span><span class="params">(dupFd())</span></span>;</span><br><span class="line">    <span class="comment">// 根据新的文件描述符创建新的InputChannel对象</span></span><br><span class="line">    <span class="keyword">return</span> InputChannel::<span class="built_in">create</span>(<span class="built_in">getName</span>(), std::<span class="built_in">move</span>(newFd), <span class="built_in">getConnectionToken</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-InputChannel-dupFd"><a href="#2-3-1-InputChannel-dupFd" class="headerlink" title="2.3.1 InputChannel.dupFd"></a>2.3.1 InputChannel.dupFd</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">base::unique_fd <span class="title">InputChannel::dupFd</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getFp返回的就是该InputChannel的mFd</span></span><br><span class="line">    <span class="comment">// ::dup 的作用是复制文件描述符，使多个文件描述符指向同一个文件</span></span><br><span class="line">    android::<span class="function">base::unique_fd <span class="title">newFd</span><span class="params">(::dup(getFd()))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!newFd.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not duplicate fd %i for channel %s: %s&quot;</span>, <span class="built_in">getFd</span>().<span class="built_in">get</span>(), <span class="built_in">getName</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">              <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> hitFdLimit = errno == EMFILE || errno == ENFILE;</span><br><span class="line">        <span class="comment">// If this process is out of file descriptors, then throwing that might end up exploding</span></span><br><span class="line">        <span class="comment">// on the other side of a binder call, which isn&#x27;t really helpful.</span></span><br><span class="line">        <span class="comment">// Better to just crash here and hope that the FD leak is slow.</span></span><br><span class="line">        <span class="comment">// Other failures could be client errors, so we still propagate those back to the caller.</span></span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(hitFdLimit, <span class="string">&quot;Too many open files, could not duplicate input channel %s&quot;</span>,</span><br><span class="line">                            <span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newFd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dupFd是通过 ::dup(int oldFd) 函数复制文件描述符，使新的文件描述符指向参数描述符指向的同一个文件。</p><h2 id="2-4-Binder通信中AIDL里的out标记"><a href="#2-4-Binder通信中AIDL里的out标记" class="headerlink" title="2.4 Binder通信中AIDL里的out标记"></a>2.4 Binder通信中AIDL里的out标记</h2><p>看完了InputChannel的copyTo函数，我们知道该函数就是在native层创建了新的NativeInputChannel，但是还是和之前客户端InputChannel一样指向同一个Socket描述符，这样服务端Socket发的消息会同步传给信息的InputChannel了。</p><p>但是这里我们还是没有看到应用进程的InputChannel是如何被赋值的，在WMS.addWindow函数中，outInputChannel在被mInputChannel.copyTo函数赋值后，就没有继续使用过了。这里我们就要看到应用进程和WMS通信的桥梁Session的AIDL文件定义了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IWindowSession.aidl</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addToDisplay</span><span class="params">(IWindow window, in WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        in <span class="type">int</span> viewVisibility, in <span class="type">int</span> layerStackId, in InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        out InputChannel outInputChannel, out InsetsState insetsState,</span></span><br><span class="line"><span class="params">        out InsetsSourceControl[] activeControls)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addToDisplayAsUser</span><span class="params">(IWindow window, in WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        in <span class="type">int</span> viewVisibility, in <span class="type">int</span> layerStackId, in <span class="type">int</span> userId,</span></span><br><span class="line"><span class="params">        in InsetsState requestedVisibility, out InputChannel outInputChannel,</span></span><br><span class="line"><span class="params">        out InsetsState insetsState, out InsetsSourceControl[] activeControls)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addToDisplayWithoutInputChannel</span><span class="params">(IWindow window, in WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        in <span class="type">int</span> viewVisibility, in <span class="type">int</span> layerStackId, out InsetsState insetsState)</span>;</span><br></pre></td></tr></table></figure><p>毫无意外，所有的InputChannel都是被标记了out标签，这样binder回调时会将该参数回传给调用进程，即应用进程。 这样一来一个WindowState对应一对Socket，分成服务端和客户端，服务端Socket的描述符被存入InputDispatcher的mConnectionsByToken，也被添加到其mLooper中用于转发Input事件至客户端Socket中。而客户端Socket又被dup函数复制成两份NativeInputChannel, 一份存在WindowState的mInputChannel中，另一份通过Binder调用存入应用进程的ViewRootImpl的WindowInputEventReceiver对象中。</p><h1 id="三-应用进程注册接听Input事件"><a href="#三-应用进程注册接听Input事件" class="headerlink" title="三. 应用进程注册接听Input事件"></a>三. 应用进程注册接听Input事件</h1><p>在ViewRootImpl.setView函数中，当应用进程通过binder调用addToDisplayAsUser获得被复制的InputChannel后，会通过该InputChannel创建WindowInputEventReceiver。</p><h2 id="3-1-WindowInputEventReceiver初始化"><a href="#3-1-WindowInputEventReceiver初始化" class="headerlink" title="3.1 WindowInputEventReceiver初始化"></a>3.1 WindowInputEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title class_">InputEventReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WindowInputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(inputChannel, looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowInputEventReceiver是继承了InputEventReceiver的，这里的构造函数也仅仅是将传入的参数继续调用给父类的构造函数。</p><h2 id="3-2-InputEventReceiver初始化"><a href="#3-2-InputEventReceiver初始化" class="headerlink" title="3.2 InputEventReceiver初始化"></a>3.2 InputEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;inputChannel must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInputChannel = inputChannel;</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 3.3 通过JNI创建native层的对象</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;InputEventReceiver&gt;(<span class="built_in">this</span>),</span><br><span class="line">            inputChannel, mMessageQueue);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeInit</span><span class="params">(WeakReference&lt;InputEventReceiver&gt; receiver,</span></span><br><span class="line"><span class="params">        InputChannel inputChannel, MessageQueue messageQueue)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-3-android-view-InputEventReceiver-cpp-nativeInit"><a href="#3-3-android-view-InputEventReceiver-cpp-nativeInit" class="headerlink" title="3.3 android_view_InputEventReceiver.cpp:nativeInit"></a>3.3 android_view_InputEventReceiver.cpp:nativeInit</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android_view_InputEventReceiver.cpp#486</span></span><br><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过java层的InputChannel转成Native层的InputChannel</span></span><br><span class="line">    std::shared_ptr&lt;InputChannel&gt; inputChannel =</span><br><span class="line">            <span class="built_in">android_view_InputChannel_getInputChannel</span>(env, inputChannelObj);</span><br><span class="line">    <span class="keyword">if</span> (inputChannel == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;InputChannel is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过java层的MessageQueue转成Native层的MessageQueue</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = <span class="built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;MessageQueue is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.4 创建NativeInputEventReceiver</span></span><br><span class="line">    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> <span class="built_in">NativeInputEventReceiver</span>(env,</span><br><span class="line">            receiverWeak, inputChannel, messageQueue);</span><br><span class="line">    <span class="comment">// 3.5 调用初始化</span></span><br><span class="line">    <span class="type">status_t</span> status = receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        std::string message =</span><br><span class="line">                android::base::<span class="built_in">StringPrintf</span>(<span class="string">&quot;Failed to initialize input event receiver.  status=%d&quot;</span>,</span><br><span class="line">                                            status);</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;<span class="built_in">incStrong</span>(gInputEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-NativeInputEventReceiver初始化"><a href="#3-4-NativeInputEventReceiver初始化" class="headerlink" title="3.4 NativeInputEventReceiver初始化"></a>3.4 NativeInputEventReceiver初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NativeInputEventReceiver::<span class="built_in">NativeInputEventReceiver</span>(</span><br><span class="line">        JNIEnv* env, jobject receiverWeak, <span class="type">const</span> std::shared_ptr&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue)</span><br><span class="line">      : <span class="built_in">mReceiverWeakGlobal</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(receiverWeak)),</span><br><span class="line">        <span class="built_in">mInputConsumer</span>(inputChannel),</span><br><span class="line">        <span class="built_in">mMessageQueue</span>(messageQueue),</span><br><span class="line">        <span class="built_in">mBatchedInputEventPending</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="built_in">mFdEvents</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (kDebugDispatchCycle) &#123;</span><br><span class="line">        <span class="built_in">ALOGD</span>(<span class="string">&quot;channel &#x27;%s&#x27; ~ Initializing input event receiver.&quot;</span>, <span class="built_in">getInputChannelName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化NativeInputEventReceiver</p><h2 id="3-5-NativeInputEventReceiver-initialize"><a href="#3-5-NativeInputEventReceiver-initialize" class="headerlink" title="3.5 NativeInputEventReceiver.initialize"></a>3.5 NativeInputEventReceiver.initialize</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">NativeInputEventReceiver::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ALOOPER_EVENT_INPUT = 1 &lt;&lt; 0;</span></span><br><span class="line">    <span class="built_in">setFdEvents</span>(ALOOPER_EVENT_INPUT);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeInputEventReceiver::setFdEvents</span><span class="params">(<span class="type">int</span> events)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时mFdEvents还只是0</span></span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="type">int</span> fd = mInputConsumer.<span class="built_in">getChannel</span>()-&gt;<span class="built_in">getFd</span>();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            <span class="comment">// 将InputChannel中的客户端Socket的文件描述符加入的Looper中监听</span></span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">addFd</span>(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;<span class="built_in">getLooper</span>()-&gt;<span class="built_in">removeFd</span>(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里设置文件描述符，将作为客户端InputChannel的Socket的描述符添加到该应用进程的主线程Looper中（ViewRootImpl.setView是主线程才能被调用的）。</p><h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四. 小结"></a>四. 小结</h1><p>WindowState和InputChannel的相关流程图如下：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/7_1.png" alt="7-1"></p><p>InputChannel的Native实现就是一对Socket，其中服务端作为input事件分发者被加入InputDispatcher的Looper中，客户端会被存入NativeInputChannel中。一个WindowState对应一对Socket，分成服务端和客户端，服务端Socket的描述符被存入InputDispatcher的mConnectionsByToken，也被添加到其mLooper中用于转发Input事件至客户端Socket中。而客户端Socket又被dup函数复制成两份NativeInputChannel, 一份存在WindowState的mInputChannel中，另一份通过Binder调用存入应用进程的ViewRootImpl的WindowInputEventReceiver对象中。</p><p>接下来我们看看input事件是如何传给正确的窗口进程的。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文集中研究input和窗口的关系, 特别是input系统是如何将事件传给正确的窗口进程的。&lt;/p&gt;
&lt;p&gt;在Activity的resume过程中，会通过ViewRootImpl.setView向WMS传递其窗口信息，我们还是从这里入手：&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    <category term="Input" scheme="https://swallowjoe.github.io/categories/Android/WMS/Input/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
    <category term="Input" scheme="https://swallowjoe.github.io/tags/Input/"/>
    
  </entry>
  
  <entry>
    <title>WMS(6)-焦点窗口的更新</title>
    <link href="https://swallowjoe.github.io/2022/05/06/WMS(6)-%E7%84%A6%E7%82%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
    <id>https://swallowjoe.github.io/2022/05/06/WMS(6)-%E7%84%A6%E7%82%B9%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9B%B4%E6%96%B0/</id>
    <published>2022-05-05T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:37.397Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>这篇文章中我们重点关注焦点窗口的更新，所谓焦点窗口就是当前选择的窗口。在Android里可以通过下面的adb命令来查看当前的焦点窗口: </p><blockquote><p>adb shell dumpsys window |grep -iE “mCurr*”</p></blockquote><p>我们知道一个实体显示器对应一个DisplayId, 相应的有一个DisplayContent，如同我们人眼或者相机的对焦，同一时刻只能有一个焦点，那么对应一个Display一般来说也只有一个焦点窗口了。</p><p>我们之前一直分析的WMS.addWindow，在应用进程调用setView传入对应窗口属性之后，当然也会有焦点窗口的重新计算了：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord!</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState, key为ViewRoomImpl.W</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        <span class="comment">// 和应用窗口权限有关，后续分析</span></span><br><span class="line">        win.initAppOpsState();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将该WindowState保存在其mToken(ActivityRecord)中</span></span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 标记焦点窗口是否更新</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">focusChanged</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// [1.1] 检查该窗口是否可以接收input事件</span></span><br><span class="line">        <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">            <span class="comment">// [1.2] 更新焦点窗口</span></span><br><span class="line">            focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">                imMayMove = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// [2.1] 如果焦点窗口有更新，也需要更新input相关设置</span></span><br><span class="line">        <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">            displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 该窗口成功被添加或者是可见的而且当前display需要更新方向时，更新display相关配置</span></span><br><span class="line">        <span class="keyword">if</span> (win.isVisibleOrAdding() &amp;&amp; displayContent.updateOrientation()) &#123;</span><br><span class="line">            displayContent.sendNewConfiguration();</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一-焦点窗口更新"><a href="#一-焦点窗口更新" class="headerlink" title="一. 焦点窗口更新"></a>一. 焦点窗口更新</h1><p>应用的第一个addWindow应该是启动窗口的，所以我们以启动窗口为例分析焦点窗口更新。</p><h2 id="1-1-WindowState-canReceiveKeys"><a href="#1-1-WindowState-canReceiveKeys" class="headerlink" title="1.1 WindowState.canReceiveKeys"></a>1.1 WindowState.canReceiveKeys</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canReceiveKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> canReceiveKeys(<span class="literal">false</span> <span class="comment">/* fromUserTouch */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canReceiveKeys</span><span class="params">(<span class="type">boolean</span> fromUserTouch)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.1.1] 检查该窗口是否可见</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">canReceiveKeys</span> <span class="operator">=</span> isVisibleOrAdding()</span><br><span class="line">            &amp;&amp; (mViewVisibility == View.VISIBLE) &amp;&amp; !mRemoveOnExit</span><br><span class="line">            &amp;&amp; ((mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// [1.1.2] 确认该ActivityRecord是否可聚焦</span></span><br><span class="line">            &amp;&amp; (mActivityRecord == <span class="literal">null</span> || mActivityRecord.windowsAreFocusable(fromUserTouch))</span><br><span class="line">            <span class="comment">// [1.1.3] 判断该WindowState是否允许接收input事件</span></span><br><span class="line">            &amp;&amp; canReceiveTouchInput();</span><br><span class="line">    <span class="keyword">if</span> (!canReceiveKeys) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 除非用户有意触摸显示器，否则不允许不受信任的虚拟显示接收input事件</span></span><br><span class="line">    <span class="keyword">return</span> fromUserTouch || getDisplayContent().isOnTop()</span><br><span class="line">            || getDisplayContent().isTrusted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里检查了一堆参数，我们一一分析：</p><ol><li>isVisibleOrAdding(): 判断当前窗口是否可见或者被添加</li><li>mViewVisibility &#x3D;&#x3D; View.VISIBLE: 窗口可见属性为VISIBLE</li><li>!mRemoveOnExit: 该窗口没有移除或者退出</li><li>((mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) &#x3D;&#x3D; 0): 该窗口的属性不带有FLAG_NOT_FOCUSABLE，是可聚焦的</li><li>(mActivityRecord &#x3D;&#x3D; null || mActivityRecord.windowsAreFocusable(fromUserTouch)):该窗口不是Activity对应的窗口，如果是那么需要满足windowsAreFocusable</li><li>canReceiveTouchInput(): 该窗口可以接收touch事件</li></ol><p>只有当上述条件都满足且窗口所处的DisplayContent是最上层的并且该Display是受信任的，该窗口才可能接收事件。</p><h3 id="1-1-1-WindowState-isVisibleOrAdding"><a href="#1-1-1-WindowState-isVisibleOrAdding" class="headerlink" title="1.1.1 WindowState.isVisibleOrAdding"></a>1.1.1 WindowState.isVisibleOrAdding</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isVisibleOrAdding</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 该窗口不一定对应Activity,比如启动窗口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">atoken</span> <span class="operator">=</span> mActivityRecord;</span><br><span class="line">    <span class="keyword">return</span> (mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility == View.VISIBLE))</span><br><span class="line">            &amp;&amp; isVisibleByPolicy() &amp;&amp; !isParentWindowHidden()</span><br><span class="line">            &amp;&amp; (atoken == <span class="literal">null</span> || atoken.mVisibleRequested)</span><br><span class="line">            &amp;&amp; !mAnimatingExit &amp;&amp; !mDestroying;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isVisibleByPolicy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断mPolicyVisibility中的POLICY_VISIBILITY_ALL位是否被设置了</span></span><br><span class="line">    <span class="comment">// mPolicyVisibility默认就是POLICY_VISIBILITY_ALL</span></span><br><span class="line">    <span class="keyword">return</span> (mPolicyVisibility &amp; POLICY_VISIBILITY_ALL) == POLICY_VISIBILITY_ALL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isParentWindowHidden</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 当前窗口的父窗口是否被隐藏了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">parent</span> <span class="operator">=</span> getParentWindow();</span><br><span class="line">    <span class="keyword">return</span> parent != <span class="literal">null</span> &amp;&amp; parent.mHidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断该窗口是否可见或者处于被添加状态。</p><ol><li>(mHasSurface || (!mRelayoutCalled &amp;&amp; mViewVisibility &#x3D;&#x3D; View.VISIBLE))：<ol><li>mHasSurface：该窗口是否有对应Surface，该Surface会在该窗口对应的启动或退出动画时创建</li><li>(!mRelayoutCalled &amp;&amp; mViewVisibility &#x3D;&#x3D; View.VISIBLE):<ol><li>!mRelayoutCalled: 该窗口被调用了relayoutWindow</li><li>mViewVisibility &#x3D;&#x3D; View.VISIBLE: 窗口View属性对应的是VISIBLE</li></ol></li><li>如果该窗口已经有Surface或者没有被relayoutWindow但窗口可见属性是VISIBLE的时</li></ol></li><li>isVisibleByPolicy()：判断mPolicyVisibility中的POLICY_VISIBILITY_ALL位都被设置了</li><li>!isParentWindowHidden(): 判断父窗口没有被隐藏</li><li>(atoken &#x3D;&#x3D; null || atoken.mVisibleRequested)：<ol><li>atoken &#x3D;&#x3D; null：该窗口不对应ActivityRecord</li><li>atoken.mVisibleRequested: 如果对应，需要mVisibleRequested被设置为true</li><li>!mAnimatingExit：该窗口当前没有执行退出动画</li><li>!mDestroying：该窗口没有被销毁</li></ol></li></ol><h3 id="1-1-2-ActivityRecord-windowsAreFocusable"><a href="#1-1-2-ActivityRecord-windowsAreFocusable" class="headerlink" title="1.1.2 ActivityRecord.windowsAreFocusable"></a>1.1.2 ActivityRecord.windowsAreFocusable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">windowsAreFocusable</span><span class="params">(<span class="type">boolean</span> fromUserTouch)</span> &#123;</span><br><span class="line">    <span class="comment">// fromUserTouch为false</span></span><br><span class="line">    <span class="keyword">if</span> (!fromUserTouch &amp;&amp; mTargetSdk &lt; Build.VERSION_CODES.Q) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> getPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">topFocusedAppOfMyProcess</span> <span class="operator">=</span></span><br><span class="line">                mWmService.mRoot.mTopFocusedAppByProcess.get(pid);</span><br><span class="line">        <span class="keyword">if</span> (topFocusedAppOfMyProcess != <span class="literal">null</span> &amp;&amp; topFocusedAppOfMyProcess != <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 对于Q以下的应用程序，每个进程只能有一个具有聚焦窗口的应用程序，因为以往的应用程序可能无法用于多聚焦系统</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确认该ActivityRecord是否已经attach了</span></span><br><span class="line">    <span class="comment">// isAttached是其父类的父类WindowContainer中的方法，用于判断该ActivityRecord的parent的DisplayArea是否为null</span></span><br><span class="line">    <span class="keyword">return</span> (canReceiveKeys() || isAlwaysFocusable()) &amp;&amp; isAttached();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canReceiveKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 确定该ActivityRecord对应的窗口配置是否允许接收input事件</span></span><br><span class="line">    <span class="keyword">return</span> getWindowConfiguration().canReceiveKeys()</span><br><span class="line">            &amp;&amp; (task == <span class="literal">null</span> || task.getWindowConfiguration().canReceiveKeys());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAlwaysFocusable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (info.flags &amp; FLAG_ALWAYS_FOCUSABLE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>windowsAreFocusable用于判断该ActivityRecord对应窗口是否可以接收input事件。</p><h3 id="1-1-3-WindowState-canReceiveTouchInput"><a href="#1-1-3-WindowState-canReceiveTouchInput" class="headerlink" title="1.1.3 WindowState.canReceiveTouchInput"></a>1.1.3 WindowState.canReceiveTouchInput</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">canReceiveTouchInput</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityRecord == <span class="literal">null</span>  || mActivityRecord.getTask() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !mActivityRecord.getTask().getRootTask().shouldIgnoreInput()</span><br><span class="line">            &amp;&amp; mActivityRecord.mVisibleRequested</span><br><span class="line">            &amp;&amp; !isRecentsAnimationConsumingAppInput();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到如果是非ActivityRecord对应的Window那么直接返回true，如果该ActivityRecord还没有被加入task也直接返回true.</p><ol><li>!mActivityRecord.getTask().getRootTask().shouldIgnoreInput()：该ActivityRecord的task所处的rootTask没有被设置忽略input事件</li><li>mActivityRecord.mVisibleRequested: 该ActivityRecord被设置了VISIBLE</li><li>!isRecentsAnimationConsumingAppInput():该窗口没有作为最近任务窗口的动画的一部分时</li></ol><h2 id="1-2-WMS-updateFocusedWindowLocked"><a href="#1-2-WMS-updateFocusedWindowLocked" class="headerlink" title="1.2 WMS.updateFocusedWindowLocked"></a>1.2 WMS.updateFocusedWindowLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">updateFocusedWindowLocked</span><span class="params">(<span class="type">int</span> mode, <span class="type">boolean</span> updateInputWindows)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;wmUpdateFocus&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> mRoot.updateFocusedWindowLocked(mode, updateInputWindows);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的mode是UPDATE_FOCUS_WILL_ASSIGN_LAYERS，而且updateInputWindows为false. WMS.mRoot就是RootWindowContainer.</p><h2 id="1-3-RootWindowContainer-updateFocusedWindowLocked"><a href="#1-3-RootWindowContainer-updateFocusedWindowLocked" class="headerlink" title="1.3 RootWindowContainer.updateFocusedWindowLocked"></a>1.3 RootWindowContainer.updateFocusedWindowLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">updateFocusedWindowLocked</span><span class="params">(<span class="type">int</span> mode, <span class="type">boolean</span> updateInputWindows)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先清除mTopFocusedAppByProcess中的元素：ArrayMap&lt;Integer, ActivityRecord&gt; mTopFocusedAppByProcess</span></span><br><span class="line">    mTopFocusedAppByProcess.clear();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">topFocusedDisplayId</span> <span class="operator">=</span> INVALID_DISPLAY;</span><br><span class="line">    <span class="comment">// 遍历所有DisplayContent, 并依次更新焦点窗口, 注意这里是倒序更新计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mChildren.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> mChildren.get(i);</span><br><span class="line">        <span class="comment">// [1.4] 更新单个DisplayContent的焦点窗口</span></span><br><span class="line">        changed |= dc.updateFocusedWindowLocked(mode, updateInputWindows, topFocusedDisplayId);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">newFocus</span> <span class="operator">=</span> dc.mCurrentFocus;</span><br><span class="line">        <span class="comment">// DC存在新的焦点窗口时</span></span><br><span class="line">        <span class="keyword">if</span> (newFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">pidOfNewFocus</span> <span class="operator">=</span> newFocus.mSession.mPid;</span><br><span class="line">            <span class="comment">// 将新焦点窗口的ActivityRecord保存在mTopFocusedAppByProcess中</span></span><br><span class="line">            <span class="keyword">if</span> (mTopFocusedAppByProcess.get(pidOfNewFocus) == <span class="literal">null</span>) &#123;</span><br><span class="line">                mTopFocusedAppByProcess.put(pidOfNewFocus, newFocus.mActivityRecord);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新topFocusedDisplayId为该DC的DisplayId</span></span><br><span class="line">            <span class="keyword">if</span> (topFocusedDisplayId == INVALID_DISPLAY) &#123;</span><br><span class="line">                topFocusedDisplayId = dc.getDisplayId();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (topFocusedDisplayId == INVALID_DISPLAY &amp;&amp; dc.mFocusedApp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 即使应用窗口还没有准备好(未附加进程或未添加窗口)，具有焦点应用的顶部显示仍然应该是焦点顶部显示</span></span><br><span class="line">            topFocusedDisplayId = dc.getDisplayId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (topFocusedDisplayId == INVALID_DISPLAY) &#123;</span><br><span class="line">        topFocusedDisplayId = DEFAULT_DISPLAY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当焦点所处的display有变化时</span></span><br><span class="line">    <span class="keyword">if</span> (mTopFocusedDisplayId != topFocusedDisplayId) &#123;</span><br><span class="line">        mTopFocusedDisplayId = topFocusedDisplayId;</span><br><span class="line">        <span class="comment">// [2.1] 通知input系统更新displayId</span></span><br><span class="line">        mWmService.mInputManager.setFocusedDisplay(topFocusedDisplayId);</span><br><span class="line">        <span class="comment">// 将PhoneWindowManager中的mTopFocusedDisplayId更新为新焦点窗口所处的DisplayId</span></span><br><span class="line">        mWmService.mPolicy.setTopFocusedDisplay(topFocusedDisplayId);</span><br><span class="line">        ProtoLog.d(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;New topFocusedDisplayId=%d&quot;</span>, topFocusedDisplayId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算更新焦点窗口是对所有DisplayContent的依次计算更新焦点窗口。首先清除mTopFocusedAppByProcess中的元素，然后依次更新所有DisplayContent的焦点窗口。</p><h2 id="1-4-DisplayContent-updateFocusedWindowLocked"><a href="#1-4-DisplayContent-updateFocusedWindowLocked" class="headerlink" title="1.4 DisplayContent.updateFocusedWindowLocked"></a>1.4 DisplayContent.updateFocusedWindowLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">updateFocusedWindowLocked</span><span class="params">(<span class="type">int</span> mode, <span class="type">boolean</span> updateInputWindows,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> topFocusedDisplayId)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.4.1] 计算当前DisplayContent的焦点窗口，注意传入的topFocusedDisplayId是INVALID_DISPLAY</span></span><br><span class="line">    <span class="type">WindowState</span> <span class="variable">newFocus</span> <span class="operator">=</span> findFocusedWindowIfNeeded(topFocusedDisplayId);</span><br><span class="line">    <span class="comment">// 如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentFocus == newFocus) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">imWindowChanged</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">imWindow</span> <span class="operator">=</span> mInputMethodWindow;</span><br><span class="line">    <span class="comment">// 如果当前存在输入法窗口，这里我们先假设不存在</span></span><br><span class="line">    <span class="keyword">if</span> (imWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProtoLog.d(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;Changing focus from %s to %s displayId=%d Callers=%s&quot;</span>,</span><br><span class="line">            mCurrentFocus, newFocus, getDisplayId(), Debug.getCallers(<span class="number">4</span>));</span><br><span class="line">    <span class="comment">// 更新焦点窗口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">oldFocus</span> <span class="operator">=</span> mCurrentFocus;</span><br><span class="line">    mCurrentFocus = newFocus;</span><br><span class="line">    <span class="comment">// 如果新的焦点窗口不为null</span></span><br><span class="line">    <span class="keyword">if</span> (newFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">        mWinAddedSinceNullFocus.clear();</span><br><span class="line">        mWinRemovedSinceNullFocus.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newFocus.canReceiveKeys()) &#123;</span><br><span class="line">            <span class="comment">// 隐式地显示一个窗口将导致取消调度</span></span><br><span class="line">            <span class="comment">// 这是为了防止有人暂停调度但忘记resume</span></span><br><span class="line">            newFocus.mToken.paused = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [1.4.2] 通知其他模组焦点窗口更新了,主要是更新两个Task的阴影</span></span><br><span class="line">    onWindowFocusChanged(oldFocus, newFocus);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.4.3] 更新DisplayPolicy中相关参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">focusChanged</span> <span class="operator">=</span> getDisplayPolicy().focusChangedLw(oldFocus, newFocus);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((focusChanged &amp; FINISH_LAYOUT_REDO_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 焦点的变化导致需要做一个布局， SystemUI状态栏或者导航栏可见性有变化了</span></span><br><span class="line">        <span class="comment">// 将参数mLayoutNeeded置位true</span></span><br><span class="line">        setLayoutNeeded();</span><br><span class="line">        <span class="comment">// 这里传入的mode为UPDATE_FOCUS_WILL_ASSIGN_LAYERS</span></span><br><span class="line">        <span class="keyword">if</span> (mode == UPDATE_FOCUS_PLACING_SURFACES) &#123;</span><br><span class="line">            performLayout(<span class="literal">true</span> <span class="comment">/*initial*/</span>, updateInputWindows);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == UPDATE_FOCUS_REMOVING_FOCUS) &#123;</span><br><span class="line">            mWmService.mRoot.performSurfacePlacement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI</span></span><br><span class="line">    scheduleToastWindowsTimeoutIfNeededLocked(oldFocus, newFocus);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 记录新焦点窗口</span></span><br><span class="line">    mLastFocus = mCurrentFocus;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayContent更新焦点窗口的流程如下:</p><ol><li>计算当前DisplayContent的焦点窗口</li><li>如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作</li><li>如果当前存在输入法窗口,执行相关操作(后续分析输入法窗口)</li><li>更新焦点窗口，保存在mCurrentFocus中<ol><li>清空mWinAddedSinceNullFocus、mWinRemovedSinceNullFocus</li></ol></li><li>通知其他模组焦点窗口更新了,主要是更新两个Task（当前焦点窗口和新的焦点窗口所处的Task）的阴影</li><li>更新DisplayPolicy中相关参数<ol><li>更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性</li></ol></li><li>如果因焦点窗口变化导致SystemUI状态栏或者导航栏可见性有变化了，将参数mLayoutNeeded置位true</li><li>将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI</li><li>记录新焦点窗口，保存在mLastFocus中</li></ol><h3 id="1-4-1-DisplayContent-findFocusedWindowIfNeeded"><a href="#1-4-1-DisplayContent-findFocusedWindowIfNeeded" class="headerlink" title="1.4.1 DisplayContent.findFocusedWindowIfNeeded"></a>1.4.1 DisplayContent.findFocusedWindowIfNeeded</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WindowState <span class="title function_">findFocusedWindowIfNeeded</span><span class="params">(<span class="type">int</span> topFocusedDisplayId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (mWmService.mPerDisplayFocusEnabled || topFocusedDisplayId == INVALID_DISPLAY)</span><br><span class="line">                ? findFocusedWindow() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowState <span class="title function_">findFocusedWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    mTmpWindow = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// [1.4.1.1] 从上到下遍历所有的ActivityRecord，并对每一个执行mFindFocusedWindow方法</span></span><br><span class="line">    forAllWindows(mFindFocusedWindow, <span class="literal">true</span> <span class="comment">/* traverseTopToBottom */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTmpWindow == <span class="literal">null</span>) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;findFocusedWindow: No focusable windows, display=%d&quot;</span>,</span><br><span class="line">                getDisplayId());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mTmpWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的mFindFocusedWindow其实是一个函数: ToBooleanFunction<WindowState> mFindFocusedWindow, 这里又是使用了函数式编程的方法。我们先看forAllWindows方法，这个是被继承的祖父类WindowContainer中的方法。</WindowState></p><h4 id="1-4-1-1-WindowContainer-forAllWindows"><a href="#1-4-1-1-WindowContainer-forAllWindows" class="headerlink" title="1.4.1.1 WindowContainer.forAllWindows"></a>1.4.1.1 WindowContainer.forAllWindows</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">forAllWindows</span><span class="params">(ToBooleanFunction&lt;WindowState&gt; callback, <span class="type">boolean</span> traverseTopToBottom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (traverseTopToBottom) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mChildren.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildren.get(i).forAllWindows(callback, traverseTopToBottom)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mChildren.get(i).forAllWindows(callback, traverseTopToBottom)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对该WindowContainer的mChildren中的每一个元素执行forAllWindows，调用callback。traverseTopToBottom参数如果为true，则按z顺序从上到下遍历层次结构，否则从下到上遍历。如果因为传入的函数callback执行后的返回值为true,那么会中止遍历直接返回true。</p><p>回顾下DisplayContent的类图:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/6_1.png" alt="6-1"></p><p>可以看到DisplayContent的是从WindowContainer<WindowContainer>一路继承下来的，所以其mChildren就是 WindowList<DisplayArea>。</DisplayArea></WindowContainer></p><p>而DisplayArea也是继承了WindowContainer，所以到底这个DisplayContent里存储了什么元素呢？ 回到之前我们研究过的DisplayContent的创建 <em><strong>WMS(2)-WMS中RootDisplayArea的创建</strong></em>， 在这里我们知道DisplayContent的mChildren中存储的是DisplayArea的对象，所以而DisplayArea又是继承了WindowContainer，然而DisplayArea中的mChildren存储的是ActivityRecord或者WindowState.</p><h4 id="1-4-1-2-WindowState-forAllWindows"><a href="#1-4-1-2-WindowState-forAllWindows" class="headerlink" title="1.4.1.2 WindowState.forAllWindows"></a>1.4.1.2 WindowState.forAllWindows</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">forAllWindows</span><span class="params">(ToBooleanFunction&lt;WindowState&gt; callback, <span class="type">boolean</span> traverseTopToBottom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildren.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// The window has no children so we just return it.</span></span><br><span class="line">        <span class="keyword">return</span> applyInOrderWithImeWindows(callback, traverseTopToBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (traverseTopToBottom) &#123;</span><br><span class="line">        <span class="keyword">return</span> forAllWindowTopToBottom(callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> forAllWindowBottomToTop(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们假设该mChildren为null:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">applyInOrderWithImeWindows</span><span class="params">(ToBooleanFunction&lt;WindowState&gt; callback,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> traverseTopToBottom)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (traverseTopToBottom) &#123;</span><br><span class="line">        <span class="comment">// applyImeWindowsIfNeeded是用于处理输入法窗口的，暂时先不管。</span></span><br><span class="line">        <span class="keyword">if</span> (applyImeWindowsIfNeeded(callback, traverseTopToBottom)</span><br><span class="line">                <span class="comment">// [1.5] 对该Window执行传入的函数,即mFindFocusedWindow</span></span><br><span class="line">                || callback.apply(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback.apply(<span class="built_in">this</span>)</span><br><span class="line">                || applyImeWindowsIfNeeded(callback, traverseTopToBottom)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-DisplayContent-onWindowFocusChanged"><a href="#1-4-2-DisplayContent-onWindowFocusChanged" class="headerlink" title="1.4.2 DisplayContent.onWindowFocusChanged"></a>1.4.2 DisplayContent.onWindowFocusChanged</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(WindowState oldFocus, WindowState newFocus)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">focusedTask</span> <span class="operator">=</span> newFocus != <span class="literal">null</span> ? newFocus.getTask() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">unfocusedTask</span> <span class="operator">=</span> oldFocus != <span class="literal">null</span> ? oldFocus.getTask() : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果是同一个task就不需要额外动作</span></span><br><span class="line">    <span class="keyword">if</span> (focusedTask == unfocusedTask) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知新的焦点窗口所处的Task有焦点了</span></span><br><span class="line">    <span class="keyword">if</span> (focusedTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        focusedTask.onWindowFocusChanged(<span class="literal">true</span> <span class="comment">/* hasFocus */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 之前焦点窗口所处的Task失去焦点</span></span><br><span class="line">    <span class="keyword">if</span> (unfocusedTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        unfocusedTask.onWindowFocusChanged(<span class="literal">false</span> <span class="comment">/* hasFocus */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从WindowState中拿到的Task其实是其对应的ActivityRecord所在的Task：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowState.java</span></span><br><span class="line">Task <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mActivityRecord != <span class="literal">null</span> ? mActivityRecord.getTask() : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityRecord.java</span></span><br><span class="line">Task <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个ActivityRecord.task就是 <em><strong>WMS(3)-ActivityRecord和WindowToken</strong></em> 中 [1.7.1]里赋值的，其实就是该ActivityRecord的mParent（创建的新Task）。</p><h4 id="1-4-2-1-Task-onWindowFocusChanged"><a href="#1-4-2-1-Task-onWindowFocusChanged" class="headerlink" title="1.4.2.1 Task.onWindowFocusChanged"></a>1.4.2.1 Task.onWindowFocusChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onWindowFocusChanged</span><span class="params">(<span class="type">boolean</span> hasFocus)</span> &#123;</span><br><span class="line">    updateShadowsRadius(hasFocus, getSyncTransaction());</span><br><span class="line">    <span class="comment">// TODO(b/180525887): Un-comment once there is resolution on the bug.</span></span><br><span class="line">    <span class="comment">// dispatchTaskInfoChangedIfNeeded(false /* force */);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateShadowsRadius</span><span class="params">(<span class="type">boolean</span> taskIsFocused,</span></span><br><span class="line"><span class="params">        SurfaceControl.Transaction pendingTransaction)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!mWmService.mRenderShadowsInCompositor || !isRootTask()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据窗口模式和任务焦点状态更新阴影的长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> <span class="variable">newShadowRadius</span> <span class="operator">=</span> getShadowRadius(taskIsFocused);</span><br><span class="line">    <span class="keyword">if</span> (mShadowRadius != newShadowRadius) &#123;</span><br><span class="line">        mShadowRadius = newShadowRadius;</span><br><span class="line">        pendingTransaction.setShadowRadius(getSurfaceControl(), mShadowRadius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据该task是否持有焦点来更新阴影，后续研究</p><h3 id="1-4-3-DisplayPolicy-focusChangedLw"><a href="#1-4-3-DisplayPolicy-focusChangedLw" class="headerlink" title="1.4.3 DisplayPolicy.focusChangedLw"></a>1.4.3 DisplayPolicy.focusChangedLw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">focusChangedLw</span><span class="params">(WindowState lastFocus, WindowState newFocus)</span> &#123;</span><br><span class="line">    mFocusedWindow = newFocus;</span><br><span class="line">    mLastFocusedWindow = lastFocus;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayContent.isDefaultDisplay) &#123;</span><br><span class="line">        <span class="comment">// 更新PhoneWindowManager中相关参数，就是更新DisplayFoldController中的mFocusedApp(焦点窗口包名)</span></span><br><span class="line">        mService.mPolicy.onDefaultDisplayFocusChangedLw(newFocus);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新SystemUi的可见与否，比如状态栏等，后续研究</span></span><br><span class="line">    <span class="keyword">if</span> (updateSystemUiVisibilityLw()) &#123;</span><br><span class="line">        <span class="comment">// 如果导航栏已经被隐藏或显示，需要做另一个布局传递来更新窗口</span></span><br><span class="line">        <span class="keyword">return</span> FINISH_LAYOUT_REDO_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新DisplayPolicy中存储的焦点窗口相关信息，包括更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性。</p><h2 id="1-5-DisplayContent-mFindFocusedWindow"><a href="#1-5-DisplayContent-mFindFocusedWindow" class="headerlink" title="1.5 DisplayContent.mFindFocusedWindow"></a>1.5 DisplayContent.mFindFocusedWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ToBooleanFunction&lt;WindowState&gt; mFindFocusedWindow = w -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">focusedApp</span> <span class="operator">=</span> mFocusedApp;</span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS, <span class="string">&quot;Looking for focus: %s, flags=%d, canReceive=%b, reason=%s&quot;</span>,</span><br><span class="line">            w, w.mAttrs.flags, w.canReceiveKeys(),</span><br><span class="line">            w.canReceiveKeysReason(<span class="literal">false</span> <span class="comment">/* fromUserTouch */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查该窗口是否可以接收input事件</span></span><br><span class="line">    <span class="comment">// 无法接收输入事件的窗口没有资格作为焦点窗口</span></span><br><span class="line">    <span class="keyword">if</span> (!w.canReceiveKeys()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> w.mActivityRecord;</span><br><span class="line">    <span class="comment">// 如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了</span></span><br><span class="line">    <span class="keyword">if</span> (focusedApp == <span class="literal">null</span>) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_FOCUS_LIGHT,</span><br><span class="line">                <span class="string">&quot;findFocusedWindow: focusedApp=null using new focus @ %s&quot;</span>, w);</span><br><span class="line">        mTmpWindow = w;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口</span></span><br><span class="line">    <span class="keyword">if</span> (!focusedApp.windowsAreFocusable()) &#123;</span><br><span class="line">        ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;findFocusedWindow: focusedApp windows not&quot;</span></span><br><span class="line">                + <span class="string">&quot; focusable using new focus @ %s&quot;</span>, w);</span><br><span class="line">        mTmpWindow = w;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有app的token, 找到第一个符合要求的作为焦点窗口(从上到下遍历所有的ActivityRecord,所以第一个符合的token对应窗口Z轴最大)</span></span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="literal">null</span> &amp;&amp; w.mAttrs.type != TYPE_APPLICATION_STARTING) &#123;</span><br><span class="line">        <span class="comment">// WindowState对应的有Activity, 而且类型不能是启动窗口</span></span><br><span class="line">        <span class="comment">// [1.6] 对比计算Z轴大小</span></span><br><span class="line">        <span class="keyword">if</span> (focusedApp.compareTo(activity) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前焦点窗口Z轴比该Activity窗口大</span></span><br><span class="line">            ProtoLog.v(WM_DEBUG_FOCUS_LIGHT,</span><br><span class="line">                    <span class="string">&quot;findFocusedWindow: Reached focused app=%s&quot;</span>, focusedApp);</span><br><span class="line">            mTmpWindow = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了新的焦点窗口，暂存在mTmpWindow中</span></span><br><span class="line">    ProtoLog.v(WM_DEBUG_FOCUS_LIGHT, <span class="string">&quot;findFocusedWindow: Found new focus @ %s&quot;</span>, w);</span><br><span class="line">    mTmpWindow = w;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更新焦点窗口的步骤也不复杂：</p><ol><li>遍历该DisplayContent中mChildren中的所有DisplayArea</li><li>依次对比DisplayArea中的mChildren集合里面的Window(ActivityRecord或WindowState)<ol><li>检查该Window是否符合要求</li><li>无法接收输入事件的窗口没有资格作为焦点窗口</li><li>如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了</li><li>如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口</li><li>遍历所有app的token, 找到第一个符合要求的作为焦点窗口<ol><li>WindowState对应的有Activity, 而且类型不能是启动窗口</li><li>该Activity窗口Z轴比当前焦点窗口大</li><li>更新mTmpWindow为当前Activity窗口，否则置为null</li></ol></li></ol></li></ol><h2 id="1-6-ActivityRecord-compareTo"><a href="#1-6-ActivityRecord-compareTo" class="headerlink" title="1.6 ActivityRecord.compareTo"></a>1.6 ActivityRecord.compareTo</h2><p>ActivityRecord其实是调用了父类WindowContainer中的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(WindowContainer other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该Activity的mParent是同一个，那么就对比两个在其中所处的位置</span></span><br><span class="line">    <span class="comment">// 序号就代表了Z轴，可以理解为序号大的在上层，盖住序号小的</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span> &amp;&amp; mParent == other.mParent) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowList&lt;WindowContainer&gt; list = mParent.mChildren;</span><br><span class="line">        <span class="keyword">return</span> list.indexOf(<span class="built_in">this</span>) &gt; list.indexOf(other) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个WindowContainer不是同一个mParent, 那么先找到z轴最大的包含两个WC的父容器，然后对比z轴大小</span></span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;WindowContainer&gt; thisParentChain = mTmpChain1;</span><br><span class="line">    <span class="keyword">final</span> LinkedList&lt;WindowContainer&gt; otherParentChain = mTmpChain2;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [1.6.1] 获取当前WindowContainer的所有父容器</span></span><br><span class="line">        getParents(thisParentChain);</span><br><span class="line">        other.getParents(otherParentChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到z轴最大的且包含两个WC的父容器</span></span><br><span class="line">        <span class="type">WindowContainer</span> <span class="variable">commonAncestor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WindowContainer</span> <span class="variable">thisTop</span> <span class="operator">=</span> thisParentChain.peekLast();</span><br><span class="line">        <span class="type">WindowContainer</span> <span class="variable">otherTop</span> <span class="operator">=</span> otherParentChain.peekLast();</span><br><span class="line">        <span class="keyword">while</span> (thisTop != <span class="literal">null</span> &amp;&amp; otherTop != <span class="literal">null</span> &amp;&amp; thisTop == otherTop) &#123;</span><br><span class="line">            <span class="comment">// 移除拿到最后一个父容器</span></span><br><span class="line">            commonAncestor = thisParentChain.removeLast();</span><br><span class="line">            otherParentChain.removeLast();</span><br><span class="line">            thisTop = thisParentChain.peekLast();</span><br><span class="line">            otherTop = otherParentChain.peekLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子容器总是被认为比父容器大，所以如果将一个容器与另一个容器的父容器进行比较，那么无论如何都是子容器更大。</span></span><br><span class="line">        <span class="keyword">if</span> (commonAncestor == <span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (commonAncestor == other) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各自对比两个WC在Z轴最大的父容器中的位置</span></span><br><span class="line">        <span class="keyword">final</span> WindowList&lt;WindowContainer&gt; list = commonAncestor.mChildren;</span><br><span class="line">        <span class="keyword">return</span> list.indexOf(thisParentChain.peekLast()) &gt; list.indexOf(otherParentChain.peekLast())</span><br><span class="line">                ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mTmpChain1.clear();</span><br><span class="line">        mTmpChain2.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将WC的整个结构理解为树形结构，对比两个WC的Z轴大小就是对比这两个WC与最近的共同父节点的距离大小，距离越大，说明Z轴越大。</p><h3 id="1-6-1-WindowContainer-getParents"><a href="#1-6-1-WindowContainer-getParents" class="headerlink" title="1.6.1 WindowContainer.getParents"></a>1.6.1 WindowContainer.getParents</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getParents</span><span class="params">(LinkedList&lt;WindowContainer&gt; parents)</span> &#123;</span><br><span class="line">    parents.clear();</span><br><span class="line">    <span class="type">WindowContainer</span> <span class="variable">current</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parents.addLast(current);</span><br><span class="line">        current = current.mParent;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次遍历，将该WindowContainer的所有mParent添加到队列中.</p><h1 id="二-小结"><a href="#二-小结" class="headerlink" title="二. 小结"></a>二. 小结</h1><p>总的来说，更新焦点窗口就是对所有DisplayContent倒序遍历，依次计算新的焦点窗口：</p><ol><li>计算当前DisplayContent的焦点窗口<ol><li>遍历该DisplayContent中mChildren中的所有DisplayArea</li><li>依次对比DisplayArea中的mChildren集合里面的Window(ActivityRecord或WindowState)<ol><li>检查该Window是否符合要求</li><li>无法接收输入事件的窗口没有资格作为焦点窗口</li><li>如果当前没有焦点窗口，那么遍历的第一个可接受input事件的窗口就是焦点窗口了</li><li>如果当前焦点窗口已经不在可聚焦了，那么也是遍历的第一个可接受input事件的窗口作为焦点窗口</li><li>遍历所有app的token, 找到第一个符合要求的作为焦点窗口<ol><li>WindowState对应的有Activity, 而且类型不能是启动窗口</li><li>该Activity窗口Z轴比当前焦点窗口大</li><li>更新mTmpWindow为当前Activity窗口，否则置为null</li></ol></li></ol></li></ol></li><li>如果计算的新焦点窗口和当前焦点窗口是同一个，则无需额外动作</li><li>如果当前存在输入法窗口,执行相关操作(后续分析输入法窗口)</li><li>更新焦点窗口，保存在mCurrentFocus中<ol><li>清空mWinAddedSinceNullFocus、mWinRemovedSinceNullFocus</li></ol></li><li>通知其他模组焦点窗口更新了,主要是更新两个Task（当前焦点窗口和新的焦点窗口所处的Task）的阴影</li><li>更新DisplayPolicy中相关参数<ol><li>更新DisplayFoldController中的mFocusedApp(焦点窗口包名)，然后根据需要更新SystemUI的可见性</li></ol></li><li>如果因焦点窗口变化导致SystemUI状态栏或者导航栏可见性有变化了，将参数mLayoutNeeded置位true</li><li>将没有焦点的窗口的toast在超时时间后移除，防止其覆盖UI</li><li>记录新焦点窗口，保存在mLastFocus中</li></ol><h2 id="2-1-通知input系统更新焦点窗口"><a href="#2-1-通知input系统更新焦点窗口" class="headerlink" title="2.1 通知input系统更新焦点窗口"></a>2.1 通知input系统更新焦点窗口</h2><p>在WMS计算更新完焦点窗口之后，需要同步通知给input系统:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [2.1] 如果焦点窗口有更新，也需要更新input相关设置</span></span><br><span class="line"><span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">    displayContent.getInputMonitor().setInputFocusLw(displayContent.mCurrentFocus,</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很自然就有疑问，窗口可大可小，不同的窗口层叠起来，input系统是如何判断分发事件到正确的窗口呢？ 接下来我们先看看应用窗口和input的关系。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;这篇文章中我们重点关注焦点窗口的更新，所谓焦点窗口就是当前选择的窗口。在Android里可以通过下面的adb命令来查看当前的焦点窗口: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;adb shell dumpsys window |grep -iE “mCurr*”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道一个实体显示器对应一个DisplayId, 相应的有一个DisplayContent，如同我们人眼或者相机的对焦，同一时刻只能有一个焦点，那么对应一个Display一般来说也只有一个焦点窗口了。&lt;/p&gt;
&lt;p&gt;我们之前一直分析的WMS.addWindow，在应用进程调用setView传入对应窗口属性之后，当然也会有焦点窗口的重新计算了：&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
    <category term="Input" scheme="https://swallowjoe.github.io/tags/Input/"/>
    
  </entry>
  
  <entry>
    <title>WMS(5)-启动窗口</title>
    <link href="https://swallowjoe.github.io/2022/05/05/WMS(5)-%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>https://swallowjoe.github.io/2022/05/05/WMS(5)-%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2022-05-04T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:34.781Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>前面几篇文章中，我们弄清楚了WMS中比较核心的几个类的作用以及初始化等流程。现在我们看看Activity启动时的启动窗口动画过程，以此为锲子剖析WMS相关流程。</p><p>启动窗口，如其名，最合理的地方应该是在Activity启动的时候播放其动画的，回到startActivityInner，开始看:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/5_1.png" alt="5-1"></p><span id="more"></span><h1 id="一-启动窗口的初始化"><a href="#一-启动窗口的初始化" class="headerlink" title="一. 启动窗口的初始化"></a>一. 启动窗口的初始化</h1><h2 id="1-1-ActivityStarter-startActivityInner"><a href="#1-1-ActivityStarter-startActivityInner" class="headerlink" title="1.1 ActivityStarter.startActivityInner"></a>1.1 ActivityStarter.startActivityInner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 交给对应Task启动Activity</span></span><br><span class="line">    mTargetRootTask.startActivityLocked(mStartActivity,</span><br><span class="line">            topRootTask != <span class="literal">null</span> ? topRootTask.getTopNonFinishingActivity() : <span class="literal">null</span>, newTask,</span><br><span class="line">            mKeepCurTransition, mOptions, startFromSamePackage);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>在Activity启动过程中，在创建新的Task并将该ActivityRecord保存其中，之后就是将启动Activity的流程转交给Task继续执行.</p><h2 id="1-2-Task-startActivityLocked"><a href="#1-2-Task-startActivityLocked" class="headerlink" title="1.2 Task.startActivityLocked"></a>1.2 Task.startActivityLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="meta">@Nullable</span> ActivityRecord focusedTopActivity,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> newTask, <span class="type">boolean</span> keepCurTransition, ActivityOptions options,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> samePackage)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((!isHomeOrRecentsRootTask() || hasActivity()) &amp;&amp; allowMoveToFront) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">doShow</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// ActivityRecord.mLaunchTaskBehind 是用于表明启动该Activity时不需要动画</span></span><br><span class="line">        <span class="comment">// 与options:&quot;android:activity.animType&quot;有关(调用了makeTaskLaunchBehind)</span></span><br><span class="line">        <span class="comment">// 使用了这个标记说明正在启动的Activity将不会显示给用户，而是只能通过最近的任务列表使用</span></span><br><span class="line">        <span class="keyword">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class="line">            <span class="comment">// 显示启动窗口</span></span><br><span class="line">            <span class="comment">// 这里判断上一个task是否存在启动窗口</span></span><br><span class="line">            <span class="type">Task</span> <span class="variable">prevTask</span> <span class="operator">=</span> r.getTask();</span><br><span class="line">            <span class="comment">// 获取当前Task中的上一个具有启动窗口的ActivityRecord</span></span><br><span class="line">            <span class="type">ActivityRecord</span> <span class="variable">prev</span> <span class="operator">=</span> prevTask.topActivityWithStartingWindow();</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前Activity和启动窗口不在同一个task时，不会重用启动窗口</span></span><br><span class="line">                <span class="keyword">if</span> (prev.getTask() != prevTask) &#123;</span><br><span class="line">                    prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前Activity已经显示出来了，也不会重用启动窗口</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (prev.nowVisible) &#123;</span><br><span class="line">                    prev = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">splashScreenThemeResId</span> <span class="operator">=</span> options != <span class="literal">null</span></span><br><span class="line">                    ? options.getSplashScreenThemeResId() : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// [1.3] 显示启动窗口， 我们这里是第一个Activity，不存在启动窗口, 所以prev为null</span></span><br><span class="line">            r.showStartingWindow(prev, newTask, isTaskSwitch(r, focusedTopActivity),</span><br><span class="line">                    splashScreenThemeResId, samePackage);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// topFocusedActivity是当前展示的前台具有焦点的Activity对应的ActivityRecord</span></span><br><span class="line"><span class="comment">// 这里是判断是否需要切换Task, 当然需要</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isTaskSwitch</span><span class="params">(ActivityRecord r, ActivityRecord topFocusedActivity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> topFocusedActivity != <span class="literal">null</span> &amp;&amp; r.getTask() != topFocusedActivity.getTask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task中执行Activity的启动主要是：</p><ol><li>将该Activity对应的ActivityRecord放在该task合适的位置</li><li>顺便检查是否需要显示启动窗口，如果需要：<ol><li>检查是否可以重用启动窗口：<ol><li>当前Activity和启动窗口不在同一个task时，不会重用启动窗口</li><li>当前Activity已经显示出来了，也不会重用启动窗口</li></ol></li><li>显示启动窗口</li></ol></li></ol><h2 id="1-3-ActivityRecord-showStartingWindow"><a href="#1-3-ActivityRecord-showStartingWindow" class="headerlink" title="1.3 ActivityRecord.showStartingWindow"></a>1.3 ActivityRecord.showStartingWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="type">boolean</span> newTask, <span class="type">boolean</span> taskSwitch,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> splashScreenTheme, <span class="type">boolean</span> samePackage)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTaskOverlay) &#123;</span><br><span class="line">        <span class="comment">// 不显示overlay activity的启动窗口, 即始终处于最上层的Activity</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPendingOptions != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; mPendingOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123;</span><br><span class="line">        <span class="comment">// 当Activity动画类型为ANIM_SCENE_TRANSITION时，不显示启动窗口</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">CompatibilityInfo</span> <span class="variable">compatInfo</span> <span class="operator">=</span></span><br><span class="line">            mAtmService.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    <span class="comment">// 选择合适的窗口主题</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">resolvedTheme</span> <span class="operator">=</span> evaluateStartingWindowTheme(packageName, theme,</span><br><span class="line">            splashScreenTheme);</span><br><span class="line">    <span class="comment">// [1.4] 添加启动窗口</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">shown</span> <span class="operator">=</span> addStartingWindow(packageName, resolvedTheme,</span><br><span class="line">            compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            prev != <span class="literal">null</span> ? prev.appToken : <span class="literal">null</span>, newTask, taskSwitch, isProcessRunning(),</span><br><span class="line">            allowTaskSnapshot(),</span><br><span class="line">            mState.ordinal() &gt;= STARTED.ordinal() &amp;&amp; mState.ordinal() &lt;= STOPPED.ordinal(),</span><br><span class="line">            samePackage);</span><br><span class="line">    <span class="comment">// 成功添加时，标记此ActivityRecord的启动窗口状态为STARTING_WINDOW_SHOWN</span></span><br><span class="line">    <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示启动窗口首先需要检查是否需要显示，以下两种情况不显示启动窗口：</p><ol><li>当此Activity为始终处于最上层时</li><li>Activity动画类型为ANIM_SCENE_TRANSITION时</li></ol><p>然后选择合适窗口主题，添加启动窗口并在成功添加时，标记此ActivityRecord的启动窗口状态为STARTING_WINDOW_SHOWN，意为此Activity已经展示了启动窗口。</p><h2 id="1-4-ActivityRecord-addStartingWindow"><a href="#1-4-ActivityRecord-addStartingWindow" class="headerlink" title="1.4 ActivityRecord.addStartingWindow"></a>1.4 ActivityRecord.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addStartingWindow</span><span class="params">(String pkg, <span class="type">int</span> resolvedTheme, CompatibilityInfo compatInfo,</span></span><br><span class="line"><span class="params">        CharSequence nonLocalizedLabel, <span class="type">int</span> labelRes, <span class="type">int</span> icon, <span class="type">int</span> logo, <span class="type">int</span> windowFlags,</span></span><br><span class="line"><span class="params">        IBinder transferFrom, <span class="type">boolean</span> newTask, <span class="type">boolean</span> taskSwitch, <span class="type">boolean</span> processRunning,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> allowTaskSnapshot, <span class="type">boolean</span> activityCreated, <span class="type">boolean</span> samePackage)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 根据当前Activity相关参数配置启动窗口的窗口属性</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">typeParameter</span> <span class="operator">=</span> mWmService.mStartingSurfaceController</span><br><span class="line">            .makeStartingWindowTypeParameter(newTask, taskSwitch, processRunning,</span><br><span class="line">                    allowTaskSnapshot, activityCreated, samePackage);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建启动窗口相关数据</span></span><br><span class="line">    mStartingData = <span class="keyword">new</span> <span class="title class_">SplashScreenStartingData</span>(mWmService, pkg,</span><br><span class="line">            resolvedTheme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags,</span><br><span class="line">            getMergedOverrideConfiguration(), typeParameter);</span><br><span class="line">    <span class="comment">// 转交给WMS的动画处理线程执行启动窗口的动画</span></span><br><span class="line">    scheduleAddStartingWindow();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleAddStartingWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// DEBUG_ENABLE_SHELL_DRAWER是&quot;persist.debug.shell_starting_surface&quot;</span></span><br><span class="line">    <span class="comment">// 该属性默认为true</span></span><br><span class="line">    <span class="keyword">if</span> (StartingSurfaceController.DEBUG_ENABLE_SHELL_DRAWER) &#123;</span><br><span class="line">        <span class="comment">// 执行启动窗口动画</span></span><br><span class="line">        mAddStartingWindow.run();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是使用postAtFrontOfQueue，会将该动画放在执行队列最前面执行</span></span><br><span class="line">        <span class="keyword">if</span> (!mWmService.mAnimationHandler.hasCallbacks(mAddStartingWindow)) &#123;</span><br><span class="line">            ProtoLog.v(WM_DEBUG_STARTING_WINDOW, <span class="string">&quot;Enqueueing ADD_STARTING&quot;</span>);</span><br><span class="line">            mWmService.mAnimationHandler.postAtFrontOfQueue(mAddStartingWindow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加启动窗口的动作有很多，忽略细节，主要是封装该启动窗口的相关数据保存在SplashScreenStartingData中，然后执行启动窗口动画。</p><p>如果是转交给WMS的动画处理线程执行启动窗口的动画，而且是将该动画放在执行队列最前面执行。</p><p>至于WMS的mAnimationHandler是在类创建时初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WMS.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mAnimationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(AnimationThread.getHandler().getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">// AnimationThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">AnimationThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;android.anim&quot;</span>, THREAD_PRIORITY_DISPLAY, <span class="literal">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以mAnimationHandler执行所在的线程就是”android.anim”线程。</p><p>该ActivityRecord中的mAddStartingWindow也是类初始化时创建的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityRecord.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AddStartingWindow</span> <span class="variable">mAddStartingWindow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddStartingWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">AddStartingWindow</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-启动窗口的动画"><a href="#二-启动窗口的动画" class="headerlink" title="二. 启动窗口的动画"></a>二. 启动窗口的动画</h1><h2 id="2-1-AddStartingWindow-run"><a href="#2-1-AddStartingWindow-run" class="headerlink" title="2.1 AddStartingWindow.run"></a>2.1 AddStartingWindow.run</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> StartingData startingData;</span><br><span class="line">    <span class="keyword">synchronized</span> (mWmService.mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (mStartingData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 该对象被置null说明启动窗口动画被取消了...</span></span><br><span class="line">            ProtoLog.v(WM_DEBUG_STARTING_WINDOW,</span><br><span class="line">                    <span class="string">&quot;startingData was nulled out before handling&quot;</span></span><br><span class="line">                            + <span class="string">&quot; mAddStartingWindow: %s&quot;</span>, ActivityRecord.<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        startingData = mStartingData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProtoLog.v(WM_DEBUG_STARTING_WINDOW, <span class="string">&quot;Add starting %s: startingData=%s&quot;</span>,</span><br><span class="line">            <span class="built_in">this</span>, startingData);</span><br><span class="line"></span><br><span class="line">    WindowManagerPolicy.<span class="type">StartingSurface</span> <span class="variable">surface</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// [2.2] 创建启动窗口Surface</span></span><br><span class="line">        surface = startingData.createStartingSurface(ActivityRecord.<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Exception when adding starting window&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (surface != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">abort</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mWmService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">// 如果mStartingData现在被置null了，说明窗口成功创建并被添加了</span></span><br><span class="line">            <span class="keyword">if</span> (mStartingData == <span class="literal">null</span>) &#123;</span><br><span class="line">                ProtoLog.v(WM_DEBUG_STARTING_WINDOW, <span class="string">&quot;Aborted starting %s: startingData=%s&quot;</span>,</span><br><span class="line">                        ActivityRecord.<span class="built_in">this</span>, mStartingData);</span><br><span class="line"></span><br><span class="line">                mStartingWindow = <span class="literal">null</span>;</span><br><span class="line">                mStartingData = <span class="literal">null</span>;</span><br><span class="line">                abort = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将创建的启动窗口surface赋值给mStartingSurface</span></span><br><span class="line">                mStartingSurface = surface;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">            <span class="comment">// 如果启动窗口动画中止，则移除该Surface</span></span><br><span class="line">            surface.remove(<span class="literal">false</span> <span class="comment">/* prepareAnimation */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AddStartingWindow就是一个runnable, 执行的时候先判断当前启动窗口是否仍需要，如果需要就创建启动窗口的Surface，如果启动窗口被中止，则移除创建的Surface.</p><h2 id="2-2-StartingData-createStartingSurface"><a href="#2-2-StartingData-createStartingSurface" class="headerlink" title="2.2 StartingData.createStartingSurface"></a>2.2 StartingData.createStartingSurface</h2><p>ActivityRecord中的mStartingData就是SplashScreenStartingData类型的对象。SplashScreenStartingData是StartingData的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">StartingSurface <span class="title function_">createStartingSurface</span><span class="params">(ActivityRecord activity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mService.mStartingSurfaceController.createSplashScreenStartingSurface(</span><br><span class="line">            activity, mPkg, mTheme, mCompatInfo, mNonLocalizedLabel, mLabelRes, mIcon,</span><br><span class="line">            mLogo, mWindowFlags, mMergedOverrideConfiguration,</span><br><span class="line">            activity.getDisplayContent().getDisplayId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过WMS中的mStartingSurfaceController来创建StartingSurface, mStartingSurfaceController是在WMS初始化的时候创建，用来管理创建和释放启动窗口Surface。</p><h2 id="2-3-StartingSurfaceController-createSplashScreenStartingSurface"><a href="#2-3-StartingSurfaceController-createSplashScreenStartingSurface" class="headerlink" title="2.3 StartingSurfaceController.createSplashScreenStartingSurface"></a>2.3 StartingSurfaceController.createSplashScreenStartingSurface</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StartingSurface <span class="title function_">createSplashScreenStartingSurface</span><span class="params">(ActivityRecord activity, String packageName,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="type">int</span> labelRes,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> icon, <span class="type">int</span> logo, <span class="type">int</span> windowFlags, Configuration overrideConfig, <span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">        <span class="comment">// 这里的task是ActivityRecord中新创建的task</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> activity.getTask();</span><br><span class="line">        <span class="comment">// 注意activity.token其实就是ActivityRecord.Token， 在ActivityRecord初始化时有分析，作为该ActivityRecord本身</span></span><br><span class="line">        <span class="comment">// [2.4] mTaskOrganizerController.addStartingWindow</span></span><br><span class="line">        <span class="keyword">if</span> (task != <span class="literal">null</span> &amp;&amp; mService.mAtmService.mTaskOrganizerController.addStartingWindow(</span><br><span class="line">                task, activity.token, theme, <span class="literal">null</span> <span class="comment">/* taskSnapshot */</span>)) &#123;</span><br><span class="line">            <span class="comment">// 最终创建的Surface是ShellStartingSurface.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShellStartingSurface</span>(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终创建的Surface是ShellStartingSurface.</p><h2 id="2-4-TaskOrganizerController-addStartingWindow"><a href="#2-4-TaskOrganizerController-addStartingWindow" class="headerlink" title="2.4 TaskOrganizerController.addStartingWindow"></a>2.4 TaskOrganizerController.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">addStartingWindow</span><span class="params">(Task task, IBinder appToken, <span class="type">int</span> launchTheme,</span></span><br><span class="line"><span class="params">        TaskSnapshot taskSnapshot)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">rootTask</span> <span class="operator">=</span> task.getRootTask();</span><br><span class="line">    <span class="keyword">if</span> (rootTask == <span class="literal">null</span> || rootTask.mTaskOrganizer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskOrganizerState</span> <span class="variable">state</span> <span class="operator">=</span></span><br><span class="line">            mTaskOrganizerStates.get(rootTask.mTaskOrganizer.asBinder());</span><br><span class="line">    <span class="comment">// 通过TaskOrganizerState执行添加动作</span></span><br><span class="line">    state.addStartingWindow(task, appToken, launchTheme, taskSnapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaskOrganizerState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskOrganizerCallbacks mOrganizer;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(Task t, IBinder appToken, <span class="type">int</span> launchTheme,</span></span><br><span class="line"><span class="params">        TaskSnapshot taskSnapshot)</span> &#123;</span><br><span class="line">    mOrganizer.addStartingWindow(t, appToken, launchTheme, taskSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TaskOrganizerCallbacks</span></span><br><span class="line"><span class="keyword">final</span> ITaskOrganizer mTaskOrganizer;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(Task task, IBinder appToken, <span class="type">int</span> launchTheme,</span></span><br><span class="line"><span class="params">        TaskSnapshot taskSnapshot)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StartingWindowInfo</span> <span class="variable">info</span> <span class="operator">=</span> task.getStartingWindowInfo();</span><br><span class="line">    <span class="keyword">if</span> (launchTheme != <span class="number">0</span>) &#123;</span><br><span class="line">        info.splashScreenThemeResId = launchTheme;</span><br><span class="line">    &#125;</span><br><span class="line">    info.mTaskSnapshot = taskSnapshot;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 交给ITaskOrganizer执行，appToken就是ActivityRecord.token, 即ActivityRecord.Token类的对象</span></span><br><span class="line">        mTaskOrganizer.addStartingWindow(info, appToken);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Exception sending onTaskStart callback&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有点绕，我们看看mTaskOrganizer是什么,看看TaskOrganizerCallbacks和TaskOrganizerState的初始化可以知道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">TaskOrganizerCallbacks(ITaskOrganizer taskOrg,</span><br><span class="line">        Consumer&lt;Runnable&gt; deferTaskOrgCallbacksConsumer) &#123;</span><br><span class="line">    mDeferTaskOrgCallbacksConsumer = deferTaskOrgCallbacksConsumer;</span><br><span class="line">    <span class="comment">// mTaskOrganizer是该类对象初始化时传入的ITaskOrganizer</span></span><br><span class="line">    mTaskOrganizer = taskOrg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskOrganizerState(ITaskOrganizer organizer, <span class="type">int</span> uid) &#123;</span><br><span class="line">    <span class="keyword">final</span> Consumer&lt;Runnable&gt; deferTaskOrgCallbacksConsumer =</span><br><span class="line">            mDeferTaskOrgCallbacksConsumer != <span class="literal">null</span></span><br><span class="line">                    ? mDeferTaskOrgCallbacksConsumer</span><br><span class="line">                    : mService.mWindowManager.mAnimator::addAfterPrepareSurfacesRunnable;</span><br><span class="line">    mOrganizer = <span class="keyword">new</span> <span class="title class_">TaskOrganizerCallbacks</span>(organizer, deferTaskOrgCallbacksConsumer);</span><br><span class="line">    mDeathRecipient = <span class="keyword">new</span> <span class="title class_">DeathRecipient</span>(organizer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        organizer.asBinder().linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;TaskOrganizer failed to register death recipient&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mUid = uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以mTaskOrganizer还是TaskOrganizerState初始化时传入的。那么TaskOrganizerState是怎么初始化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TaskOrganizerController.java#121</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ParceledListSlice&lt;TaskAppearedInfo&gt; <span class="title function_">registerTaskOrganizer</span><span class="params">(ITaskOrganizer organizer)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (!mTaskOrganizerStates.containsKey(organizer.asBinder())) &#123;</span><br><span class="line">                mTaskOrganizers.add(organizer);</span><br><span class="line">                mTaskOrganizerStates.put(organizer.asBinder(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TaskOrganizerState</span>(organizer, uid));</span><br><span class="line">            &#125;</span><br><span class="line">            .......</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以是有其他进程调用了TaskOrganizerController的registerTaskOrganizer将该成员注册了，而这里的方法仅有TaskOrganizer.java#72调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission(android.Manifest.permission.MANAGE_ACTIVITY_TASKS)</span></span><br><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> List&lt;TaskAppearedInfo&gt; <span class="title function_">registerOrganizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mTaskOrganizerController.registerTaskOrganizer(mInterface).getList();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ITaskOrganizer</span> <span class="variable">mInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ITaskOrganizer</span>.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(StartingWindowInfo windowInfo,</span></span><br><span class="line"><span class="params">            IBinder appToken)</span> &#123;</span><br><span class="line">        mExecutor.execute(() -&gt; TaskOrganizer.<span class="built_in">this</span>.addStartingWindow(windowInfo, appToken));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BinderThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(<span class="meta">@NonNull</span> StartingWindowInfo info,</span></span><br><span class="line"><span class="params">        <span class="meta">@NonNull</span> IBinder appToken)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>所以这个是将启动窗口的信息通过binder调用，添加到实现TaskOrganizer的addStartingWindow方法的其他进程了，并非是系统进程管控。</p><p>总的来说AddStartingWindow.run这个就是做了两件事：</p><ol><li>创建启动窗口Surface， 即ShellStartingSurface</li><li>将启动窗口信息通过binder调用传递给实现TaskOrganizer的进程</li></ol><p>这里的流程和R的差异有点大，推测是Google希望启动窗口可以交给Launcher或者SystemUI实现，而不是由framework的system_server进程来管控。</p><p>搜索SystemUI源码可以发现，继承TaskOrganizer的类有一个：ShellTaskOrganizer!</p><h2 id="2-5-ShellTaskOrganizer-addStartingWindow"><a href="#2-5-ShellTaskOrganizer-addStartingWindow" class="headerlink" title="2.5 ShellTaskOrganizer.addStartingWindow"></a>2.5 ShellTaskOrganizer.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(StartingWindowInfo info, IBinder appToken)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mStartingWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">        mStartingWindow.addStartingWindow(info, appToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来Google还真是将启动窗口交给SystemUI模块了。</p><h1 id="三-SystemUI负责的启动窗口"><a href="#三-SystemUI负责的启动窗口" class="headerlink" title="三. SystemUI负责的启动窗口"></a>三. SystemUI负责的启动窗口</h1><p>上面我们知道一个Activity启动后，从App进程交给SystemServer处理，在创建该Activity的ActivityRecord, 并将其保存在对应的Task之后，会在需要的时候开始启动窗口的播放。</p><p>启动窗口在Android S上是交给SystemUI进程负责了，在以前是交给SystemServer的“android.anim”线程处理。</p><p>关于R上SystemUI的ShellTaskOrganizer这一块涉及到<a href="https://github.com/google/dagger">Dagger2, 是一款基于 Java 注解来实现的在编译阶段完成依赖注入的开源库</a>的使用，这里先不展开讲了，感兴趣的可以自行研究。</p><p>ShellTaskOrganizer中的mStartingWindow是StartingWindowController类对象。</p><h2 id="3-1-StartingWindowController-addStartingWindow"><a href="#3-1-StartingWindowController-addStartingWindow" class="headerlink" title="3.1 StartingWindowController.addStartingWindow"></a>3.1 StartingWindowController.addStartingWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStartingWindow</span><span class="params">(StartingWindowInfo windowInfo, IBinder appToken)</span> &#123;</span><br><span class="line">    mSplashScreenExecutor.execute(() -&gt; &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;addStartingWindow&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">suggestionType</span> <span class="operator">=</span> mStartingWindowTypeAlgorithm.getSuggestedWindowType(</span><br><span class="line">                windowInfo);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">RunningTaskInfo</span> <span class="variable">runningTaskInfo</span> <span class="operator">=</span> windowInfo.taskInfo;</span><br><span class="line">        <span class="keyword">if</span> (mTaskLaunchingCallback != <span class="literal">null</span> &amp;&amp; shouldSendToListener(suggestionType)) &#123;</span><br><span class="line">            mTaskLaunchingCallback.accept(runningTaskInfo.taskId, suggestionType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suggestionType == STARTING_WINDOW_TYPE_SPLASH_SCREEN) &#123;</span><br><span class="line">            mStartingSurfaceDrawer.addSplashScreenStartingWindow(windowInfo, appToken,</span><br><span class="line">                    <span class="literal">false</span> <span class="comment">/* emptyView */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suggestionType == STARTING_WINDOW_TYPE_EMPTY_SPLASH_SCREEN) &#123;</span><br><span class="line">            mStartingSurfaceDrawer.addSplashScreenStartingWindow(windowInfo, appToken,</span><br><span class="line">                    <span class="literal">true</span> <span class="comment">/* emptyView */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suggestionType == STARTING_WINDOW_TYPE_SNAPSHOT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">TaskSnapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> windowInfo.mTaskSnapshot;</span><br><span class="line">            mStartingSurfaceDrawer.makeTaskSnapshotWindow(windowInfo, appToken,</span><br><span class="line">                    snapshot);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/* suggestionType == STARTING_WINDOW_TYPE_NONE */</span> &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t add a staring window.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据启动窗口类型选择不同的启动窗口，这里我们假设是STARTING_WINDOW_TYPE_SPLASH_SCREEN类型。</p><h2 id="3-2-StartingSurfaceDrawer-addSplashScreenStartingWindow"><a href="#3-2-StartingSurfaceDrawer-addSplashScreenStartingWindow" class="headerlink" title="3.2 StartingSurfaceDrawer.addSplashScreenStartingWindow"></a>3.2 StartingSurfaceDrawer.addSplashScreenStartingWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addSplashScreenStartingWindow</span><span class="params">(StartingWindowInfo windowInfo, IBinder appToken,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> emptyView)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">RunningTaskInfo</span> <span class="variable">taskInfo</span> <span class="operator">=</span> windowInfo.taskInfo;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityInfo</span> <span class="variable">activityInfo</span> <span class="operator">=</span> taskInfo.topActivityInfo;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> mContext;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取启动窗口显示view的资源id</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] splashscreenContentResId = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 这里的R是 &quot;import com.android.internal.R;&quot; 说明是framework/res中的资源</span></span><br><span class="line">    getWindowResFromContext(context, a -&gt; &#123;</span><br><span class="line">        splashscreenContentResId[<span class="number">0</span>] =</span><br><span class="line">                a.getResourceId(R.styleable.Window_windowSplashscreenContent, <span class="number">0</span>);</span><br><span class="line">        showWallpaper[<span class="number">0</span>] = a.getBoolean(R.styleable.Window_windowShowWallpaper, <span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">PhoneWindow</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(context);</span><br><span class="line">    win.setIsStartingWindow(<span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    win.setType(WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line">    ......</span><br><span class="line">    win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">            WindowManager.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">params</span> <span class="operator">=</span> win.getAttributes();</span><br><span class="line">    <span class="comment">// 这里的appToken就是一路传递过来的待启动的activity的appToken,即ActivityRecord.Token类的对象</span></span><br><span class="line">    params.token = appToken;</span><br><span class="line">    params.packageName = activityInfo.packageName;</span><br><span class="line">    ......</span><br><span class="line">    params.setTitle(<span class="string">&quot;Splash Screen &quot;</span> + activityInfo.packageName);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SplashScreenViewSupplier</span> <span class="variable">viewSupplier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SplashScreenViewSupplier</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">setViewSynchronized</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取启动窗口的ContentView</span></span><br><span class="line">        <span class="comment">// SplashScreenViewSupplier.get必须要等待其被调用setView之后才会返回，否则会阻塞等待</span></span><br><span class="line">        <span class="type">SplashScreenView</span> <span class="variable">contentView</span> <span class="operator">=</span> viewSupplier.get();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 设置启动窗口View内容</span></span><br><span class="line">        win.setContentView(contentView);</span><br><span class="line">        contentView.cacheRootWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [3.3] 创建启动窗口对应的View</span></span><br><span class="line">    mSplashscreenContentDrawer.createContentView(context, emptyView,</span><br><span class="line">            splashscreenContentResId[<span class="number">0</span>], activityInfo, taskId, viewSupplier::setView);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> win.getDecorView();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowManager</span> <span class="variable">wm</span> <span class="operator">=</span> mContext.getSystemService(WindowManager.class);</span><br><span class="line">    <span class="comment">// 将启动窗口的View添加进WMS,创建对应的WindowState</span></span><br><span class="line">    postAddWindow(taskId, appToken, view, wm, params);</span><br><span class="line">    <span class="comment">// 请求Vsync,下一帧时调用setViewSynchronized，设置启动窗口View内容</span></span><br><span class="line">    mChoreographer.postCallback(CALLBACK_INSETS_ANIMATION, setViewSynchronized, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postAddWindow</span><span class="params">(<span class="type">int</span> taskId, IBinder appToken, View view, WindowManager wm,</span></span><br><span class="line"><span class="params">        WindowManager.LayoutParams params)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// WMS用来创建启动窗口对应的WindowState</span></span><br><span class="line">    <span class="comment">// 注意LayoutParams中的token是待启动的activity的appToken,即ActivityRecord.Token类的对象</span></span><br><span class="line">    wm.addView(view, params);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建启动窗口对应的PhoneWindow以及设置相关的参数，并将启动窗口的DecorView和窗口属性通过binder传给WMS用来创建对应的WindowState，最后通过Choreographer请求vsync，在下一帧的时候设置该启动窗口的内容。</p><h2 id="3-3-SplashscreenContentDrawer-createContentView"><a href="#3-3-SplashscreenContentDrawer-createContentView" class="headerlink" title="3.3 SplashscreenContentDrawer.createContentView"></a>3.3 SplashscreenContentDrawer.createContentView</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createContentView</span><span class="params">(Context context, <span class="type">boolean</span> emptyView, <span class="type">int</span> splashScreenResId,</span></span><br><span class="line"><span class="params">        ActivityInfo info, <span class="type">int</span> taskId, Consumer&lt;SplashScreenView&gt; consumer)</span> &#123;</span><br><span class="line">    mSplashscreenWorkerHandler.post(() -&gt; &#123;</span><br><span class="line">        SplashScreenView contentView;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// [3.3.1] 制作启动窗口显示的view</span></span><br><span class="line">            contentView = SplashscreenContentDrawer.makeSplashscreenContent(</span><br><span class="line">                    context, splashScreenResId);</span><br><span class="line">            <span class="comment">// Android S之后这个一般都是null的</span></span><br><span class="line">            <span class="keyword">if</span> (contentView == <span class="literal">null</span>) &#123;</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;makeSplashScreenContentView&quot;</span>);</span><br><span class="line">                <span class="comment">// emptyView是false的</span></span><br><span class="line">                <span class="keyword">if</span> (emptyView) &#123;</span><br><span class="line">                    contentView = makeEmptySplashScreenContentView(context);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// [3.3.2] 最后启动窗口的contentView是在这里创建的</span></span><br><span class="line">                    contentView = makeSplashScreenContentView(context, info);</span><br><span class="line">                &#125;</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;failed creating starting window content at taskId: &quot;</span></span><br><span class="line">                    + taskId, e);</span><br><span class="line">            contentView = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [3.4] consumer是传入的viewSupplier::setView</span></span><br><span class="line">        consumer.accept(contentView);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是创建启动窗口显示的内容，首先通过SplashscreenContentDrawer创建SplashScreenView.</p><h3 id="3-3-1-SplashscreenContentDrawer-makeSplashscreenContent"><a href="#3-3-1-SplashscreenContentDrawer-makeSplashscreenContent" class="headerlink" title="3.3.1 SplashscreenContentDrawer.makeSplashscreenContent"></a>3.3.1 SplashscreenContentDrawer.makeSplashscreenContent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SplashScreenView <span class="title function_">makeSplashscreenContent</span><span class="params">(Context ctx,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> splashscreenContentResId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前systemui的sdk版本</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">targetSdkVersion</span> <span class="operator">=</span> ctx.getApplicationInfo().targetSdkVersion;</span><br><span class="line">    <span class="comment">// Andriod S之后不支持Window_SplashscreenContent了</span></span><br><span class="line">    <span class="keyword">if</span> (targetSdkVersion &gt;= Build.VERSION_CODES.S) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Andriod S之后不支持Window_windowSplashscreenContent了.</p><h3 id="3-3-2-SplashscreenContentDrawer-makeSplashScreenContentView"><a href="#3-3-2-SplashscreenContentDrawer-makeSplashScreenContentView" class="headerlink" title="3.3.2 SplashscreenContentDrawer.makeSplashScreenContentView"></a>3.3.2 SplashscreenContentDrawer.makeSplashScreenContentView</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SplashScreenView <span class="title function_">makeSplashScreenContentView</span><span class="params">(Context context, ActivityInfo ai)</span> &#123;</span><br><span class="line">    <span class="comment">// 重置View相关配置</span></span><br><span class="line">    updateDensity();</span><br><span class="line">    <span class="comment">// 重置窗口相关属性至mTmpAttrs中保存</span></span><br><span class="line">    getWindowAttrs(context, mTmpAttrs);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StartingWindowViewBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StartingWindowViewBuilder</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> animationDuration;</span><br><span class="line">    Drawable iconDrawable;</span><br><span class="line">    <span class="comment">// mReplaceIcon默认是R.styleable.Window_windowSplashScreenAnimatedIcon</span></span><br><span class="line">    <span class="keyword">if</span> (mTmpAttrs.mReplaceIcon != <span class="literal">null</span>) &#123;</span><br><span class="line">        iconDrawable = mTmpAttrs.mReplaceIcon;</span><br><span class="line">        animationDuration = Math.max(<span class="number">0</span>,</span><br><span class="line">                Math.min(mTmpAttrs.mAnimationDuration, mMaxAnimatableIconDuration));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iconDrawable = mIconProvider.getIconForUI(</span><br><span class="line">                ai, getUserHandleForUid(ai.applicationInfo.uid));</span><br><span class="line">        <span class="keyword">if</span> (iconDrawable == <span class="literal">null</span>) &#123;</span><br><span class="line">            iconDrawable = context.getPackageManager().getDefaultActivityIcon();</span><br><span class="line">        &#125;</span><br><span class="line">        animationDuration = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选择启动窗口背景颜色</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">themeBGColor</span> <span class="operator">=</span> peekWindowBGColor(context);</span><br><span class="line">    <span class="comment">// [3.3.3] 创建SplashScreenView</span></span><br><span class="line">    <span class="keyword">return</span> builder</span><br><span class="line">            .setContext(context)</span><br><span class="line">            .setWindowBGColor(themeBGColor)</span><br><span class="line">            .setIconDrawable(iconDrawable)</span><br><span class="line">            .setIconAnimationDuration(animationDuration)</span><br><span class="line">            .setBrandingDrawable(mTmpAttrs.mBrandingImage)</span><br><span class="line">            .setIconBackground(mTmpAttrs.mIconBgColor).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先重置相关配置属性，然后根据默认配置创建SplashScreenView。</p><h3 id="3-3-3-StartingWindowViewBuilder-build"><a href="#3-3-3-StartingWindowViewBuilder-build" class="headerlink" title="3.3.3 StartingWindowViewBuilder.build"></a>3.3.3 StartingWindowViewBuilder.build</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SplashScreenView <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// mIconDrawable必须不为空且是AdaptiveIconDrawable的实例</span></span><br><span class="line">    <span class="keyword">if</span> (!processAdaptiveIcon() &amp;&amp; mIconDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">&quot;The icon is not an AdaptiveIconDrawable&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        createIconDrawable(mIconDrawable, mIconSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">iconSize</span> <span class="operator">=</span> mFinalIconDrawable != <span class="literal">null</span> ? (<span class="type">int</span>) (mIconSize * mScale) : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 填充SplashScreenView内容</span></span><br><span class="line">    mCachedResult = fillViewWithIcon(mContext, iconSize, mFinalIconDrawable);</span><br><span class="line">    mBuildComplete = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> mCachedResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也仅仅是检查了下mIconDrawable是否为AdaptiveIconDrawable的实例，如果不是则重新创建一个。然后使用fillViewWithIcon填充内容，创建SplashScreenView.</p><h3 id="3-3-4-StartingWindowViewBuilder-fillViewWithIcon"><a href="#3-3-4-StartingWindowViewBuilder-fillViewWithIcon" class="headerlink" title="3.3.4 StartingWindowViewBuilder.fillViewWithIcon"></a>3.3.4 StartingWindowViewBuilder.fillViewWithIcon</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SplashScreenView <span class="title function_">fillViewWithIcon</span><span class="params">(Context context,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> iconSize, Drawable iconDrawable)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;fillViewWithIcon&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> SplashScreenView.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SplashScreenView</span>.Builder(context);</span><br><span class="line">    builder.setIconSize(iconSize).setBackgroundColor(mThemeColor)</span><br><span class="line">            .setIconBackground(mIconBackground);</span><br><span class="line">    <span class="keyword">if</span> (iconDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.setCenterViewDrawable(iconDrawable);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.setAnimationDurationMillis(mIconAnimationDuration);</span><br><span class="line">    <span class="keyword">if</span> (mBrandingDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.setBrandingDrawable(mBrandingDrawable, mBrandingImageWidth,</span><br><span class="line">                mBrandingImageHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.3.5 实例化SplashScreenView</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SplashScreenView</span> <span class="variable">splashScreenView</span> <span class="operator">=</span> builder.build();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">&quot;fillViewWithIcon surfaceWindowView &quot;</span> + splashScreenView);</span><br><span class="line">    &#125;</span><br><span class="line">    splashScreenView.makeSystemUIColorsTransparent();</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    <span class="keyword">return</span> splashScreenView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置待创建的SplashScreenView相关的内容，如主题颜色、图标背景色、图标动画时长、三方应用的图标等等，然后通过build构建SplashScreenView.</p><h3 id="3-3-5-SplashScreenView-Builder-build"><a href="#3-3-5-SplashScreenView-Builder-build" class="headerlink" title="3.3.5 SplashScreenView.Builder.build"></a>3.3.5 SplashScreenView.Builder.build</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SplashScreenView <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;SplashScreenView#build&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">LayoutInflater</span> <span class="variable">layoutInflater</span> <span class="operator">=</span> LayoutInflater.from(mContext);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SplashScreenView</span> <span class="variable">view</span> <span class="operator">=</span> (SplashScreenView)</span><br><span class="line">            layoutInflater.inflate(R.layout.splash_screen_view, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    ......</span><br><span class="line">    view.mIconView = view.findViewById(R.id.splashscreen_icon_view);</span><br><span class="line">    view.mBrandingImageView = view.findViewById(R.id.splashscreen_branding_view);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 设置icon图像</span></span><br><span class="line">    <span class="keyword">if</span> (mIconDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        view.mIconView.setBackground(mIconDrawable);</span><br><span class="line">        view.initIconAnimation(mIconDrawable,</span><br><span class="line">                mIconAnimationDuration != <span class="literal">null</span> ? mIconAnimationDuration.toMillis() : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 设置brand图像</span></span><br><span class="line">    <span class="keyword">if</span> (mBrandingImageHeight &gt; <span class="number">0</span> &amp;&amp; mBrandingImageWidth &gt; <span class="number">0</span> &amp;&amp; mBrandingDrawable != <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        view.mBrandingImageView.setBackground(mBrandingDrawable);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SplashScreenView是继承FrameLayout的，通过LayoutInflater实例化splash_screen_view作为其内容布局:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.window.SplashScreenView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/splashscreen_icon_view&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/splash_screen_view_icon_description&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/splashscreen_branding_view&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal|bottom&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;60dp&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/splash_screen_view_branding_description&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.window.SplashScreenView</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个非常简单，就是两个View, 所以说启动窗口的显示内容就是两个图标（如果有图标对应的image不为null,则会显示）。</p><h2 id="3-4-SplashScreenViewSupplier-setView"><a href="#3-4-SplashScreenViewSupplier-setView" class="headerlink" title="3.4 SplashScreenViewSupplier.setView"></a>3.4 SplashScreenViewSupplier.setView</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SplashScreenViewSupplier</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;SplashScreenView&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> SplashScreenView mView;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsViewSet;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(SplashScreenView view)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存SplashScreenView并通知其他线程继续执行get</span></span><br><span class="line">            mView = view;</span><br><span class="line">            mIsViewSet = <span class="literal">true</span>;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> SplashScreenView <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!mIsViewSet) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的主要作用就是将SplashScreenView的创建交给与使用线程不同的线程。</p><h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四.小结"></a>四.小结</h1><p>来一张流程图回顾下启动窗口被添加的过程:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/5_2.png" alt="5-2"></p><p>虽然启动窗口对应的View和内容是通过SystemUI创建的，但是其还是被WMS归属为待启动的Activity的Task中的一员。究其原因还是其窗口属性中的token是该Activity对应的ActivityRecord.Token。SystemUI创建启动窗口的内容后，会在下一帧来时将该View添加到WMS中，然后WMS就会在addWindow里创建对应的WindowState。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;前面几篇文章中，我们弄清楚了WMS中比较核心的几个类的作用以及初始化等流程。现在我们看看Activity启动时的启动窗口动画过程，以此为锲子剖析WMS相关流程。&lt;/p&gt;
&lt;p&gt;启动窗口，如其名，最合理的地方应该是在Activity启动的时候播放其动画的，回到startActivityInner，开始看:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/WMS%E7%B3%BB%E5%88%97/5_1.png&quot; alt=&quot;5-1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
  </entry>
  
  <entry>
    <title>WMS(4)-WindowState创建及移除</title>
    <link href="https://swallowjoe.github.io/2022/05/04/WMS(4)-WindowState%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%A7%BB%E9%99%A4/"/>
    <id>https://swallowjoe.github.io/2022/05/04/WMS(4)-WindowState%E5%88%9B%E5%BB%BA%E5%8F%8A%E7%A7%BB%E9%99%A4/</id>
    <published>2022-05-03T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:31.689Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord!</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// [1.1] 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// [1.2] 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState, key为ViewRoomImpl.W</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将该WindowState保存在其mToken(ActivityRecord)中</span></span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一-WindowState"><a href="#一-WindowState" class="headerlink" title="一. WindowState"></a>一. WindowState</h1><p>WindowState，顾名思义是用于保存窗口状态的类，WindowToke是用于标记窗口身份、对应哪个进程的Activity的类。</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/4_1.png" alt="4-1"></p><h2 id="1-1-WindowState的初始化"><a href="#1-1-WindowState的初始化" class="headerlink" title="1.1 WindowState的初始化"></a>1.1 WindowState的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">        WindowState parentWindow, <span class="type">int</span> appOp, WindowManager.LayoutParams a, <span class="type">int</span> viewVisibility,</span><br><span class="line">        <span class="type">int</span> ownerId, <span class="type">int</span> showUserId, <span class="type">boolean</span> ownerCanAddInternalSystemWindow,</span><br><span class="line">        PowerManagerWrapper powerManagerWrapper) &#123;</span><br><span class="line">    <span class="built_in">super</span>(service);</span><br><span class="line">    <span class="comment">// 创建Transaction，用于和SurfaceFlinger通信</span></span><br><span class="line">    <span class="comment">// mTransactionFactory是实现了Supplier接口的SurfaceControl.Transaction::new</span></span><br><span class="line">    mTmpTransaction = service.mTransactionFactory.get();</span><br><span class="line">    <span class="comment">// mSession就是ViewRootImpl对应的mWindowSession</span></span><br><span class="line">    mSession = s;</span><br><span class="line">    <span class="comment">// mClinet就是ViewRootImpl中的mWindow(即W类的对象)</span></span><br><span class="line">    mClient = c;</span><br><span class="line">    mAppOp = appOp;</span><br><span class="line">    <span class="comment">// mToken即WindowToke,也就是该WindowState对应的ActivityRecord</span></span><br><span class="line">    mToken = token;</span><br><span class="line">    mActivityRecord = mToken.asActivityRecord();</span><br><span class="line">    mOwnerUid = ownerId;</span><br><span class="line">    mShowUserId = showUserId;</span><br><span class="line">    mOwnerCanAddInternalSystemWindow = ownerCanAddInternalSystemWindow;</span><br><span class="line">    <span class="comment">// 创建WindowId</span></span><br><span class="line">    mWindowId = <span class="keyword">new</span> <span class="title class_">WindowId</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 保存该Activity的View对应的窗口属性</span></span><br><span class="line">    mAttrs.copyFrom(a);</span><br><span class="line">    mLastSurfaceInsets.set(mAttrs.surfaceInsets);</span><br><span class="line">    mViewVisibility = viewVisibility;</span><br><span class="line">    <span class="comment">// mPolicy就是PhoneWindowPolicy</span></span><br><span class="line">    mPolicy = mWmService.mPolicy;</span><br><span class="line">    mContext = mWmService.mContext;</span><br><span class="line">    <span class="comment">// 创建WindowState所处进程的死亡监听</span></span><br><span class="line">    <span class="type">DeathRecipient</span> <span class="variable">deathRecipient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeathRecipient</span>();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建InputApplicationHandle, 将该Window注册进Input系统，以便后续input事件传输</span></span><br><span class="line">    mInputWindowHandle = <span class="keyword">new</span> <span class="title class_">InputWindowHandleWrapper</span>(<span class="keyword">new</span> <span class="title class_">InputWindowHandle</span>(</span><br><span class="line">            mActivityRecord != <span class="literal">null</span></span><br><span class="line">                    ? mActivityRecord.getInputApplicationHandle(<span class="literal">false</span> <span class="comment">/* update */</span>) : <span class="literal">null</span>,</span><br><span class="line">            getDisplayId()));</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// IWindow(ViewRootImpl.W) 建立binder死亡监听</span></span><br><span class="line">        c.asBinder().linkToDeath(deathRecipient, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 当前 Window type仍旧是TYPE_BASE_APPLICATION</span></span><br><span class="line">    <span class="keyword">if</span> (mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将baseLayer设置为window类型对应的layer * TYPE_LAYER_MULTIPLIER 再加上一段偏移</span></span><br><span class="line">        <span class="comment">// 即 baseLayer = windowLayer * 10000 + 1000;</span></span><br><span class="line">        mBaseLayer = mPolicy.getWindowLayerLw(<span class="built_in">this</span>)</span><br><span class="line">                * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;</span><br><span class="line">        mSubLayer = <span class="number">0</span>;</span><br><span class="line">        mIsChildWindow = <span class="literal">false</span>;</span><br><span class="line">        mLayoutAttached = <span class="literal">false</span>;</span><br><span class="line">        mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD</span><br><span class="line">                || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;</span><br><span class="line">        mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是输入法或者壁纸窗口，则标记为floating layer.</span></span><br><span class="line">    mIsFloatingLayer = mIsImWindow || mIsWallpaper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mActivityRecord != <span class="literal">null</span> &amp;&amp; mActivityRecord.mShowForAllUsers) &#123;</span><br><span class="line">        <span class="comment">// 标记可以为所有用户显示的应用窗口可以在锁屏时显示</span></span><br><span class="line">        mAttrs.flags |= FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建WindowAnimator，用于实现该窗口的动画</span></span><br><span class="line">    mWinAnimator = <span class="keyword">new</span> <span class="title class_">WindowStateAnimator</span>(<span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 非系统进程会有WPC来响应管理该窗口所属进程状态变化</span></span><br><span class="line">    mWpcForDisplayAreaConfigChanges = (s.mPid == MY_PID || s.mPid &lt; <span class="number">0</span>)</span><br><span class="line">            ? <span class="literal">null</span></span><br><span class="line">            : service.mAtmService.getProcessController(s.mPid, s.mUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化WindowState的过程并不复杂：</p><ol><li>调用SurfaceControl.Transaction::new创建mTmpTransaction</li><li>保存来自应用ViewRootImpl中的mWindowSession、mWindow等</li><li>保存该WindowState对应window的ActivityRecord</li><li>创建WindowId</li><li>保存该Activity的View对应的窗口属性</li><li>创建InputApplicationHandle，即将该Window注册进Input系统，以便后续input事件传输</li><li>建立binder死亡监听,处理该WindowState所属应用进程死亡后资源处理</li><li>计算mBaseLayer，mBaseLayer &#x3D; windowLayer(2) * 10000 + 1000;</li><li>标记mIsChildWindow、mIsImWindow（输入法窗口）、mIsWallpaper（壁纸窗口）</li><li>创建WindowAnimator，用于实现该窗口的动画</li><li>获取该pid对应的WindowProcessController</li></ol><p>这里关于input相关的流程我们后续分析。</p><h2 id="1-2-WindowState-attach"><a href="#1-2-WindowState-attach" class="headerlink" title="1.2 WindowState.attach"></a>1.2 WindowState.attach</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">attach</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">&quot;Attaching &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; token=&quot;</span> + mToken);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的，直接交给mSession处理。</p><h3 id="1-2-1-Session-windowAddedLocked"><a href="#1-2-1-Session-windowAddedLocked" class="headerlink" title="1.2.1 Session.windowAddedLocked"></a>1.2.1 Session.windowAddedLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">windowAddedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 第一次进入则需要创建mSurfaceSession</span></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.v(TAG_WM, <span class="string">&quot;First window added to &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;, creating SurfaceSession&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建SurfaceSession</span></span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> <span class="title class_">SurfaceSession</span>();</span><br><span class="line">        ProtoLog.i(WM_SHOW_TRANSACTIONS, <span class="string">&quot;  NEW SURFACE SESSION %s&quot;</span>, mSurfaceSession);</span><br><span class="line">        <span class="comment">// 新创建的SurfaceSession后，将此Session保存至WMS中的mSessions集合中</span></span><br><span class="line">        mService.mSessions.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记窗口数量增一</span></span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceSession是用于和SurfaceFlinger通信的，因为Session是单个进程只会持有一个，所以创建SurfaceSession也只会初始化一次。</p><blockquote><p>创建Session的过程：WindowManagerGlobal.getWindowSession</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;<span class="comment">// WindowManagerGlobal.getWindowSession</span></span><br><span class="line">&gt;&gt;<span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title function_">getWindowSession</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">       <span class="comment">// 单个进程仅会创建一次</span></span><br><span class="line">       <span class="keyword">if</span> (sWindowSession == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ......</span><br><span class="line">               sWindowSession = windowManager.openSession(</span><br><span class="line">               ......</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sWindowSession;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="1-2-2-创建SurfaceSession"><a href="#1-2-2-创建SurfaceSession" class="headerlink" title="1.2.2 创建SurfaceSession"></a>1.2.2 创建SurfaceSession</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">nativeCreate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SurfaceSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过JNI创建</span></span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接通过JNI创建对应native层对象，关于JNI后续单独出文章分析，有一个最简单的法则：</p><p>SurfaceSession所处的包是 “android.view”, 所以对应JNI文件就是:android_view_SurfaceSession.cpp</p><h3 id="1-2-3-android-view-SurfaceSession-cpp-nativeCreate"><a href="#1-2-3-android-view-SurfaceSession-cpp-nativeCreate" class="headerlink" title="1.2.3 android_view_SurfaceSession.cpp:nativeCreate"></a>1.2.3 android_view_SurfaceSession.cpp:nativeCreate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对应创建的是SurfaceComposerClient</span></span><br><span class="line">    SurfaceComposerClient* client = <span class="keyword">new</span> <span class="built_in">SurfaceComposerClient</span>();</span><br><span class="line">    <span class="comment">// 对象引用计数加一</span></span><br><span class="line">    client-&gt;<span class="built_in">incStrong</span>((<span class="type">void</span>*)nativeCreate);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceSession对应的native层对象就是SurfaceComposerClient！</p><h3 id="1-2-4-创建SurfaceComposerClient"><a href="#1-2-4-创建SurfaceComposerClient" class="headerlink" title="1.2.4 创建SurfaceComposerClient"></a>1.2.4 创建SurfaceComposerClient</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::<span class="built_in">SurfaceComposerClient</span>()</span><br><span class="line">    : <span class="built_in">mStatus</span>(NO_INIT)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记mStatus为NO_INIT，尚未初始化。</p><p>回过头看WindowState.attach，这个方法其实就是创建mSurfaceSession并将其保存在WMS.mSessions集合中。而SurfaceSession其实就是对native层SurfaceComposerClient的包装。</p><h2 id="1-3-WindowState所属应用进程死亡"><a href="#1-3-WindowState所属应用进程死亡" class="headerlink" title="1.3 WindowState所属应用进程死亡"></a>1.3 WindowState所属应用进程死亡</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binderDied</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">resetSplitScreenResizing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mWmService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">// [1.3.1] 获取WindowState</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> mWmService</span><br><span class="line">                    .windowForClientLocked(mSession, mClient, <span class="literal">false</span>);</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;WIN DEATH: &quot;</span> + win);</span><br><span class="line">            <span class="comment">// 当WindowState尚未被移除时</span></span><br><span class="line">            <span class="keyword">if</span> (win != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> getDisplayContent();</span><br><span class="line">                <span class="comment">// 如果该WindowState是对应Activity的，且WindowState的mChildren中类型为TYPE_BASE_APPLICATION的WindowState</span></span><br><span class="line">                <span class="comment">// 就是保存在WMS中的WindowState</span></span><br><span class="line">                <span class="keyword">if</span> (win.mActivityRecord != <span class="literal">null</span> &amp;&amp; win.mActivityRecord.findMainWindow() == win) &#123;</span><br><span class="line">                    mWmService.mTaskSnapshotController.onAppDied(win.mActivityRecord);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// [1.3.2] 移除该WindowState</span></span><br><span class="line">                win.removeIfPossible(shouldKeepVisibleDeadAppWindow());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHasSurface) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">&quot;!!! LEAK !!! Window removed but surface still valid.&quot;</span>);</span><br><span class="line">                WindowState.<span class="built_in">this</span>.removeIfPossible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="comment">// This will happen if the window has already been removed.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-1-WMS-windowForClientLocked"><a href="#1-3-1-WMS-windowForClientLocked" class="headerlink" title="1.3.1 WMS.windowForClientLocked"></a>1.3.1 WMS.windowForClientLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WindowState <span class="title function_">windowForClientLocked</span><span class="params">(Session session, IWindow client, <span class="type">boolean</span> throwOnError)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> windowForClientLocked(session, client.asBinder(), throwOnError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> WindowState <span class="title function_">windowForClientLocked</span><span class="params">(Session session, IBinder client, <span class="type">boolean</span> throwOnError)</span> &#123;</span><br><span class="line">    <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> mWindowMap.get(client);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.v(TAG_WM, <span class="string">&quot;Looking up client &quot;</span> + client + <span class="string">&quot;: &quot;</span> + win);</span><br><span class="line">    <span class="keyword">if</span> (win == <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; win.mSession != session) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> win;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从WMS的mWindowMap中查找client(ViewRootImpl.W)对应的WindowState, 这个是在addWindow时保存的。</p><h3 id="1-3-2-WindowState-removeIfPossible"><a href="#1-3-2-WindowState-removeIfPossible" class="headerlink" title="1.3.2 WindowState.removeIfPossible"></a>1.3.2 WindowState.removeIfPossible</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeIfPossible</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// WindowState是WindowContainer的子类，这里是对mChilder中的每一个WindowContainer执行removeIfPossible</span></span><br><span class="line">    <span class="built_in">super</span>.removeIfPossible();</span><br><span class="line">    removeIfPossible(<span class="literal">false</span> <span class="comment">/*keepVisibleDeadWindow*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeIfPossible</span><span class="params">(<span class="type">boolean</span> keepVisibleDeadWindow)</span> &#123;</span><br><span class="line">    <span class="comment">// 标记该WindowState是被移除的</span></span><br><span class="line">    mWindowRemovalAllowed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 应用启动窗口？</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">startingWindow</span> <span class="operator">=</span> mAttrs.type == TYPE_APPLICATION_STARTING;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将该WindowState从Input系统中移除</span></span><br><span class="line">        disposeInputChannel();</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记待移除窗口的可见性</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasVisible</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先确认是否需要运行动画。如果需要，必须推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。</span></span><br><span class="line">        <span class="keyword">if</span> (mHasSurface &amp;&amp; mToken.okToAnimate()) &#123;</span><br><span class="line">            <span class="comment">// 该窗口将被替换，只需要标记相关状态，等待被替换完成即可。</span></span><br><span class="line">            <span class="keyword">if</span> (mWillReplaceWindow) &#123;</span><br><span class="line">                ......</span><br><span class="line">                mAnimatingExit = <span class="literal">true</span>;</span><br><span class="line">                mReplacingRemoveRequested = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录待移除的窗口是否可见</span></span><br><span class="line">            wasVisible = isWinVisibleLw();</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 如果是可见的，需要创建一个窗口退出动画</span></span><br><span class="line">            <span class="keyword">if</span> (wasVisible) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">transit</span> <span class="operator">=</span> (!startingWindow) ? TRANSIT_EXIT : TRANSIT_PREVIEW_DONE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mWinAnimator.applyAnimationLocked(transit, <span class="literal">false</span>)) &#123;</span><br><span class="line">                    mAnimatingExit = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 请求vsync进行动画</span></span><br><span class="line">                    setDisplayLayoutNeeded();</span><br><span class="line">                    mWmService.requestTraversal();</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [1.3.2.1] 将此WindowState移除</span></span><br><span class="line">        removeImmediately();</span><br><span class="line">        <span class="comment">// 移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数</span></span><br><span class="line">        <span class="keyword">if</span> (wasVisible) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContent();</span><br><span class="line">            <span class="keyword">if</span> (displayContent.updateOrientation()) &#123;</span><br><span class="line">                displayContent.sendNewConfiguration();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除窗口后，计算更新焦点窗口</span></span><br><span class="line">        mWmService.updateFocusedWindowLocked(isFocused()</span><br><span class="line">                        ? UPDATE_FOCUS_REMOVING_FOCUS</span><br><span class="line">                        : UPDATE_FOCUS_NORMAL,</span><br><span class="line">                <span class="literal">true</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>窗口所属进程死亡后，需要清理该窗口的WindowState:</p><ol><li>标记该WindowState是被移除的,mWindowRemovalAllowed置为true</li><li>将该WindowState从Input系统中移除</li><li>确认是否需要运行动画。如果需要，推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。<ol><li>如果是可见的，需要创建并执行一个窗口退出动画</li></ol></li><li>将此WindowState移除</li><li>移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数</li><li>更新焦点窗口</li></ol><h4 id="1-3-2-1-WindowState-removeImmediately-移除WindowState"><a href="#1-3-2-1-WindowState-removeImmediately-移除WindowState" class="headerlink" title="1.3.2.1 WindowState.removeImmediately - 移除WindowState"></a>1.3.2.1 WindowState.removeImmediately - 移除WindowState</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeImmediately</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 对所有mChildren执行清理动作</span></span><br><span class="line">    <span class="built_in">super</span>.removeImmediately();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> getDisplayContent();</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">// 将该Window的窗口属性从DisplayContent中移除</span></span><br><span class="line">    dc.getDisplayPolicy().removeWindowLw(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    disposeInputChannel();</span><br><span class="line">    <span class="comment">// 移除窗口的Surface</span></span><br><span class="line">    mWinAnimator.destroySurfaceLocked(mTmpTransaction);</span><br><span class="line">    mTmpTransaction.apply();</span><br><span class="line">    <span class="comment">// 将此窗口WindowState从Session中移除</span></span><br><span class="line">    mSession.windowRemovedLocked();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解除binder死亡监听</span></span><br><span class="line">        mClient.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制</span></span><br><span class="line">    mWmService.postWindowRemoveCleanupLocked(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除WindowState会执行:</p><ol><li>对所有mChildren执行清理动作</li><li>将该WindowState的窗口属性从DisplayContent中移除</li><li>移除窗口的Surface</li><li>将此窗口WindowState从Session中移除<ol><li>Session中窗口数目减一</li><li>如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用</li><li>否则将此Session从WMS.mSessions集合中移除</li><li>如果存在mSurfaceSession，则同步清理，清理时将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉</li></ol></li><li>执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制</li></ol><h4 id="1-3-2-2-Session-windowRemovedLocked"><a href="#1-3-2-2-Session-windowRemovedLocked" class="headerlink" title="1.3.2.2 Session.windowRemovedLocked"></a>1.3.2.2 Session.windowRemovedLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">windowRemovedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 窗口数目减一</span></span><br><span class="line">    mNumWindow--;</span><br><span class="line">    killSessionLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">killSessionLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用</span></span><br><span class="line">    <span class="keyword">if</span> (mNumWindow &gt; <span class="number">0</span> || !mClientDead) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将此Session从WMS.mSessions集合中移除</span></span><br><span class="line">    mService.mSessions.remove(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 如果存在mSurfaceSession，则同步清理</span></span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不用怀疑，肯定是需要进入native层执行清理动作</span></span><br><span class="line">        mSurfaceSession.kill();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG_WM, <span class="string">&quot;Exception thrown when killing surface session &quot;</span> + mSurfaceSession</span><br><span class="line">                + <span class="string">&quot; in session &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;: &quot;</span> + e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    mSurfaceSession = <span class="literal">null</span>;</span><br><span class="line">    mAlertWindowSurfaces.clear();</span><br><span class="line">    mAppOverlaySurfaces.clear();</span><br><span class="line">    setHasOverlayUi(<span class="literal">false</span>);</span><br><span class="line">    cancelAlertWindowNotification();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-3-SurfaceSession-kill-清理SurfaceSession"><a href="#1-3-2-3-SurfaceSession-kill-清理SurfaceSession" class="headerlink" title="1.3.2.3 SurfaceSession.kill - 清理SurfaceSession"></a>1.3.2.3 SurfaceSession.kill - 清理SurfaceSession</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeClient != <span class="number">0</span>) &#123;</span><br><span class="line">        nativeDestroy(mNativeClient);</span><br><span class="line">        mNativeClient = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行native清理动作，将mNativeClient置为0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">nativeDestroy</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    SurfaceComposerClient* client = <span class="built_in">reinterpret_cast</span>&lt;SurfaceComposerClient*&gt;(ptr);</span><br><span class="line">    client-&gt;<span class="built_in">decStrong</span>((<span class="type">void</span>*)nativeCreate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>native层的清理动作也很简单，将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉即可。</p><h1 id="二-小结"><a href="#二-小结" class="headerlink" title="二. 小结"></a>二. 小结</h1><p>回顾下本文涉及类的类图：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/4_2.png" alt="4-2"></p><p>之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState:</p><ol><li>初始化WindowState<ol><li>调用SurfaceControl.Transaction::new创建mTmpTransaction</li><li>保存来自应用ViewRootImpl中的mWindowSession、mWindow等</li><li>保存该WindowState对应window的ActivityRecord</li><li>创建WindowId</li><li>保存该Activity的View对应的窗口属性</li><li>创建InputApplicationHandle，即将该Window注册进Input系统，以便后续input事件传输</li><li>建立binder死亡监听,处理该WindowState所属应用进程死亡后资源处理</li><li>计算mBaseLayer，mBaseLayer &#x3D; windowLayer(2) * 10000 + 1000;</li><li>标记mIsChildWindow、mIsImWindow（输入法窗口）、mIsWallpaper（壁纸窗口）</li><li>创建WindowAnimator，用于实现该窗口的动画</li><li>获取该pid对应的WindowProcessController</li></ol></li><li>WindowState.attach, 创建SurfaceSession<ol><li>SurfaceSession是用于和SurfaceFlinger通信的，因为Session是单个进程只会持有一个，所以创建SurfaceSession也只会初始化一次。</li><li>创建SurfaceSession就是创建其对应native层的对象SurfaceComposerClient, 将其mStatus标记为NO_INIT，尚未初始化</li></ol></li><li>保存WindowState至WMS.mTokenMap中, key为ViewRoomImpl.W</li><li>将该WindowState保存在其mToken(ActivityRecord的mChildren)中</li></ol><p>当WindowState对应的进程死亡时，执行相关清理动作:</p><ol><li>标记该WindowState是被移除的,mWindowRemovalAllowed置为true</li><li>将该WindowState从Input系统中移除</li><li>确认是否需要运行动画。如果需要，推迟删除窗口，直到动画完成。如果显示被冻结，只需立即移除，因为不会看到动画。<ol><li>如果是可见的，需要创建并执行一个窗口退出动画</li></ol></li><li>将此WindowState移除<ol><li>对其所有mChildren执行清理动作</li><li>将该WindowState的窗口属性从DisplayContent中移除</li><li>移除窗口的Surface</li><li>将此窗口WindowState从Session中移除<ol><li>Session中窗口数目减一</li><li>如果窗口数量大于0或者对应应用进程没有死亡时,不需要移除session,以备后续使用</li><li>否则将此Session从WMS.mSessions集合中移除</li><li>如果存在mSurfaceSession，则同步清理，清理时将该SurfaceSession对应的SurfaceComposerClient的引用计数减掉</li></ol></li><li>执行清理后操作，从WMS.mWindowMap中移除该WindowState然后更新绘制</li></ol></li><li>移除一个可见的窗口可能会影响显示方向，比如横屏游戏，此时需要重新计算更新相关参数</li><li>更新焦点窗口</li></ol><p>这里我们注意到WindowState被销毁时会存在一个窗口动画，那么当WindowState的窗口创建时应该也存在一个窗口动画，对应的应该是我们在WindowState被销毁时的TYPE_APPLICATION_STARTING类型窗口（因为Activity对应窗口尚未创建完毕，那么窗口启动动画应该在另一个准备完毕的窗口执行才行）。</p><p>下一篇文章我们就探秘一下应用启动窗口动画。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;之前分析，Activity在被start时会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中，之后在该Activity被resume时，会通过其对应ViewRootImpl中的setView调用到WMS的addWindow方法，传入参数就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，通过这些信息创建WindowState：&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
  </entry>
  
  <entry>
    <title>WMS(3)-ActivityRecord和WindowToken.md</title>
    <link href="https://swallowjoe.github.io/2022/05/03/WMS(3)-ActivityRecord%E5%92%8CWindowToken/"/>
    <id>https://swallowjoe.github.io/2022/05/03/WMS(3)-ActivityRecord%E5%92%8CWindowToken/</id>
    <published>2022-05-02T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:28.811Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上文中我们知道Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。</p><p>在Activity的Window被添加至WMS中，我们仅仅分析了一半，然后重点区分析了DisplayContent的构建，了解了其层次结构器的创建过程以及layer的个数和Window类型对应的layer。现在我们接着看WindowToken的创建，上文中留有一个疑问：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(<span class="type">int</span> windowType, <span class="type">boolean</span> ownerCanManageAppTokens,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> roundedCornerOverlay)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取window类型对应的layer，getWindowLayerFromTypeLw看[Window类型转Layer](#222-windowmanagerpolicygetwindowlayerfromtypelw)。</span></span><br><span class="line">    <span class="comment">// 一般应用的window类型是 TYPE_BASE_APPLICATION （值为1，handleResumeActivity中赋值的）</span></span><br><span class="line">    <span class="comment">// 所以windowLayerFromType就是APPLICATION_LAYER！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">windowLayerFromType</span> <span class="operator">=</span> mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,</span><br><span class="line">            ownerCanManageAppTokens, roundedCornerOverlay);</span><br><span class="line">    <span class="comment">// 所以这里就会抛出异常？？？</span></span><br><span class="line">    <span class="keyword">if</span> (windowLayerFromType == APPLICATION_LAYER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAreaForLayer[windowLayerFromType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Activity对应的windowType是TYPE_BASE_APPLICATION，所以拿到的windowLayerFromType就是APPLICATION_LAYER，那么这里必然会抛出异常！</p><p>当然按照正常理解来说，必然不会发生异常才对，所以是我们流程分析哪里有问题？ 是也不是，这里就要留意到应用启动过程了，回到Activity的启动过程，我们先看ActivityRecord的创建过程。</p><h1 id="一-ActivityRecord的创建"><a href="#一-ActivityRecord的创建" class="headerlink" title="一. ActivityRecord的创建"></a>一. ActivityRecord的创建</h1><p>ActivityRecord类是WindowToken子类：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/3_1.png" alt="3-1"></p><p>而且从名字中也可以看出，这个类应该是和Activity一一对应的，那么应该在Activity启动流程中哪个步骤创建其对象呢？不难理解，肯定是在startActivity的过程中。</p><p>Activity的启动流程这里就不展开了，直接看关键代码.</p><h2 id="1-1-ActivityTaskManagerService-startActivity"><a href="#1-1-ActivityTaskManagerService-startActivity" class="headerlink" title="1.1 ActivityTaskManagerService.startActivity"></a>1.1 ActivityTaskManagerService.startActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span><br><span class="line"><span class="params">        IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="type">int</span> userId, <span class="type">boolean</span> validateIncomingUser)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// obtainStarter其实就是通过ActivityStarter.DefaultFactory获取ActivityStarter</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setCallingFeatureId(callingFeatureId)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setUserId(userId)</span><br><span class="line">            .execute(); <span class="comment">// 执行Activity的启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将Activity的启动委托给ActivityStarter执行。</p><h2 id="1-2-ActivityStarter-execute"><a href="#1-2-ActivityStarter-execute" class="headerlink" title="1.2 ActivityStarter.execute"></a>1.2 ActivityStarter.execute</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            ......</span><br><span class="line">            res = executeRequest(mRequest);</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">executeRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 注意这里的inTask是null的，因为ActivityStarter构建时没有设置inTask.</span></span><br><span class="line">    <span class="type">Task</span> <span class="variable">inTask</span> <span class="operator">=</span> request.inTask;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [1.2.1] 针对此次启动的Activity创建对应的ActivityRecord</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>.Builder(mService)</span><br><span class="line">            .setCaller(callerApp)</span><br><span class="line">            .setLaunchedFromPid(callingPid)</span><br><span class="line">            .setLaunchedFromUid(callingUid)</span><br><span class="line">            .setLaunchedFromPackage(callingPackage)</span><br><span class="line">            .setLaunchedFromFeature(callingFeatureId)</span><br><span class="line">            .setIntent(intent)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setActivityInfo(aInfo)</span><br><span class="line">            .setConfiguration(mService.getGlobalConfiguration())</span><br><span class="line">            .setResultTo(resultRecord)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setComponentSpecified(request.componentSpecified)</span><br><span class="line">            .setRootVoiceInteraction(voiceSession != <span class="literal">null</span>)</span><br><span class="line">            .setActivityOptions(checkedOptions)</span><br><span class="line">            .setSourceRecord(sourceRecord)</span><br><span class="line">            .build();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// [1.3] 启动Activity</span></span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, <span class="literal">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityRecord的初始化是采用了Build模式.</p><h3 id="1-2-1-ActivityRecord的初始化"><a href="#1-2-1-ActivityRecord的初始化" class="headerlink" title="1.2.1 ActivityRecord的初始化"></a>1.2.1 ActivityRecord的初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">ActivityRecord</span><span class="params">(ActivityTaskManagerService _service, WindowProcessController _caller,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> _launchedFromPid, <span class="type">int</span> _launchedFromUid, String _launchedFromPackage,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String _launchedFromFeature, Intent _intent, String _resolvedType,</span></span><br><span class="line"><span class="params">        ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo,</span></span><br><span class="line"><span class="params">        String _resultWho, <span class="type">int</span> _reqCode, <span class="type">boolean</span> _componentSpecified,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> _rootVoiceInteraction, ActivityTaskSupervisor supervisor,</span></span><br><span class="line"><span class="params">        ActivityOptions options, ActivityRecord sourceRecord, PersistableBundle persistentState,</span></span><br><span class="line"><span class="params">        TaskDescription _taskDescription, <span class="type">long</span> _createTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里创建的Token是IApplicationToken.Stub的子类, 保存在ActivityRecord父类WindowToken的成员变量token中</span></span><br><span class="line">    <span class="built_in">super</span>(_service.mWindowManager, <span class="keyword">new</span> <span class="title class_">Token</span>(_intent).asBinder(), TYPE_APPLICATION, <span class="literal">true</span>,</span><br><span class="line">            <span class="literal">null</span> <span class="comment">/* displayContent */</span>, <span class="literal">false</span> <span class="comment">/* ownerCanManageAppTokens */</span>);</span><br><span class="line"></span><br><span class="line">    mAtmService = _service;</span><br><span class="line">    appToken = (Token) token;</span><br><span class="line">    info = aInfo;</span><br><span class="line">    ......</span><br><span class="line">    appToken.attach(<span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Token</span> <span class="keyword">extends</span> <span class="title class_">IApplicationToken</span>.Stub &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(ActivityRecord activity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weakActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already attached...&quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将传入的ActivityRecord用弱引用方式保存起来</span></span><br><span class="line">        weakActivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>所以ActivityRecord里的appToken其实是ActivityRecord初始化时创建的Token(为IApplicationToken.Stub的子类)，里面保存了该Activity的Intent信息。</p><h2 id="1-3-ActivityStarter-startActivityUnchecked"><a href="#1-3-ActivityStarter-startActivityUnchecked" class="headerlink" title="1.3 ActivityStarter.startActivityUnchecked"></a>1.3 ActivityStarter.startActivityUnchecked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, restrictedBgActivity, intentGrants);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.3.1 设置初始化状态</span></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">                voiceInteractor, restrictedBgActivity);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取可重用的task</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">reusedTask</span> <span class="operator">=</span> getReusableTask();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 计算目标task</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">targetTask</span> <span class="operator">=</span> reusedTask != <span class="literal">null</span> ? reusedTask : computeTargetTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">newTask</span> <span class="operator">=</span> targetTask == <span class="literal">null</span>;</span><br><span class="line">    mTargetTask = targetTask;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 因为当前Activity是应用启动的第一个Activity，所以newTask为true,targetTaskTop就是null的了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">targetTaskTop</span> <span class="operator">=</span> newTask</span><br><span class="line">            ? <span class="literal">null</span> : targetTask.getTopNonFinishingActivity();</span><br><span class="line">    <span class="keyword">if</span> (targetTaskTop != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为此次Activity的启动回收task</span></span><br><span class="line">        startResult = recycleTask(targetTask, targetTaskTop, reusedTask, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAddingToTask = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 获取当前焦点（前台）Task</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">topRootTask</span> <span class="operator">=</span> mPreferredTaskDisplayArea.getFocusedRootTask();</span><br><span class="line">    <span class="keyword">if</span> (topRootTask != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断待启动的Activity是否与前台Activity一致</span></span><br><span class="line">        startResult = deliverToCurrentTopIfNeeded(topRootTask, intentGrants);</span><br><span class="line">        <span class="keyword">if</span> (startResult != START_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> startResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mTargetRootTask == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取root task.</span></span><br><span class="line">        mTargetRootTask = getLaunchRootTask(mStartActivity, mLaunchFlags, targetTask, mOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要创建新的task</span></span><br><span class="line">    <span class="keyword">if</span> (newTask) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">taskToAffiliate</span> <span class="operator">=</span> (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="literal">null</span>)</span><br><span class="line">                ? mSourceRecord.getTask() : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 设置新的Task</span></span><br><span class="line">        setNewTask(taskToAffiliate);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAddingToTask) &#123;</span><br><span class="line">        addOrReparentStartingActivity(targetTask, <span class="string">&quot;adding to task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 交给对应Task启动Activity</span></span><br><span class="line">    mTargetRootTask.startActivityLocked(mStartActivity,</span><br><span class="line">            topRootTask != <span class="literal">null</span> ? topRootTask.getTopNonFinishingActivity() : <span class="literal">null</span>, newTask,</span><br><span class="line">            mKeepCurTransition, mOptions, startFromSamePackage);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNewTask</span><span class="params">(Task taskToAffiliate)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">toTop</span> <span class="operator">=</span> !mLaunchTaskBehind &amp;&amp; !mAvoidMoveToFront;</span><br><span class="line">    <span class="comment">// 创建新的Task，关于Task的创建我们后续分析</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> mTargetRootTask.reuseOrCreateTask(</span><br><span class="line">            mNewTaskInfo != <span class="literal">null</span> ? mNewTaskInfo : mStartActivity.info,</span><br><span class="line">            mNewTaskIntent != <span class="literal">null</span> ? mNewTaskIntent : mIntent, mVoiceSession,</span><br><span class="line">            mVoiceInteractor, toTop, mStartActivity, mSourceRecord, mOptions);</span><br><span class="line">    mService.getTransitionController().collectExistenceChange(task);</span><br><span class="line">    <span class="comment">// [1.4] 保存Activity至task！</span></span><br><span class="line">    addOrReparentStartingActivity(task, <span class="string">&quot;setTaskFromReuseOrCreateNewTask - mReuseTask&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们假设启动的Activity是应用的首个Activity，而且也没有设置affinity，这样在启动该Activity时，会创建新的Task, 并在该Task中保存ActivityRecord！</p><h3 id="1-3-1-ActivityStarter-setInitialState-设置初始化状态"><a href="#1-3-1-ActivityStarter-setInitialState-设置初始化状态" class="headerlink" title="1.3.1 ActivityStarter.setInitialState - 设置初始化状态"></a>1.3.1 ActivityStarter.setInitialState - 设置初始化状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setInitialState</span><span class="params">(ActivityRecord r, ActivityOptions options, Task inTask,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> doResume, <span class="type">int</span> startFlags, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> restrictedBgActivity)</span> &#123;</span><br><span class="line">    reset(<span class="literal">false</span> <span class="comment">/* clearRequest */</span>);</span><br><span class="line"></span><br><span class="line">    mStartActivity = r;</span><br><span class="line">    ......</span><br><span class="line">    mLaunchParams.reset();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 因为mLaunchParams被重置了，所以mPreferredTaskDisplayArea获取的就是mRootWindowContainer.getDefaultTaskDisplayArea</span></span><br><span class="line">    <span class="comment">// 即上文中RootDisplayArea创建的Result中的mDefaultTaskDisplayArea</span></span><br><span class="line">    mPreferredTaskDisplayArea = mLaunchParams.hasPreferredTaskDisplayArea()</span><br><span class="line">            ? mLaunchParams.mPreferredTaskDisplayArea</span><br><span class="line">            : mRootWindowContainer.getDefaultTaskDisplayArea();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先先清理ActivityStarter内部成员，然后依次赋值。</p><h2 id="1-4-ActivityStarter-addOrReparentStartingActivity"><a href="#1-4-ActivityStarter-addOrReparentStartingActivity" class="headerlink" title="1.4 ActivityStarter.addOrReparentStartingActivity"></a>1.4 ActivityStarter.addOrReparentStartingActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addOrReparentStartingActivity</span><span class="params">(Task parent, String reason)</span> &#123;</span><br><span class="line">    <span class="comment">// mStartActivity是该Activity启动时创建的ActivityRecord.</span></span><br><span class="line">    <span class="comment">// ActivityRecord.getTask就是获取其task成员，该成员目前是没有被赋值的</span></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.getTask() == <span class="literal">null</span> || mStartActivity.getTask() == parent) &#123;</span><br><span class="line">        <span class="comment">// [1.5] 将该ActivityRecord添加至task中</span></span><br><span class="line">        parent.addChild(mStartActivity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mStartActivity.reparent(parent, parent.getChildCount() <span class="comment">/* top */</span>, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-Task-addChild"><a href="#1-5-Task-addChild" class="headerlink" title="1.5 Task.addChild"></a>1.5 Task.addChild</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(ActivityRecord r)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认添加到该Task的最上层</span></span><br><span class="line">    addChild(r, Integer.MAX_VALUE <span class="comment">/* add on top */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(WindowContainer child, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断mChildren集合中是否存在元素</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hadChild</span> <span class="operator">=</span> hasChild();</span><br><span class="line">    <span class="comment">// [1.5.1] 获取当前Task最上层的WindowContainer对应的Activity类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">activityType</span> <span class="operator">=</span> getActivityType();</span><br><span class="line">    <span class="comment">// [1.5.2] 调整被添加的ActivityRecord在task中的位置</span></span><br><span class="line">    index = getAdjustedChildPosition(child, index);</span><br><span class="line">    <span class="comment">// [1.6] 将WindowContainer添加至mChildren中index位置</span></span><br><span class="line">    <span class="built_in">super</span>.addChild(child, index);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-1-Task-getActivityType"><a href="#1-5-1-Task-getActivityType" class="headerlink" title="1.5.1 Task.getActivityType"></a>1.5.1 Task.getActivityType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getActivityType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Task的父类是WindowContainer, WindowContainer的父类是ConfigurationContainer</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">applicationType</span> <span class="operator">=</span> <span class="built_in">super</span>.getActivityType();</span><br><span class="line">    <span class="keyword">if</span> (applicationType != ACTIVITY_TYPE_UNDEFINED || !hasChild()) &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getTopChild().getActivityType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/content/res/Configuration.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getActivityType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// mFullConfiguration就是Configuration.java类</span></span><br><span class="line">    <span class="keyword">return</span> mFullConfiguration.windowConfiguration.getActivityType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// frameworks/base/core/java/android/app/WindowConfiguration.java</span></span><br><span class="line"><span class="meta">@ActivityType</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getActivityType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mActivityType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityType有如下取值:</p><table><thead><tr><th>名称</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ACTIVITY_TYPE_UNDEFINED</td><td>0</td><td>Activity类型尚未定义</td></tr><tr><td>ACTIVITY_TYPE_STANDARD</td><td>1</td><td>标准Activity类型</td></tr><tr><td>ACTIVITY_TYPE_HOME</td><td>2</td><td>Home或Launcher的Activity类型</td></tr><tr><td>ACTIVITY_TYPE_RECENTS</td><td>3</td><td>Recents或者Overview的Activity类型，系统中只有一个具有此类型的Activity</td></tr><tr><td>ACTIVITY_TYPE_ASSISTANT</td><td>4</td><td>Assistant Activity类型</td></tr><tr><td>ACTIVITY_TYPE_DREAM</td><td>5</td><td>Dream Activity类型</td></tr></tbody></table><p>一般情况都是ACTIVITY_TYPE_STANDARD或者ACTIVITY_TYPE_HOME类型。当前Task获取的值应该是初始化的默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConfigurationContainer.java:mFullConfiguration</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Configuration</span> <span class="variable">mFullConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration.java:windowConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">WindowConfiguration</span> <span class="variable">windowConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowConfiguration</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowConfiguration.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WindowConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">    unset();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unset</span><span class="params">()</span> &#123;</span><br><span class="line">    setToDefaults();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setToDefaults</span><span class="params">()</span> &#123;</span><br><span class="line">    setAppBounds(<span class="literal">null</span>);</span><br><span class="line">    setBounds(<span class="literal">null</span>);</span><br><span class="line">    setMaxBounds(<span class="literal">null</span>);</span><br><span class="line">    setWindowingMode(WINDOWING_MODE_UNDEFINED);</span><br><span class="line">    setActivityType(ACTIVITY_TYPE_UNDEFINED);</span><br><span class="line">    setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED);</span><br><span class="line">    setRotation(ROTATION_UNDEFINED);</span><br><span class="line">    setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ActivityType是被设置成：ACTIVITY_TYPE_UNDEFINED，也即未定义类型！</p><h3 id="1-5-2-Task-getAdjustedChildPosition"><a href="#1-5-2-Task-getAdjustedChildPosition" class="headerlink" title="1.5.2 Task.getAdjustedChildPosition"></a>1.5.2 Task.getAdjustedChildPosition</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getAdjustedChildPosition</span><span class="params">(WindowContainer wc, <span class="type">int</span> suggestedPosition)</span> &#123;</span><br><span class="line">    <span class="comment">// wc就是创建的ActivityRecord, 这里就是检查Activity是否带有FLAG_SHOW_FOR_ALL_USERS标志</span></span><br><span class="line">    <span class="comment">// 或者该Activity所属的userId是否是当前userId，即非当前用户的Activity不可见</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">canShowChild</span> <span class="operator">=</span> wc.showToCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mChildren.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据WindowContainer是否可见，决定该WC应该被插入Task的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minPosition</span> <span class="operator">=</span> (canShowChild) ? computeMinUserPosition(<span class="number">0</span>, size) : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxPosition</span> <span class="operator">=</span> (canShowChild) ? size : computeMaxUserPosition(size - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.5.2.1] 检查该WindowContainer是否是永远处于Task最上层</span></span><br><span class="line">    <span class="keyword">if</span> (!wc.isAlwaysOnTop()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所有应该永远处于最上层的WC放在Task的最上层</span></span><br><span class="line">        <span class="keyword">while</span> (maxPosition &gt; minPosition) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mChildren.get(maxPosition - <span class="number">1</span>).isAlwaysOnTop()) <span class="keyword">break</span>;</span><br><span class="line">            --maxPosition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当该WC可以处于POSITION_BOTTOM且minPosition也是0时，返回POSITION_BOTTOM</span></span><br><span class="line">    <span class="comment">// 或者可以处于POSITION_TOP且maxPosition超过目前children数量时，返回POSITION_TOP</span></span><br><span class="line">    <span class="keyword">if</span> (suggestedPosition == POSITION_BOTTOM &amp;&amp; minPosition == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> POSITION_BOTTOM;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (suggestedPosition == POSITION_TOP &amp;&amp; maxPosition &gt;= (size - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> POSITION_TOP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挑选一个合适的位置</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(Math.max(suggestedPosition, minPosition), maxPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过检查WindowContainer是否可见的属性以及是否应该永远处于最上层来调整该WC应该被插入Task的哪个位置。</p><p>当我们ActivityRecord被添加入一个新建的Task时，毫无疑问应该是处于最上层即返回POSITION_TOP。</p><h4 id="1-5-2-1-WindowContainer-isAlwaysOnTop"><a href="#1-5-2-1-WindowContainer-isAlwaysOnTop" class="headerlink" title="1.5.2.1 WindowContainer.isAlwaysOnTop"></a>1.5.2.1 WindowContainer.isAlwaysOnTop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAlwaysOnTop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindowingMode == WINDOWING_MODE_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mActivityType == ACTIVITY_TYPE_DREAM) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAlwaysOnTop != ALWAYS_ON_TOP_ON) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">return</span> <span class="variable">mWindowingMode</span> <span class="operator">=</span>= WINDOWING_MODE_FREEFORM</span><br><span class="line">                || mWindowingMode == WINDOWING_MODE_MULTI_WINDOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明如下情况，该WindowContainer应该始终处于所在Task的最上层:</p><ol><li>window模式为WINDOWING_MODE_PINNED</li><li>Activity类型是ACTIVITY_TYPE_DREAM</li><li>当mAlwaysOnTop为ALWAYS_ON_TOP_ON，window模式为WINDOWING_MODE_FREEFORM或WINDOWING_MODE_MULTI_WINDOW</li></ol><h2 id="1-6-WindowContainer-addChild"><a href="#1-6-WindowContainer-addChild" class="headerlink" title="1.6 WindowContainer.addChild"></a>1.6 WindowContainer.addChild</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(E child, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 最后调整index</span></span><br><span class="line">    <span class="keyword">if</span> (index == POSITION_TOP) &#123;</span><br><span class="line">        index = mChildren.size();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == POSITION_BOTTOM) &#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将child保存在mChildren中的特定位置</span></span><br><span class="line">    mChildren.add(index, child);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1.7] 让child保存该WC（即Task）</span></span><br><span class="line">    child.setParent(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@CallSuper: 是Android中特有的注解，如果子类覆盖了同名方法而没有显示调用父类的该方法时就会报错!</p></blockquote><p>这个也挺简单的，首先最后调整一下index：</p><ol><li>如果传入的index为POSITION_TOP，则将index设置为当前mChildren的size值，意为将待存入的child保存在mChildren中最后一位（上面）</li><li>如果传入的index为POSITION_BOTTOM， 则将index设置为0，意为将待存入的child保存在mChildren中第一位（下面）</li></ol><p>然后让child(ActivityRecord)保存该WC（即Task）。</p><h2 id="1-7-WindowContainer-setParent"><a href="#1-7-WindowContainer-setParent" class="headerlink" title="1.7 WindowContainer.setParent"></a>1.7 WindowContainer.setParent</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(WindowContainer&lt;WindowContainer&gt; parent)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowContainer</span> <span class="variable">oldParent</span> <span class="operator">=</span> mParent;</span><br><span class="line">    mParent = parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mParent.onChildAdded(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ActivityRecord创建时，该值默认为false,只有被调用reparent重设父集时才会被短暂更改为true</span></span><br><span class="line">    <span class="keyword">if</span> (!mReparenting) &#123;</span><br><span class="line">        onSyncReparent(oldParent, mParent);</span><br><span class="line">        <span class="comment">// mDisplayContent此时还是null的，而Task.mDisplayContent就是defaultDisplayContent</span></span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="literal">null</span> &amp;&amp; mParent.mDisplayContent != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; mDisplayContent != mParent.mDisplayContent) &#123;</span><br><span class="line">            <span class="comment">// [1.8] 更改当前WC(ActivityRecord)的DisplayContent</span></span><br><span class="line">            onDisplayChanged(mParent.mDisplayContent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// [1.7.1] 当前ActivityRecord的parent有更改</span></span><br><span class="line">        onParentChanged(mParent, oldParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置WC(ActivityRecord)的父集（mParent, 即保存该WC的Task）, 如有必要同步Task中DisplayContent至该WC中。</p><h3 id="1-7-1-ActivityRecord-onParentChanged"><a href="#1-7-1-ActivityRecord-onParentChanged" class="headerlink" title="1.7.1 ActivityRecord.onParentChanged"></a>1.7.1 ActivityRecord.onParentChanged</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onParentChanged</span><span class="params">(ConfigurationContainer newParent, ConfigurationContainer oldParent)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">oldTask</span> <span class="operator">=</span> oldParent != <span class="literal">null</span> ? (Task) oldParent : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Task</span> <span class="variable">newTask</span> <span class="operator">=</span> newParent != <span class="literal">null</span> ? (Task) newParent : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 存入ActivityRecord.task中</span></span><br><span class="line">    <span class="built_in">this</span>.task = newTask;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将传入的ConfigurationContainer作为Task，存入ActivityRecord.task中，其余部分暂时先不研究。</p><h2 id="1-8-ActivityRecord-onDisplayChanged"><a href="#1-8-ActivityRecord-onDisplayChanged" class="headerlink" title="1.8 ActivityRecord.onDisplayChanged"></a>1.8 ActivityRecord.onDisplayChanged</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDisplayChanged</span><span class="params">(DisplayContent dc)</span> &#123;</span><br><span class="line">    <span class="type">DisplayContent</span> <span class="variable">prevDc</span> <span class="operator">=</span> mDisplayContent;</span><br><span class="line">    <span class="comment">// WindowToken.onDisplayChanged</span></span><br><span class="line">    <span class="built_in">super</span>.onDisplayChanged(dc);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowToken.java:onDisplayChanged</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDisplayChanged</span><span class="params">(DisplayContent dc)</span> &#123;</span><br><span class="line">    <span class="comment">// [1.9] 将WindowToken（ActivityRecord）保存至DisplayContent中</span></span><br><span class="line">    dc.reParentWindowToken(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WindowContainer.onDisplayChanged</span></span><br><span class="line">    <span class="built_in">super</span>.onDisplayChanged(dc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowContainer.java:onDisplayChanged</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDisplayChanged</span><span class="params">(DisplayContent dc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayContent != <span class="literal">null</span> &amp;&amp; mDisplayContent.mChangingContainers.remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="comment">// Cancel any change transition queued-up for this container on the old display.</span></span><br><span class="line">        mSurfaceFreezer.unfreeze(getPendingTransaction());</span><br><span class="line">    &#125;</span><br><span class="line">    mDisplayContent = dc;</span><br><span class="line">    <span class="keyword">if</span> (dc != <span class="literal">null</span> &amp;&amp; dc != <span class="built_in">this</span>) &#123;</span><br><span class="line">        dc.getPendingTransaction().merge(mPendingTransaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将mChildren中的每个WC的DisplayContent也同步更改</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mChildren.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowContainer</span> <span class="variable">child</span> <span class="operator">=</span> mChildren.get(i);</span><br><span class="line">        child.onDisplayChanged(dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mListeners.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        mListeners.get(i).onDisplayChanged(dc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最主要的是理清ActivityRecord、WindowToken、Task和WindowContainer之间的继承关系：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/3_2.png" alt="3-2"></p><h2 id="1-9-DisplayContent-reParentWindowToken"><a href="#1-9-DisplayContent-reParentWindowToken" class="headerlink" title="1.9 DisplayContent.reParentWindowToken"></a>1.9 DisplayContent.reParentWindowToken</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reParentWindowToken</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    <span class="comment">// prevDc目前还是null的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">prevDc</span> <span class="operator">=</span> token.getDisplayContent();</span><br><span class="line">    <span class="keyword">if</span> (prevDc == <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prevDc != <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将ActivityRecord添加到该DC中,key为WindowToken的.token值</span></span><br><span class="line">    addWindowToken(token.token, token);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于此时还处于ActivityRecord刚被创建，正在第一次被设置DisplayContent时，所以其DisplayContent此时还是null的。那么就直接将该WindowToken(即ActivityRecord)保存在此DisplayContent中，注意token.token其实是WindowToken.token, 这个值我们之前分析过，是attrs.token,也就是从App进程传入的LocalActivityRecord.</p><h2 id="1-10-DisplayContent-addWindowToken"><a href="#1-10-DisplayContent-addWindowToken" class="headerlink" title="1.10 DisplayContent.addWindowToken"></a>1.10 DisplayContent.addWindowToken</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addWindowToken</span><span class="params">(IBinder binder, WindowToken token)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> mWmService.mRoot.getWindowTokenDisplay(token);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将ActivityRecord保存在DisplayContent中，key为WindowToken的token变量，即app传入的LayoutParam中的token</span></span><br><span class="line">    mTokenMap.put(binder, token);</span><br><span class="line">    <span class="comment">// WindowToken（其实是ActivityRecord）的asActivityRecord函数返回值不为null</span></span><br><span class="line">    <span class="keyword">if</span> (token.asActivityRecord() == <span class="literal">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我们终于明白了一个ActivityRecord是如何被添加进DisplayContent中了，看到这里是不是似曾相识呢？Bingo, 之前我们的windowToken创建时会抛出一个异常，就是因为这个WindowToken.asActivityRecord返回值为null, 导致DisplayContent中添加该WindowToken时找不到合适layer！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">windowLayerFromType</span> <span class="operator">=</span> mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,</span><br><span class="line">        ownerCanManageAppTokens, roundedCornerOverlay);</span><br><span class="line"><span class="comment">// 所以这里就会抛出异常？？？</span></span><br><span class="line"><span class="keyword">if</span> (windowLayerFromType == APPLICATION_LAYER) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">            <span class="string">&quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道了，在app的Activity被resume时，早就已经有了其WindowToken（ActivityRecord）被保存在DisplayContent的mTokenMap中。所以回过头我们看WMS.addWindow方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 这里DisplayContent中至少包含该App的一个WindowToke，也就是Activity被start时创建的ActivityRecord!</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 所以这里就不会进入了，疑问解除！</span></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊哈，异常解除，因为Activity需要resume必须先start, 而start过程中就会创建其对应ActivityRecord并保存在对应DisplayContent的mTokenMap中！</p><p>最后附上一张时序图以备忘：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/3_3.png" alt="3-3"></p><p>接下来，我们继续看WMS.addWindow的流程：WindowState的创建及其管理。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;上文中我们知道Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。&lt;/p&gt;
&lt;p&gt;在Activity的Window被添加至WMS中，我们仅仅分析了一半，然后重点区分析了DisplayContent的构建，了解了其层次结构器的创建过程以及layer的个数和Window类型对应的layer。现在我们接着看WindowToken的创建，上文中留有一个疑问：&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
  </entry>
  
  <entry>
    <title>WMS(2)-WMS中RootDisplayArea的创建</title>
    <link href="https://swallowjoe.github.io/2022/05/02/WMS(2)-WMS%E4%B8%ADRootDisplayArea%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https://swallowjoe.github.io/2022/05/02/WMS(2)-WMS%E4%B8%ADRootDisplayArea%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2022-05-01T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:25.509Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在我们开始分析WMS是怎么管理不同应用的Window的时，有点一头雾水，不知如何下手。那么我们还是从单个Activity的Window被添加至WMS中来入手。</p><p>从上文中我们知道PhoneWindow是通过IWindowSession被添加的，在ViewRoontImpl中调用了addToDisplayAsUser:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,</span><br><span class="line">        getHostVisibility(), mDisplay.getDisplayId(), userId,</span><br><span class="line">        mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets,</span><br><span class="line">        mTempControls);</span><br></pre></td></tr></table></figure><p>这里的mWindow是ViewRootImpl.W类的对象，用于WMS和该Window通信。</p><span id="more"></span><h1 id="一-Activity的Window被添加至WMS"><a href="#一-Activity的Window被添加至WMS" class="headerlink" title="一. Activity的Window被添加至WMS"></a>一. Activity的Window被添加至WMS</h1><p>mWindowSession是ViewRootImpl被创建时通过IWindowManager在WMS中创建并返回的。这个我们回顾下：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_1.png" alt="2-1"></p><h2 id="1-1-Session-addToDisplayAsUser"><a href="#1-1-Session-addToDisplayAsUser" class="headerlink" title="1.1 Session.addToDisplayAsUser"></a>1.1 Session.addToDisplayAsUser</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addToDisplayAsUser</span><span class="params">(IWindow window, WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> viewVisibility, <span class="type">int</span> displayId, <span class="type">int</span> userId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="built_in">this</span>, window, attrs, viewVisibility, displayId, userId,</span><br><span class="line">            requestedVisibility, outInputChannel, outInsetsState, outActiveControls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mService自然就是WMS本身了。</p><h2 id="1-2-WMS-addWindow"><a href="#1-2-WMS-addWindow" class="headerlink" title="1.2 WMS.addWindow"></a>1.2 WMS.addWindow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 窗口类型保存在LayoutParams中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 1.2.1 获取该token对应的DisplayContent</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContentOrCreate(displayId, attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasParent</span> <span class="operator">=</span> parentWindow != <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 当该Activity没有parent时，此时获取的token还是null</span></span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasParent) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1.2.2 一般走这里创建WindowToken</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">                token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">                        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-1-WMS-getDisplayContentOrCreate"><a href="#1-2-1-WMS-getDisplayContentOrCreate" class="headerlink" title="1.2.1 WMS.getDisplayContentOrCreate"></a>1.2.1 WMS.getDisplayContentOrCreate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DisplayContent <span class="title function_">getDisplayContentOrCreate</span><span class="params">(<span class="type">int</span> displayId, IBinder token)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的DisplayContent找到保存该token的WindowToken</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowToken</span> <span class="variable">wToken</span> <span class="operator">=</span> mRoot.getWindowToken(token);</span><br><span class="line">        <span class="keyword">if</span> (wToken != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> wToken.getDisplayContent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mRoot.getDisplayContentOrCreate(displayId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先遍历所有的DisplayContent尝试找到保存该token的WindowToken，自然是没有的，我们是第一次添加。</p><p>mRoot是WMS服务启动时创建的RootWindowContainer对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DisplayContent <span class="title function_">getDisplayContentOrCreate</span><span class="params">(<span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    <span class="comment">// 是否已被创建，假设已创建</span></span><br><span class="line">    <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContent(displayId);</span><br><span class="line">    <span class="keyword">if</span> (displayContent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> displayContent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The system isn&#x27;t fully initialized yet.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Display</span> <span class="variable">display</span> <span class="operator">=</span> mDisplayManager.getDisplay(displayId);</span><br><span class="line">    <span class="keyword">if</span> (display == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The display is not registered in DisplayManager.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2.1.1 创建DisplayContent</span></span><br><span class="line">    displayContent = <span class="keyword">new</span> <span class="title class_">DisplayContent</span>(display, <span class="built_in">this</span>);</span><br><span class="line">    addChild(displayContent, POSITION_BOTTOM);</span><br><span class="line">    <span class="keyword">return</span> displayContent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisplayContent <span class="title function_">getDisplayContent</span><span class="params">(<span class="type">int</span> displayId)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getChildCount() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (displayContent.mDisplayId == displayId) &#123;</span><br><span class="line">            <span class="keyword">return</span> displayContent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了便于后续分析，先看看相关的类图:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_2.png" alt="2-2"></p><p>从类的成员变量上推测：</p><ol><li>WindowState: 代表Activity在WMS中的Window</li><li>DisplayContent: 管理显示窗口以及显示区域</li><li>DisplayPolicy: 管理显示窗口的可视化，决定哪些窗口可以有焦点，可以被”看见”(mFocusedWindow)</li></ol><p>注意到这些类图里有很多都使用了WindowContainer，这个类中最重要的是一个WindowList类的成员，该类就是一个继承了ArrayList的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        add(<span class="number">0</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">0</span> ? get(size() - <span class="number">1</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    E <span class="title function_">peekFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; <span class="number">0</span> ? get(<span class="number">0</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单包装了ArrayList, 实现了三个方法：</p><ol><li>addFirst: 将元素添加至index为0的位置，原先元素的index依次+1</li><li>peekLast: 获取集合最后一个元素</li><li>peekFirst: 获取集合第一个元素</li></ol><h4 id="1-2-1-1-DisplayContent-的创建"><a href="#1-2-1-1-DisplayContent-的创建" class="headerlink" title="1.2.1.1 DisplayContent 的创建"></a>1.2.1.1 DisplayContent 的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DisplayContent(Display display, RootWindowContainer root) &#123;</span><br><span class="line">    <span class="built_in">super</span>(root.mWindowManager, <span class="string">&quot;DisplayContent&quot;</span>, FEATURE_ROOT);</span><br><span class="line">    ......</span><br><span class="line">    mRootWindowContainer = root;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建DisplayPolicy</span></span><br><span class="line">    mDisplayPolicy = <span class="keyword">new</span> <span class="title class_">DisplayPolicy</span>(mWmService, <span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化DisplayAreaPolicy</span></span><br><span class="line">    mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(</span><br><span class="line">            mWmService, <span class="built_in">this</span> <span class="comment">/* content */</span>, <span class="built_in">this</span> <span class="comment">/* root */</span>, mImeWindowsContainer);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayContent的初始化中做了很多工作，包括创建SurfaceControl等等，但这不是我们目前关注的。</p><p>DisplayContent是继承了RootDisplayArea, 其对应的Feature是FEATURE_ROOT，表示是该逻辑显示设备上的根显示区域</p><p>DisplayPolicy暂时不是我们关注的，主要了解下其是在这里初始化即可, 重点是初始化DisplayAreaPolicy。</p><h4 id="1-2-1-2-DisplayAreaPolicy的初始化"><a href="#1-2-1-2-DisplayAreaPolicy的初始化" class="headerlink" title="1.2.1.2 DisplayAreaPolicy的初始化"></a>1.2.1.2 DisplayAreaPolicy的初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getDisplayAreaPolicyProvider拿到的就是WMS初始化时创建的mDisplayAreaPolicyProvider</span></span><br><span class="line"><span class="comment">// 初始化时的代码：</span></span><br><span class="line"><span class="comment">// mDisplayAreaPolicyProvider = DisplayAreaPolicy.Provider.fromResources(</span></span><br><span class="line"><span class="comment">//            mContext.getResources());</span></span><br><span class="line">mDisplayAreaPolicy = mWmService.getDisplayAreaPolicyProvider().instantiate(</span><br><span class="line">        mWmService, <span class="built_in">this</span> <span class="comment">/* content */</span>, <span class="built_in">this</span> <span class="comment">/* root */</span>, mImeWindowsContainer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DisplayAreaPolicy.java</span></span><br><span class="line"><span class="keyword">static</span> Provider <span class="title function_">fromResources</span><span class="params">(Resources res)</span> &#123;</span><br><span class="line">    <span class="comment">// config_deviceSpecificDisplayAreaPolicyProvider用于特定屏幕设备的DisplayAreaPolicy初始化</span></span><br><span class="line">    <span class="comment">// 一般都是个空值，除非屏幕设备特殊</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> res.getString(</span><br><span class="line">            com.android.internal.R.string.config_deviceSpecificDisplayAreaPolicyProvider);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="comment">// 使用默认的DisplayAreaPolicy初始化构造器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DisplayAreaPolicy</span>.DefaultProvider();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static final class DefaultProvider implements DisplayAreaPolicy.Provider</span></span><br><span class="line"><span class="keyword">public</span> DisplayAreaPolicy <span class="title function_">instantiate</span><span class="params">(WindowManagerService wmService,</span></span><br><span class="line"><span class="params">        DisplayContent content, RootDisplayArea root,</span></span><br><span class="line"><span class="params">        DisplayArea.Tokens imeContainer)</span> &#123;</span><br><span class="line">    <span class="comment">// FEATURE_DEFAULT_TASK_CONTAINER 默认任务容器所在的显示区域</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">TaskDisplayArea</span> <span class="variable">defaultTaskDisplayArea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskDisplayArea</span>(content, wmService,</span><br><span class="line">            <span class="string">&quot;DefaultTaskDisplayArea&quot;</span>, FEATURE_DEFAULT_TASK_CONTAINER);</span><br><span class="line">    <span class="keyword">final</span> List&lt;TaskDisplayArea&gt; tdaList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    tdaList.add(defaultTaskDisplayArea);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层次结构生成， 将在此基础上构建DisplayArea层次结构。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">HierarchyBuilder</span> <span class="variable">rootHierarchy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HierarchyBuilder</span>(root);</span><br><span class="line">    <span class="comment">// 设置基本容器（即使显示器不支持输入法）以及设置mTaskDisplayAreas集合</span></span><br><span class="line">    rootHierarchy.setImeContainer(imeContainer).setTaskDisplayAreas(tdaList);</span><br><span class="line">    <span class="comment">// 这个就是确认Display是否包含FLAG_TRUSTED, 一般是包含的</span></span><br><span class="line">    <span class="keyword">if</span> (content.isTrusted()) &#123;</span><br><span class="line">        <span class="comment">// 1.2.1.3 设置rootHierarchy中的feature</span></span><br><span class="line">        configureTrustedHierarchyBuilder(rootHierarchy, wmService, content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.1.4 实例化DisplayAreaPolicy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DisplayAreaPolicyBuilder</span>().setRootHierarchy(rootHierarchy).build(wmService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了名为”DefaultTaskDisplayArea”的显示区域-TaskDisplayArea，并将其放入层次结构生成器中，然后设置该层次结构生成器的相应参数，最后通过DisplayAreaPolicyBuilder实例化DisplayAreaPolicy。</p><p>注意传入的content和root都是DisplayContent本身。</p><h4 id="1-2-1-3-DisplayAreaPolicy-DefaultProvider-configureTrustedHierarchyBuilder"><a href="#1-2-1-3-DisplayAreaPolicy-DefaultProvider-configureTrustedHierarchyBuilder" class="headerlink" title="1.2.1.3 DisplayAreaPolicy.DefaultProvider.configureTrustedHierarchyBuilder"></a>1.2.1.3 DisplayAreaPolicy.DefaultProvider.configureTrustedHierarchyBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureTrustedHierarchyBuilder</span><span class="params">(HierarchyBuilder rootHierarchy,</span></span><br><span class="line"><span class="params">        WindowManagerService wmService, DisplayContent content)</span> &#123;</span><br><span class="line">    <span class="comment">// 窗口放大应该在顶部，因为只有一个表面被放大</span></span><br><span class="line">    rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;WindowedMagnification&quot;</span>, FEATURE_WINDOWED_MAGNIFICATION)</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (content.isDefaultDisplay) &#123;</span><br><span class="line">        <span class="comment">// 只有默认显示可以有剪切</span></span><br><span class="line">        <span class="comment">// See LocalDisplayAdapter.LocalDisplayDevice#getDisplayDeviceInfoLocked.</span></span><br><span class="line">        rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;HideDisplayCutout&quot;</span>, FEATURE_HIDE_DISPLAY_CUTOUT)</span><br><span class="line">                ......</span><br><span class="line">                .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;OneHandedBackgroundPanel&quot;</span>, FEATURE_ONE_HANDED_BACKGROUND_PANEL)</span><br><span class="line">                ......</span><br><span class="line">                .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;OneHanded&quot;</span>, FEATURE_ONE_HANDED)</span><br><span class="line">    &#125;</span><br><span class="line">    rootHierarchy</span><br><span class="line">            .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;FullscreenMagnification&quot;</span>, FEATURE_FULLSCREEN_MAGNIFICATION)</span><br><span class="line">            ......</span><br><span class="line">            .addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;ImePlaceholder&quot;</span>, FEATURE_IME_PLACEHOLDER)</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里的层次结构对应DisplayContent所处的DisplayId是默认的显示设备即DEFAULT_DISPLA，默认是添加6个FEATURE：</p><ol><li>FEATURE_WINDOWED_MAGNIFICATION: 可以放大的显示区域(比如无障碍里的放大镜)</li><li>FEATURE_HIDE_DISPLAY_CUTOUT: 用于隐藏显示裁剪功能的显示区域</li><li>FEATURE_ONE_HANDED_BACKGROUND_PANEL:显示区域为单手背景层</li><li>FEATURE_ONE_HANDED: 单手功能的显示区域</li><li>FEATURE_FULLSCREEN_MAGNIFICATION: 可以放大的显示区域,但这个是整个显示放大</li><li>FEATURE_IME_PLACEHOLDER: 可以放置IME(输入法窗口)容器的显示区域</li></ol><p>注意这里的顺序比较重要。</p><h4 id="1-2-1-4-DisplayAreaPolicyBuilder-build"><a href="#1-2-1-4-DisplayAreaPolicyBuilder-build" class="headerlink" title="1.2.1.4 DisplayAreaPolicyBuilder.build"></a>1.2.1.4 DisplayAreaPolicyBuilder.build</h4><p>可以看到DisplayAreaPolicy的构建其实是采用build设计模式，最后由DisplayAreaPolicyBuilder生成DisplayAreaPolicy：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisplayAreaPolicyBuilder.java</span></span><br><span class="line">Result <span class="title function_">build</span><span class="params">(WindowManagerService wmService)</span> &#123;</span><br><span class="line">    validate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在将窗口添加到组层次结构之前，将DisplayArea组根附加到屏幕层次结构</span></span><br><span class="line">    <span class="comment">// 这里的mRootHierarchyBuilder就是上面DefaultProvider.instantiate初始化的rootHierarchy</span></span><br><span class="line">    mRootHierarchyBuilder.build(mDisplayAreaGroupHierarchyBuilders);</span><br><span class="line">    List&lt;RootDisplayArea&gt; displayAreaGroupRoots = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">            mDisplayAreaGroupHierarchyBuilders.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mDisplayAreaGroupHierarchyBuilders.size(); i++) &#123;</span><br><span class="line">        <span class="type">HierarchyBuilder</span> <span class="variable">hierarchyBuilder</span> <span class="operator">=</span> mDisplayAreaGroupHierarchyBuilders.get(i);</span><br><span class="line">        hierarchyBuilder.build();</span><br><span class="line">        displayAreaGroupRoots.add(hierarchyBuilder.mRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用默认的DefaultSelectRootForWindowFunction</span></span><br><span class="line">    <span class="keyword">if</span> (mSelectRootForWindowFunc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// RootHierarchyBuilder.mRoot就是创建的DisplayContent</span></span><br><span class="line">        mSelectRootForWindowFunc = <span class="keyword">new</span> <span class="title class_">DefaultSelectRootForWindowFunction</span>(</span><br><span class="line">                mRootHierarchyBuilder.mRoot, displayAreaGroupRoots);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(wmService, mRootHierarchyBuilder.mRoot, displayAreaGroupRoots,</span><br><span class="line">            mSelectRootForWindowFunc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultSelectRootForWindowFunction的构造</span></span><br><span class="line">DefaultSelectRootForWindowFunction(RootDisplayArea displayRoot,</span><br><span class="line">        List&lt;RootDisplayArea&gt; displayAreaGroupRoots) &#123;</span><br><span class="line">    <span class="comment">// 所以mDisplayRoot其实就是拥有该DisplayAreaPolicy的DisplayContent</span></span><br><span class="line">    mDisplayRoot = displayRoot;</span><br><span class="line">    mDisplayAreaGroupRoots = Collections.unmodifiableList(displayAreaGroupRoots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里返回的是DisplayAreaPolicyBuilder.Result类对象。并且其TaskDisplayArea是FEATURE_DEFAULT_TASK_CONTAINER，表示默认任务容器所在的显示区域。</p><h3 id="1-2-2-WindowToken的创建"><a href="#1-2-2-WindowToken的创建" class="headerlink" title="1.2.2 WindowToken的创建"></a>1.2.2 WindowToken的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br></pre></td></tr></table></figure><p>这里的attrs.token我们之前也分析了，其实就是Activity里的mToken.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type, <span class="type">boolean</span> persistOnEmpty,</span><br><span class="line">        DisplayContent dc, <span class="type">boolean</span> ownerCanManageAppTokens, <span class="type">boolean</span> roundedCornerOverlay,</span><br><span class="line">        <span class="type">boolean</span> fromClientToken, <span class="meta">@Nullable</span> Bundle options) &#123;</span><br><span class="line">    <span class="built_in">super</span>(service);</span><br><span class="line">    <span class="comment">// WindowToken中保存了来自Activity的mToken</span></span><br><span class="line">    token = _token;</span><br><span class="line">    windowType = type;</span><br><span class="line">    mOptions = options;</span><br><span class="line">    mPersistOnEmpty = persistOnEmpty;</span><br><span class="line">    mOwnerCanManageAppTokens = ownerCanManageAppTokens;</span><br><span class="line">    mRoundedCornerOverlay = roundedCornerOverlay;</span><br><span class="line">    mFromClientToken = fromClientToken;</span><br><span class="line">    <span class="comment">// DisplayContent 不是null的</span></span><br><span class="line">    <span class="keyword">if</span> (dc != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将该WindowToken添加到DisplayContent中</span></span><br><span class="line">        dc.addWindowToken(token, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将该WindowToken添加到DisplayContent中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addWindowToken</span><span class="params">(IBinder binder, WindowToken token)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将该token保存至mTokenMap中，注意这里的key是binder，即对应Activity中的mToken(LocalActivityRecord)</span></span><br><span class="line">    mTokenMap.put(binder, token);</span><br><span class="line">    <span class="comment">// 判断该WindowToken是否是ActivityRecord，这里并不是</span></span><br><span class="line">    <span class="keyword">if</span> (token.asActivityRecord() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将该WindowToken的DisplayContent赋值为当前DisplayContent</span></span><br><span class="line">        token.mDisplayContent = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">// 该token对应Activity的Window类型是TYPE_BASE_APPLICATION</span></span><br><span class="line">        <span class="keyword">switch</span> (token.windowType) &#123;</span><br><span class="line">            <span class="keyword">case</span> TYPE_INPUT_METHOD:</span><br><span class="line">            <span class="keyword">case</span> TYPE_INPUT_METHOD_DIALOG:</span><br><span class="line">                mImeWindowsContainer.addChild(token);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 将该token保存至mDisplayAreaPolicy中</span></span><br><span class="line">                mDisplayAreaPolicy.addWindow(token);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mDisplayAreaPolicy是该DisplayContent初始化时创建的，所以 mDisplayAreaPolicy.addWindow(token) 其实是调用了 DisplayAreaPolicyBuilder.Result.addWindow：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWindow</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    DisplayArea.<span class="type">Tokens</span> <span class="variable">area</span> <span class="operator">=</span> findAreaForToken(token);</span><br><span class="line">    area.addChild(token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    <span class="comment">// mSelectRootForWindowFunc就是DefaultSelectRootForWindowFunction</span></span><br><span class="line">    <span class="keyword">return</span> mSelectRootForWindowFunc.apply(token.windowType, token.mOptions)</span><br><span class="line">            .findAreaForToken(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mSelectRootForWindowFunc一般都是DefaultSelectRootForWindowFunction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RootDisplayArea <span class="title function_">apply</span><span class="params">(Integer windowType, Bundle options)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDisplayAreaGroupRoots.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> mDisplayRoot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认mDisplayAreaGroupRoots中只有一个RootDisplayArea，也就是mDisplayRoot，（CTS测试会有多个）</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">null</span> &amp;&amp; options.containsKey(KEY_ROOT_DISPLAY_AREA_ID)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">rootId</span> <span class="operator">=</span> options.getInt(KEY_ROOT_DISPLAY_AREA_ID);</span><br><span class="line">        <span class="keyword">if</span> (mDisplayRoot.mFeatureId == rootId) &#123;</span><br><span class="line">            <span class="keyword">return</span> mDisplayRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mDisplayAreaGroupRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDisplayAreaGroupRoots.get(i).mFeatureId == rootId) &#123;</span><br><span class="line">                <span class="keyword">return</span> mDisplayAreaGroupRoots.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDisplayRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mSelectRootForWindowFunc.apply(token.windowType, token.mOptions).findAreaForToken(token)其实是根据Window类型和Window所在的显示屏幕来选择应该将此WindowToken放入哪个RootDisplayArea中存储。</p><p>一般来说，mDisplayAreaGroupRoots中只有一个元素，即mDisplayRoot，也就是DisplayContent（猜猜什么情况下会有多个DisplayContent？）。所以这个方法其实等效于：mDisplayRoot.findAreaForToken，这里的mDisplayRoot就是DisplayContent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(WindowToken token)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findAreaForToken(token.windowType, token.mOwnerCanManageAppTokens,</span><br><span class="line">            token.mRoundedCornerOverlay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">DisplayArea.Tokens <span class="title function_">findAreaForToken</span><span class="params">(<span class="type">int</span> windowType, <span class="type">boolean</span> ownerCanManageAppTokens,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> roundedCornerOverlay)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取window类型对应的layer，getWindowLayerFromTypeLw看[Window类型转Layer](#222-windowmanagerpolicygetwindowlayerfromtypelw)。</span></span><br><span class="line">    <span class="comment">// 一般应用的window类型是 TYPE_BASE_APPLICATION （值为1，handleResumeActivity中赋值的）</span></span><br><span class="line">    <span class="comment">// 所以windowLayerFromType就是APPLICATION_LAYER！</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">windowLayerFromType</span> <span class="operator">=</span> mWmService.mPolicy.getWindowLayerFromTypeLw(windowType,</span><br><span class="line">            ownerCanManageAppTokens, roundedCornerOverlay);</span><br><span class="line">    <span class="comment">// 所以这里就会抛出异常？？？</span></span><br><span class="line">    <span class="keyword">if</span> (windowLayerFromType == APPLICATION_LAYER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;There shouldn&#x27;t be WindowToken on APPLICATION_LAYER&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAreaForLayer[windowLayerFromType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Activity对应的windowType是TYPE_BASE_APPLICATION，所以拿到的windowLayerFromType就是APPLICATION_LAYER，那么这里必然会抛出异常！这个疑问我们后续分析，先看返回值，这里最终是返回了RootDisplayArea中mAreaForLayer数组对应存储的对象，接下来我们看看这个数组是如何被创建。</p><h1 id="二-RootDisplayArea的构造"><a href="#二-RootDisplayArea的构造" class="headerlink" title="二. RootDisplayArea的构造"></a>二. RootDisplayArea的构造</h1><h2 id="2-1-HierarchyBuilder-build"><a href="#2-1-HierarchyBuilder-build" class="headerlink" title="2.1 HierarchyBuilder.build"></a>2.1 HierarchyBuilder.build</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="meta">@Nullable</span> List&lt;HierarchyBuilder&gt; displayAreaGroupHierarchyBuilders)</span> &#123;</span><br><span class="line">    <span class="comment">// ------ 第一部分 --------</span></span><br><span class="line">    <span class="comment">// 这个mPolicy就是WMS服务初始化时候创建的PhoneWindowManager</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowManagerPolicy</span> <span class="variable">policy</span> <span class="operator">=</span> mRoot.mWmService.mPolicy;</span><br><span class="line">    <span class="comment">// getMaxWindowLayer值目前是固定的36，也就是窗口Layer最大不能超过36，稍后我们就知道为什么是36了！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">maxWindowLayerCount</span> <span class="operator">=</span> policy.getMaxWindowLayer() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> DisplayArea.Tokens[] displayAreaForLayer =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DisplayArea</span>.Tokens[maxWindowLayerCount];</span><br><span class="line">    <span class="comment">// 由前面的分析可知，这里的feature数目是6个</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; featureAreas =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;(mFeatures.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mFeatures.size(); i++) &#123;</span><br><span class="line">        featureAreas.put(mFeatures.get(i), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// PendingArea是一个树形结构, 以下使用PA替代</span></span><br><span class="line">    PendingArea[] areaForLayer = <span class="keyword">new</span> <span class="title class_">PendingArea</span>[maxWindowLayerCount];</span><br><span class="line">    <span class="comment">// 创建根PA，并用其填充上面创建的36个PA数组，也就是每一个PA对应一个WindowLayer</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">PendingArea</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 注意这里areaForLayer数组中每一个元素都是root，而不是copy了一个PA</span></span><br><span class="line">    Arrays.fill(areaForLayer, root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------ 第二部分 --------</span></span><br><span class="line">    <span class="comment">// 创建显示区域以覆盖所有的Feature</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mFeatures.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部。</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Feature</span> <span class="variable">feature</span> <span class="operator">=</span> mFeatures.get(i);</span><br><span class="line">        <span class="type">PendingArea</span> <span class="variable">featureArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">            <span class="comment">// Feature的mWindowLayers是一个boolean类型的数组，但是该值又是什么意思呢？</span></span><br><span class="line">            <span class="comment">// 这里我们先打断一下，看看Feature是怎么构造的--[2.2.3](DisplayAreaPolicyBuilder.Feature的构造)</span></span><br><span class="line">            <span class="keyword">if</span> (feature.mWindowLayers[layer]) &#123;</span><br><span class="line">                <span class="comment">// 此功能将应用于此窗口层。为它找到一个显示区：</span></span><br><span class="line">                <span class="comment">// 可以重用现有的一个，如果它是为上一层的此功能创建的，并且应用到上一层的最后一个功能与应用到当前层的功能相同（因此它们可以共享相同的父显示区域）</span></span><br><span class="line">                <span class="keyword">if</span> (featureArea == <span class="literal">null</span> || featureArea.mParent != areaForLayer[layer]) &#123;</span><br><span class="line">                    <span class="comment">// 没有合适的显示区域：</span></span><br><span class="line">                    <span class="comment">// 在该层的上一个区域（作为父对象）下创建一个新区域。</span></span><br><span class="line">                    featureArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(feature, layer, areaForLayer[layer]);</span><br><span class="line">                    areaForLayer[layer].mChildren.add(featureArea);</span><br><span class="line">                &#125;</span><br><span class="line">                areaForLayer[layer] = featureArea;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此功能不会应用于此窗口层。如果需要应用到下一层，需要为此创建一个新的显示区域。</span></span><br><span class="line">                featureArea = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------ 第三部分 --------</span></span><br><span class="line">    <span class="comment">// 为每个层创建Tokens作为叶子</span></span><br><span class="line">    <span class="type">PendingArea</span> <span class="variable">leafArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leafType</span> <span class="operator">=</span> LEAF_TYPE_TOKENS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">        <span class="comment">// 2.2.1 获取当前layer类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> typeOfLayer(policy, layer);</span><br><span class="line">        <span class="comment">// 检查我们是否可以重用上一层的相同Tokens。如果上一个图层与当前图层的类型相同，并且没有仅应用于其中一个图层的功能，则会发生这种情况。</span></span><br><span class="line">        <span class="keyword">if</span> (leafArea == <span class="literal">null</span> || leafArea.mParent != areaForLayer[layer]</span><br><span class="line">                || type != leafType) &#123;</span><br><span class="line">            <span class="comment">// 为当前layer创建新的Tokens</span></span><br><span class="line">            leafArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span> <span class="comment">/* feature */</span>, layer, areaForLayer[layer]);</span><br><span class="line">            areaForLayer[layer].mChildren.add(leafArea);</span><br><span class="line">            leafType = type;</span><br><span class="line">            <span class="keyword">if</span> (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123;</span><br><span class="line">                <span class="comment">// 我们使用传入的TaskDisplayAreas作为层的任务容器类型。</span></span><br><span class="line">                <span class="comment">// 即使没有TaskDisplayArea，也不要创建Tokens。</span></span><br><span class="line">                addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);</span><br><span class="line">                addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],</span><br><span class="line">                        displayAreaGroupHierarchyBuilders);</span><br><span class="line">                leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leafType == LEAF_TYPE_IME_CONTAINERS) &#123;</span><br><span class="line">                <span class="comment">// 我们使用传入的ImeContainer作为层的ime容器类型。</span></span><br><span class="line">                <span class="comment">// 即使没有ime容器，也不要创建Tokens。</span></span><br><span class="line">                leafArea.mExisting = mImeContainer;</span><br><span class="line">                leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        leafArea.mMaxLayer = layer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------ 第四部分 --------</span></span><br><span class="line">    <span class="comment">// [2.5.1]计算最大layer</span></span><br><span class="line">    root.computeMaxLayer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [2.5.2]构建了一个PendingAreas树，其中包含表示层次结构的所有必要信息，现在创建并将真实的显示区域附加到根目录</span></span><br><span class="line">    root.instantiateChildren(mRoot, displayAreaForLayer, <span class="number">0</span>, featureAreas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [2.5.3]完成DisplayArea的创建，缓存结果便于快速访问</span></span><br><span class="line">    mRoot.onHierarchyBuilt(mFeatures, displayAreaForLayer, featureAreas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法使用以下属性构造图层层次结构：</p><ol><li>每个Feature映射到一组显示区域(PendingArea)</li><li>添加窗口后，对于该窗口类型所属的每个要素，它都是该要素的相应显示区域之一的后代。</li><li>保持Z顺序，即如果Z范围（区域）表示显示区域内的窗口层集：<br> 对于每对DisplayArea同级(a，b)，其中a低于b，它保持 max(z-range(a)) &lt;&#x3D; min(z-range(b))</li></ol><p>下面的算法迭代地创建这样一个层次结构：<br>-最初，所有窗口都附加到根目录。<br>-对于每个feature，我们通过在层上循环创建一组显示区域<br>-如果该feature确实适用于当前层，我们需要为它找到一个显示区域以满足（2）<br>-如果当前feature也适用于前一层（满足（3）），并且应用于前一层的最后一个特征与应用于当前层的最后一个特征相同（满足（2）），我们可以重用前一层的区域<br>-否则，我们将在应用于当前层的最后一个功能下面创建一个新的显示区域</p><p>云里雾里的，看不懂啊, 将这段代码分成四个部分，逐一解析。</p><h2 id="2-2-build的第一部分-layer-feature"><a href="#2-2-build的第一部分-layer-feature" class="headerlink" title="2.2 build的第一部分 - layer, feature"></a>2.2 build的第一部分 - layer, feature</h2><h3 id="2-2-1-layer类型-–-HierarchyBuilder-typeOfLayer"><a href="#2-2-1-layer类型-–-HierarchyBuilder-typeOfLayer" class="headerlink" title="2.2.1 layer类型 – HierarchyBuilder.typeOfLayer"></a>2.2.1 layer类型 – HierarchyBuilder.typeOfLayer</h3><p>此方法获取layer对应的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">typeOfLayer</span><span class="params">(WindowManagerPolicy policy, <span class="type">int</span> layer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (layer == APPLICATION_LAYER) &#123;</span><br><span class="line">        <span class="keyword">return</span> LEAF_TYPE_TASK_CONTAINERS;</span><br><span class="line">    <span class="comment">// 2.2.2 获取输入法对应的layer类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD)</span><br><span class="line">            || layer == policy.getWindowLayerFromTypeLw(TYPE_INPUT_METHOD_DIALOG)) &#123;</span><br><span class="line">        <span class="keyword">return</span> LEAF_TYPE_IME_CONTAINERS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LEAF_TYPE_TOKENS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里的layer类型有三种:</p><ol><li>LEAF_TYPE_TOKENS: tokens的layer</li><li>LEAF_TYPE_TASK_CONTAINERS: 作为Task的layer</li><li>LEAF_TYPE_IME_CONTAINERS: 作为输入法的layer</li></ol><p>其次当layer&#x3D;2时，其type为LEAF_TYPE_TASK_CONTAINERS；当layer&#x3D;15或16时，其type为LEAF_TYPE_IME_CONTAINERS；其余layer都是LEAF_TYPE_TOKENS类型。</p><h3 id="2-2-2-WindowManagerPolicy-getWindowLayerFromTypeLw"><a href="#2-2-2-WindowManagerPolicy-getWindowLayerFromTypeLw" class="headerlink" title="2.2.2 WindowManagerPolicy.getWindowLayerFromTypeLw"></a>2.2.2 WindowManagerPolicy.getWindowLayerFromTypeLw</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getWindowLayerFromTypeLw</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> canAddInternalSystemWindow,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> roundedCornerOverlay)</span> &#123;</span><br><span class="line">    <span class="comment">// 始终将圆角层放在最上面, 所以返回的layer类型就是对应最大的layer index</span></span><br><span class="line">    <span class="comment">// 所谓圆角层是指手机屏幕的四个角，现在大多时候圆角，会用一层黑色覆盖避免硬件显示的毛刺</span></span><br><span class="line">    <span class="comment">// 这样也容易调整角的弧度，使得出厂机器表现一致</span></span><br><span class="line">    <span class="keyword">if</span> (roundedCornerOverlay &amp;&amp; canAddInternalSystemWindow) &#123;</span><br><span class="line">        <span class="keyword">return</span> getMaxWindowLayer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 窗口类型是应用窗口时，返回的layer就是APPLICATION_LAYER（2）</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_LAYER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TYPE_WALLPAPER:</span><br><span class="line">            <span class="comment">// 墙纸在底部，不过可能会被WindowManager移动</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> TYPE_POINTER:</span><br><span class="line">            <span class="comment">// （鼠标）指针层</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="number">35</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Slog.e(<span class="string">&quot;WindowManager&quot;</span>, <span class="string">&quot;Unknown window type: &quot;</span> + type);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以解答刚刚的疑问了，为什么layer数量是36了，在考虑上面Window类型和Layer类型的对应，可以想到，layer类型的也是其Z轴的位置！</p><table><thead><tr><th>Window类型</th><th>值</th><th>作用</th><th>Layer(Z轴)</th></tr></thead><tbody><tr><td>TYPE_WALLPAPER</td><td>2013</td><td>壁纸窗口</td><td>1</td></tr><tr><td>[FIRST_APPLICATION_WINDOW,<br>LAST_APPLICATION_WINDOW]</td><td>[1, 99]</td><td>应用窗口</td><td>2</td></tr><tr><td>TYPE_PRESENTATION<br>TYPE_PRIVATE_PRESENTATION<br>TYPE_DOCK_DIVIDER<br>TYPE_QS_DIALOG<br>TYPE_PHONE</td><td>2037<br>2030<br>2034<br>2035<br>2002</td><td>*在外部显示器上显示的窗口<br>*在专用屏幕上方显示的窗口<br>*显示调整docked堆栈大小的窗口<br>*用于快速设置的窗口<br>*phone窗口，比如来电窗口</td><td>3</td></tr><tr><td>TYPE_SEARCH_BAR<br>TYPE_VOICE_INTERACTION_STARTING</td><td>2001<br>2033</td><td>*搜索栏窗口,位于屏幕顶部<br>*语音交互层的启动窗口</td><td>4</td></tr><tr><td>TYPE_VOICE_INTERACTION</td><td>2031</td><td>语音交互层窗口</td><td>5</td></tr><tr><td>TYPE_INPUT_CONSUMER</td><td>2022</td><td>systemUI栏隐藏时使用输入事件的窗口</td><td>6</td></tr><tr><td>TYPE_SYSTEM_DIALOG</td><td>2008</td><td>从状态栏滑出的面板窗口</td><td>7</td></tr><tr><td>TYPE_TOAST</td><td>2005</td><td>临时通知窗口，即toast窗口</td><td>8</td></tr><tr><td>TYPE_PRIORITY_PHONE</td><td>2007</td><td>优先电话UI界面</td><td>9</td></tr><tr><td>TYPE_SYSTEM_ALERT</td><td>2003</td><td>系统窗口，比如低电Dialog或者ANR之类</td><td>10或者13</td></tr><tr><td>TYPE_APPLICATION_OVERLAY</td><td>2038</td><td>应用覆盖窗口,在所有窗口的上方<br>但在关键系统窗口（如状态栏）的下方<br>需要SYSTEM_ALERT_WINDOW权限</td><td>12</td></tr><tr><td>TYPE_INPUT_METHOD</td><td>2011</td><td>内部输入法窗口，显示在普通用户界面上方。<br>可以调整应用窗口的大小或平移，以在显示<br>此窗口时保持输入焦点可见</td><td>15</td></tr><tr><td>TYPE_INPUT_METHOD_DIALOG</td><td>2012</td><td>显示在当前输入法窗口上方的内部输入法<br>对话框窗口</td><td>16</td></tr><tr><td>TYPE_STATUS_BAR</td><td>2000</td><td>状态栏</td><td>17</td></tr><tr><td>TYPE_STATUS_BAR_ADDITIONAL</td><td>2041</td><td>用于在屏幕的非常规部分（即屏幕的左侧或<br>底部）显示状态栏窗口</td><td>18</td></tr><tr><td>TYPE_NOTIFICATION_SHADE</td><td>2040</td><td>状态栏下拉的通知栏窗口和keyguard</td><td>19</td></tr><tr><td>TYPE_STATUS_BAR_SUB_PANEL</td><td>2017</td><td>从状态栏滑出的面板窗口</td><td>20</td></tr><tr><td>TYPE_KEYGUARD_DIALOG</td><td>2009</td><td>keyguard创建的对话框窗口</td><td>21</td></tr><tr><td>TYPE_VOLUME_OVERLAY</td><td>2020</td><td>音量调整窗口</td><td>22</td></tr><tr><td>TYPE_SYSTEM_OVERLAY</td><td>2006</td><td>系统覆盖窗口，需要显示在所有其他窗口之上。<br>这些窗口不能获取输入焦点，否则会干扰keyguard</td><td>23或者11</td></tr><tr><td>TYPE_NAVIGATION_BAR</td><td>2019</td><td>导航栏窗口，即虚拟按键的窗口</td><td>24</td></tr><tr><td>TYPE_NAVIGATION_BAR_PANEL</td><td>2024</td><td>导航栏面板窗口</td><td>25</td></tr><tr><td>TYPE_SCREENSHOT</td><td>2036</td><td>截图窗口,用于屏幕截图动画、区域选择和UI</td><td>26</td></tr><tr><td>TYPE_SYSTEM_ERROR</td><td>2010</td><td>内部系统错误窗口</td><td>27或者10</td></tr><tr><td>TYPE_MAGNIFICATION_OVERLAY</td><td>2027</td><td>放大覆盖窗口。启用辅助功能放大时，用于<br>突出显示的放大部分</td><td>28</td></tr><tr><td>TYPE_DISPLAY_OVERLAY</td><td>2026</td><td>显示覆盖窗口。用于模拟辅助显示设备</td><td>29</td></tr><tr><td>TYPE_DRAG</td><td>2016</td><td>拖放窗口</td><td>30</td></tr><tr><td>TYPE_ACCESSIBILITY_OVERLAY</td><td>2032</td><td>无障碍辅助窗口</td><td>31</td></tr><tr><td>TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY</td><td>2039</td><td>无障碍辅助放大窗口</td><td>32</td></tr><tr><td>TYPE_SECURE_SYSTEM_OVERLAY</td><td>2015</td><td>安全系统覆盖窗口。<br>这些窗口不能获取输入焦点，否则会干扰keyguard</td><td>33</td></tr><tr><td>TYPE_BOOT_PROGRESS</td><td>2021</td><td>开机动画之后的启动对话框窗口</td><td>34</td></tr><tr><td>TYPE_POINTER</td><td>2018</td><td>鼠标指针窗口。如轨迹追踪球</td><td>35</td></tr><tr><td>-</td><td>roundedCornerOverlay&#x3D;true<br>canAddInternalSystemWindow&#x3D;true</td><td>圆角层，始终在最上面</td><td>36</td></tr></tbody></table><p>在分析DisplayArea的构造时，首先需要了解下这些类的作用：Feature、Feature.Builder、HierarchyBuilder：</p><h3 id="2-2-3-DisplayAreaPolicyBuilder-Feature的构造"><a href="#2-2-3-DisplayAreaPolicyBuilder-Feature的构造" class="headerlink" title="2.2.3 DisplayAreaPolicyBuilder.Feature的构造"></a>2.2.3 DisplayAreaPolicyBuilder.Feature的构造</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Feature</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span>[] mWindowLayers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NewDisplayAreaSupplier mNewDisplayAreaSupplier;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意mWindowLayers是一个boolean数组，这里的feature有如下几种：</p><table><thead><tr><th>Feature Name</th><th>ID</th><th>Function</th></tr></thead><tbody><tr><td>FEATURE_ROOT</td><td>0</td><td>表示该逻辑显示设备上的根显示区域</td></tr><tr><td>FEATURE_DEFAULT_TASK_CONTAINER</td><td>1</td><td>默认任务容器所在的显示区域</td></tr><tr><td>FEATURE_WINDOW_TOKENS</td><td>2</td><td>无Activity的显示区域</td></tr><tr><td>FEATURE_ONE_HANDED</td><td>3</td><td>单手功能的显示区域</td></tr><tr><td>FEATURE_WINDOWED_MAGNIFICATION</td><td>4</td><td>可以放大的显示区域。包含在{@link WindowManager.LayoutParams#TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY}下面的所有窗口</td></tr><tr><td>FEATURE_FULLSCREEN_MAGNIFICATION</td><td>5</td><td>可以放大的显示区域,但这个是整个显示放大</td></tr><tr><td>FEATURE_HIDE_DISPLAY_CUTOUT</td><td>6</td><td>用于隐藏显示裁剪功能的显示区域</td></tr><tr><td>FEATURE_IME_PLACEHOLDER</td><td>7</td><td>可以放置IME容器的显示区域。当IME目标改变时，如果IME容器可能被重表示为该层次结构，那么应该在每个根层次结构上启用。</td></tr><tr><td>FEATURE_ONE_HANDED_BACKGROUND_PANEL</td><td>8</td><td>显示区域为单手背景层，防止用户在打开暗主题时，无法清楚地识别屏幕已进入单手模式。</td></tr><tr><td>FEATURE_SYSTEM_LAST</td><td>10000</td><td>系统特征显示区的最后一个id，作为边界</td></tr><tr><td>FEATURE_VENDOR_FIRST</td><td>10001</td><td>供应商特定的显示区域定义可以从该值开始</td></tr><tr><td>FEATURE_VENDOR_LAST</td><td>20001</td><td>供应商特定的显示区域定义用该值作为边界</td></tr><tr><td>FEATURE_RUNTIME_TASK_CONTAINER_FIRST</td><td>20002</td><td>可以在运行时创建的任务显示区域以此值开始</td></tr></tbody></table><h3 id="2-2-4-DisplayAreaPolicyBuilder-Feature-Builder"><a href="#2-2-4-DisplayAreaPolicyBuilder-Feature-Builder" class="headerlink" title="2.2.4 DisplayAreaPolicyBuilder.Feature.Builder"></a>2.2.4 DisplayAreaPolicyBuilder.Feature.Builder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WindowManagerPolicy mPolicy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span>[] mLayers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">NewDisplayAreaSupplier</span> <span class="variable">mNewDisplayAreaSupplier</span> <span class="operator">=</span> DisplayArea::<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mExcludeRoundedCorner</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Builder(WindowManagerPolicy policy, String name, <span class="type">int</span> id) &#123;</span><br><span class="line">        mPolicy = policy;</span><br><span class="line">        mName = name;</span><br><span class="line">        mId = id;</span><br><span class="line">        <span class="comment">// mPolicy.getMaxWindowLayer = 36</span></span><br><span class="line">        mLayers = <span class="keyword">new</span> <span class="title class_">boolean</span>[mPolicy.getMaxWindowLayer() + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Feature <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mExcludeRoundedCorner) &#123;</span><br><span class="line">            <span class="comment">// 将mLayers[36]置为false</span></span><br><span class="line">            mLayers[mPolicy.getMaxWindowLayer()] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// builder中的mLayers就是Feature中的mWindowLayers</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Feature</span>(mName, mId, mLayers.clone(), mNewDisplayAreaSupplier);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看这里的mLayers，也是一个boolean数组，是一一对应36个layer的。</p><p>接下来看看 DisplayAreaPolicyBuilder.Feature.Builder 中关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将mLayers中所有元素都置为true</span></span><br><span class="line">Builder <span class="title function_">all</span><span class="params">()</span> &#123;</span><br><span class="line">    Arrays.fill(mLayers, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个int数组，其元素值代表Window类型,标记这些window窗口对应的layer为true</span></span><br><span class="line">Builder <span class="title function_">and</span><span class="params">(<span class="type">int</span>... types)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> types[i];</span><br><span class="line">        <span class="comment">// 将该Window类型对应的layer置位true</span></span><br><span class="line">        set(type, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个int数组，其元素值代表Window类型, 标记这些window窗口对应的layer为false</span></span><br><span class="line">Builder <span class="title function_">except</span><span class="params">(<span class="type">int</span>... types)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> types[i];</span><br><span class="line">        set(type, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从layer所处z轴从低往高直到typeInclusive类型窗口对应的layer，全部标记为true</span></span><br><span class="line"><span class="comment">// 注意是包含typeInclusive类型的</span></span><br><span class="line">Builder <span class="title function_">upTo</span><span class="params">(<span class="type">int</span> typeInclusive)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> layerFromType(typeInclusive, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        mLayers[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    set(typeInclusive, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将window类型为type对应的layer在mLayers中标记为value</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">    mLayers[layerFromType(type, <span class="literal">true</span>)] = value;</span><br><span class="line">    <span class="comment">// 当window类型是应用覆盖窗口时，其在所有窗口的上方, 但在关键系统窗口（如状态栏）的下方</span></span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_APPLICATION_OVERLAY) &#123;</span><br><span class="line">        <span class="comment">// 这是多余的一句了。。。</span></span><br><span class="line">        mLayers[layerFromType(type, <span class="literal">true</span>)] = value;</span><br><span class="line">        <span class="comment">// 将TYPE_SYSTEM_ALERT、TYPE_SYSTEM_OVERLAY、TYPE_SYSTEM_ERROR的Layer对应的数组元素也置为true</span></span><br><span class="line">        mLayers[layerFromType(TYPE_SYSTEM_ALERT, <span class="literal">false</span>)] = value;</span><br><span class="line">        mLayers[layerFromType(TYPE_SYSTEM_OVERLAY, <span class="literal">false</span>)] = value;</span><br><span class="line">        mLayers[layerFromType(TYPE_SYSTEM_ERROR, <span class="literal">false</span>)] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">layerFromType</span><span class="params">(<span class="type">int</span> type, <span class="type">boolean</span> internalWindows)</span> &#123;</span><br><span class="line">    <span class="comment">// 所以这个type是window的类型</span></span><br><span class="line">    <span class="keyword">return</span> mPolicy.getWindowLayerFromTypeLw(type, internalWindows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们通过分析FEATURE_WINDOWED_MAGNIFICATION和FEATURE_IME_PLACEHOLDER的构造，来理解，这个Feature的作用</p><h4 id="2-2-4-1-FEATURE-WINDOWED-MAGNIFICATION"><a href="#2-2-4-1-FEATURE-WINDOWED-MAGNIFICATION" class="headerlink" title="2.2.4.1 FEATURE_WINDOWED_MAGNIFICATION"></a>2.2.4.1 FEATURE_WINDOWED_MAGNIFICATION</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;WindowedMagnification&quot;</span>,</span><br><span class="line">                    FEATURE_WINDOWED_MAGNIFICATION)</span><br><span class="line">                    .upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    .except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</span><br><span class="line">                    <span class="comment">// Make the DA dimmable so that the magnify window also mirrors the dim layer.</span></span><br><span class="line">                    .setNewDisplayAreaSupplier(DisplayArea.Dimmable::<span class="keyword">new</span>)</span><br><span class="line">                    .build());</span><br></pre></td></tr></table></figure><p>FEATURE_WINDOWED_MAGNIFICATION的feature构造，注释上标记的是代表可以放大的显示区域(比如无障碍里的放大镜)，名称是”WindowedMagnification”：</p><ol><li>首先调用 Builder.upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY), TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY的layer对应Z轴值为32，也就是mLayer中0~31的值都是true</li><li>调用except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)，将其对应的layer值32置为false</li></ol><h4 id="2-2-4-2-FEATURE-IME-PLACEHOLDER"><a href="#2-2-4-2-FEATURE-IME-PLACEHOLDER" class="headerlink" title="2.2.4.2 FEATURE_IME_PLACEHOLDER"></a>2.2.4.2 FEATURE_IME_PLACEHOLDER</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rootHierarchy.addFeature(<span class="keyword">new</span> <span class="title class_">Feature</span>.Builder(wmService.mPolicy, <span class="string">&quot;ImePlaceholder&quot;</span>,</span><br><span class="line">                    FEATURE_IME_PLACEHOLDER)</span><br><span class="line">                    .and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG)</span><br><span class="line">                    .build());</span><br></pre></td></tr></table></figure><p>FEATURE_IME_PLACEHOLDER的feature构造，注释上标记的是代表可以放置IME(输入法窗口)容器的显示区域，只有一个最简单的and(TYPE_INPUT_METHOD, TYPE_INPUT_METHOD_DIALOG), 也就是仅仅将该feature中mWindowLayers里对应TYPE_INPUT_METHOD(15)和TYPE_INPUT_METHOD_DIALOG(16)的layer置位true, 其他都是false.</p><p>好了，大致明白Feature的构造过程，以及mWindowLayers中的值来源，现在在回过头继续看 <a href="#x1-hierarchybuilderbuild">HierarchyBuilder.build</a> 过程。</p><h2 id="2-3-build第二部分–PendingArea的构造"><a href="#2-3-build第二部分–PendingArea的构造" class="headerlink" title="2.3 build第二部分–PendingArea的构造"></a>2.3 build第二部分–PendingArea的构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mFeatures.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="comment">// 按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Feature</span> <span class="variable">feature</span> <span class="operator">=</span> mFeatures.get(i);</span><br><span class="line">    <span class="type">PendingArea</span> <span class="variable">featureArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">        <span class="comment">// Feature的mWindowLayers是一个boolean类型的数组，但是该值又是什么意思呢？</span></span><br><span class="line">        <span class="comment">// 这里我们先打断一下，看看Feature是怎么构造的--[2.2.3](DisplayAreaPolicyBuilder.Feature的构造)</span></span><br><span class="line">        <span class="keyword">if</span> (feature.mWindowLayers[layer]) &#123;</span><br><span class="line">            <span class="comment">// 此功能将应用于此窗口层。为它找到一个显示区：</span></span><br><span class="line">            <span class="comment">// 可以重用现有的一个，如果它是为上一层的此功能创建的，并且应用到上一层的最后一个功能与应用到当前层的功能相同（因此它们可以共享相同的父显示区域）</span></span><br><span class="line">            <span class="keyword">if</span> (featureArea == <span class="literal">null</span> || featureArea.mParent != areaForLayer[layer]) &#123;</span><br><span class="line">                <span class="comment">// 没有合适的显示区域：</span></span><br><span class="line">                <span class="comment">// 在该层的上一个区域（作为父对象）下创建一个新区域。</span></span><br><span class="line">                featureArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(feature, layer, areaForLayer[layer]);</span><br><span class="line">                areaForLayer[layer].mChildren.add(featureArea);</span><br><span class="line">            &#125;</span><br><span class="line">            areaForLayer[layer] = featureArea;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此功能不会应用于此窗口层。如果需要应用到下一层，需要为此创建一个新的显示区域。</span></span><br><span class="line">            featureArea = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以默认的DisplayContent为例，有6个FEATURE：</p><table><thead><tr><th>Feature名</th><th>操作</th><th>mWindowLayers中为true的元素</th><th>mWindowLayers中为false的元素</th></tr></thead><tbody><tr><td>FEATURE_WINDOWED_MAGNIFICATION</td><td>.upTo(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)<br>.except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY)</td><td>[0,31]</td><td>[32,36]</td></tr><tr><td>FEATURE_HIDE_DISPLAY_CUTOUT</td><td>.all()<br>.except(TYPE_NAVIGATION_BAR,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_STATUS_BAR,TYPE_NOTIFICATION_SHADE)</td><td>all</td><td>17,19,24,25</td></tr><tr><td>FEATURE_ONE_HANDED_BACKGROUND_PANEL</td><td>.upTo(TYPE_WALLPAPER)</td><td>0</td><td>[1,36]</td></tr><tr><td>FEATURE_ONE_HANDED</td><td>.all()<br>.except(TYPE_NAVIGATION_BAR, <br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL)</td><td>all</td><td>24,25</td></tr><tr><td>FEATURE_FULLSCREEN_MAGNIFICATION</td><td>.all()<br>.except(TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD_DIALOG<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_MAGNIFICATION_OVERLAY,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_NAVIGATION_BAR_PANEL)</td><td>all</td><td>15,16,24,25,32</td></tr><tr><td>FEATURE_IME_PLACEHOLDER</td><td>.and(TYPE_INPUT_METHOD,<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TYPE_INPUT_METHOD_DIALOG)</td><td>15,16</td><td>all</td></tr></tbody></table><ol><li>第一个feature-FEATURE_WINDOWED_MAGNIFICATION里的mWindowLayers是[0,31]为true,其他位为false, 当此feature遍历完毕之后，areaForLayer数组中[0,31]的元素都是同一个新创建的PA，记为PA_for_WF_0(其mParent为root)， 其他元素都是指向root，而且现在root.mChildren中的唯一元素就是PA_for_WF_0. areaForLayer中的结果如下:<ol><li>[0,31] &#x3D; PA_for_WF_0(其mParent为root)</li><li>[32,36]&#x3D; root</li></ol></li><li>FEATURE_HIDE_DISPLAY_CUTOUT里除了17,19,24,25号其余都是true：<ol><li>当第二个for循环开始时，featureArea为null, 会新建一个PA, 记为PA_for_HDC_0， 并将其保存到root.mChildren中</li><li>依次将areaForLayer[0,16]置为PA_for_HDC_0</li><li>当layer为17时，因为FEATURE_HIDE_DISPLAY_CUTOUT.mWindowLayers[17]为false, 所以会将featureArea重置为null, 继续</li><li>当layer为18时，而FEATURE_HIDE_DISPLAY_CUTOUT.mWindowLayers[18]为true, 所以又创建一个PA, 记为PA_for_HDC_18，并将areaForLayer[18]置为PA_for_HDC_18</li><li>重复制止遍历完毕<ol><li>现在areaForLayer中的结果如下:<ol><li>[0,16] &#x3D; PA_for_HDC_0  (此PA的mParent为PA_for_WF_0)</li><li>[17]   &#x3D; PA_for_WF_0</li><li>[18]   &#x3D; PA_for_HDC_18 (此PA的mParent为PA_for_WF_0)</li><li>[19]   &#x3D; PA_for_WF_0</li><li>[20,23]&#x3D; PA_for_HDC_20 (此PA的mParent为PA_for_WF_0)</li><li>[24,25]&#x3D; PA_for_WF_0</li><li>[26,31]&#x3D; PA_for_HDC_26 (此PA的mParent为PA_for_WF_0)</li><li>[32,35]&#x3D; PA_for_HDC_32 (此PA的mParent为root)</li><li>[36]   &#x3D; root</li></ol></li><li>root.mChildren结果中保存PA_for_WF_0、PA_for_HDC_0、PA_for_HDC_18、PA_for_HDC_20及PA_for_HDC_26,PA_for_HDC_32</li></ol></li></ol></li></ol><p>这么分析不够直观，我们画个图来看看:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_3.png" alt="2-3"></p><p>然后其他的feature过程省略，直接看结果:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_4.png" alt="2-4"></p><p>于此同时，各个PA中的mParent指向如下：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_5.png" alt="2-5"></p><p>注意每个PA中的mChildren集合包含所有以该PA为mParent的PA. 其子PA按从上到下，从左到右的顺序依次被添加到该PA中。</p><h2 id="2-4-build第三部分–创建Tokens"><a href="#2-4-build第三部分–创建Tokens" class="headerlink" title="2.4 build第三部分–创建Tokens"></a>2.4 build第三部分–创建Tokens</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------ 第三部分 --------</span></span><br><span class="line"><span class="comment">// 为每个层创建Tokens作为叶子</span></span><br><span class="line"><span class="type">PendingArea</span> <span class="variable">leafArea</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">leafType</span> <span class="operator">=</span> LEAF_TYPE_TOKENS;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">layer</span> <span class="operator">=</span> <span class="number">0</span>; layer &lt; maxWindowLayerCount; layer++) &#123;</span><br><span class="line">    <span class="comment">// 2.2.1 获取当前layer类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> typeOfLayer(policy, layer);</span><br><span class="line">    <span class="comment">// 检查我们是否可以重用上一层的相同Tokens。如果上一个图层与当前图层的类型相同，并且没有仅应用于其中一个图层的功能，则会发生这种情况。</span></span><br><span class="line">    <span class="keyword">if</span> (leafArea == <span class="literal">null</span> || leafArea.mParent != areaForLayer[layer]</span><br><span class="line">            || type != leafType) &#123;</span><br><span class="line">        <span class="comment">// 为当前layer创建新的Tokens</span></span><br><span class="line">        leafArea = <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span> <span class="comment">/* feature */</span>, layer, areaForLayer[layer]);</span><br><span class="line">        areaForLayer[layer].mChildren.add(leafArea);</span><br><span class="line">        leafType = type;</span><br><span class="line">        <span class="keyword">if</span> (leafType == LEAF_TYPE_TASK_CONTAINERS) &#123;</span><br><span class="line">            <span class="comment">// 使用传入的TaskDisplayAreas作为任务容器类型。</span></span><br><span class="line">            <span class="comment">// [2.4.1] 即 DisplayAreaPolicy的初始化 的时候创建的 DefaultTaskDisplayArea</span></span><br><span class="line">            addTaskDisplayAreasToApplicationLayer(areaForLayer[layer]);</span><br><span class="line">            addDisplayAreaGroupsToApplicationLayer(areaForLayer[layer],</span><br><span class="line">                    displayAreaGroupHierarchyBuilders);</span><br><span class="line">            leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leafType == LEAF_TYPE_IME_CONTAINERS) &#123;</span><br><span class="line">            <span class="comment">// 我们使用传入的ImeContainer作为层的ime容器类型。</span></span><br><span class="line">            <span class="comment">// 即使没有ime容器，也不要创建Tokens。</span></span><br><span class="line">            leafArea.mExisting = mImeContainer;</span><br><span class="line">            leafArea.mSkipTokens = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    leafArea.mMaxLayer = layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段循环看起来和第二段中的循环类似，从Z轴最底层往上依次遍历37个layer。typeOfLayer这个我们已经分析过了: 其次当layer&#x3D;2(也就是APPLICATION_LAYER)时，其type为LEAF_TYPE_TASK_CONTAINERS；当layer&#x3D;15或16时，其type为LEAF_TYPE_IME_CONTAINERS；其余layer都是LEAF_TYPE_TOKENS类型：</p><ol><li>layer&#x3D;0时，layerType&#x3D;LEAF_TYPE_TOKENS， 创建一个PA,记为PA_TOKENS_0, 其mParent指向areaForLayer[0], 也即是 PA_for_FM_0, 并将该PA添加到PA_for_FM_0的mChildren中。</li><li>layer&#x3D;1时，layerType&#x3D;LEAF_TYPE_TOKENS， 现在leafArea就是PA_TOKENS_0, 所以此次循环仅仅是将PA_TOKENS_0.mMaxLayer改成当前layer也就是1.</li><li>layer&#x3D;2时，layerType&#x3D;LEAF_TYPE_TASK_CONTAINERS, 新建一个PA, 记为 PA_TASK_2, 其mParent指向areaForLayer[2],即 PA_for_FM_2</li><li>layer&#x3D;3时，layerType&#x3D;LEAF_TYPE_TOKENS， 创建一个PA,记为PA_TOKENS_3, 其mParent指向areaForLayer[3], 还是 PA_for_FM_2</li></ol><p>最终结果如下:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_6.png" alt="2-6"></p><p>上图中，leafArea的命名方式是 PA_layerType_minLayer_max_Layer. 箭头指向的方向就是其parent方向。</p><h3 id="2-4-1-HierarchyBuilder-addTaskDisplayAreasToApplicationLayer"><a href="#2-4-1-HierarchyBuilder-addTaskDisplayAreasToApplicationLayer" class="headerlink" title="2.4.1 HierarchyBuilder.addTaskDisplayAreasToApplicationLayer"></a>2.4.1 HierarchyBuilder.addTaskDisplayAreasToApplicationLayer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTaskDisplayAreasToApplicationLayer</span><span class="params">(PendingArea parentPendingArea)</span> &#123;</span><br><span class="line">    <span class="comment">// mTaskDisplayAreas中仅包含一个名为&quot;DefaultTaskDisplayArea&quot;的TaskDisplayArea</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mTaskDisplayAreas.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">PendingArea</span> <span class="variable">leafArea</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PendingArea</span>(<span class="literal">null</span> <span class="comment">/* feature */</span>, APPLICATION_LAYER, parentPendingArea);</span><br><span class="line">        <span class="comment">// 将mTaskDisplayAreas中的DisplayArea放入该PA中</span></span><br><span class="line">        leafArea.mExisting = mTaskDisplayAreas.get(i);</span><br><span class="line">        leafArea.mMaxLayer = APPLICATION_LAYER;</span><br><span class="line">        <span class="comment">// 添加一个新的PA, 记为 PA_Task_2_2_tda</span></span><br><span class="line">        parentPendingArea.mChildren.add(leafArea);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道传入的parentPendingArea就是上面构造的areaForLayer[APPLICATION_LAYER], 即 PA_for_FM_2!</p><p>这里就是把mTaskDisplayAreas中所有的TaskDisplayArea保存到PA_for_FM_2中, 最后结果如下:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_7.png" alt="2-7"></p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_8.png" alt="2-8"></p><h2 id="2-5-build第四部分–创建DisplayArea"><a href="#2-5-build第四部分–创建DisplayArea" class="headerlink" title="2.5 build第四部分–创建DisplayArea"></a>2.5 build第四部分–创建DisplayArea</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------ 第四部分 --------</span></span><br><span class="line"><span class="comment">// [2.5.1]计算最大layer</span></span><br><span class="line">root.computeMaxLayer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2.5.2]构建了一个PendingAreas树，其中包含表示层次结构的所有必要信息，现在创建并将真实的显示区域附加到根目录</span></span><br><span class="line">root.instantiateChildren(mRoot, displayAreaForLayer, <span class="number">0</span>, featureAreas);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [2.5.3]完成DisplayArea的创建，缓存结果便于快速访问</span></span><br><span class="line">mRoot.onHierarchyBuilt(mFeatures, displayAreaForLayer, featureAreas);</span><br></pre></td></tr></table></figure><h3 id="2-5-1-计算最大layer"><a href="#2-5-1-计算最大layer" class="headerlink" title="2.5.1 计算最大layer"></a>2.5.1 计算最大layer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">computeMaxLayer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mChildren.size(); i++) &#123;</span><br><span class="line">        mMaxLayer = Math.max(mMaxLayer, mChildren.get(i).computeMaxLayer());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mMaxLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有上面的图可以知道，root的children中最大的mMaxLayer为PA_TOKENS_36_36, 值为36。</p><h3 id="2-5-2-遍历PA树生成DisplayArea"><a href="#2-5-2-遍历PA树生成DisplayArea" class="headerlink" title="2.5.2 遍历PA树生成DisplayArea"></a>2.5.2 遍历PA树生成DisplayArea</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">instantiateChildren</span><span class="params">(DisplayArea&lt;DisplayArea&gt; parent, DisplayArea.Tokens[] areaForLayer,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> level, Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; areas)</span> &#123;</span><br><span class="line">    <span class="comment">// 将root里面的mChildren按照mMinLayer的大小排序，最小的在前面</span></span><br><span class="line">    mChildren.sort(Comparator.comparingInt(pendingArea -&gt; pendingArea.mMinLayer));</span><br><span class="line">    <span class="comment">// 遍历所有的children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mChildren.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PendingArea</span> <span class="variable">child</span> <span class="operator">=</span> mChildren.get(i);</span><br><span class="line">        <span class="comment">// 为该children创建DisplayArea</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayArea</span> <span class="variable">area</span> <span class="operator">=</span> child.createArea(parent, areaForLayer);</span><br><span class="line">        <span class="keyword">if</span> (area == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TaskDisplayArea 和 ImeContainer 可以不用设置</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为父DisplayArea添加新建的DisplayArea,且放在最前面</span></span><br><span class="line">        <span class="comment">// POSITION_TOP的值是Integer.MAX_VALUE, 这里的意思就是放在parent.mChildren集合的最末尾（Z轴来看就是最上面）</span></span><br><span class="line">        <span class="comment">// parent就是DisplayContent本身</span></span><br><span class="line">        parent.addChild(area, WindowContainer.POSITION_TOP);</span><br><span class="line">        <span class="keyword">if</span> (child.mFeature != <span class="literal">null</span>) &#123;</span><br><span class="line">            areas.get(child.mFeature).add(area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为每一个子PA遍历生成其子树的DisplayArea</span></span><br><span class="line">        child.instantiateChildren(area, areaForLayer, level + <span class="number">1</span>, areas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mChildren中只有三个PA, 分别是: PA_for_WF_0, PA_for_HDC_32以及PA_TOKENS_36_36. </p><p>这个方法不难看出，就是简单的遍历我们之前创建的PA树，然后给出了root之外的所有PA生成其对应的DisplayArea。</p><p>注意这里的传入的parent就是mRoot, 也就是DisplayContent，所以DisplayContent.mChildren中存入的元素就是此时构建的DisplayArea。</p><h4 id="2-5-2-1-PendingArea-createArea"><a href="#2-5-2-1-PendingArea-createArea" class="headerlink" title="2.5.2.1 PendingArea.createArea"></a>2.5.2.1 PendingArea.createArea</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DisplayArea <span class="title function_">createArea</span><span class="params">(DisplayArea&lt;DisplayArea&gt; parent,</span></span><br><span class="line"><span class="params">        DisplayArea.Tokens[] areaForLayer)</span> &#123;</span><br><span class="line">    <span class="comment">// 对于PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16</span></span><br><span class="line">    <span class="keyword">if</span> (mExisting != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mExisting.asTokens() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 为layer存储WindowToken的容器</span></span><br><span class="line">            fillAreaForLayers(mExisting.asTokens(), areaForLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mExisting;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSkipTokens) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DisplayArea.Type type;</span><br><span class="line">    <span class="keyword">if</span> (mMinLayer &gt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.ABOVE_TASKS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mMaxLayer &lt; APPLICATION_LAYER) &#123;</span><br><span class="line">        type = DisplayArea.Type.BELOW_TASKS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = DisplayArea.Type.ANY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）</span></span><br><span class="line">    <span class="keyword">if</span> (mFeature == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayArea.<span class="type">Tokens</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisplayArea</span>.Tokens(parent.mWmService, type,</span><br><span class="line">                <span class="string">&quot;Leaf:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer);</span><br><span class="line">        fillAreaForLayers(leaf, areaForLayer);</span><br><span class="line">        <span class="keyword">return</span> leaf;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,</span><br><span class="line">                mFeature.mName + <span class="string">&quot;:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer, mFeature.mId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会创建PendingArea对应的DisplayArea，对于我们的PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16！</p><p><strong>这里我们先看看PA_TASK_2_2_tda的DisplayArea的创建：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于PA树来说，有且只有两个PA的mExisting不为null: PA_TASK_2_2_tda和PA_IME_15_16</span></span><br><span class="line"><span class="keyword">if</span> (mExisting != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mExisting.asTokens() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 为layer存储WindowToken的容器</span></span><br><span class="line">        fillAreaForLayers(mExisting.asTokens(), areaForLayer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mExisting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道PA_TASK_2_2_tda的mExisting就是<a href="#1212-displayareapolicy%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">1.2.1.2 DisplayAreaPolicy的初始化</a>中创建的”DefaultTaskDisplayArea”</p><blockquote><p>final TaskDisplayArea defaultTaskDisplayArea &#x3D; new TaskDisplayArea(content, wmService, “DefaultTaskDisplayArea”, FEATURE_DEFAULT_TASK_CONTAINER);</p></blockquote><p>而TaskDisplayArea又是继承了DisplayArea， 其asTokens直接返回了null, 所以说PA_TASK_2_2_tda的DisplayArea就是其mExisting!</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_9.png" alt="2-9"></p><p><strong>接下来是PA_IME_15_16的DisplayArea的创建：</strong></p><p>因为mImeContainer是在DisplayContent初始化过程中创建的ImeContainer类的对象，其就是Tokens的子类。所以mExisting.asTokens()确实不为null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fillAreaForLayers</span><span class="params">(DisplayArea.Tokens leaf, DisplayArea.Tokens[] areaForLayer)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mMinLayer; i &lt;= mMaxLayer; i++) &#123;</span><br><span class="line">        areaForLayer[i] = leaf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是将displayAreaForLayer中从minLayer到maxLayer都改成该PA的mExisting. 也就是 displayAreaForLayer[15], displayAreaForLayer[16]为mImeContainer!</p><p><strong>当mExisting为null时PA对应的DisplayArea的创建：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DisplayArea.Type type;</span><br><span class="line"><span class="keyword">if</span> (mMinLayer &gt; APPLICATION_LAYER) &#123;</span><br><span class="line">    type = DisplayArea.Type.ABOVE_TASKS;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mMaxLayer &lt; APPLICATION_LAYER) &#123;</span><br><span class="line">    type = DisplayArea.Type.BELOW_TASKS;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    type = DisplayArea.Type.ANY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）</span></span><br><span class="line"><span class="keyword">if</span> (mFeature == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> DisplayArea.<span class="type">Tokens</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DisplayArea</span>.Tokens(parent.mWmService, type,</span><br><span class="line">            <span class="string">&quot;Leaf:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer);</span><br><span class="line">    fillAreaForLayers(leaf, areaForLayer);</span><br><span class="line">    <span class="keyword">return</span> leaf;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mFeature.mNewDisplayAreaSupplier.create(parent.mWmService, type,</span><br><span class="line">            mFeature.mName + <span class="string">&quot;:&quot;</span> + mMinLayer + <span class="string">&quot;:&quot;</span> + mMaxLayer, mFeature.mId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PA的mFeature只有leafArea的mFeature才是null的（或者root,但是root不参与DisplayArea的创建）:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/2_10.png" alt="2-10"></p><ol><li>当mFeature为null时，也就是当前PA是leafArea(即PA为TOKENS、TASK或者IME时)，直接创建Tokens,然后进行displayAreaForLayer的填充</li><li>当mFeature不为null时，通过mNewDisplayAreaSupplier创建DisplayArea<ol><li>当feature为FEATURE_WINDOWED_MAGNIFICATION，通过DisplayArea.Dimmable::new创建一个Dimmable</li><li>其余feature通过DisplayArea::new创建一个DisplayArea</li></ol></li></ol><p>所以遍历PA树生成DisplayArea就是将PA树除root节点之外，给每一个子PA创建一个DisplayArea.</p><p>经过这步骤之后，displayAreaForLayer[0~36]中的元素如下：</p><ol><li>displayAreaForLayer[2]     &#x3D; PA_TASK_2_2_tda</li><li>displayAreaForLayer[15,16] &#x3D; mImeContainer</li><li>其余元素皆为新建的DisplayArea.Tokens</li></ol><h3 id="2-5-3-RootDisplayArea-onHierarchyBuilt"><a href="#2-5-3-RootDisplayArea-onHierarchyBuilt" class="headerlink" title="2.5.3 RootDisplayArea.onHierarchyBuilt"></a>2.5.3 RootDisplayArea.onHierarchyBuilt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">onHierarchyBuilt</span><span class="params">(ArrayList&lt;Feature&gt; features, DisplayArea.Tokens[] areaForLayer,</span></span><br><span class="line"><span class="params">            Map&lt;Feature, List&lt;DisplayArea&lt;WindowContainer&gt;&gt;&gt; featureToDisplayAreas)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mHasBuiltHierarchy) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Root should only build the hierarchy once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mHasBuiltHierarchy = <span class="literal">true</span>;</span><br><span class="line">    mFeatures = Collections.unmodifiableList(features);</span><br><span class="line">    <span class="comment">// 注意这里将构建的displayAreaForLayer保存在了mAreaForLayer中</span></span><br><span class="line">    mAreaForLayer = areaForLayer;</span><br><span class="line">    mFeatureToDisplayAreas = featureToDisplayAreas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，仅仅是将传入的参数保存起来。并且将mHasBuiltHierarchy标记为true, 表明RootTaskDisplayArea仅仅需要构建一次层次结构。</p><h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>Activity的Window被添加至WMS其实就是该Activity的ViewRootImpl中的W作为IWindow、存储该Activity窗口属性信息的LayoutParams以及InputChannel被传入WMS，然后生成WindowToken, 当然之后WindowToken自然是保存在DisplayContent.mTokenMap中，该map的key即对应Activity中的mToken(LocalActivityRecord)。</p><p>这里的DisplayContent是继承了RootDisplayArea, 其对应的Feature是FEATURE_ROOT，表示是该逻辑显示设备上的根显示区域。DisplayContent的初始化中做了很多工作，包括创建SurfaceControl，创建DisplayPolicy等等，重点是初始化DisplayAreaPolicy，而DisplayAreaPolicy的初始化过程中也同时构建了DisplayContent的层次结构器。</p><p>这个层次结构的初始化过程稍显复杂，可以看 <a href="#21-hierarchybuilderbuild">HierarchyBuilder.build</a> 上面的分析，大致分为四个部分:</p><ol><li><a href="#22-build%E7%9A%84%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86---layer-feature">第一部分</a> Layer的数量为37个,最上层是root, 默认DisplayArea的Feature有六个</li><li><a href="#23-build%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86--pendingarea%E7%9A%84%E6%9E%84%E9%80%A0">第二部分</a> 构造PA树<ol><li>按照定义的顺序遍历feature，以便数组前面的Feature位于层次结构的顶部</li><li>依次编译该feature中定义的mWindowLayer数组，该数组由37个boolean值组成，从小到大一次对应37层layer</li><li>如果mWindowLayer[layer]的值为true, 那么根据需要创建子PA</li></ol></li><li><a href="#24-build%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86--%E5%88%9B%E5%BB%BAtokens">第三部分</a> 遍历第二部分创建的PA树，根据window类型创建对应叶子节点的PA</li><li><a href="#25-build%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86--%E5%88%9B%E5%BB%BAdisplayarea">第四部分</a> 为PA树的每个PA创建对应的DisplayArea，并将结果存储在RootDisplayArea（DisplayContent）中</li></ol><p>接下来我们分析WindowToke到底是如何管理的，包括WindowState的作用，而且我们分析WindowState创建的时候发现会抛出异常，这个问题我们下篇文章分析。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;在我们开始分析WMS是怎么管理不同应用的Window的时，有点一头雾水，不知如何下手。那么我们还是从单个Activity的Window被添加至WMS中来入手。&lt;/p&gt;
&lt;p&gt;从上文中我们知道PhoneWindow是通过IWindowSession被添加的，在ViewRoontImpl中调用了addToDisplayAsUser:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getHostVisibility(), mDisplay.getDisplayId(), userId,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mTempControls);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里的mWindow是ViewRootImpl.W类的对象，用于WMS和该Window通信。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
  </entry>
  
  <entry>
    <title>WMS(1)-服务启动和Activity窗口回顾</title>
    <link href="https://swallowjoe.github.io/2022/05/01/WMS(1)-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%92%8CActivity%E7%AA%97%E5%8F%A3%E5%9B%9E%E9%A1%BE/"/>
    <id>https://swallowjoe.github.io/2022/05/01/WMS(1)-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%92%8CActivity%E7%AA%97%E5%8F%A3%E5%9B%9E%E9%A1%BE/</id>
    <published>2022-04-30T17:35:34.000Z</published>
    <updated>2022-06-18T09:50:16.308Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div>---<p><strong>以下分析基于Android S.</strong></p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>之前我们通过Vsync这个Android绘制的脉搏疏通了绘制的流程，在Activity的显示研究过程中，粗略接触了WindowManagerService，也即Android的窗口管理。</p><p>接下来我们深入探讨一下Android中的窗口管理设计，以便我们理解View、Activity、Window、Task等之间的关系。</p><p>首先还是从WindowManagerService服务的启动开始，在Android开机流程中，我们知道WMS是在引导服务和核心服务启动之后才会开始的:</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startOtherServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    t.traceBegin(<span class="string">&quot;StartWindowManagerService&quot;</span>);</span><br><span class="line">    <span class="comment">// WMS needs sensor service ready</span></span><br><span class="line">    ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">    mSensorServiceStart = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1.1 WMS的初始化</span></span><br><span class="line">    wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PhoneWindowManager</span>(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">    <span class="comment">// 发布WMS</span></span><br><span class="line">    ServiceManager.addService(Context.WINDOW_SERVICE, wm, <span class="comment">/* allowIsolated= */</span> <span class="literal">false</span>,</span><br><span class="line">            DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">    ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">            <span class="comment">/* allowIsolated= */</span> <span class="literal">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    t.traceBegin(<span class="string">&quot;SetWindowManagerService&quot;</span>);</span><br><span class="line">    mActivityManagerService.setWindowManager(wm);</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    t.traceBegin(<span class="string">&quot;WindowManagerServiceOnInitReady&quot;</span>);</span><br><span class="line">    wm.onInitReady();</span><br><span class="line">    t.traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里眼尖的同学发现了，WMS的启动必须等待SensorService的启动完毕，为什么呢,后面给出答案。</p><h1 id="一-WMS启动"><a href="#一-WMS启动" class="headerlink" title="一. WMS启动"></a>一. WMS启动</h1><p>从上面也看出了，WMS的启动是先调用了其静态方法main, 并传入context, inputManager及ActivityTaskManager等，还有一个WindowManagerPolicy子类PhoneWindowManager的对象.</p><h2 id="1-1-WindowManagerService-main"><a href="#1-1-WindowManagerService-main" class="headerlink" title="1.1 WindowManagerService.main"></a>1.1 WindowManagerService.main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="type">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span><br><span class="line"><span class="params">        ActivityTaskManagerService atm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> main(context, im, showBootMsgs, onlyCore, policy, atm,</span><br><span class="line">            SurfaceControl.Transaction::<span class="keyword">new</span>, Surface::<span class="keyword">new</span>, SurfaceControl.Builder::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns an instance of the WindowManagerService. This call allows the caller</span></span><br><span class="line"><span class="comment"> * to override factories that can be used to stub native calls during test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="type">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span><br><span class="line"><span class="params">        ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory,</span></span><br><span class="line"><span class="params">        Supplier&lt;Surface&gt; surfaceFactory,</span></span><br><span class="line"><span class="params">        Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用&quot;android.display&quot;线程初始化WindowManagerService</span></span><br><span class="line">    <span class="comment">// 初始化没有结束时，调用main的线程会被阻塞</span></span><br><span class="line">    DisplayThread.getHandler().runWithScissors(() -&gt;</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">WindowManagerService</span>(context, im, showBootMsgs, onlyCore, policy,</span><br><span class="line">                    atm, transactionFactory, surfaceFactory, surfaceControlFactory), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的双冒号”::”、Supplier以及Function都是java8引入的函数式编程语法。这里值得注意的是runWithScissors方法。</p><h2 id="1-2-DisplayThread-getHandler"><a href="#1-2-DisplayThread-getHandler" class="headerlink" title="1.2 DisplayThread.getHandler"></a>1.2 DisplayThread.getHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DisplayThread</span> <span class="keyword">extends</span> <span class="title class_">ServiceThread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DisplayThread sInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler sHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DisplayThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// DisplayThread runs important stuff, but these are not as important as things running in</span></span><br><span class="line">        <span class="comment">// AnimationThread. Thus, set the priority to one lower.</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;android.display&quot;</span>, Process.THREAD_PRIORITY_DISPLAY + <span class="number">1</span>, <span class="literal">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ensureThreadLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> <span class="title class_">DisplayThread</span>();</span><br><span class="line">            sInstance.start();</span><br><span class="line">            sInstance.getLooper().setTraceTag(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">            sHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(sInstance.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Handler <span class="title function_">getHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DisplayThread.class) &#123;</span><br><span class="line">            ensureThreadLocked();</span><br><span class="line">            <span class="keyword">return</span> sHandler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可以看出DisplayThread其实就是Android里的”android.display”线程，优先级仅仅比THREAD_PRIORITY_DISPLAY低一档。</p><h3 id="1-2-1-Handler-runWithScissors"><a href="#1-2-1-Handler-runWithScissors" class="headerlink" title="1.2.1 Handler.runWithScissors"></a>1.2.1 Handler.runWithScissors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">runWithScissors</span><span class="params">(<span class="meta">@NonNull</span> Runnable r, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;runnable must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout must be non-negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Looper.myLooper() == mLooper) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">BlockingRunnable</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockingRunnable</span>(r);</span><br><span class="line">    <span class="keyword">return</span> br.postAndWait(<span class="built_in">this</span>, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到该方法首先检查了参数合法性，然后判断当前允许的线程是否是Handler处理线程:</p><ol><li>如果是Handler处理线程，则执行runnable</li><li>如果不是，则创建一个BlockingRunnable，执行其postAndWait方法</li></ol><p>从postAndWait名字中可以推测，必定是需要等待指定runnable在Handler处理线程上执行完毕后，调用runWithScissors的线程才能继续运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">BlockingRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable mTask;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mDone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingRunnable</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        mTask = task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mTask.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runnable执行完毕后标记mDone为true,然后通知所以等待线程</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                mDone = <span class="literal">true</span>;</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postAndWait</span><span class="params">(Handler handler, <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="comment">// 当handler中已经存在此runnable时，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!handler.post(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">expirationTime</span> <span class="operator">=</span> SystemClock.uptimeMillis() + timeout;</span><br><span class="line">                <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待delay时长</span></span><br><span class="line">                        wait(delay);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以runWithScissors方法为啥会标记为hide呢，明明很好的实现了将某个任务放到指定线程执行并等待该任务执行完毕后继续。</p><ol><li>考虑到如果等待超时，postAndWait返回的也是false,但是对应runnable的message仍旧处于Handler的MessageQueue之中，这样该runnable最终还是会被执行的。</li><li>可能造成死锁，因为runWithScissors所处线程会一直等待，除非超时。比如任务所处的handler的Looper被调用了quit()退出时。我们知道quit方法是会清理Looper的MessageQueue中所有消息，如果此时timeout的时间设置的是0，那么runWithScissors方法所处的线程会一直等到天荒地老。除非Looper退出时是调用的quitSafely(), 该方法只会清空MessageQueue中当前时间点之后的message,在这之前的message仍会被执行。</li></ol><p>而我们知道，DisplayThread代表线程是不会退出的(除非关机), 所以这里调用runWithScissors是安全的。</p><h2 id="1-3-WindowManagerService"><a href="#1-3-WindowManagerService" class="headerlink" title="1.3 WindowManagerService"></a>1.3 WindowManagerService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> showBootMsgs, <span class="type">boolean</span> onlyCore, WindowManagerPolicy policy,</span></span><br><span class="line"><span class="params">        ActivityTaskManagerService atm, Supplier&lt;SurfaceControl.Transaction&gt; transactionFactory,</span></span><br><span class="line"><span class="params">        Supplier&lt;Surface&gt; surfaceFactory,</span></span><br><span class="line"><span class="params">        Function&lt;SurfaceSession, SurfaceControl.Builder&gt; surfaceControlFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 在LockGuard中创建代表WINDOW的Lock, 可以帮助检测系统服务内部锁的机制</span></span><br><span class="line">    installLock(<span class="built_in">this</span>, INDEX_WINDOW);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 标记当前设备是否是可触摸的</span></span><br><span class="line">    mInTouchMode = context.getResources().getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_defaultInTouchMode);</span><br><span class="line">    <span class="comment">// 设置是否允许触摸，现在手机、平板设备一般都是可触摸的</span></span><br><span class="line">    inputManager.setInTouchMode(mInTouchMode);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过surfaceControlFactory可以直接生成SurfaceControl.Builder的对象</span></span><br><span class="line">    mSurfaceControlFactory = surfaceControlFactory;</span><br><span class="line">    <span class="comment">// 其实是实现了Supplier接口的SurfaceControl.Transaction::new</span></span><br><span class="line">    mTransactionFactory = transactionFactory;</span><br><span class="line">    <span class="comment">// 其实是实现了Supplier接口Surface::new</span></span><br><span class="line">    mSurfaceFactory = surfaceFactory;</span><br><span class="line">    <span class="comment">// 创建Transaction对象, 注意每次调用get方法生成的都是新的SurfaceControl.Transaction对象</span></span><br><span class="line">    mTransaction = mTransactionFactory.get();</span><br><span class="line">    <span class="comment">// 这个policy就是PhoneWindowPolicy</span></span><br><span class="line">    mPolicy = policy;</span><br><span class="line">    <span class="comment">// 创建WindowAnimator</span></span><br><span class="line">    mAnimator = <span class="keyword">new</span> <span class="title class_">WindowAnimator</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 创建RootWindowContainer</span></span><br><span class="line">    mRoot = <span class="keyword">new</span> <span class="title class_">RootWindowContainer</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 創建WindowSurfacePlacer，如其名，用於定位窗口及其表面</span></span><br><span class="line">    <span class="comment">// 通过计算窗口的框架来设置窗口的位置，然后根据这些框架来定位Surface</span></span><br><span class="line">    mWindowPlacerLocked = <span class="keyword">new</span> <span class="title class_">WindowSurfacePlacer</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 創建TaskSnapshotController，用於获取相应任务的快照(位图)并将其放入缓存</span></span><br><span class="line">    mTaskSnapshotController = <span class="keyword">new</span> <span class="title class_">TaskSnapshotController</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建WakeLock,用于在转屏等动作时保持cpu不休眠</span></span><br><span class="line">    mScreenFrozenLock = mPowerManager.newWakeLock(</span><br><span class="line">            PowerManager.PARTIAL_WAKE_LOCK, <span class="string">&quot;SCREEN_FROZEN&quot;</span>);</span><br><span class="line">    mScreenFrozenLock.setReferenceCounted(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于管理监听Display的层次属性变化的监听器</span></span><br><span class="line">    mDisplayNotificationController = <span class="keyword">new</span> <span class="title class_">DisplayWindowListenerController</span>(<span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建WakeLock,在必要时保持屏幕常量</span></span><br><span class="line">    mHoldingScreenWakeLock = mPowerManager.newWakeLock(</span><br><span class="line">            PowerManager.SCREEN_BRIGHT_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, TAG_WM);</span><br><span class="line">    mHoldingScreenWakeLock.setReferenceCounted(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 用于执行不需要持有WindowManager的锁的窗口动画</span></span><br><span class="line">    mSurfaceAnimationRunner = <span class="keyword">new</span> <span class="title class_">SurfaceAnimationRunner</span>(mTransactionFactory,</span><br><span class="line">            mPowerManagerInternal);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 用于任务拖动定位的控制器</span></span><br><span class="line">    mTaskPositioningController = <span class="keyword">new</span> <span class="title class_">TaskPositioningController</span>(</span><br><span class="line">            <span class="built_in">this</span>, mInputManager, mActivityTaskManager, mH.getLooper());</span><br><span class="line">    <span class="comment">// 该类处理并组合从多个视图中生成的拖动事件，然后向任何已经注册了回调的ondragdroplistener触发事件。</span></span><br><span class="line">    mDragDropController = <span class="keyword">new</span> <span class="title class_">DragDropController</span>(<span class="built_in">this</span>, mH.getLooper());</span><br><span class="line">    <span class="comment">// 用于强制显示高刷新率的包的Denylist</span></span><br><span class="line">    mHighRefreshRateDenylist = HighRefreshRateDenylist.create(context.getResources());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建DisplayAreaPolicyProvider，用于后续的DisplayAreaPolicy的构建</span></span><br><span class="line">    mDisplayAreaPolicyProvider = DisplayAreaPolicy.Provider.fromResources(</span><br><span class="line">            mContext.getResources());</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置全局阴影</span></span><br><span class="line">    setGlobalShadowSettings();</span><br><span class="line">    mAnrController = <span class="keyword">new</span> <span class="title class_">AnrController</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 管理创建和释放启动窗口Surface</span></span><br><span class="line">    mStartingSurfaceController = <span class="keyword">new</span> <span class="title class_">StartingSurfaceController</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里省略的很多设置代码，仅贴了一些比较重要或者有趣的类对象初始化。</p><h1 id="二-Activity的Window创建"><a href="#二-Activity的Window创建" class="headerlink" title="二. Activity的Window创建"></a>二. Activity的Window创建</h1><p>之前我们在*Activity的显示(1)*一文中有分析过，应用的Activity在onCreate方法中setContentView设置了UI布局，之后在该Activity第一次resume时，初始化ViewRootImpl，当该Activity是应用进程第一个被resume的Activity时，建立进程与WMS的通信通道，也就是WindowSession!</p><p>最后ViewRootImpl的setView方法中，通过binder调用WindowManager的addToDisplay,之后进入到SystemServer进程调用到WMS.addWindow，在这里创建该Activity对应的WindowState,并保存在mWindowMap中。</p><p>如下即是WMS中addWindow的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWindow</span><span class="params">(Session session, IWindow client, LayoutParams attrs, <span class="type">int</span> viewVisibility,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> displayId, <span class="type">int</span> requestUserId, InsetsState requestedVisibility,</span></span><br><span class="line"><span class="params">        InputChannel outInputChannel, InsetsState outInsetsState,</span></span><br><span class="line"><span class="params">        InsetsSourceControl[] outActiveControls)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">displayContent</span> <span class="operator">=</span> getDisplayContentOrCreate(displayId, attrs.token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="type">ActivityRecord</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">hasParent</span> <span class="operator">=</span> parentWindow != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WindowToken</span> <span class="variable">token</span> <span class="operator">=</span> displayContent.getWindowToken(</span><br><span class="line">                hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">rootType</span> <span class="operator">=</span> hasParent ? parentWindow.mAttrs.type : type;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">addToastWindowRequiresToken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">windowContextToken</span> <span class="operator">=</span> attrs.mWindowContextToken;</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasParent) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 一般走这里创建WindowToken</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">                token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">                        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 初始化WindowState</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">WindowState</span> <span class="variable">win</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowState</span>(<span class="built_in">this</span>, session, client, token, parentWindow,</span><br><span class="line">                appOp[<span class="number">0</span>], attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                session.mCanAddInternalSystemWindow);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 创建SurfaceSession, 用来和SurfaceFlinger通信</span></span><br><span class="line">        win.attach();</span><br><span class="line">        <span class="comment">// 保存WindowState</span></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        win.mToken.addWindow(win);</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们可以看到WMS中几个关键的类: WindowState,WindowToken,ActivityRecord等。之前我们就绘制过这个类图：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_1.png" alt="1-1"></p><ol><li>WindowToken: 是在WindowManagerService 中定义的一个基类，顾名思义，它是用来标识某一个窗口。可以把WindowToken看成是一个显示令牌，无论是系统窗口还是应用窗口，添加新的窗口时需要使用这个令牌向WMS表明自己的身份，添加窗口(addWindow)时会创建WindowToken，销毁窗口的时候移除WindowToken(removeWindowToken方法)。</li><li>ActivityRecord(原AppWindowToken): 顾名思义，它是用来标识app, 跟准确的说法，是用来标识某个具体的Activity. App每个的Activity对应一個ActivityRecord。其中的appToken為IApplicationToken.Stub类型，有了它就可以找到对应的ActivityRecord.</li></ol><p>从上面的关系图也能发现，这个WindowToken中token是关键点，我们尚未理清这个值的含义，接下来我们分析一下这个token的来源：</p><h2 id="2-1-PhoneWindow的创建"><a href="#2-1-PhoneWindow的创建" class="headerlink" title="2.1 PhoneWindow的创建"></a>2.1 PhoneWindow的创建</h2><p>简单回顾一下 Activity 对应的 PhoneWindow的创建，注意这里仅仅是App进程中的Window.</p><p>我们从handleLaunchActivity开始:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Activity <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-performLaunchActivity"><a href="#2-1-1-performLaunchActivity" class="headerlink" title="2.1.1 performLaunchActivity"></a>2.1.1 performLaunchActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Activity <span class="title function_">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">    <span class="type">ActivityInfo</span> <span class="variable">aInfo</span> <span class="operator">=</span> r.activityInfo;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> appContext.getClassLoader();</span><br><span class="line">        <span class="comment">// 通过反射生成Activity</span></span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建应用Application</span></span><br><span class="line">        <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> r.packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 这里传入的window一般是null的</span></span><br><span class="line">            activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                    r.assistToken, r.shareableActivityToken);</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">                <span class="comment">// 将该Activity保存至mActivities集合中，key值就是ActivityClientRecord中的token</span></span><br><span class="line">                mActivities.put(r.token, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用performLaunchActivity就一定会创建一个新的Activity对象，并保存在mActivities集合中。</p><h3 id="2-1-2-Activity-attach"><a href="#2-1-2-Activity-attach" class="headerlink" title="2.1.2 Activity.attach"></a>2.1.2 Activity.attach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span><br><span class="line"><span class="params">        Instrumentation instr, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">        CharSequence title, Activity parent, String id,</span></span><br><span class="line"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="line"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken,</span></span><br><span class="line"><span class="params">        IBinder shareableActivityToken)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建Activity对应的PhoneWindow</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(mWindowControllerCallback);</span><br><span class="line">    mWindow.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 设置PhoneWindow的WindowManager</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当Activity的parent不为空时，该Activity的PhoneWindow对应的容器就是其parent对应的窗口</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到一个Activity对应一个PhoneWindow, 而且PhoneWindow是在Activity launch的时候才创建的。</p><h2 id="2-2-WindowToken中token的作用"><a href="#2-2-WindowToken中token的作用" class="headerlink" title="2.2 WindowToken中token的作用"></a>2.2 WindowToken中token的作用</h2><p>我们假设添加window的Activity是该应用第一个被resume的activity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WMS.addWindow函数中：</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> attrs.token != <span class="literal">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">token = <span class="keyword">new</span> <span class="title class_">WindowToken</span>(<span class="built_in">this</span>, binder, type, <span class="literal">false</span>, displayContent,</span><br><span class="line">        session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WindowToken.java</span></span><br><span class="line">WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type, <span class="type">boolean</span> persistOnEmpty,</span><br><span class="line">        DisplayContent dc, <span class="type">boolean</span> ownerCanManageAppTokens, <span class="type">boolean</span> roundedCornerOverlay) &#123;</span><br><span class="line">    <span class="built_in">this</span>(service, _token, type, persistOnEmpty, dc, ownerCanManageAppTokens,</span><br><span class="line">            roundedCornerOverlay, <span class="literal">false</span> <span class="comment">/* fromClientToken */</span>, <span class="literal">null</span> <span class="comment">/* options */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WindowToken(WindowManagerService service, IBinder _token, <span class="type">int</span> type, <span class="type">boolean</span> persistOnEmpty,</span><br><span class="line">        DisplayContent dc, <span class="type">boolean</span> ownerCanManageAppTokens, <span class="type">boolean</span> roundedCornerOverlay,</span><br><span class="line">        <span class="type">boolean</span> fromClientToken, <span class="meta">@Nullable</span> Bundle options) &#123;</span><br><span class="line">    <span class="built_in">super</span>(service);</span><br><span class="line">    token = _token;</span><br><span class="line">    windowType = type;</span><br><span class="line">    mOptions = options;</span><br><span class="line">    mPersistOnEmpty = persistOnEmpty;</span><br><span class="line">    mOwnerCanManageAppTokens = ownerCanManageAppTokens;</span><br><span class="line">    mRoundedCornerOverlay = roundedCornerOverlay;</span><br><span class="line">    mFromClientToken = fromClientToken;</span><br><span class="line">    <span class="keyword">if</span> (dc != <span class="literal">null</span>) &#123;</span><br><span class="line">        dc.addWindowToken(token, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从WindowToken的构造函数和其初始化的传参中可以看到，WindowToken中的token就是attrs的token,或者是client(IWindow)转换来的。</p><h3 id="2-2-1-LayoutParams中的token"><a href="#2-2-1-LayoutParams中的token" class="headerlink" title="2.2.1 LayoutParams中的token"></a>2.2.1 LayoutParams中的token</h3><p>溯源addWindow, 在ViewRootImpl.setView时，会将该LayoutParams作为参数传入，注意，有两个LayoutParams，一个是WindowManager.LayoutParams, 一个是其父类ViewGroup.LayoutParams:</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_2.png" alt="1_2"></p><p>而ViewRootImpl.setView也是在 WindowManagerGlobal.addView 时调用的,也就是ActivityThread处理该Activity的Resume状态时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="type">boolean</span> finalStateRequest,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isForward, String reason)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> r.activity;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="literal">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> r.window.getDecorView();</span><br><span class="line">        <span class="comment">// 现将该View设置为不可见</span></span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        <span class="type">ViewManager</span> <span class="variable">wm</span> <span class="operator">=</span> a.getWindowManager();</span><br><span class="line">        <span class="comment">// 从这里拿到的params, 所以token也需要查一下这个LayoutParams</span></span><br><span class="line">        <span class="comment">// 最后可以发现是在PhoneWindow创建时候创建的默认值，token还是null的</span></span><br><span class="line">        WindowManager.<span class="type">LayoutParams</span> <span class="variable">l</span> <span class="operator">=</span> r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        <span class="comment">// 注意这里type表示为应用窗口</span></span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 这里的wm是Activity中保存的WindowManager, 是该Activity被创建</span></span><br><span class="line">                <span class="comment">// 后调用其attach函数创建Window时的WindowManagerImpl,这一部分我</span></span><br><span class="line">                <span class="comment">// 们在Activity的显示(1)中有分析</span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            ......</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可以看出只有当该Activity的window是尚未被添加且此次resume状态时是需要可见的时候，才会将该Activity对应View添加至WindowManager中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowManagerImpl.addView</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    applyTokens(params);</span><br><span class="line">    <span class="comment">// 这里的WMI是在Activity调用attach时通过createLocalWindowManager创建的</span></span><br><span class="line">    <span class="comment">// mParentWindow就是创建该WMI的window,即Activity里的PhoneWindow</span></span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplayNoVerify(), mParentWindow,</span><br><span class="line">            mContext.getUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">applyTokens</span><span class="params">(<span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// Only use the default token if we don&#x27;t have a parent window and a token.</span></span><br><span class="line">    <span class="keyword">if</span> (mDefaultToken != <span class="literal">null</span> &amp;&amp; mParentWindow == <span class="literal">null</span> &amp;&amp; wparams.token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// token在此赋值吗？其实一般不是的，这个mDefaultToken只有AccessibilityService中会设置</span></span><br><span class="line">        <span class="comment">// 所以mDefaultToken还是null的</span></span><br><span class="line">        wparams.token = mDefaultToken;</span><br><span class="line">    &#125;</span><br><span class="line">    wparams.mWindowContextToken = mWindowContextToken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不是在此追踪，但是我们可以发现mGlobal.addView中的LayoutParams仍然是ViewGroup.LayoutParams类型，其并不带有token成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowManagerGlobal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="line"><span class="params">        Display display, Window parentWindow, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 因为WindowManager.LayoutParams是ViewGroup.LayoutParams子类，所以可以强制转换</span></span><br><span class="line">    <span class="comment">// 但是token默认是null的</span></span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="comment">// parentWindow一般不为null,如果是ApplicationType的window，这就是resume的Activity里的PhoneWindow自身</span></span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调整 WindowManager.LayoutParams</span></span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 2.3 创建ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">        ......</span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意每个Activity对应一个PhoneWindow, 一个PhoneWindow对应一个WindowManager(即WindowManagerImpl), 而PhoneWindow继承自Window。PhoneWindow在其对应的Activity被调用attach时创建， 然后会创建WindowManagerImpl，保存在PhoneWindow的mWindowManager成员中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Window.java</span></span><br><span class="line"><span class="comment">// Activity.attach -&gt; PhoneWindow.setWindowManager-&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hardwareAccelerated)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个就是Activity中的 mToken, 对应的是LocalActivityManager.LocalActivityRecord</span></span><br><span class="line">    <span class="comment">// 顺便说一下这个token是在startActivity时创建的</span></span><br><span class="line">    mAppToken = appToken;</span><br><span class="line">    mAppName = appName;</span><br><span class="line">    mHardwareAccelerated = hardwareAccelerated;</span><br><span class="line">    <span class="keyword">if</span> (wm == <span class="literal">null</span>) &#123;</span><br><span class="line">        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ActivityThread.handleResumeActivity-&gt;WindowManagerImpl.addView-&gt;WindowManagerGlobal.addView-&gt;</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">adjustLayoutParamsForSubWindow</span><span class="params">(WindowManager.LayoutParams wp)</span> &#123;</span><br><span class="line">    <span class="type">CharSequence</span> <span class="variable">curTitle</span> <span class="operator">=</span> wp.getTitle();</span><br><span class="line">    <span class="comment">// 在handleResumeActivity我们可以看到这个type被指明为TYPE_BASE_APPLICATION</span></span><br><span class="line">    <span class="keyword">if</span> (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">            wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 到目前为止，token确实是null的</span></span><br><span class="line">        <span class="keyword">if</span> (wp.token == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// mContainer是包含此窗户的容器，没有设置时，DecorWindow将作为顶级窗口</span></span><br><span class="line">            wp.token = mContainer == <span class="literal">null</span> ? mAppToken : mContainer.mAppToken;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般Window的mContainer是null的，所以wp.token就是Window的mAppToken,也即Activity中的mToken, 对应LocalActivityManager.LocalActivityRecord, 通过此变量可以快速找到Activity、ActivityInfo、Window等。所以最后Activity对应的WindowState中对应的WindowToken里的token成员变量就是Activity中的mToken.</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_3.png" alt="1-3"></p><h2 id="2-3-Activity的View与Window的关系"><a href="#2-3-Activity的View与Window的关系" class="headerlink" title="2.3 Activity的View与Window的关系"></a>2.3 Activity的View与Window的关系</h2><p>在应用的一个Activity对象即将resume时，会通过WindowManagerImpl将View与该Activity对应的PhoneWindow关联起来。这部分发生WindowManagerGlobal.addView中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowManagerGlobal.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="line"><span class="params">        Display display, Window parentWindow, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 创建ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">        ......</span><br><span class="line">            root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的View 就是 r.window.getDecorView() 获取的decorView; 而parentWindow就是该Activity首次launch时创建的PhoneWindow（如果没有parent Activity时）</p><p>简单回顾下 PhoneWindow 的 DecorView是怎么来的：</p><ol><li>在Activity被launch后，会调用其onCreate方法</li><li>应用会在这个方法中调用setContentView, 将该Activity对应的View或者layout资源ID传入</li><li>然后在调用该Activity对应PhoneWindow的setContentView方法<ol><li>如果是首次调用，则先调用installDecor方法创建DecorView</li><li>之后通过PhoneWindow中的mLayoutInflater将该View实例化</li><li>最后将该View保存在PhoneWindow的ViewGroup对象mContentParent中</li></ol></li></ol><p>这部分的流程比如installDecor方法我们之后讨论View的生成时再详细分析。所以简单来说，Activity对应的layout视图作为一个子视图保存在这个Activity对应PhoneWindow的DecorView中。</p><h2 id="2-4-IWindowSession-PhoneWindow与WMS的交互"><a href="#2-4-IWindowSession-PhoneWindow与WMS的交互" class="headerlink" title="2.4 IWindowSession - PhoneWindow与WMS的交互"></a>2.4 IWindowSession - PhoneWindow与WMS的交互</h2><p>Activity对应的Window和WMS的交互肯定是双向的，那么:</p><ol><li>Activity对应的PhoneWindow需要保存WMS的client端</li><li>WMS需要保存该PhoneWindow的client端</li></ol><p>毫无疑问，PhoneWindow中保存WMS的client端就是对应的IWindowManager, 保存在WindowManagerGlobal中。而PhoneWindow会用在其对应的ViewRootImpl中继承了IWindow.Stub的W类的对象，通过binder传递到WMS中，作为PhoneWindow在WMS中的client端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewRootImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(context, display, WindowManagerGlobal.getWindowSession(),</span><br><span class="line">            <span class="literal">false</span> <span class="comment">/* useSfChoreographer */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(<span class="meta">@UiContext</span> Context context, Display display, IWindowSession session,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> useSfChoreographer)</span> &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = session;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 创建W对象</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> <span class="title class_">W</span>(<span class="built_in">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">                .......</span><br><span class="line">                res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(), userId,</span><br><span class="line">                        mInsetsController.getRequestedVisibility(), inputChannel, mTempInsets,</span><br><span class="line">                        mTempControls);</span><br><span class="line">                ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_4.png" alt="1-4"></p><p>由此可见，ViewRootImpl发挥这至关重要的作用，其不仅包含Activity对应的View, PhoneWindow及该Window的属性LayoutParams, 还保存着作为WMS中该Activity的Window的服务端W类的对象。</p><p>之前我们略有分析mWindowSession的创建，这里我们直接给出时序图：</p><p><img src="/images/WMS%E7%B3%BB%E5%88%97/1_5.png" alt="1-5"></p><p>之前我们也说过:</p><ol><li>IWindowManager 对应WindowManagerService, 应用进程端通过这个接口即可向WMS传递消息.</li><li>IWindowSession 通过这个Session和WMS中的Session交互.暂时还不理解这个作用</li><li>W extends IWindow 对应应用进程端的窗口, WMS通过这个向应用进程的Window发送消息.</li></ol><p>现在我们分析IWindowSession的方法其实不难理解，IWindowSession是为了方便管理某个应用的某个Window与WMS通信的，虽然最后也是与WMS通信，但是将通信过程也视为一个对象，方便了管理。</p><h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>本文中分析了Android显示框架中Framework层最重要的WMS服务启动过程，以及复习了Activity窗口的创建过程。</p><h2 id="3-1-WMS服务启动"><a href="#3-1-WMS服务启动" class="headerlink" title="3.1 WMS服务启动"></a>3.1 WMS服务启动</h2><ol><li>WMS服务是在引导服务和核心服务启动之后启动的，而且必须等待Sensor服务的启动完毕。</li><li>WMS服务的启动首先初始化了”android.display”线程，然后将启动过程放在此线程中处理，主线程阻塞等待该启动完毕。</li><li>WMS服务的创建过程：<ol><li>创建了WindowAnimator</li><li>创建RootWindowContainer</li><li>创建WindowSurfacePlacer，如其名，用於定位窗口及其表面</li><li>创建TaskSnapshotController，用於获取相应任务的快照(位图)并将其放入缓存</li><li>设置全局阴影等等</li></ol></li><li>WMS服务创建完毕后，通过ServiceManager将其发布，服务名为Context.WINDOW_SERVICE</li></ol><h2 id="3-2-Activity、Window与WindowManagerService"><a href="#3-2-Activity、Window与WindowManagerService" class="headerlink" title="3.2 Activity、Window与WindowManagerService"></a>3.2 Activity、Window与WindowManagerService</h2><ol><li>Activity在第一次启动后，调用attach方法时，会创建PhoneWindow以及对应的WindowManagerImpl</li><li>在Activity第一次resume时，调用该Activity的WindowManagerImpl创建ViewRootImpl<ol><li>在创建ViewRootImpl之前，会通过adjustLayoutParamsForSubWindow将该Activity的mToken保存在PhoneWindow的LayoutParams中</li><li>创建ViewRootImpl过程中，会通过IWindowManager与WMS通信，创建IWindowSession, 用于该Activity的Window和WMS通信</li></ol></li><li>创建ViewRootImpl之后，再通过期间创建的IWindowSession与将该Activity的IWindow、相关Window属性传递给WMS.</li></ol><p>接下来我们看看WMS是怎么管理不同应用的Window的。</p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;
---

&lt;p&gt;&lt;strong&gt;以下分析基于Android S.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;之前我们通过Vsync这个Android绘制的脉搏疏通了绘制的流程，在Activity的显示研究过程中，粗略接触了WindowManagerService，也即Android的窗口管理。&lt;/p&gt;
&lt;p&gt;接下来我们深入探讨一下Android中的窗口管理设计，以便我们理解View、Activity、Window、Task等之间的关系。&lt;/p&gt;
&lt;p&gt;首先还是从WindowManagerService服务的启动开始，在Android开机流程中，我们知道WMS是在引导服务和核心服务启动之后才会开始的:&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/categories/Android/WMS/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="WMS" scheme="https://swallowjoe.github.io/tags/WMS/"/>
    
  </entry>
  
  <entry>
    <title>Binder(5)--binder驱动响应ioctl</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/</id>
    <published>2022-04-04T02:38:44.000Z</published>
    <updated>2022-04-04T02:44:23.947Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，我们现在了解了binder驱动的加载过程，回过头继续分析App使用Binder通信的过程。</p><p>先回顾下App使用binder通信的大致过程：</p><ol><li>创建AIDL文件，定义接口函数并在服务端app中实现,并注册进SystemServer</li><li>客户端app通过SystemServer获取服务端注册的Service所代表的IBinder(BpBinder)<ol><li>Client app &lt;–&gt; SystemServer &lt;–&gt; Server app</li><li>Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。</li></ol></li><li>客户端app通过该IBinder与服务端app直接通信。</li></ol><p>之前我们分析到最后一步是：IPCThreadState#talkWithDriver</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Finished read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面我们也了解了ioctl的用法，简单回顾下:</p><blockquote><p>int ioctl(int fd, unsigned long request, …);</p></blockquote><ol><li>fd 必须是打开文件描述符。</li><li>cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作</li><li>argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。</li></ol><p>这里我们还不知道此处的ioctl是怎么和binder驱动勾搭上的，是因为我们之前分析客户端app使用ioctl的时候忽略了IPCThreadState的初始化。</p><p>传入的参数mProcess-&gt;mDriverFD这个文件描述符是怎么获取的呢，接下来先看IPCThreadState的初始化。</p><h1 id="一-IPCThreadState的初始化"><a href="#一-IPCThreadState的初始化" class="headerlink" title="一. IPCThreadState的初始化"></a>一. IPCThreadState的初始化</h1><p>我们在调用transact的时候，会先调用self()函数，这个函数就是初始化用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br></pre></td></tr></table></figure><h2 id="1-1-IPCThreadState-self"><a href="#1-1-IPCThreadState-self" class="headerlink" title="1.1 IPCThreadState::self"></a>1.1 IPCThreadState::self</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">gHaveTLS</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> gTLS = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; gShutdown = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; gDisableBackgroundScheduling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// gHaveTLS为true说明之前已经初始化过</span></span><br><span class="line">    <span class="comment">// 或者说pthread_key_create有被调用过，及本线程私有数据内存空间已开辟</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">        <span class="comment">// 取得本线程对应关键字gTLS所关联的私有数据空间首址</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="comment">// 如果不为null,直接返回, 当然如果是第一次进入肯定为null的。</span></span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">// 1.2 实例化IPCThreadState</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处于shutdown时直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (gShutdown.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// 创建关键字gTLS及其对应的内存释放函数threadDestructor</span></span><br><span class="line">        <span class="comment">// 关键字关联线程私有数据空间首址，初始化时是NULL</span></span><br><span class="line">        <span class="type">int</span> key_create_value = <span class="built_in">pthread_key_create</span>(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;</span>,</span><br><span class="line">                    <span class="built_in">strerror</span>(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表明线程私有数据内存空间已开辟</span></span><br><span class="line">        gHaveTLS.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="comment">// 回到restart中准备实例化IPCThreadState</span></span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Linux 中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone() 。<br>该系统copy 了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。<br>copy 后的进程和原先的进程共享了所有的变量，运行环境（clone的实现是可以指定新进程与老进程之间的共享关系，100%共享就表示创建了一个线程）。<br>这样，原先进程中的变量变动在copy 后的进程中便能体现出来。</p></blockquote><h2 id="1-2-IPCThreadState实例化"><a href="#1-2-IPCThreadState实例化" class="headerlink" title="1.2 IPCThreadState实例化"></a>1.2 IPCThreadState实例化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">    <span class="comment">// 1.2.1 创建ProcessState</span></span><br><span class="line">    : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),</span><br><span class="line">      <span class="built_in">mServingStackPointer</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">mWorkSource</span>(kUnsetWorkSource),</span><br><span class="line">      <span class="built_in">mPropagateWorkSource</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mStrictModePolicy</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLastTransactionBinderFlags</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mCallRestriction</span>(mProcess-&gt;mCallRestriction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自身存入关键字gTLS对应的线程私有数据空间中，缓存以备后续使用</span></span><br><span class="line">    <span class="built_in">pthread_setspecific</span>(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">clearCaller</span>();</span><br><span class="line">    mIn.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">    mOut.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-３-ProcessState-self"><a href="#1-３-ProcessState-self" class="headerlink" title="1.３ ProcessState::self"></a>1.３ ProcessState::self</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ANDROID_VNDK__</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* kDefaultDriver = <span class="string">&quot;/dev/vndbinder&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* kDefaultDriver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里假定kDefaultDriver为&quot;/dev/binder&quot;</span></span><br><span class="line">    gProcess = <span class="keyword">new</span> <span class="built_in">ProcessState</span>(kDefaultDriver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-４-ProcessState实例化"><a href="#1-４-ProcessState实例化" class="headerlink" title="1.４ ProcessState实例化"></a>1.４ ProcessState实例化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    <span class="comment">// 1.5 打开binder驱动，获取其文件描述符</span></span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))</span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mCallRestriction</span>(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-open-driver-打开binder驱动"><a href="#1-5-open-driver-打开binder驱动" class="headerlink" title="1.5 open_driver - 打开binder驱动"></a>1.5 open_driver - 打开binder驱动</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.5.1 打开/dev/binder驱动</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.5.2 ioctl通信!!!</span></span><br><span class="line">        <span class="type">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// #define DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line">        <span class="comment">// 默认最大binder线程数目是15个</span></span><br><span class="line">        <span class="type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">// 1.5.2 ioctl通信，设置当前进程的最大binder线程数为15</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先使用open函数打开对应目录的驱动文件，成功打开后调用ioctl函数获取Binder版本，最后还是通过ioctl设置最大binder线程。</p><p>我们常听闻在Linux中，一切皆文件，这里就体现出来了。回顾下binder驱动注册进文件系统时的操作函数集:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android/kernel/msm-4.19/drivers/android/binder.c</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> binder_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.poll = binder_poll,</span><br><span class="line">.unlocked_ioctl = binder_ioctl,</span><br><span class="line">.compat_ioctl = binder_ioctl,</span><br><span class="line">.mmap = binder_mmap,</span><br><span class="line">.open = binder_open,</span><br><span class="line">.flush = binder_flush,</span><br><span class="line">.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-5-1-open函数-binder-open"><a href="#1-5-1-open函数-binder-open" class="headerlink" title="1.5.1 open函数-binder_open"></a>1.5.1 open函数-binder_open</h3><p>在app进程中通过open函数打开&#x2F;dev&#x2F;binder文件，就会调用到binder.c中的binder_open函数了。</p><p>我们来看看这个open的时候驱动里面具体做了什么吧，至于用户进程中调用open进而使用系统调用进入内核态调用到binder_open的方式我们后续分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// binder_proc代表一个进程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_device</span> *binder_dev;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *binder_binderfs_dir_entry_proc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">binder_debug</span>(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;%s: %d:%d\n&quot;</span>, __func__,</span><br><span class="line">     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    <span class="comment">// 给binder_proc分配内核内存</span></span><br><span class="line">proc = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">// 初始化自旋锁lock,其实是将自旋锁指针lock 指向SPIN_LOCK_UNLOCKED宏</span></span><br><span class="line">    <span class="comment">// 该宏的定义在内核文件spinlock_types.h中，它表示自旋锁的状态为未加锁</span></span><br><span class="line"><span class="built_in">spin_lock_init</span>(&amp;proc-&gt;inner_lock);</span><br><span class="line"><span class="built_in">spin_lock_init</span>(&amp;proc-&gt;outer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current是一个内核宏，它是当前进程的指针</span></span><br><span class="line">    <span class="comment">// get_task_struct的最终实现是将传入的task_struct的usage加1:</span></span><br><span class="line">    <span class="comment">//  #define get_task_struct(tsk) do &#123; atomic_inc(&amp;(tsk)-&gt;usage); &#125; while(0)</span></span><br><span class="line">    <span class="comment">// 这个宏的作用是标记传入的task_struct，当期有人在用。</span></span><br><span class="line">    <span class="comment">// usage的数量代表正在使用该task_struct的程序数量。</span></span><br><span class="line"><span class="built_in">get_task_struct</span>(current-&gt;group_leader);</span><br><span class="line">    <span class="comment">// 将binder_proc的tsk标记为当前进程的主进程</span></span><br><span class="line">proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    <span class="comment">// 加上互斥锁</span></span><br><span class="line"><span class="built_in">mutex_init</span>(&amp;proc-&gt;files_lock);</span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;todo);</span><br><span class="line">    <span class="comment">// 确定进程调度策略</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binder_supported_policy</span>(current-&gt;policy)) &#123;</span><br><span class="line">proc-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">proc-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">proc-&gt;default_priority.sched_policy = SCHED_NORMAL;</span><br><span class="line">proc-&gt;default_priority.prio = <span class="built_in">NICE_TO_PRIO</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断nodp是否是binder_device:</span></span><br><span class="line">    <span class="comment">//  inode-&gt;i_sb-&gt;s_magic == BINDERFS_SUPER_MAGIC</span></span><br><span class="line">    <span class="comment">// s_magic是在binderfs_fill_super也就是binder驱动挂载时赋值的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_binderfs_device</span>(nodp)) &#123;</span><br><span class="line">        <span class="comment">// 如果是binder_device:</span></span><br><span class="line">        <span class="comment">// 回忆下上一篇文章3.4 binderfs.c#binderfs_binder_device_create</span></span><br><span class="line">        <span class="comment">// 我们将创建的binder_device存入了i_private数据中</span></span><br><span class="line">binder_dev = nodp-&gt;i_private;</span><br><span class="line">info = nodp-&gt;i_sb-&gt;s_fs_info;</span><br><span class="line">binder_binderfs_dir_entry_proc = info-&gt;proc_log_dir;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">binder_dev = <span class="built_in">container_of</span>(filp-&gt;private_data,</span><br><span class="line">  <span class="keyword">struct</span> binder_device, miscdev);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 标记binder_device的引用计数+1</span></span><br><span class="line"><span class="built_in">refcount_inc</span>(&amp;binder_dev-&gt;ref);</span><br><span class="line">    <span class="comment">// binder_proc的上下文</span></span><br><span class="line">proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line"><span class="built_in">binder_alloc_init</span>(&amp;proc-&gt;alloc);</span><br><span class="line">    <span class="comment">// binder_stats中BINDER_STAT_PROC类型的创建数加+1</span></span><br><span class="line"><span class="built_in">binder_stats_created</span>(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">// binder_proc的pid为当前进程的主进程的pid</span></span><br><span class="line">proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;delivered_death);</span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;waiting_threads);</span><br><span class="line">filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mutex_lock</span>(&amp;binder_procs_lock);</span><br><span class="line">    <span class="comment">// 将当前binder_proc的proc_node加入binder_procs列表中</span></span><br><span class="line">    <span class="comment">// binder_procs是binder驱动中存储一系列binder_proc的链表</span></span><br><span class="line">    <span class="comment">// 关于binder_proc是如何插入链表中的，我们后续分析，涉及‘传说中’的红黑树操作</span></span><br><span class="line">    <span class="comment">// 注意当前虽然是在应用进程中，但此时已经进入内核态了。</span></span><br><span class="line"><span class="built_in">hlist_add_head</span>(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line"><span class="built_in">mutex_unlock</span>(&amp;binder_procs_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sys/kernel/debug/binder/proc目录存在时</span></span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line"><span class="type">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(strbuf, <span class="built_in">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line"><span class="comment">// proc调试条目是在上下文之间共享的</span></span><br><span class="line">        <span class="comment">// 创建当前binder_proc的目录，可以看到在sys/kernel/debug/binder/proc目录下有很多pid的目录</span></span><br><span class="line">proc-&gt;debugfs_entry = <span class="built_in">debugfs_create_file</span>(strbuf, <span class="number">0444</span>,</span><br><span class="line">binder_debugfs_dir_entry_proc,</span><br><span class="line">(<span class="type">void</span> *)(<span class="type">unsigned</span> <span class="type">long</span>)proc-&gt;pid,</span><br><span class="line">&amp;proc_fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是binderfs_fill_super中创建的一个目录：/dev/binderfs/binder_logs/proc</span></span><br><span class="line"><span class="keyword">if</span> (binder_binderfs_dir_entry_proc) &#123;</span><br><span class="line"><span class="type">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *binderfs_entry;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(strbuf, <span class="built_in">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line"><span class="comment">// 与debugfs类似，进程特定的日志文件在上下文之间共享。</span></span><br><span class="line">        <span class="comment">// 如果已经为进程创建了文件，如果同一进程的另一个上下文调用binder_open（）</span></span><br><span class="line">        <span class="comment">// 则以下binderfs_create_file（）调用将失败，错误代码为EEXIST。</span></span><br><span class="line">        <span class="comment">// 因为与debugfs相同，日志文件将包含给定PID的所有上下文的信息。</span></span><br><span class="line">binderfs_entry = <span class="built_in">binderfs_create_file</span>(binder_binderfs_dir_entry_proc,</span><br><span class="line">strbuf, &amp;proc_fops, (<span class="type">void</span> *)(<span class="type">unsigned</span> <span class="type">long</span>)proc-&gt;pid);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(binderfs_entry)) &#123;</span><br><span class="line">proc-&gt;binderfs_entry = binderfs_entry;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = <span class="built_in">PTR_ERR</span>(binderfs_entry);</span><br><span class="line"><span class="keyword">if</span> (error != -EEXIST) &#123;</span><br><span class="line"><span class="built_in">pr_warn</span>(<span class="string">&quot;Unable to create file %s in binderfs (error %d)\n&quot;</span>,</span><br><span class="line">strbuf, error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_open的函数做的事情也不复杂：</p><ol><li>创建binder_proc, 其pid为当前进程的主进程pid</li><li>标记binder_device的引用计数+1</li><li>将当前binder_proc的proc_node加入binder_procs列表中</li><li>创建当前binder_proc的目录，目录名为: sys&#x2F;kernel&#x2F;debug&#x2F;binder&#x2F;proc&#x2F;pid</li><li>&#x2F;dev&#x2F;binderfs&#x2F;binder_logs&#x2F;proc存在时，也在这个目录下创建对应pid目录</li></ol><p>顺便说一下很多Linux内核宏都用 do { code; } while(0) 的形式,这个是确保code不会被打乱，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> demo do &#123; codeA; codeB; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (A) </span><br><span class="line"> demo; <span class="comment">//这里展开就不会因为宏内有多行代码而出现逻辑异常</span></span><br><span class="line">nextCodeLine;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-binder-ioctl-BINDER-VERSION-amp-BINDER-SET-CONTEXT-MGR-EXT"><a href="#1-5-2-binder-ioctl-BINDER-VERSION-amp-BINDER-SET-CONTEXT-MGR-EXT" class="headerlink" title="1.5.2 binder_ioctl - BINDER_VERSION &amp; BINDER_SET_CONTEXT_MGR_EXT"></a>1.5.2 binder_ioctl - BINDER_VERSION &amp; BINDER_SET_CONTEXT_MGR_EXT</h3><blockquote><p>status_t result &#x3D; ioctl(fd, BINDER_VERSION, &amp;vers);</p></blockquote><p>从参数名称可以看到，这里是获取binder版本号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_thread</span> *thread;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line"><span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*pr_info(&quot;binder_ioctl: %d:%d %x %lx\n&quot;,</span></span><br><span class="line"><span class="comment">proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配BUFFER_NUM buffers以覆盖所有页面对齐情况，然后以所有可能的顺序释放它们。</span></span><br><span class="line">    <span class="comment">// 检查页面是否正确分配，在释放缓冲区时放在lru上，在调用binder_alloc_free_page时释放。</span></span><br><span class="line"><span class="built_in">binder_selftest_alloc</span>(&amp;proc-&gt;alloc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">trace_binder_ioctl</span>(cmd, arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_stop_on_user_error是一个int变量，当出现binder_stop_on_user_error错误</span></span><br><span class="line">    <span class="comment">// 时为2, 这里的意思是只要这个不为2,使得cpu不休眠。</span></span><br><span class="line">ret = <span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据binder_proc获取binder_thread, 后续分析</span></span><br><span class="line">thread = <span class="built_in">binder_get_thread</span>(proc);</span><br><span class="line"><span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> fbo;</span><br><span class="line">        <span class="comment">// 从用户空间拷贝ubuf内容至fbo中，其实就是15，单个进程的最大binder线程数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;fbo, ubuf, <span class="built_in">sizeof</span>(fbo))) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 设置单个进程的最大binder数目，默认是15个(app进程)</span></span><br><span class="line">ret = <span class="built_in">binder_ioctl_set_ctx_mgr</span>(filp, &amp;fbo);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_version</span> __user *ver = ubuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_version)) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 从内核空间获取BINDER_CURRENT_PROTOCOL_VERSION拷贝到用户空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">put_user</span>(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_from_user函数的目的是从用户空间拷贝数据到内核空间，<strong>失败返回没有被拷贝的字节数，成功返回0</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(void *to, const void __user *from, unsigned long n)</span><br><span class="line">1. *to         将数据拷贝到内核的地址</span><br><span class="line">2. *from       需要拷贝数据的地址</span><br><span class="line">3. n           拷贝数据的长度（字节）</span><br><span class="line"></span><br><span class="line">也就是将from地址中的数据拷贝到to地址中去，拷贝长度是n</span><br></pre></td></tr></table></figure><h1 id="二-ioctl-BINDER-WRITE-READ"><a href="#二-ioctl-BINDER-WRITE-READ" class="headerlink" title="二. ioctl - BINDER_WRITE_READ"></a>二. ioctl - BINDER_WRITE_READ</h1><p>现在万事具备了，我们继续分析进程间的ioctl通信传输数据, 回到最开始：IPCThreadState#talkWithDriver</p><p>其实我们在open_driver - 打开binder驱动的过程中就有分析看到ioctl了。</p><p>从代码的角度理解为什么说binder跨进程通信只需要一次内存拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">    err = NO_ERROR;</span><br></pre></td></tr></table></figure><h2 id="2-1-binder-ioctl-BINDER-WRITE-READ"><a href="#2-1-binder-ioctl-BINDER-WRITE-READ" class="headerlink" title="2.1 binder_ioctl - BINDER_WRITE_READ"></a>2.1 binder_ioctl - BINDER_WRITE_READ</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        <span class="comment">// thread是根据binder_proc获取的binder_thread</span></span><br><span class="line">        <span class="comment">// 这里的arg就是上面的ioctl的最后一个参数bwr的地址</span></span><br><span class="line">ret = <span class="built_in">binder_ioctl_write_read</span>(filp, cmd, arg, thread);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"><span class="keyword">if</span> (thread)</span><br><span class="line">thread-&gt;looper_need_return = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line"><span class="built_in">pr_info</span>(<span class="string">&quot;%d:%d ioctl %x %lx returned %d\n&quot;</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line"><span class="built_in">trace_binder_ioctl_done</span>(ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-binder-c-binder-ioctl-write-read"><a href="#2-2-binder-c-binder-ioctl-write-read" class="headerlink" title="2.2 binder.c:binder_ioctl_write_read"></a>2.2 binder.c:binder_ioctl_write_read</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line"><span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 从用户空间拷贝ubuf内容至bwr中, 一次拷贝：从用户空间到内核空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">     <span class="string">&quot;%d:%d write %lld at %016llx, read %lld at %016llx\n&quot;</span>,</span><br><span class="line">     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">     (u64)bwr.write_size, (u64)bwr.write_buffer,</span><br><span class="line">     (u64)bwr.read_size, (u64)bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还记得么，这个bwr是在IPCThreadState#talkWithDriver中填充的数据</span></span><br><span class="line">    <span class="comment">// write_size 代表 binder in parcel数据大小</span></span><br><span class="line">    <span class="comment">// read_size 代表 binder out parcel数据大小</span></span><br><span class="line"><span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理用户进程传来的数据</span></span><br><span class="line">ret = <span class="built_in">binder_thread_write</span>(proc, thread,</span><br><span class="line">  bwr.write_buffer,</span><br><span class="line">  bwr.write_size,</span><br><span class="line">  &amp;bwr.write_consumed);</span><br><span class="line"><span class="built_in">trace_binder_write_done</span>(ret);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理需要回传的数据</span></span><br><span class="line">ret = <span class="built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer,</span><br><span class="line"> bwr.read_size,</span><br><span class="line"> &amp;bwr.read_consumed,</span><br><span class="line"> filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line"><span class="built_in">trace_binder_read_done</span>(ret);</span><br><span class="line"><span class="built_in">binder_inner_proc_lock</span>(proc);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))</span><br><span class="line"><span class="built_in">binder_wakeup_proc_ilocked</span>(proc);</span><br><span class="line"><span class="built_in">binder_inner_proc_unlock</span>(proc);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">     <span class="string">&quot;%d:%d wrote %lld of %lld, read return %lld of %lld\n&quot;</span>,</span><br><span class="line">     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">     (u64)bwr.write_consumed, (u64)bwr.write_size,</span><br><span class="line">     (u64)bwr.read_consumed, (u64)bwr.read_size);</span><br><span class="line">    <span class="comment">// 将从内核空间拷贝bwr内容至ubuf中, 一次拷贝：从内核空间到用户空间</span></span><br><span class="line">    <span class="comment">// 但是这里是新的数据了，不算是内容的重复拷贝，如果说不需要回传数据，oneway的方式，这个拷贝也不是必要的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_from_user函数的目的是从内核空间拷贝数据到用户空间，失败返回没有被拷贝的字节数，成功返回0.</p><p>unsigned long copy_to_user(void *to, const void *from, unsigned long n)</p><ol><li>*to            目标地址（用户空间）</li><li>*from          源地址（内核空间）</li><li>n              将要拷贝数据的字节数</li></ol><p>返回：成功返回0，失败返回没有拷贝成功的数据字节数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到用户进程IPCThreadState的初始化之后会将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。<br>这里就拿到了binder的fd, 保存在用户进程的mDriverFD中, 现在就可以愉快的通信了。</p><p>鉴于 binder_thread_write 和 binder_thread_read 函数都特别大，接下来单开两篇分开论述。</p><p>之前看 <strong>红茶一杯话Binder（传输机制篇_中）</strong> 有一张图特别清晰的展现了这里的流程，在此贴出:</p><p><img src="/images/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/5_1_%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="图片"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>module_init解析及内核initcall的初始化顺序 <a href="https://www.cnblogs.com/chaozhu/p/6410271.html">https://www.cnblogs.com/chaozhu/p/6410271.html</a></li><li>各种initcall的执行先后顺序 <a href="https://blog.csdn.net/fenzhikeji/article/details/6860143">https://blog.csdn.net/fenzhikeji/article/details/6860143</a></li><li>binder 驱动的操作 <a href="https://blog.csdn.net/qq_15893929/article/details/103965668">https://blog.csdn.net/qq_15893929/article/details/103965668</a></li><li>Android的IPC机制Binder的各个部分 <a href="http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml">http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml</a></li><li>字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 <a href="https://blog.csdn.net/weixin_42314225/article/details/81112217">https://blog.csdn.net/weixin_42314225/article/details/81112217</a></li><li>linux文件系统 - 初始化(一) <a href="https://www.cnblogs.com/alantu2018/p/8447303.html">https://www.cnblogs.com/alantu2018/p/8447303.html</a></li><li>mount过程分析之五(mount_bdev-&gt;fill_super) <a href="https://blog.csdn.net/ZR_Lang/article/details/40115013">https://blog.csdn.net/ZR_Lang/article/details/40115013</a></li><li>VFS四大对象之一 struct super_block <a href="https://www.cnblogs.com/linhaostudy/p/7427027.html">https://www.cnblogs.com/linhaostudy/p/7427027.html</a></li><li>Linux字符设备驱动file_operations <a href="https://www.cnblogs.com/chen-farsight/p/6181341.html">https://www.cnblogs.com/chen-farsight/p/6181341.html</a></li><li>一种linux线程私有数据技术 <a href="http://blog.163.com/william_djj@126/blog/static/3516650120085111193035/">http://blog.163.com/william_djj@126/blog/static/3516650120085111193035/</a></li><li>pthread_key_t和pthread_key_create()详解 <a href="https://www.cnblogs.com/klcf0220/p/5807148.html">https://www.cnblogs.com/klcf0220/p/5807148.html</a></li><li>腾讯面试题——谈一谈Binder的原理和实现一次拷贝的流程 <a href="https://blog.csdn.net/AndroidStudyDay/article/details/93749470">https://blog.csdn.net/AndroidStudyDay/article/details/93749470</a></li><li>红茶一杯话Binder（传输机制篇_中） <a href="https://my.oschina.net/youranhongcha/blog/152963">https://my.oschina.net/youranhongcha/blog/152963</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，我们现在了解了binder驱动的加载过程，回过头继续分析App使用Binder通信的过程。&lt;/p&gt;
&lt;p&gt;先回顾下App使用binder通信的大致过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建AIDL文件，定义接口函数并在服务端app中实现,并注册进SystemServer&lt;/li&gt;
&lt;li&gt;客户端app通过SystemServer获取服务端注册的Service所代表的IBinder(BpBinder)&lt;ol&gt;
&lt;li&gt;Client app &amp;lt;–&amp;gt; SystemServer &amp;lt;–&amp;gt; Server app&lt;/li&gt;
&lt;li&gt;Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;客户端app通过该IBinder与服务端app直接通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前我们分析到最后一步是：IPCThreadState#talkWithDriver&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(4)--binder驱动的加载</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-4-binder%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-4-binder%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-04-04T02:38:31.000Z</published>
    <updated>2022-04-04T02:43:26.817Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，想要了解binder驱动的工作原理，我们从binder驱动加载过程开始：</p><p>在android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c中，我们可以看到有这么一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure><p>在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它的initcall 的level为6。</p><p>他可以将驱动设备加载进内核中，以供后续使用。</p><span id="more"></span><h1 id="一-Linux内核init-call过程"><a href="#一-Linux内核init-call过程" class="headerlink" title="一. Linux内核init call过程"></a>一. Linux内核init call过程</h1><p>在<a href="https://blog.csdn.net/u014535072/article/details/82936972">Android开机流程(一)</a>一文中有阐述Android开机过程。</p><p>我们知道系统加电自检后，引导程序执行完毕，内核映像被加载到内存并获得控制权之后，会启动kernel_init。</p><h2 id="1-1-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c"><a href="#1-1-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c" class="headerlink" title="1.1 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c"></a>1.1 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 初始化kernel参数</span></span><br><span class="line"><span class="built_in">kernel_init_freeable</span>()</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-kernel-init-freeable"><a href="#1-2-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-kernel-init-freeable" class="headerlink" title="1.2 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:kernel_init_freeable"></a>1.2 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:kernel_init_freeable</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> noinline <span class="type">void</span> __init <span class="title">kernel_init_freeable</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="built_in">do_basic_setup</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_basic_setup</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 调用各种initcall</span></span><br><span class="line"><span class="built_in">do_initcalls</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_initcalls</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> level;</span><br><span class="line">    <span class="comment">// initcall_levels 的大小是9，所以这里level是从0到7的</span></span><br><span class="line"><span class="keyword">for</span> (level = <span class="number">0</span>; level &lt; <span class="built_in">ARRAY_SIZE</span>(initcall_levels) - <span class="number">1</span>; level++)</span><br><span class="line"><span class="built_in">do_initcall_level</span>(level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-do-initcall-level"><a href="#1-3-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-do-initcall-level" class="headerlink" title="1.3 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:do_initcall_level"></a>1.3 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:do_initcall_level</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keep these in sync with initcalls in include/linux/init.h */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *initcall_level_names[] __initdata = &#123;</span><br><span class="line"><span class="string">&quot;pure&quot;</span>,</span><br><span class="line"><span class="string">&quot;core&quot;</span>,</span><br><span class="line"><span class="string">&quot;postcore&quot;</span>,</span><br><span class="line"><span class="string">&quot;arch&quot;</span>,</span><br><span class="line"><span class="string">&quot;subsys&quot;</span>,</span><br><span class="line"><span class="string">&quot;fs&quot;</span>,</span><br><span class="line"><span class="string">&quot;device&quot;</span>,</span><br><span class="line"><span class="string">&quot;late&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_initcall_level</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 按顺序执行initcall_levels，其实就是initcall_level_names中的顺序。</span></span><br><span class="line"><span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line"><span class="built_in">do_one_initcall</span>(<span class="built_in">initcall_from_entry</span>(fn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实Andorid开机过程中的init.rc中各种init进程和这里类似。</p><h1 id="二-binder驱动的初始化"><a href="#二-binder驱动的初始化" class="headerlink" title="二. binder驱动的初始化"></a>二. binder驱动的初始化</h1><p>在了解Linux内核各种init call之后, 我们注意到binder.c最后几行代码中有这么一行:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">device_initcall</span>(binder_init);</span><br></pre></td></tr></table></figure><p>而在android&#x2F;kernel&#x2F;msm-4.9&#x2F;include&#x2F;linux&#x2F;init.h中可以看到定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pure_initcall(fn)__define_initcall(fn, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall(fn)__define_initcall(fn, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall_sync(fn)__define_initcall(fn, 1s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall(fn)__define_initcall(fn, 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall_sync(fn)__define_initcall(fn, 2s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall(fn)__define_initcall(fn, 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall_sync(fn)__define_initcall(fn, 3s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall(fn)__define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall_sync(fn)__define_initcall(fn, 4s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall(fn)__define_initcall(fn, 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall_sync(fn)__define_initcall(fn, 5s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rootfs_initcall(fn)__define_initcall(fn, rootfs)</span></span><br><span class="line"><span class="comment">// HERE!!!</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall(fn)__define_initcall(fn, 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall_sync(fn)__define_initcall(fn, 6s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall(fn)__define_initcall(fn, 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall_sync(fn)__define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure><p>所以binder驱动的加载时机是先于Android的init进程的，在Linux内核启动中是以level为6（device）的优先级加载的。</p><h2 id="2-1-binder-c-binder-init"><a href="#2-1-binder-c-binder-init" class="headerlink" title="2.1 binder.c:binder_init"></a>2.1 binder.c:binder_init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">char</span> *device_name, *device_tmp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_device</span> *device;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hlist_node</span> *tmp;</span><br><span class="line"><span class="type">char</span> *device_names = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化binder缓冲区,其实就是一个list_lru结构体:binder_alloc_lru</span></span><br><span class="line">ret = <span class="built_in">binder_alloc_shrinker_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建binder相关文件</span></span><br><span class="line">    <span class="comment">// 在sys/kernel/debug目录下，创建binder目录　- debugfs是一种用户内核调试的虚拟文件系统</span></span><br><span class="line">binder_debugfs_dir_entry_root = <span class="built_in">debugfs_create_dir</span>(<span class="string">&quot;binder&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建sys/kernel/debug/binder/proc目录</span></span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">binder_debugfs_dir_entry_proc = <span class="built_in">debugfs_create_dir</span>(<span class="string">&quot;proc&quot;</span>,</span><br><span class="line"> binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建其余文件</span></span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;state&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="comment">// 2.1.1 操作函数的定义</span></span><br><span class="line">    &amp;binder_state_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;stats&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;binder_stats_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;transactions&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;binder_transactions_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;transaction_log&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    &amp;binder_transaction_log,</span><br><span class="line">    &amp;binder_transaction_log_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;failed_transaction_log&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    &amp;binder_transaction_log_failed,</span><br><span class="line">    &amp;binder_transaction_log_fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CONFIG_ANDROID_BINDERFS是编译配置,一般都是定义的，所以这个分支不进入</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_ENABLED</span>(CONFIG_ANDROID_BINDERFS) &amp;&amp;</span><br><span class="line">    <span class="built_in">strcmp</span>(binder_devices_param, <span class="string">&quot;&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 初始化binder文件系统</span></span><br><span class="line">ret = <span class="built_in">init_binderfs</span>();</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是创建了sys&#x2F;kernel&#x2F;debug&#x2F;binder目录，以及其子目录或文件:</p><ol><li>proc:记录调用Binder各个进程的内容</li><li>state:记录状态信息，操作函数binder_state_fops</li><li>stats:记录统计信息，操作函数binder_stats_fops</li><li>transactions:记录transaction相关信息，操作函数binder_transactions_fops</li><li>transaction_log:记录transaction日志，操作函数binder_transaction_log_fops</li><li>failed_transaction_log:记录失败的transaction日志信息，操作函数binder_transaction_log_fops</li></ol><p>这里比较奇怪的是没有找到创建文件(目录)时的操作函数的定义,比如binder_state_fops。</p><h3 id="2-1-1-操作函数的定义"><a href="#2-1-1-操作函数的定义" class="headerlink" title="2.1.1 操作函数的定义"></a>2.1.1 操作函数的定义</h3><p>以binder_state_fops为例，其实这些函数的定义是通过宏定义统一实现的。</p><p>在文件android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h中我们可以看到有如下函数的声明:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_stats_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_stats);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_state_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_state);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_transactions_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_transactions);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_transaction_log_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_transaction_log);</span><br></pre></td></tr></table></figure><p>我们看binder_state_show这个函数下面的DEFINE_SHOW_ATTRIBUTE这个宏。</p><h3 id="2-1-2-DEFINE-SHOW-ATTRIBUTE"><a href="#2-1-2-DEFINE-SHOW-ATTRIBUTE" class="headerlink" title="2.1.2 DEFINE_SHOW_ATTRIBUTE"></a>2.1.2 DEFINE_SHOW_ATTRIBUTE</h3><p>这个宏的申明是在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;include&#x2F;linux&#x2F;seq_file.h#148</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SHOW_ATTRIBUTE(__name)\</span></span><br><span class="line"><span class="meta">static int __name ## _open(struct inode *inode, struct file *file)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">return single_open(file, __name ## _show, inode-&gt;i_private);\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">static const struct file_operations __name ## _fops = &#123;\</span></span><br><span class="line"><span class="meta">.owner= THIS_MODULE,\</span></span><br><span class="line"><span class="meta">.open= __name ## _open,\</span></span><br><span class="line"><span class="meta">.read= seq_read,\</span></span><br><span class="line"><span class="meta">.llseek= seq_lseek,\</span></span><br><span class="line"><span class="meta">.release= single_release,\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>把这个宏展开就是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __name_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> single_open(file, __name_show, inode-&gt;i_private);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> __<span class="title">name_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open= __name_open,</span><br><span class="line">.read= seq_read,</span><br><span class="line">.llseek= seq_lseek,</span><br><span class="line">.release= single_release,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当声明函数binder_state_show时，也就通过DEFINE_SHOW_ATTRIBUTE(binder_state)申明了：</p><ol><li>函数:   binder_state_open</li><li>结构体: binder_state_fops</li></ol><h2 id="2-2-init-binderfs-初始化binder文件系统"><a href="#2-2-init-binderfs-初始化binder文件系统" class="headerlink" title="2.2 init_binderfs 初始化binder文件系统"></a>2.2 init_binderfs 初始化binder文件系统</h2><p>在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h#init_binderfs</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ANDROID_BINDERFS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __init <span class="title function_">init_binderfs</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __init <span class="title function_">init_binderfs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里的CONFIG_ANDROID_BINDERFS就对应内核编译时的配置:android-base.config#20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_ANDROID_BINDERFS=y</span><br></pre></td></tr></table></figure><p>y就是定义该宏。</p><p>这里是引用了外部文件的函数: init_binderfs, 在该头文件的同目录下的文件binderfs.c可以找到对应函数实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __init <span class="title">init_binderfs</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_devices_param是定义在binder.c文件中的：</span></span><br><span class="line">    <span class="comment">//  char *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES;</span></span><br><span class="line">    <span class="comment">// 而CONFIG_ANDROID_BINDER_DEVICES 是编译配置: </span></span><br><span class="line">    <span class="comment">//  CONFIG_ANDROID_BINDER_DEVICES=&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line"><span class="comment">// 所以这里的name就是&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line">    name = binder_devices_param;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证默认的binderfs设备名是否合法有效</span></span><br><span class="line">    <span class="comment">// 检验的方式是判断名字中是否含有字符&#x27;,&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>); len &gt; <span class="number">0</span>; len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// BINDERFS_MAX_NAME = 255</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; BINDERFS_MAX_NAME)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line">name += len;</span><br><span class="line"><span class="keyword">if</span> (*name == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">name++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配binder设备编号</span></span><br><span class="line">ret = <span class="built_in">alloc_chrdev_region</span>(&amp;binderfs_dev, <span class="number">0</span>, BINDERFS_MAX_MINOR,</span><br><span class="line">  <span class="string">&quot;binder&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2.1 注册binder文件系统</span></span><br><span class="line">ret = <span class="built_in">register_filesystem</span>(&amp;binder_fs_type);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">unregister_chrdev_region</span>(binderfs_dev, BINDERFS_MAX_MINOR);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_system_type</span> binder_fs_type = &#123;</span><br><span class="line">.name= <span class="string">&quot;binder&quot;</span>,</span><br><span class="line">.mount= binderfs_mount,</span><br><span class="line">.kill_sb= binderfs_kill_super,</span><br><span class="line">.fs_flags= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化binder文件系统，三件事：</p><ol><li>验证binder_devices_param也就是编译配置文件中的：CONFIG_ANDROID_BINDER_DEVICES是否合法</li><li>分配binder设备编号</li><li>注册binder文件系统</li></ol><p>在这一步之后我们就可以通过　cat proc&#x2F;devices 查到binder驱动对应的设备号了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SS9805:/ # cat proc/devices</span><br><span class="line">Character devices:</span><br><span class="line">......</span><br><span class="line">488 binder</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>比如这次我们机器中binder驱动的设备号为488，而且还可以看到这里是注册成字符设备的。</p><blockquote><p>Linux 中的设备有2种类型：字符设备(无缓冲且只能顺序存取)、块设备(有缓冲且可以随机存取)。</p></blockquote><p>在Linux下，一切皆文件，设备也不例外，为了管理这些设备，系统为它们各自都编了号，而每个设备号又分为主设备号和次设备号。主设备号用来区分不同类型的设备，而次设备号用来区分同一类型内的多个设备（及其设备分区）。</p><h3 id="2-2-1-register-filesystem"><a href="#2-2-1-register-filesystem" class="headerlink" title="2.2.1 register_filesystem"></a>2.2.1 register_filesystem</h3><p>定义在android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;filesystems.c中:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_system_type</span> ** p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BUG_ON</span>(<span class="built_in">strchr</span>(fs-&gt;name, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"><span class="keyword">if</span> (fs-&gt;next)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="built_in">write_lock</span>(&amp;file_systems_lock);</span><br><span class="line">    <span class="comment">// 在file_systems链表中找到合适位置，插入</span></span><br><span class="line">p = <span class="built_in">find_filesystem</span>(fs-&gt;name, <span class="built_in">strlen</span>(fs-&gt;name));</span><br><span class="line"><span class="comment">// 如果不为空，说明已经注册过了，不能重复注册</span></span><br><span class="line">    <span class="keyword">if</span> (*p)</span><br><span class="line">res = -EBUSY;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*p = fs;</span><br><span class="line"><span class="built_in">write_unlock</span>(&amp;file_systems_lock);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(register_filesystem);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_system_type</span> **<span class="built_in">find_filesystem</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_system_type</span> **p;</span><br><span class="line"><span class="keyword">for</span> (p = &amp;file_systems; *p; p = &amp;(*p)-&gt;next)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>((*p)-&gt;name, name, len) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    !(*p)-&gt;name[len])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是将传入的fs插入file_systems链表的末尾，且不能重复注册。</p><h1 id="三-binder设备创建及挂载－debugfs挂载"><a href="#三-binder设备创建及挂载－debugfs挂载" class="headerlink" title="三.binder设备创建及挂载－debugfs挂载"></a>三.binder设备创建及挂载－debugfs挂载</h1><p>上面的步骤我们分析了binder驱动的初始化，最后会注册binder文件系统。这一过程都是在kernel初始化的device_initcall中完成的。</p><p>当kernel启动到一定程度，将文件系统挂载后，自然binder驱动会运作起来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct file_system_type binder_fs_type = &#123;</span><br><span class="line">.name= &quot;binder&quot;,</span><br><span class="line">.mount= binderfs_mount, // 文件系统挂载后调用函数</span><br><span class="line">.kill_sb= binderfs_kill_super,</span><br><span class="line">.fs_flags= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件系统挂载后，就会调用binderfs_mount函数.</p><h2 id="3-1-binderfs-c-binderfs-mount"><a href="#3-1-binderfs-c-binderfs-mount" class="headerlink" title="3.1 binderfs.c#binderfs_mount"></a>3.1 binderfs.c#binderfs_mount</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">dentry</span> *<span class="built_in">binderfs_mount</span>(<span class="keyword">struct</span> file_system_type *fs_type,</span><br><span class="line">     <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name,</span><br><span class="line">     <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 留意这个binderfs_fill_super</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mount_nodev</span>(fs_type, flags, data, binderfs_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-android-x2F-kernel-x2F-msm-4-19-x2F-fs-x2F-super-c-mount-nodev"><a href="#3-2-android-x2F-kernel-x2F-msm-4-19-x2F-fs-x2F-super-c-mount-nodev" class="headerlink" title="3.2 android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;super.c#mount_nodev"></a>3.2 android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;super.c#mount_nodev</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *<span class="built_in">mount_nodev</span>(<span class="keyword">struct</span> file_system_type *fs_type,</span><br><span class="line"><span class="type">int</span> flags, <span class="type">void</span> *data,</span><br><span class="line"><span class="built_in">int</span> (*fill_super)(<span class="keyword">struct</span> super_block *, <span class="type">void</span> *, <span class="type">int</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line">    <span class="comment">// 获取超级块</span></span><br><span class="line">    <span class="comment">// 超级块代表了整个文件系统，超级块是文件系统的控制块，有整个文件系统信息</span></span><br><span class="line">    <span class="comment">// 一个文件系统所有的inode都要连接到超级块上，可以说，一个超级块就代表了一个文件系统。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">super_block</span> *s = <span class="built_in">sget</span>(fs_type, <span class="literal">NULL</span>, set_anon_super, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(s))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ERR_CAST</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用传入的函数fill_super</span></span><br><span class="line">error = <span class="built_in">fill_super</span>(s, data, flags &amp; SB_SILENT ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">deactivate_locked_super</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(error);</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_flags |= SB_ACTIVE;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dget</span>(s-&gt;s_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(mount_nodev);</span><br></pre></td></tr></table></figure><p>这些设计文件系统挂载知识，后续我们在研究一下。</p><p>调用mount_nodev后，获取超级块如果一切正常，会调用传入的fill_super函数，这里对应的就是binderfs_fill_super!</p><h2 id="3-3-binderfs-c-binderfs-fill-super"><a href="#3-3-binderfs-c-binderfs-fill-super" class="headerlink" title="3.3 binderfs.c#binderfs_fill_super"></a>3.3 binderfs.c#binderfs_fill_super</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binderfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_device</span> device_info = &#123; &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件系统中数据块大小，以字节单位为一页(一般为4096)</span></span><br><span class="line">sb-&gt;s_blocksize = PAGE_SIZE;</span><br><span class="line">sb-&gt;s_blocksize_bits = PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// kmalloc用于内核空间申请内存，申请的内存位于物理内存映射区域，而且在物理上也是连续的</span></span><br><span class="line">    <span class="comment">// 与真实的物理地址只有一个固定的偏移,因为存在较简单的转换关系，所以对申请的内存大小有限制，不能超过128KB。</span></span><br><span class="line">    <span class="comment">// GFP_KERNEL —— 正常分配内存；</span></span><br><span class="line">sb-&gt;s_fs_info = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> binderfs_info), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// inode 保存的其实是实际的数据的一些信息，这些信息称为“元数据”(也就是对文件属性的描述)。</span></span><br><span class="line">    <span class="comment">// 例如：文件大小，设备标识符，用户标识符，用户组标识符，文件模式，扩展属性，文件读取或</span></span><br><span class="line">    <span class="comment">// 修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等等。</span></span><br><span class="line">inode = <span class="built_in">new_inode</span>(sb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此函数在@sb引用的binderfs中创建一个新的binderfs控制设备节点。</span></span><br><span class="line">ret = <span class="built_in">binderfs_binder_ctl_create</span>(sb);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">name = binder_devices_param;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并创建所有binder设备，三种:&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line">    <span class="comment">// 1. binder</span></span><br><span class="line">    <span class="comment">// 2. hwbinder</span></span><br><span class="line">    <span class="comment">// 3. vndbinder</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>); len &gt; <span class="number">0</span>; len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">strscpy</span>(device_info.name, name, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.4 创建对应binder设备</span></span><br><span class="line">ret = <span class="built_in">binderfs_binder_device_create</span>(inode, <span class="literal">NULL</span>, &amp;device_info);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">name += len;</span><br><span class="line"><span class="keyword">if</span> (*name == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">name++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info-&gt;mount_opts.stats_mode == STATS_GLOBAL)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">init_binder_logs</span>(sb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-binderfs-c-binderfs-binder-device-create"><a href="#3-4-binderfs-c-binderfs-binder-device-create" class="headerlink" title="3.4 binderfs.c#binderfs_binder_device_create"></a>3.4 binderfs.c#binderfs_binder_device_create</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binderfs_binder_device_create</span><span class="params">(<span class="keyword">struct</span> inode *ref_inode,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">struct</span> binderfs_device __user *userp,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">struct</span> binderfs_device *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> minor, ret;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *dentry, *root;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_device</span> *device;</span><br><span class="line"><span class="type">char</span> *name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">size_t</span> name_len;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">super_block</span> *sb = ref_inode-&gt;i_sb;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info = sb-&gt;s_fs_info;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给binder_device分配内核内存空间</span></span><br><span class="line">device = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*device), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!device)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 创建一个新的inode节点</span></span><br><span class="line">inode = <span class="built_in">new_inode</span>(sb);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点,　这里将加载文件操作集－binder操作</span></span><br><span class="line">inode-&gt;i_fop = &amp;binder_fops;</span><br><span class="line">inode-&gt;i_uid = info-&gt;root_uid;</span><br><span class="line">inode-&gt;i_gid = info-&gt;root_gid;</span><br><span class="line"></span><br><span class="line">req-&gt;name[BINDERFS_MAX_NAME] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* NUL-terminate */</span></span><br><span class="line">name_len = <span class="built_in">strlen</span>(req-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一块长度为name_len + 1的内存（kmalloc+gfp）</span></span><br><span class="line">    <span class="comment">// 然后将req-&gt;name到(req-&gt;name + len)内存的内容copy到新分配的内存中</span></span><br><span class="line">    <span class="comment">// 最后后返回该内存的首地址</span></span><br><span class="line">name = <span class="built_in">kmemdup</span>(req-&gt;name, name_len + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!name)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化binder_device的相关设置</span></span><br><span class="line"><span class="built_in">refcount_set</span>(&amp;device-&gt;ref, <span class="number">1</span>);</span><br><span class="line">device-&gt;binderfs_inode = inode;</span><br><span class="line">device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">device-&gt;context.name = name;</span><br><span class="line">device-&gt;miscdev.name = name;<span class="comment">// 分别是binder, hwbinder, vndbinder</span></span><br><span class="line">device-&gt;miscdev.minor = minor;</span><br><span class="line"><span class="built_in">mutex_init</span>(&amp;device-&gt;context.context_mgr_node_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 将创建的binder_device保存在inode中</span></span><br><span class="line">inode-&gt;i_private = device;</span><br><span class="line"><span class="built_in">d_instantiate</span>(dentry, inode);</span><br><span class="line"><span class="built_in">fsnotify_create</span>(root-&gt;d_inode, dentry);</span><br><span class="line"><span class="built_in">inode_unlock</span>(<span class="built_in">d_inode</span>(root));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建binder_device的步骤分为:</p><ol><li>给binder_device分配内核内存空间</li><li>根据超级块创建一个新的inode节点</li><li>加载文件操作集－binder_fops 至inode中</li><li>初始化binder_device的相关设置</li><li>将创建的binder_device保存在inode中</li></ol><p>最重要的是关注步骤3,这里我们还要看看binder_fops的文件操作集具体指向的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android/kernel/msm-4.19/drivers/android/binder.c</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> binder_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.poll = binder_poll,</span><br><span class="line">.unlocked_ioctl = binder_ioctl,</span><br><span class="line">.compat_ioctl = binder_ioctl,</span><br><span class="line">.mmap = binder_mmap,</span><br><span class="line">.open = binder_open,</span><br><span class="line">.flush = binder_flush,</span><br><span class="line">.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哦偶, 终于看到ioctl了，这里先解释下文件操作集的含义及作用:</p><blockquote><p>Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用。<br>用户进程利用在对设备文件进行诸如read&#x2F;write操作的时候，系统调用通过设备文件的主设备号找到相应的设备<br>驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。</p></blockquote><p>其实驱动程序可以理解为一个被动服务，当有上层调用时，才会进入，内核调用的具体实现后续分析。</p><p>比如我们在应用进程中调用ioctl，通过syscall进入内核态，但此时进程上下文还是该应用进程的上下文，对应进程状态为S状态。</p><p>所以我们在上一篇文章中 ##1.6 IPCThreadState#talkWithDriver 里面调用ioctl最后是调用了binder_ioctl这个函数！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>module_init解析及内核initcall的初始化顺序 <a href="https://www.cnblogs.com/chaozhu/p/6410271.html">https://www.cnblogs.com/chaozhu/p/6410271.html</a></li><li>各种initcall的执行先后顺序 <a href="https://blog.csdn.net/fenzhikeji/article/details/6860143">https://blog.csdn.net/fenzhikeji/article/details/6860143</a></li><li>binder 驱动的操作 <a href="https://blog.csdn.net/qq_15893929/article/details/103965668">https://blog.csdn.net/qq_15893929/article/details/103965668</a></li><li>Android的IPC机制Binder的各个部分 <a href="http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml">http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml</a></li><li>字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 <a href="https://blog.csdn.net/weixin_42314225/article/details/81112217">https://blog.csdn.net/weixin_42314225/article/details/81112217</a></li><li>linux文件系统 - 初始化(一) <a href="https://www.cnblogs.com/alantu2018/p/8447303.html">https://www.cnblogs.com/alantu2018/p/8447303.html</a></li><li>mount过程分析之五(mount_bdev-&gt;fill_super) <a href="https://blog.csdn.net/ZR_Lang/article/details/40115013">https://blog.csdn.net/ZR_Lang/article/details/40115013</a></li><li>VFS四大对象之一 struct super_block <a href="https://www.cnblogs.com/linhaostudy/p/7427027.html">https://www.cnblogs.com/linhaostudy/p/7427027.html</a></li><li>Linux字符设备驱动file_operations <a href="https://www.cnblogs.com/chen-farsight/p/6181341.html">https://www.cnblogs.com/chen-farsight/p/6181341.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，想要了解binder驱动的工作原理，我们从binder驱动加载过程开始：&lt;/p&gt;
&lt;p&gt;在android&amp;#x2F;kernel&amp;#x2F;msm-4.19&amp;#x2F;drivers&amp;#x2F;android&amp;#x2F;binder.c中，我们可以看到有这么一行：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;device_initcall(binder_init);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它的initcall 的level为6。&lt;/p&gt;
&lt;p&gt;他可以将驱动设备加载进内核中，以供后续使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(3)--sayHello之ioctl</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-3-sayHello%E4%B9%8Bioctl/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-3-sayHello%E4%B9%8Bioctl/</id>
    <published>2022-04-04T02:38:20.000Z</published>
    <updated>2022-04-04T02:51:16.414Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，首先回顾一下IBinder相关接口的类图：</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png" alt="2_4_IBinder全类图"></p><p>我们知道在Client App中获取的IBinder实际上是BinderProxy类型的对象。那么在上一文中Client App调用sayHello方法过程的的#2.3.2中，我们卡住了，现在可以继续了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>        <span class="title">transact</span><span class="params">(   <span class="type">uint32_t</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Parcel* reply,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="一-IBinder-transact"><a href="#一-IBinder-transact" class="headerlink" title="一. IBinder.transact"></a>一. IBinder.transact</h1><ol><li>Service.onServiceConnected</li><li>IDemoInterface.Stub.Proxy.sayHello</li><li>BinderProxy.transact(Stub.TRANSACTION_sayHello, ……)</li></ol><h2 id="1-1-BinderProxy-transact"><a href="#1-1-BinderProxy-transact" class="headerlink" title="1.1 BinderProxy.transact"></a>1.1 BinderProxy.transact</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不多废话，直接开始, 注意我们现在的进程环境是Client App哦</span></span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-android-util-Binder-android-os-BinderProxy-transact"><a href="#1-2-android-util-Binder-android-os-BinderProxy-transact" class="headerlink" title="1.2 android_util_Binder#android_os_BinderProxy_transact"></a>1.2 android_util_Binder#android_os_BinderProxy_transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 获取IBinder对象，这里我们已经知道了，是BinderProxy对应Native的IBinder对象</span></span><br><span class="line">    <span class="comment">// 也就是对应Server App存入的JavaBBinder, 是Parcel:flattenBinder中存入cookie的BBinder</span></span><br><span class="line">    <span class="comment">// 然后在通信过程中经过Binder驱动转成了对应的BpBinder</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 上一篇文章我们就分析了，这个target就是BpBinder</span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-BpBinder-transact"><a href="#1-3-BpBinder-transact" class="headerlink" title="1.3 BpBinder#transact"></a>1.3 BpBinder#transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOLINTNEXTLINE(google-default-arguments)</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一旦Binder对象死掉，就不会复活</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.4 IPCThreadState!</span></span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-IPCThreadState-transact"><a href="#1-4-IPCThreadState-transact" class="headerlink" title="1.4 IPCThreadState#transact"></a>1.4 IPCThreadState#transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.1 将数据写入mOut中存储, cmd 是BC_TRANSACTION</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// TF_ONE_WAY 是代表这个binder调用是one_way的，不需要等待回传</span></span><br><span class="line">        <span class="comment">// 这个分支表示需要回传数据</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            <span class="comment">// 1.5 当传入的reply Parcel不为null时</span></span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当直接传入一个null的Parcel作为reply时</span></span><br><span class="line">            <span class="comment">// 创建一个假的Parcel接收可能的回写数据</span></span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要回传数据</span></span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transaction的flag一共有四种：</p><table><thead><tr><th>name</th><th>value</th><th>function</th></tr></thead><tbody><tr><td>TF_ONE_WAY</td><td>0x01</td><td>代表oneway的binder调用，不需要回传数据</td></tr><tr><td>TF_ROOT_OBJECT</td><td>0x04</td><td>内容是组件的根对象</td></tr><tr><td>TF_STATUS_CODE</td><td>0x08</td><td>内容是32位的状态代码</td></tr><tr><td>TF_ACCEPT_FDS</td><td>0x10</td><td>允许使用文件描述符答复</td></tr></tbody></table><p>首先将需要传递的数据写入out中存储，然后去和binder driver通信。</p><p>这里我们先忽略IPCThreadState的初始化过程。</p><h3 id="1-4-1-IPCThreadState-writeTransactionData"><a href="#1-4-1-IPCThreadState-writeTransactionData" class="headerlink" title="1.4.1 IPCThreadState#writeTransactionData"></a>1.4.1 IPCThreadState#writeTransactionData</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// cmd为BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    <span class="comment">// 将data保存在mOut中</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里折后就是将数据保存在mOut中，这里是怎么保证多线程并发的时的处理呢？稍后我们研究IPC的初始化就知道了。</p><h2 id="1-5-IPCThreadState-waitForResponse"><a href="#1-5-IPCThreadState-waitForResponse" class="headerlink" title="1.5 IPCThreadState#waitForResponse"></a>1.5 IPCThreadState#waitForResponse</h2><p>从名字也可以猜出来，这里应该就是与binder.c驱动通信。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.6 显而易见, 与驱动通信</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// #1.6中已经通过ioctl与binder驱动通信了，回传的输入也写入了mIn中</span></span><br><span class="line">        <span class="comment">// 读取的第一个uint32_t的数据代表binder通信类型</span></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            err = FAILED_TRANSACTION;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(acquireResult != <span class="literal">NULL</span>, <span class="string">&quot;Unexpected brACQUIRE_RESULT&quot;</span>);</span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> result = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">                <span class="keyword">if</span> (!acquireResult) <span class="keyword">continue</span>;</span><br><span class="line">                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="comment">// 一般非oneway的通信就是走的这里</span></span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                <span class="comment">// 读取从binder驱动回传的数据</span></span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将回传的数据存入reply中</span></span><br><span class="line">                        reply-&gt;<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-IPCThreadState-talkWithDriver"><a href="#1-6-IPCThreadState-talkWithDriver" class="headerlink" title="1.6 IPCThreadState#talkWithDriver"></a>1.6 IPCThreadState#talkWithDriver</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_write_read是一个保存了传输数据以及回传数据信息的结构体</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断读缓冲区是否为空</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仍在从输入缓冲区中剩余的数据中读取数据，并且调用者已请求读取下一个数据，则不编写任何内容</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将待传入的数据存入bwr中，以便通过binder驱动传输</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要回传的数据时</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">// 读缓冲区大小设置为可接受的最大大小</span></span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        <span class="comment">// 将bwr中读缓冲区指针指向mIn中的data，后续驱动直接将数据填充到这里</span></span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Finished read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在回传的数据，则标记</span></span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 到这里我们对Binder通信已经有了一个初步的认知,最核心跨进程的通信手段是通过ioctl这个东东。</p><h1 id="二-ioctl介绍"><a href="#二-ioctl介绍" class="headerlink" title="二. ioctl介绍"></a>二. ioctl介绍</h1><p>本身对Linux内核驱动不太了解，可以参考这篇博文: <a href="https://blog.csdn.net/qq_19923217/article/details/82698787">https://blog.csdn.net/qq_19923217/article/details/82698787</a></p><p>ioctl（）系统调用操作特殊文件的底层设备参数。特别是，字符特殊文件（例如终端）的许多操作特性可以通过ioctl（）请求来控制。</p><blockquote><p>ioctl 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>fd</td><td>文件描述符</td></tr><tr><td>cmd</td><td>交互协议，设备驱动将根据 cmd 执行对应操作</td></tr><tr><td>…</td><td>可变参数 arg，依赖 cmd 指定长度以及类型</td></tr></tbody></table><h2 id="2-1-API"><a href="#2-1-API" class="headerlink" title="2.1 API"></a>2.1 API</h2><ol><li>头文件: #include &lt;sys&#x2F;ioctl.h&gt;, 用于指定ioctl（）请求的宏和定义位于文件&lt;sys&#x2F;ioctl.h&gt;中。</li><li>参数:  int ioctl(int fd, unsigned long request, …);<ol><li>fd 必须是打开文件描述符。</li><li>cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作</li><li>argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。</li></ol></li><li>返回值: ioctl() 函数执行成功时返回 0，失败则返回 -1 并设置全局变量 errorno 值<ol><li>EBADF  fd不是有效的文件描述符。</li><li>EFAULT 默认argp引用不可访问的内存区域。</li><li>EINVAL 请求或argp无效。</li><li>ENOTTY fd与字符专用设备不关联。</li><li>ENOTTY 指定的请求不适用于文件描述符fd引用的对象类型。</li></ol></li></ol><h2 id="2-2-ioctl用户与驱动之间的协议"><a href="#2-2-ioctl用户与驱动之间的协议" class="headerlink" title="2.2 ioctl用户与驱动之间的协议"></a>2.2 ioctl用户与驱动之间的协议</h2><blockquote><p>参考:<a href="https://blog.csdn.net/zifehng/article/details/59576539">https://blog.csdn.net/zifehng/article/details/59576539</a></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个sayHello的过程，我们对binder通信有了基本概念。知道BBinder, BpBinder, IBinder, IInterface等等类的作用。</p><p>接下来我们先看看Binder驱动的加载过程，之后在继续分析ioctl接下来的流程：比如Client发送请求后，binder驱动是怎么找到对应Server的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li><li>msm-4.14 Code <a href="https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c">https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c</a></li><li>linux 内核 - ioctl 函数详解 <a href="https://blog.csdn.net/qq_19923217/article/details/82698787">https://blog.csdn.net/qq_19923217/article/details/82698787</a></li><li>ioctl(2) — Linux manual page <a href="https://man7.org/linux/man-pages/man2/ioctl.2.html">https://man7.org/linux/man-pages/man2/ioctl.2.html</a></li><li>ioctl()分析——从用户空间到设备驱动 <a href="https://blog.csdn.net/zifehng/article/details/59576539">https://blog.csdn.net/zifehng/article/details/59576539</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，首先回顾一下IBinder相关接口的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png&quot; alt=&quot;2_4_IBinder全类图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道在Client App中获取的IBinder实际上是BinderProxy类型的对象。那么在上一文中Client App调用sayHello方法过程的的#2.3.2中，我们卡住了，现在可以继续了：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;status_t&lt;/span&gt;        &lt;span class=&quot;title&quot;&gt;transact&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(   &lt;span class=&quot;type&quot;&gt;uint32_t&lt;/span&gt; code,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                        &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; Parcel&amp;amp; data,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                        Parcel* reply,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                        &lt;span class=&quot;type&quot;&gt;uint32_t&lt;/span&gt; flags = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(2)--sayHello之BinderProxy的创建过程</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-04T02:38:09.000Z</published>
    <updated>2022-04-04T02:50:23.037Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，首先回顾一下IBinder相关接口的类图：</p><p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png" alt="DemoInterfac"></p><p>现在我们Client进程已经拿到Server端IDemoInterface中的IBinder对象，但是这个IBinder对象到底是哪个呢，Stub本身？还是Proxy亦或是Proxy中的mRemote？</p><p>还是看sayHello的调用过程先:</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">    <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">    <span class="comment">// 1.1 这个asInterface是做了什么操作呢？</span></span><br><span class="line">    <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.1 sayHello!</span></span><br><span class="line">        mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="一-asInterface方法"><a href="#一-asInterface方法" class="headerlink" title="一. asInterface方法"></a>一. asInterface方法</h1><h2 id="1-1-IDemoInterface-Stub-asInterface"><a href="#1-1-IDemoInterface-Stub-asInterface" class="headerlink" title="1.1 IDemoInterface.Stub.asInterface"></a>1.1 IDemoInterface.Stub.asInterface</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2 生成IInterface</span></span><br><span class="line">    android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.oneplus.opbench.server.IDemoInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.oneplus.opbench.server.IDemoInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.3 转换成Proxy对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是自动生成的，看起来就是通过IBinder生成一个IInterface或者Proxy？</p><h2 id="1-2-Binder-queryLocalInterface"><a href="#1-2-Binder-queryLocalInterface" class="headerlink" title="1.2 Binder.queryLocalInterface"></a>1.2 Binder.queryLocalInterface</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> IInterface <span class="title function_">queryLocalInterface</span><span class="params">(<span class="meta">@NonNull</span> String descriptor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDescriptor != <span class="literal">null</span> &amp;&amp; mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachInterface</span><span class="params">(<span class="meta">@Nullable</span> IInterface owner, <span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">    mOwner = owner;</span><br><span class="line">    mDescriptor = descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看类图我们也知道，只有Binder实现了IBinder接口，而也只有IDemoInterface.Stub继承了Binder。这么说起来，SystemServer回传的IBinder对象实际上是服务端的IDemoInterface.Stub？然而mOwner此时还是null的，注意我们现在在Client进程中。这里我们直接debug client进程发现queryLocalInterface返回的null值，而且传入的IBinder的类型居然是BinderProxy的！这里什么时候返回非null，传入的IBinder是什么时候变成BinderProxy的呢，先留个疑问。</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_1_IBinder%E7%B1%BB%E5%9B%BE.png" alt="2_1_IBinder类图"></p><h2 id="1-3-创建IDemoInterface-Stub-Proxy对象"><a href="#1-3-创建IDemoInterface-Stub-Proxy对象" class="headerlink" title="1.3 创建IDemoInterface.Stub.Proxy对象"></a>1.3 创建IDemoInterface.Stub.Proxy对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">Proxy(android.os.IBinder remote)</span><br><span class="line">&#123;</span><br><span class="line">  mRemote = remote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白了，现在这个mRemote对象实际上是指代的BinderProxy!</p><h1 id="二-sayHello"><a href="#二-sayHello" class="headerlink" title="二. sayHello"></a>二. sayHello</h1><h2 id="2-1-Proxy-sayHello"><a href="#2-1-Proxy-sayHello" class="headerlink" title="2.1 Proxy.sayHello"></a>2.1 Proxy.sayHello</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">  android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">  android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 按顺序写入参数, 注意DESCRIPTOR</span></span><br><span class="line">    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">    _data.writeLong(aLong);</span><br><span class="line">    _data.writeString(aString);</span><br><span class="line">    <span class="comment">// 2.2 实质上是mRemote起作用的，在1.3中我们通过Debug知道这个其实是BinderProxy对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">      getDefaultImpl().sayHello(aLong, aString);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _reply.readException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-BinderProxy-transact"><a href="#2-2-BinderProxy-transact" class="headerlink" title="2.2 BinderProxy.transact"></a>2.2 BinderProxy.transact</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3 忽略其他代码，这个是call了一个native方法，通过JNI调用</span></span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-android-util-Binder-cpp-android-os-BinderProxy-transact"><a href="#2-3-android-util-Binder-cpp-android-os-BinderProxy-transact" class="headerlink" title="2.3 android_util_Binder.cpp#android_os_BinderProxy_transact"></a>2.3 android_util_Binder.cpp#android_os_BinderProxy_transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3.1 首先从名字中可以推出是获取远程通信的目标</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3.2 继续</span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-android-util-Binder-cpp-getBPNativeData"><a href="#2-3-1-android-util-Binder-cpp-getBPNativeData" class="headerlink" title="2.3.1 android_util_Binder.cpp#getBPNativeData"></a>2.3.1 android_util_Binder.cpp#getBPNativeData</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinderProxyNativeData</span> &#123;</span><br><span class="line">    <span class="comment">// Both fields are constant and not null once javaObjectForIBinder returns this as</span></span><br><span class="line">    <span class="comment">// part of a BinderProxy.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The native IBinder proxied by this BinderProxy.</span></span><br><span class="line">    sp&lt;IBinder&gt; mObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Death recipients for mObject. Reference counted only because DeathRecipients</span></span><br><span class="line">    <span class="comment">// hold a weak reference that can be temporarily promoted.</span></span><br><span class="line">    sp&lt;DeathRecipientList&gt; mOrgue;  <span class="comment">// Death recipients for mObject.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">binderproxy_offsets_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mGetInstance;</span><br><span class="line">    jmethodID mSendDeathNotice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData.</span></span><br><span class="line">&#125; gBinderProxyOffsets;</span><br><span class="line"></span><br><span class="line"><span class="function">BinderProxyNativeData* <span class="title">getBPNativeData</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其实就是读取BinderProxy对象中保存的long类型的mNativeData数据</span></span><br><span class="line">    <span class="comment">// 然后强制转换成BinderProxyNativeData类型</span></span><br><span class="line">    <span class="keyword">return</span> (BinderProxyNativeData *) env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderProxyOffsets.mNativeData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并不知道BinderProxy从哪儿来的，Native层也没有定义，应该就是指代java层的BinderProxy。</p><h3 id="2-3-2-IBinder-transact"><a href="#2-3-2-IBinder-transact" class="headerlink" title="2.3.2 IBinder#transact"></a>2.3.2 IBinder#transact</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>        <span class="title">transact</span><span class="params">(   <span class="type">uint32_t</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Parcel* reply,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里我们知道getBpNativeData中的mObject是IBinder类型的。但是是一个虚函数，没有具体实现，怎么往下查呢。</p><p>Native的Debug方式也有，但是总归不方便，那我们先梳理一下Native层关于IBinder的类图吧。注意现在我们还是在Client进程内的。</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_2_NativeIBinder%E7%B1%BB%E5%9B%BE.png" alt="2_2_NativeIBinder类图"></p><p>IBinder相关类之间的关系大致理清楚了，从这个函数名称getBPNativeData可以猜出来应该是指代的BpBinder!</p><p>但是怎么确认呢，那我们回到Client App和Server App建立通信的过程中，溯源BinderProxy。</p><h1 id="三-BinderProxy的创建过程"><a href="#三-BinderProxy的创建过程" class="headerlink" title="三. BinderProxy的创建过程"></a>三. BinderProxy的创建过程</h1><h2 id="3-1-publishServiceLocked"><a href="#3-1-publishServiceLocked" class="headerlink" title="3.1 publishServiceLocked"></a>3.1 publishServiceLocked</h2><ol><li>ServerApp:        ActivityThread.handleBindService(BindServiceData data)</li><li>SystemServer: ActivityManagerService.publishService(IBinder token, Intent intent, IBinder service)</li><li>SystemServer: ActiveService.publishServiceLocked(ServiceRecord r, Intent intent, IBinder service)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个mService就是Service在被调用onCreate方法的时候存入的</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">&quot;handleBindService s=&quot;</span> + s + <span class="string">&quot; rebind=&quot;</span> + data.rebind);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">// 3.1.1 所以这个onBind，就是Service中我们实现的onBind方法了</span></span><br><span class="line">                    <span class="comment">// 这里的binder就是对应我们实现的IDemoInterface.Stub</span></span><br><span class="line">                    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">// 告诉SystemServer该服务已准备就绪</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里就是rebind</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-服务端的Stub初始化"><a href="#3-1-1-服务端的Stub初始化" class="headerlink" title="3.1.1 服务端的Stub初始化"></a>3.1.1 服务端的Stub初始化</h3><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoBinder</span>:<span class="type">IDemoInterface.Stub</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(aLong: <span class="type">Long</span>, aString: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;DemoService&quot;</span>, <span class="string">&quot;<span class="variable">$aString</span>:<span class="variable">$aLong</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看这个Stub的初始化过程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binder = DemoBinder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">    <span class="comment">// 所以Service中的onBind含义就是通知到AMS</span></span><br><span class="line">    <span class="comment">// 本服务已准备继续，随时可以工作</span></span><br><span class="line">    <span class="keyword">return</span> binder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要注意的是，初始化DemoBinder过程，会调用父类的构造函数哦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachInterface</span><span class="params">(<span class="meta">@Nullable</span> IInterface owner, <span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 噢噢，这个mOwner就是在这里保存的！</span></span><br><span class="line">    <span class="comment">// 它代表的就是IDemoInterface.Stub类的对象，其实就是DemoBinder</span></span><br><span class="line">    mOwner = owner;</span><br><span class="line">    mDescriptor = descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里还是没有找到BinderProxy对象的创建。不过我们知道，Binder通信是通过往Parcel中写入数据的；</p><p>而AMS.publishService函数中最后一个参数就是IBinder类型的。</p><h2 id="3-2-publishService写入参数"><a href="#3-2-publishService写入参数" class="headerlink" title="3.2 publishService写入参数"></a>3.2 publishService写入参数</h2><p>通过查看IActivityManager.aidl文件编译后生成的IActivityManager.Stub.Proxy.class(想想为啥不是Stub而是Proxy)文件可以知道这个函数的具体内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">  <span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">  <span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _data.writeInterfaceToken(<span class="string">&quot;android.app.IActivityManager&quot;</span>);</span><br><span class="line">    _data.writeStrongBinder(token);</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="literal">null</span>) &#123;</span><br><span class="line">      _data.writeInt(<span class="number">1</span>);</span><br><span class="line">      intent.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.1.3 IBinder对象是通过writeStrongBinder方法写入的</span></span><br><span class="line">    <span class="comment">// 注意这个IBinder就是Service实现的onBind方法中返回的, 就是IDemoInterface.Stub类型</span></span><br><span class="line">    _data.writeStrongBinder(service);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> <span class="built_in">this</span>.mRemote.transact(<span class="number">32</span>, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; IActivityManager.Stub.getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">      IActivityManager.Stub.getDefaultImpl().publishService(token, intent, service);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    _reply.readException();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-Parcel-writeStrongBinder"><a href="#3-2-1-Parcel-writeStrongBinder" class="headerlink" title="3.2.1 Parcel.writeStrongBinder"></a>3.2.1 Parcel.writeStrongBinder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeStrongBinder</span><span class="params">(IBinder val)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的mNativePtr就是此Parcel在Native的对应标识</span></span><br><span class="line">    nativeWriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子直接去了Native层干活去了。</p><h3 id="3-2-2-android-os-Parcel-android-os-Parcel-writeStrongBinder"><a href="#3-2-2-android-os-Parcel-android-os-Parcel-writeStrongBinder" class="headerlink" title="3.2.2 android_os_Parcel#android_os_Parcel_writeStrongBinder"></a>3.2.2 android_os_Parcel#android_os_Parcel_writeStrongBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 转成Native的Parcel</span></span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.2.1 注意这个ibinderForJavaObject方法，将java层IBinder转成Native层的</span></span><br><span class="line">        <span class="comment">// 3.2.3 然后是保存这个Native的IBinder</span></span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> err = parcel-&gt;<span class="built_in">writeStrongBinder</span>(<span class="built_in">ibinderForJavaObject</span>(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">signalExceptionForError</span>(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-1-android-util-Binder-ibinderForJavaObject"><a href="#3-2-2-1-android-util-Binder-ibinderForJavaObject" class="headerlink" title="3.2.2.1 android_util_Binder#ibinderForJavaObject"></a>3.2.2.1 android_util_Binder#ibinderForJavaObject</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance of Binder?</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="comment">// 3.2.2.2 返回一个IBinder</span></span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance of BinderProxy?</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块首次出现了BinderProxy，不过当前我们还处于Service App进程对吧，而且上层传入的IBinder明显只是一个IDemoInterface.Stub类型。</p><p>所以这里还是将这个jobject转换成了JavaBBinderHolder！不过我们有理由猜测，BinderProxy是在AMS所处的SystemServer进程中转换的。</p><h4 id="3-2-2-2-android-util-Binder-JavaBBinderHolder-get"><a href="#3-2-2-2-android-util-Binder-JavaBBinderHolder-get" class="headerlink" title="3.2.2.2 android_util_Binder#JavaBBinderHolder#get"></a>3.2.2.2 android_util_Binder#JavaBBinderHolder#get</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;JavaBBinder&gt; <span class="title">get</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    sp&lt;JavaBBinder&gt; b = mBinder.<span class="built_in">promote</span>();</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.2.3 创建JavaBBinder</span></span><br><span class="line">        b = <span class="keyword">new</span> <span class="built_in">JavaBBinder</span>(env, obj);</span><br><span class="line">        <span class="keyword">if</span> (mVintf) &#123;</span><br><span class="line">            ::android::internal::Stability::<span class="built_in">markVintf</span>(b.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mExtension != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            b.<span class="built_in">get</span>()-&gt;<span class="built_in">setExtension</span>(mExtension);</span><br><span class="line">        &#125;</span><br><span class="line">        mBinder = b;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBinder %p (refs %p) for Object %p, weakCount=%&quot;</span> PRId32 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                b.<span class="built_in">get</span>(), b-&gt;<span class="built_in">getWeakRefs</span>(), obj, b-&gt;<span class="built_in">getWeakRefs</span>()-&gt;<span class="built_in">getWeakCount</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回的JavaBBinder,说明JavaBBinder继承了IBinder</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-3-创建Native层的IBinder对象-JavaBBinder"><a href="#3-2-2-3-创建Native层的IBinder对象-JavaBBinder" class="headerlink" title="3.2.2.3 创建Native层的IBinder对象-JavaBBinder"></a>3.2.2.3 创建Native层的IBinder对象-JavaBBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JavaBBinder</span>(JNIEnv* env, jobject <span class="comment">/* Java Binder */</span> object)</span><br><span class="line">        : <span class="built_in">mVM</span>(<span class="built_in">jnienv_to_javavm</span>(env)), <span class="built_in">mObject</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(object))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBBinder %p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 这些先不管</span></span><br><span class="line">    gNumLocalRefsCreated.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">gcIfManyNewRefs</span>(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在看看现在Native层和IBinder有关系的类的类图:</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_3_IBinder%E7%B1%BB%E5%9B%BE_JavaBBinder.png" alt="2_3_IBinder类图_JavaBBinder.png"></p><p>果然JavaBBinder继承了IBinder。回到#3.2.2中，继续往下就是writeStrongBinder了。</p><h3 id="3-2-3-Parcel-writeStrongBinder"><a href="#3-2-3-Parcel-writeStrongBinder" class="headerlink" title="3.2.3 Parcel#writeStrongBinder"></a>3.2.3 Parcel#writeStrongBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flattenBinder</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::flattenBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.3.1 是local还是remote？</span></span><br><span class="line">        BBinder *local = binder-&gt;<span class="built_in">localBinder</span>();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进入！</span></span><br><span class="line">            <span class="keyword">if</span> (local-&gt;<span class="built_in">isRequestingSid</span>()) &#123;</span><br><span class="line">                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里的type，是BINDER_TYPE_BINDER！</span></span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            <span class="comment">// 保存BBinder的弱引用，这个是干啥用的?</span></span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            <span class="comment">// 保存BBinder对象</span></span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.4 完成IBinder的写入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">finishFlattenBinder</span>(binder, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对local和remote存在不同的处理方式，不过我们先仅仅关注其中一个分支。</p><h4 id="3-2-3-1-IBinder-localBinder"><a href="#3-2-3-1-IBinder-localBinder" class="headerlink" title="3.2.3.1 IBinder#localBinder"></a>3.2.3.1 IBinder#localBinder</h4><p>我们这里的IBinder就是JavaBBinder类的对象，前面我们看过了JavaBBinder的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BBinder* <span class="title">IBinder::localBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意IBinder调用的是这个</span></span><br><span class="line"><span class="function">BBinder* <span class="title">BBinder::localBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里的IBinder指针是指向其子类的子类JavaBBinder,然后其子类BBinder实现了虚函数localBinder，而JavaBBinder并没有。</p><p>所以这里是local的！</p><h3 id="3-2-4-Parcel-finishFlattenBinder"><a href="#3-2-4-Parcel-finishFlattenBinder" class="headerlink" title="3.2.4 Parcel#finishFlattenBinder"></a>3.2.4 Parcel#finishFlattenBinder</h3><p>flatten的意思是压平，其实可以理解为打包，将JavaBBinder打包然后发送出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::finishFlattenBinder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="type">const</span> flat_binder_object&amp; flat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 写入内存区域，这一块没有接触过，暂时先不管，后面研究</span></span><br><span class="line">    <span class="comment">// 理解为将IBinder保存到内存中的某个特定区域</span></span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">writeObject</span>(flat, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    internal::Stability::<span class="built_in">tryMarkCompilationUnit</span>(binder.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">writeInt32</span>(internal::Stability::<span class="built_in">get</span>(binder.<span class="built_in">get</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们知道了Java层的IBinder对象是如何通过Parcel保存到Native中的。</p><h2 id="3-3-SystemServer接收参数"><a href="#3-3-SystemServer接收参数" class="headerlink" title="3.3 SystemServer接收参数"></a>3.3 SystemServer接收参数</h2><p>这里我们先不去细究通信的过程，因为这本身就是一次Binder通信。先看AMS收到Server App发布Service的IBinder对象是什么。</p><p>还是通过看编译后生成的IActivityManager.Stub.Class文件中对应的publishService方法，注意我们现在切换到了SystemServer进程(忽略进程切换过程)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    data.enforceInterface(descriptor);</span><br><span class="line">    <span class="comment">// 读取IBinder对象，不过这个是token, 不是我们想要的Service的IBinder</span></span><br><span class="line">    <span class="comment">// 用过Binder通信知道，是按顺序来读写的，所以我们看最后一个IBinder</span></span><br><span class="line">    iBinder11 = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != data.readInt()) &#123;</span><br><span class="line">      intent6 = (Intent)Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      intent6 = <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 3.3.1 这里就是我们想要的Service的IBinder了</span></span><br><span class="line">    iBinder26 = data.readStrongBinder();</span><br><span class="line">    publishService(iBinder11, intent6, iBinder26);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-Parcel-readStrongBinder"><a href="#3-3-1-Parcel-readStrongBinder" class="headerlink" title="3.3.1 Parcel.readStrongBinder"></a>3.3.1 Parcel.readStrongBinder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title function_">readStrongBinder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeReadStrongBinder(mNativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是直接切到Native.</p><h3 id="3-3-2-android-os-Parcel-android-os-Parcel-readStrongBinder"><a href="#3-3-2-android-os-Parcel-android-os-Parcel-readStrongBinder" class="headerlink" title="3.3.2 android_os_Parcel#android_os_Parcel_readStrongBinder"></a>3.3.2 android_os_Parcel#android_os_Parcel_readStrongBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">android_os_Parcel_readStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.3.2.1 先看Parce-&gt;readStrongBinder</span></span><br><span class="line">        <span class="comment">// 3.3.3  将IBinder转换成jobject</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">javaObjectForIBinder</span>(env, parcel-&gt;<span class="built_in">readStrongBinder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-1-Parcel-readStrongBinder"><a href="#3-3-2-1-Parcel-readStrongBinder" class="headerlink" title="3.3.2.1 Parcel#readStrongBinder"></a>3.3.2.1 Parcel#readStrongBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">Parcel::readStrongBinder</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    <span class="comment">// 暂时不明确IBinder指代的是具体哪个子类吼</span></span><br><span class="line">    <span class="built_in">readNullableStrongBinder</span>(&amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">readNullableStrongBinder</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (status == OK &amp;&amp; !val-&gt;<span class="built_in">get</span>()) &#123;</span><br><span class="line">        status = UNEXPECTED_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 来了，解压的过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unflattenBinder</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-2-Parcel-unflattenBinder"><a href="#3-3-2-2-Parcel-unflattenBinder" class="headerlink" title="3.3.2.2 Parcel#unflattenBinder"></a>3.3.2.2 Parcel#unflattenBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::unflattenBinder</span><span class="params">(sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从内存区域中读取当前位置的数据</span></span><br><span class="line">    <span class="type">const</span> flat_binder_object* flat = <span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="comment">// 我们在flatten中的Type就是这个！</span></span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">                <span class="comment">// 转成IBinder，没有问题，我们存入的JavaBBinder，其父类的父类就是IBinder</span></span><br><span class="line">                sp&lt;IBinder&gt; binder = <span class="built_in">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="comment">// 3.3.2.3 完成数据解压</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">                sp&lt;IBinder&gt; binder =</span><br><span class="line">                    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方留个心眼哦，这里的flat-&gt;hdr.type真的还是原来的BINDER_TYPE_BINDER吗？</p><h4 id="3-3-2-3-Parcel-finishUnflattenBinder"><a href="#3-3-2-3-Parcel-finishUnflattenBinder" class="headerlink" title="3.3.2.3 Parcel#finishUnflattenBinder"></a>3.3.2.3 Parcel#finishUnflattenBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::finishUnflattenBinder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> stability;</span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">readInt32</span>(&amp;stability);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    status = internal::Stability::<span class="built_in">set</span>(binder.<span class="built_in">get</span>(), stability, <span class="literal">true</span> <span class="comment">/*log*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out指向这个内存区域</span></span><br><span class="line">    *out = binder;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个IBinder到底是什么类型的呢？先回到#3.3.2中，继续readStrongBinder的过程</p><h3 id="3-3-3-android-util-Binder-javaObjectForIBinder"><a href="#3-3-3-android-util-Binder-javaObjectForIBinder" class="headerlink" title="3.3.3 android_util_Binder#javaObjectForIBinder"></a>3.3.3 android_util_Binder#javaObjectForIBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 3.3.3.1 这里决定是不是直接返回JavaBBinder的类型</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;<span class="built_in">checkSubclass</span>(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="built_in">static_cast</span>&lt;JavaBBinder*&gt;(val.<span class="built_in">get</span>())-&gt;<span class="built_in">object</span>();</span><br><span class="line">        <span class="built_in">LOGDEATH</span>(<span class="string">&quot;objectForBinder %p: it&#x27;s our own %p!\n&quot;</span>, val.<span class="built_in">get</span>(), object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3.4 终于看到和BinderProxy相关的了, 至少名字上看都有关系</span></span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> <span class="built_in">BinderProxyNativeData</span>();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    <span class="comment">// 将从内存中读取的IBinder对象存起来</span></span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3.5 调用到java方法mGetInstance，生成BinderProxy！</span></span><br><span class="line">    jobject object = env-&gt;<span class="built_in">CallStaticObjectMethod</span>(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 所以这里最终返回是BinderProxy对象对应JNI的jobject.</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-1-IBinder-checkSubclass"><a href="#3-3-3-1-IBinder-checkSubclass" class="headerlink" title="3.3.3.1 IBinder#checkSubclass"></a>3.3.3.1 IBinder#checkSubclass</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IBinder::checkSubclass</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* <span class="comment">/*subclassID*/</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaBBinder:</span></span><br><span class="line"><span class="function"><span class="type">bool</span>    <span class="title">checkSubclass</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* subclassID)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 3.3.3.2 gBinderOffsets的初始化</span></span><br><span class="line">    <span class="keyword">return</span> subclassID == &amp;gBinderOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里思考一个问题，注意我们现在已经处于SystemServer进程了，这里的IBinder指向一块内存区域，是从Server App中拷贝而来的，与JavaBBinder数据保持一致。</p><p>那我们强制转换转成了IBinder，然后调用IBinder中的函数是调用IBinder中函数实现还是JavaBBinder中的函数实现呢？</p><h4 id="3-3-3-2-android-util-Binder-int-register-android-os-Binder"><a href="#3-3-3-2-android-util-Binder-int-register-android-os-Binder" class="headerlink" title="3.3.3.2 android_util_Binder#int_register_android_os_Binder"></a>3.3.3.2 android_util_Binder#int_register_android_os_Binder</h4><p>首先gBinderOffsets是bindernative_offsets_t类型的结构体，其在int_register_android_os_Binder中被填充数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);</span><br><span class="line"></span><br><span class="line">    gBinderOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">    gBinderOffsets.mGetInterfaceDescriptor = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;getInterfaceDescriptor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    gBinderOffsets.mObject = <span class="built_in">GetFieldIDOrDie</span>(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在Java中，每个进程都有自己的虚拟机环境，所以对于不同进程来说，JNIEnv肯定也是不同的，这就导致gBinderOffsets也是不同的。</p><p>所以对于3.3.3.1中checkSubclass来说，返回的就是false了。</p><h3 id="3-3-4-创建BinderProxyNativeData"><a href="#3-3-4-创建BinderProxyNativeData" class="headerlink" title="3.3.4 创建BinderProxyNativeData"></a>3.3.4 创建BinderProxyNativeData</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinderProxyNativeData</span> &#123;</span><br><span class="line">    <span class="comment">// Both fields are constant and not null once javaObjectForIBinder returns this as</span></span><br><span class="line">    <span class="comment">// part of a BinderProxy.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The native IBinder proxied by this BinderProxy.</span></span><br><span class="line">    sp&lt;IBinder&gt; mObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Death recipients for mObject. Reference counted only because DeathRecipients</span></span><br><span class="line">    <span class="comment">// hold a weak reference that can be temporarily promoted.</span></span><br><span class="line">    sp&lt;DeathRecipientList&gt; mOrgue;  <span class="comment">// Death recipients for mObject.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哦噢，空欢喜？这里只是一个结构体，将IBinder和DeathRecipientList组合起来。</p><h3 id="3-3-5-gBinderProxyOffsets-mGetInstance-x3D-gt-BinderProxy-getInstance"><a href="#3-3-5-gBinderProxyOffsets-mGetInstance-x3D-gt-BinderProxy-getInstance" class="headerlink" title="3.3.5 gBinderProxyOffsets.mGetInstance &#x3D;&gt; BinderProxy.getInstance"></a>3.3.5 gBinderProxyOffsets.mGetInstance &#x3D;&gt; BinderProxy.getInstance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BinderProxy <span class="title function_">getInstance</span><span class="params">(<span class="type">long</span> nativeData, <span class="type">long</span> iBinder)</span> &#123;</span><br><span class="line">    BinderProxy result;</span><br><span class="line">    <span class="keyword">synchronized</span> (sProxyMap) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = sProxyMap.get(iBinder);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建BinderProxy对象！</span></span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">BinderProxy</span>(nativeData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// We&#x27;re throwing an exception (probably OOME); don&#x27;t drop nativeData.</span></span><br><span class="line">            NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer,</span><br><span class="line">                    nativeData);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData);</span><br><span class="line">        <span class="comment">// The registry now owns nativeData, even if registration threw an exception.</span></span><br><span class="line">        sProxyMap.set(iBinder, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">BinderProxy</span><span class="params">(<span class="type">long</span> nativeData)</span> &#123;</span><br><span class="line">    <span class="comment">// 所以这个nativeData原来是代表的BinderProxyNativeData</span></span><br><span class="line">    mNativeData = nativeData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JNI调用到Java方法，最终生成BinderProxy对象。</p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h1><p>到这里我们就理清了BinderProxy这个是怎么来的了。总结一下：</p><ol><li>Server App实现Service的onBind方法，返回一个IBinder对象，这个IBinder对象是继承了某个aidl接口的Stub类，记为StubIBinder</li><li>Server App调用publishService，将StubIBinder通过一系列方法，在Native层转成JavaBBinder，保存在Parce的内存区域中</li><li>Binder驱动拷贝Parcel并将其传给SystemServer进程(这个过程我们稍后分析)</li><li>SystemServer接收到Parcel内存数据，将其中JavaBBinder所在的内存区域强制转成IBinder类型，并将其保存为Java层的BinderProxy对象</li></ol><p>同理我们知道Client App通过调用bindService获取了一个IBinder对象，那这个IBinder对象也是BinderProxy类型的, 只不过这里有点点小差异:</p><p>SystemServer通过IServiceConnection向Client App发送Server App注册的BinderProxy对象时，在Parcel.writeStrongBinder过程中，存入cookie的是BinderProxy:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为Binder对象</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为BinderProxy对象</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="comment">// SystemServer向Client App发送Server App的BinderProxy对象，走这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在接下来打包flattenBinder的过程中, type 的类型其实是 BINDER_TYPE_HANDLE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::flattenBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// ......</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 注意此时我们身处SystemServer进程，传入的IBinder实际上是对应BinderProxy</span></span></span><br><span class="line"><span class="function">        BBinder *local </span>= binder-&gt;<span class="built_in">localBinder</span>();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (local-&gt;<span class="built_in">isRequestingSid</span>()) &#123;</span><br><span class="line">                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line">            &#125;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-新的疑问"><a href="#4-1-新的疑问" class="headerlink" title="4.1 新的疑问"></a>4.1 新的疑问</h2><p>哦吼，新的问题来了，这个binder-&gt;localBinder()调用的到底是那个方法呢？IBinder, BBinder中都有实现。</p><p>如果是直接拷贝的话，那么按理说也是会调用到BBinder的localBinder，这样这里还是个local!</p><p>如果拷贝后在新进程中调用的是IBinder的localBinder，那么接下来的remoteBinder也是IBinder的，还是返回null！</p><p>这样也说不通，因为如果remoteBinder返回的也是空，那么打包后传入的信息就不能识别Server App的IDemoInterface了。</p><p>这里曾困扰我一段时间，这个IBinder到底是什么是我们理解Binder通信的基础。</p><p>按照网上一大堆的文章来说，从Binder通信到了另一个进程，那么BBinder就会转成了BpBinder。</p><p>然而我们梳理了上层代码，并没有发现这个转变过程。在Parcel整个压缩和解包的过程中都没有发现将IBinder强制转成BpBinder。</p><h2 id="4-2-binder驱动"><a href="#4-2-binder驱动" class="headerlink" title="4.2 binder驱动"></a>4.2 binder驱动</h2><p>其实这里是在驱动层做的处理：android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">struct</span> binder_thread *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;</span><br><span class="line">            buffer_offset += <span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> *fp;</span><br><span class="line"></span><br><span class="line">                fp = <span class="built_in">to_flat_binder_object</span>(hdr);</span><br><span class="line">                ret = <span class="built_in">binder_translate_binder</span>(fp, t, thread);</span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_translate_binder</span><span class="params">(<span class="keyword">struct</span> flat_binder_object *fp,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> binder_transaction *t,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">        <span class="comment">// 这里，如果读取的hdr.type是BINDER_TYPE_BINDER</span></span><br><span class="line">        <span class="comment">// 将会被改成BINDER_TYPE_HANDLE！！！</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在驱动层传输数据的时候会加工一次！怪不得上层找不到任何信息，这个可真的是太容易误导了。</p><h2 id="4-3-SystemServer-x3D-gt-Parcel-unflattenBinder"><a href="#4-3-SystemServer-x3D-gt-Parcel-unflattenBinder" class="headerlink" title="4.3 SystemServer &#x3D;&gt; Parcel#unflattenBinder"></a>4.3 SystemServer &#x3D;&gt; Parcel#unflattenBinder</h2><p>所以在 #3.3.2.2 中 Parcel#unflattenBinder 解包数据时，对IBinder对象的处理是另外一条路径了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::unflattenBinder</span><span class="params">(sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从内存区域中读取当前位置的数据</span></span><br><span class="line">    <span class="type">const</span> flat_binder_object* flat = <span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">                sp&lt;IBinder&gt; binder = <span class="built_in">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">                <span class="comment">// 注意此时收到的数据是经过Binder驱动加工过的，我们现在是在SystemServer进程</span></span><br><span class="line">                <span class="comment">// 所以这个hdr.type从BINDER_TYPE_BINDER转成了BINDER_TYPE_HANDLE！</span></span><br><span class="line">                <span class="comment">// 这里解包，注意flat_binder_object这个结构体，他里面的binder和handle是被组合成union结构的!</span></span><br><span class="line">                <span class="comment">// 所以封包的时候写存入的binder就是此时读取的handle，这也代表了Server App中对应的BBinder</span></span><br><span class="line">                sp&lt;IBinder&gt; binder =</span><br><span class="line">                    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="comment">// 这里我们在回到#3.3.2中android_os_Parcel#android_os_Parcel_readStrongBinder</span></span><br><span class="line">                <span class="comment">// 就可以知道，其实SystemServer自始至终都是保存了来自Server App的BBinder相同数据但是转成了BpBinder的IBinder对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个疑问吼，我们看这个flat_binder_object结构的内容:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __u32 <span class="type">binder_size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span><span class="title">hdr</span>;</span></span><br><span class="line">__u32flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8 bytes of data. */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">binder_uintptr_t</span>binder;<span class="comment">/* local object */</span></span><br><span class="line">__u32handle;<span class="comment">/* remote object */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extra data associated with local object */</span></span><br><span class="line"><span class="type">binder_uintptr_t</span>cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个handle是一个__u32类型的数据，说明该变量占4字节。</p><h3 id="4-3-1-ProcessState-getStrongProxyForHandle-int32-t-handle"><a href="#4-3-1-ProcessState-getStrongProxyForHandle-int32-t-handle" class="headerlink" title="4.3.1 ProcessState#getStrongProxyForHandle(int32_t handle)"></a>4.3.1 ProcessState#getStrongProxyForHandle(int32_t handle)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">// 4.3.2 从mHandleToObject中获取handle对应的handle_entry</span></span><br><span class="line">    handle_entry* e = <span class="built_in">lookupHandleLocked</span>(handle);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="comment">// 第一次当然是null的</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;<span class="built_in">attemptIncWeak</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.3.3 创建BpBinder!!!</span></span><br><span class="line">            b = BpBinder::<span class="built_in">create</span>(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="built_in">getWeakRefs</span>();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;<span class="built_in">decWeak</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个result就是新创建的BpBinder,或者之前创建缓存的BpBinder</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-ProcessState-lookupHandleLocked"><a href="#4-3-2-ProcessState-lookupHandleLocked" class="headerlink" title="4.3.2 ProcessState#lookupHandleLocked"></a>4.3.2 ProcessState#lookupHandleLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessState::handle_entry* <span class="title">ProcessState::lookupHandleLocked</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mHandleToObject 是Vector类型的数据集合</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> N=mHandleToObject.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="type">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">nullptr</span>;</span><br><span class="line">        e.refs = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">status_t</span> err = mHandleToObject.<span class="built_in">insertAt</span>(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.<span class="built_in">editItemAt</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的handle其实是Server App在打包数据时，获取的：obj.binder &#x3D; reinterpret_cast<uintptr_t>(local-&gt;getWeakRefs()), 然后经过驱动加工，可以视为BBinder的映射BpBinder的Token. 这里的细节我们后面分析。</uintptr_t></p><p>一般来说每个BBinder都不一样(为什么呢，涉及到binder驱动以及Android的智能指针)，所以，这里的mHandleToObject是缓存IBinder对象，防止频繁创建销毁消耗资源。</p><h3 id="4-3-3-创建BpBinder"><a href="#4-3-3-创建BpBinder" class="headerlink" title="4.3.3 创建BpBinder"></a>4.3.3 创建BpBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BpBinder* <span class="title">BpBinder::create</span><span class="params">(<span class="type">int32_t</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> trackedUid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// sCountByUidEnabled默认是false的，SystemServer进程是再开机过程中打开的</span></span><br><span class="line">    <span class="keyword">if</span> (sCountByUidEnabled) &#123;</span><br><span class="line">        <span class="comment">// 获取Server App的UID</span></span><br><span class="line">        trackedUid = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>();</span><br><span class="line">        <span class="comment">// 接下来是判断Server App是否存在过多的binder proxy对象</span></span><br><span class="line">        <span class="comment">// 默认2500个, 对于SystemServer进程是6000个(也是开机过程中设置的nSetBinderProxyCountWatermarks)</span></span><br><span class="line">        AutoMutex _l(sTrackingLock);</span><br><span class="line">        <span class="type">uint32_t</span> trackedValue = sTrackingMap[trackedUid];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(trackedValue &amp; LIMIT_REACHED_MASK)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((trackedValue &amp; COUNTING_VALUE_MASK) &gt;= sBinderProxyCountHighWatermark) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)&quot;</span>,</span><br><span class="line">                      <span class="built_in">getuid</span>(), trackedUid, trackedValue);</span><br><span class="line">                sTrackingMap[trackedUid] |= LIMIT_REACHED_MASK;</span><br><span class="line">                <span class="keyword">if</span> (sLimitCallback) <span class="built_in">sLimitCallback</span>(trackedUid);</span><br><span class="line">                <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                    <span class="built_in">ALOGI</span>(<span class="string">&quot;Throttling binder proxy creates from uid %d in uid %d until binder proxy&quot;</span></span><br><span class="line">                          <span class="string">&quot; count drops below %d&quot;</span>,</span><br><span class="line">                          trackedUid, <span class="built_in">getuid</span>(), sBinderProxyCountLowWatermark);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该UID创建了新的BpBinder</span></span><br><span class="line">        sTrackingMap[trackedUid]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BpBinder</span>(handle, trackedUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BpBinder::<span class="built_in">BpBinder</span>(<span class="type">int32_t</span> handle, <span class="type">int32_t</span> trackedUid)</span><br><span class="line">    : <span class="built_in">mHandle</span>(handle)</span><br><span class="line">    , <span class="built_in">mStability</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mAlive</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mObitsSent</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mObituaries</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mTrackedUid</span>(trackedUid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating BpBinder %p handle %d\n&quot;</span>, <span class="keyword">this</span>, mHandle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">extendObjectLifetime</span>(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    <span class="comment">// 给此BpBinder新增一个弱引用</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">incWeakHandle</span>(handle, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后补上一张IBinder类图:</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png" alt="2_4_IBinder全类图"></p><p>了解了IBinder转换过程的原理，BinderProxy的生成过程，也知道了BBinder和BpBinder的映射关系，接下来就是在Client App和Server App之间的通信了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li><li>msm-4.14 Code <a href="https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c">https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，首先回顾一下IBinder相关接口的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png&quot; alt=&quot;DemoInterfac&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在我们Client进程已经拿到Server端IDemoInterface中的IBinder对象，但是这个IBinder对象到底是哪个呢，Stub本身？还是Proxy亦或是Proxy中的mRemote？&lt;/p&gt;
&lt;p&gt;还是看sayHello的调用过程先:&lt;/p&gt;
&lt;figure class=&quot;highlight kt&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onServiceConnected&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(p0: &lt;span class=&quot;type&quot;&gt;ComponentName&lt;/span&gt;?, p1: &lt;span class=&quot;type&quot;&gt;IBinder&lt;/span&gt;?)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Log.d(&lt;span class=&quot;string&quot;&gt;&amp;quot;Client&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;DemoService connected&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 远程服务连接成功，打个招呼&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.1 这个asInterface是做了什么操作呢？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; mProxyBinder = IDemoInterface.Stub.asInterface(p1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 2.1 sayHello!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mProxyBinder.sayHello(&lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello?&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e:RemoteException) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(1)--App使用Binder通信</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/</id>
    <published>2022-04-04T02:37:56.000Z</published>
    <updated>2022-04-04T02:56:11.761Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在初学Android的时候，一般是从四大组件开始学起的。最开始学，是通过追代码流程的方式快速熟悉Android系统框架。</p><p>在这个速学的过程中，很多细节部分就被忽略掉了(这也是必须的，否则学起来极其痛苦且缓慢)。</p><p>比如四大组件之一的Service，在跨进程通信的时候，我们只知道是通过Binder通信的。至于内部实现是如何就不甚了了。</p><p>接下来我们通过一个简单的Demo深入探究这个跨进程通信的过程。</p><span id="more"></span><h1 id="一-在App之间使用Binder通信"><a href="#一-在App之间使用Binder通信" class="headerlink" title="一. 在App之间使用Binder通信"></a>一. 在App之间使用Binder通信</h1><p>目标是在AppClient中给AppServer发送一个简单的字符串</p><h2 id="1-1-创建Interface"><a href="#1-1-创建Interface" class="headerlink" title="1.1 创建Interface"></a>1.1 创建Interface</h2><p>首先在服务端提供接口文件：IDemoInterface. </p><p>Android Studio中通过”File-&gt;New-&gt;AIDL”创建这个 aidl 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IDemoInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void sayHello(long aLong, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建之后需要在 “Build-&gt;Rebuild Project”, 生成对应可用的文件</p><h2 id="1-2-实现服务端接口"><a href="#1-2-实现服务端接口" class="headerlink" title="1.2 实现服务端接口"></a>1.2 实现服务端接口</h2><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> mName = <span class="string">&quot;DemoService&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoBinder</span>:<span class="type">IDemoInterface.Stub</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(aLong: <span class="type">Long</span>, aString: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;DemoService&quot;</span>, <span class="string">&quot;<span class="variable">$aString</span>:<span class="variable">$aLong</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binder = DemoBinder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> binder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，就是将传入的字符串输出出来。但是这个地方就有一个疑问，为啥是继承IDemoInterface.Stub呢？直接看这个文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oneplus.opbench.server;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDemoInterface</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/** Default implementation for IDemoInterface. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Default</span> <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">         * and return values in AIDL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.oneplus.opbench.server.IDemoInterface&quot;</span>;</span><br><span class="line">    <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cast an IBinder object into an com.oneplus.opbench.server.IDemoInterface interface,</span></span><br><span class="line"><span class="comment">     * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.oneplus.opbench.server.IDemoInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.oneplus.opbench.server.IDemoInterface)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">      java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(descriptor);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_sayHello:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          <span class="type">long</span> _arg0;</span><br><span class="line">          _arg0 = data.readLong();</span><br><span class="line">          java.lang.String _arg1;</span><br><span class="line">          _arg1 = data.readString();</span><br><span class="line">          <span class="built_in">this</span>.sayHello(_arg0, _arg1);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote)</span><br><span class="line">      &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">           * and return values in AIDL.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">      &#123;</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          _data.writeLong(aLong);</span><br><span class="line">          _data.writeString(aString);</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            getDefaultImpl().sayHello(aLong, aString);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_sayHello</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setDefaultImpl</span><span class="params">(com.oneplus.opbench.server.IDemoInterface impl)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Stub.Proxy.sDefaultImpl == <span class="literal">null</span> &amp;&amp; impl != <span class="literal">null</span>) &#123;</span><br><span class="line">        Stub.Proxy.sDefaultImpl = impl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">getDefaultImpl</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Stub.Proxy.sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">       * and return values in AIDL.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释的就很清楚，是自动生成的文件。Stub是一个静态内部抽象类，继承了Binder和接口IDemoInterface。</p><h2 id="1-3-客户端调用"><a href="#1-3-客户端调用" class="headerlink" title="1.3 客户端调用"></a>1.3 客户端调用</h2><p>注意把服务端aidl文件夹内容拷贝到客户端项目的aidl文件内，然后客户端也rebuild一下project.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        &lt;!-- for binder(aidl) --&gt;</span></span><br><span class="line"><span class="comment">        &lt;service android:name=&quot;.server.DemoService&quot;</span></span><br><span class="line"><span class="comment">            android:process=&quot;.DemoService&quot;</span></span><br><span class="line"><span class="comment">            android:enabled=&quot;true&quot;</span></span><br><span class="line"><span class="comment">            android:exported=&quot;true&quot; &gt;</span></span><br><span class="line"><span class="comment">            &lt;intent-filter&gt;</span></span><br><span class="line"><span class="comment">                &lt;action android:name=&quot;android.intent.action.DemoService&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;/intent-filter&gt;</span></span><br><span class="line"><span class="comment">        &lt;/service&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">attemptToBindService</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> intent = Intent()</span><br><span class="line">      Log.e(<span class="string">&quot;client&quot;</span>, <span class="string">&quot; connected now&quot;</span>)</span><br><span class="line">      intent.action = <span class="string">&quot;android.intent.action.DemoService&quot;</span> <span class="comment">//服务类的Action</span></span><br><span class="line">      intent.`<span class="keyword">package</span>` = <span class="string">&quot;com.oneplus.opbench&quot;</span> <span class="comment">//服务端包名</span></span><br><span class="line">      <span class="comment">// 建立通信</span></span><br><span class="line">      bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mDemoServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindingDied</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService died!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(p0: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService disconnected!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">          <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">          <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="相关类图"><a href="#相关类图" class="headerlink" title="相关类图"></a>相关类图</h2><p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png" alt="DemoInterface"></p><p>接下来我们从客户端的bindService建立远程连接开始看看是怎么通信的，当然这里我们重点是binder通信，而不是service的bind流程。</p><h1 id="二-通信过程"><a href="#二-通信过程" class="headerlink" title="二. 通信过程"></a>二. 通信过程</h1><p>分析跨进程通信的过程，一定要时刻谨记当前代码所处的进程哦, 为了方便和聚焦, 忽略非紧要代码。</p><h2 id="2-1-Client-x3D-gt-ContextImpl-bindService"><a href="#2-1-Client-x3D-gt-ContextImpl-bindService" class="headerlink" title="2.1 Client&#x3D;&gt;ContextImpl.bindService"></a>2.1 Client&#x3D;&gt;ContextImpl.bindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, <span class="literal">null</span>, mMainThread.getHandler(), <span class="literal">null</span>,</span><br><span class="line">            getUser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.1 获取IServiceConnection对象</span></span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">        <span class="comment">// 2.2 看来是先与Android系统中的AMS服务通信</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-LoadedApk-getServiceDispatcher"><a href="#2-1-1-LoadedApk-getServiceDispatcher" class="headerlink" title="2.1.1 LoadedApk.getServiceDispatcher"></a>2.1.1 LoadedApk.getServiceDispatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title function_">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">        Context context, Handler handler, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getServiceDispatcherCommon(c, context, handler, <span class="literal">null</span>, flags);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> IServiceConnection <span class="title function_">getServiceDispatcherCommon</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">        Context context, Handler handler, Executor executor, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Returning existing dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, executor, flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第一次建立连接，当然需要新建</span></span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, handler, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Creating new dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的是ServiceDispatcher里的mIServiceConnection对象,是InnerConnection</span></span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将ServiceConnection做一个打包，存起来，隐藏细节，注意到返回的是 InnerConnection 类型哦。<br>相关类图如下：</p><p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_2_InnerConnection%E7%B1%BB%E5%9B%BE.png" alt="InnerConnection"></p><h2 id="2-2-SytemServer-x3D-gt-AMS-bindIsolatedService"><a href="#2-2-SytemServer-x3D-gt-AMS-bindIsolatedService" class="headerlink" title="2.2 SytemServer&#x3D;&gt;AMS.bindIsolatedService"></a>2.2 SytemServer&#x3D;&gt;AMS.bindIsolatedService</h2><p>这里其实就存在Binder通信，但是我们先不看，假设直接call过来了（四大组件之Service）.</p><p>我们知道，当服务端app进程没有启动时，会先将进程启动，然后继续进行bindService操作，为了方便，这里假设服务端进程已启动。</p><p>这里忽略中间一系列调用，走到ActiveServices.bindServiceLocked中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">            String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            String instanceName, String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span></span><br><span class="line">            <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 注意这里传入的connection是IServiceConnection</span></span><br><span class="line">    <span class="comment">// retrieveServiceLocked是从已安装的package中找到对应包以及指定Service组件</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">            retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                    Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="literal">true</span>,</span><br><span class="line">                    callerFg, isBindExternal, allowInstant);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> res.record;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 根据我们之前的研究过的Service知识，这个AppBindRecord就是记录App之间Service通信的</span></span><br><span class="line">        <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionRecord</span>(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent,</span><br><span class="line">                callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line">        <span class="comment">// 注意这里的connection.asBinder调用的就是IServiceConnection.Stub.Proxy.asBinder</span></span><br><span class="line">        <span class="comment">// 返回的就是mRemote</span></span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">          <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">          <span class="comment">// publish the connection.</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// c.conn就是Client端传入的IServiceConnection</span></span><br><span class="line">              <span class="comment">// 所以这里又调回去Client进程了，注意传入的b.intent.binder对象</span></span><br><span class="line">              <span class="comment">// 这个传入的b.intent.binder对象就是服务端App发布Service时传入的（publishServiceLocked）</span></span><br><span class="line">              <span class="comment">// 其实可以猜得到是这个就是对应服务端App的IDemoInterface对象</span></span><br><span class="line">              <span class="comment">// 2.3 转到Client进程</span></span><br><span class="line">              c.conn.connected(s.name, b.intent.binder, <span class="literal">false</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              Slog.w(TAG, <span class="string">&quot;Failure sending service &quot;</span> + s.shortInstanceName</span><br><span class="line">                      + <span class="string">&quot; to connection &quot;</span> + c.conn.asBinder()</span><br><span class="line">                      + <span class="string">&quot; (in &quot;</span> + c.binding.client.processName + <span class="string">&quot;)&quot;</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Client-x3D-gt-LoadedApk-ServiceDispatcher-InnerConnection-connected"><a href="#2-3-Client-x3D-gt-LoadedApk-ServiceDispatcher-InnerConnection-connected" class="headerlink" title="2.3 Client&#x3D;&gt;LoadedApk.ServiceDispatcher.InnerConnection.connected"></a>2.3 Client&#x3D;&gt;LoadedApk.ServiceDispatcher.InnerConnection.connected</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="literal">null</span>) &#123;</span><br><span class="line">        sd.connected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-LoadedApk-ServiceDispatcher-connected"><a href="#2-3-1-LoadedApk-ServiceDispatcher-connected" class="headerlink" title="2.3.1 LoadedApk.ServiceDispatcher.connected"></a>2.3.1 LoadedApk.ServiceDispatcher.connected</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="literal">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.3.2 这里其实最后还是调用到了doConnected</span></span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-LoadedApk-ServiceDispatcher-doConnected"><a href="#2-3-2-LoadedApk-ServiceDispatcher-doConnected" class="headerlink" title="2.3.2 LoadedApk.ServiceDispatcher.doConnected"></a>2.3.2 LoadedApk.ServiceDispatcher.doConnected</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个service就是服务端App中的DemoBinder中的mRemote了</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mDemoServiceConnection通知已经建立连接</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-客户端的ServiceConnection"><a href="#2-3-3-客户端的ServiceConnection" class="headerlink" title="2.3.3 客户端的ServiceConnection"></a>2.3.3 客户端的ServiceConnection</h3><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">    <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">    <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，Android系统中两个进程通过四大组件之一的Service进行跨进程通信的连接已经建立了。</p><p>简单来说这个过程借助了SystemServer的帮助：Client app &lt;–&gt; SystemServer &lt;–&gt; Server app</p><p>Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。这样Client App就有了和Server App通信的基础。</p><p>搞清楚是怎么建立连接的过程，接下来深入探究下mProxyBinder.sayHello调用到不同进程对应的方法的细节。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在初学Android的时候，一般是从四大组件开始学起的。最开始学，是通过追代码流程的方式快速熟悉Android系统框架。&lt;/p&gt;
&lt;p&gt;在这个速学的过程中，很多细节部分就被忽略掉了(这也是必须的，否则学起来极其痛苦且缓慢)。&lt;/p&gt;
&lt;p&gt;比如四大组件之一的Service，在跨进程通信的时候，我们只知道是通过Binder通信的。至于内部实现是如何就不甚了了。&lt;/p&gt;
&lt;p&gt;接下来我们通过一个简单的Demo深入探究这个跨进程通信的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(5)--composer</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-5-composer/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-5-composer/</id>
    <published>2022-04-04T01:58:09.000Z</published>
    <updated>2022-04-04T02:30:13.509Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><p>接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。<br>前面我们也稍微分析了一下，直接看handleMessageRefresh方法：</p><p><img src="/images/SurfaceFlinger-5-composer/5_1_sf_onVsync.png" alt="图片"></p><p>从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。<br>如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。</p><p>这里重点分析handleMessageRefresh.</p><span id="more"></span><h1 id="一-handleMessageRefresh"><a href="#一-handleMessageRefresh" class="headerlink" title="一. handleMessageRefresh"></a>一. handleMessageRefresh</h1><h2 id="1-1-SurfaceFlinger-handleMessageRefresh"><a href="#1-1-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="1.1 SurfaceFlinger:handleMessageRefresh"></a>1.1 SurfaceFlinger:handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 1.2 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 重建layer堆栈, 提取可见的Laye并计算可见区域</span></span><br><span class="line">    <span class="comment">// 并将数据更新给对应的Display</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4 hwcomposer的设定，将Layer数据更新给HWC</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有Display，依次合成处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="comment">// 1.5 其实beginFrame和prepareFrame最终都是调用到FrameBufferSurface中，没有做特别的事情</span></span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="comment">// 1.6 正式的合成处理，简单来说就是申请GraphicBuffer，向其中填充帧数据</span></span><br><span class="line">        <span class="comment">// 最终给到硬件帧缓冲区</span></span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知composer,即HWC</span></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据状况决定是否更新Vsync Offset</span></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</span></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-SurfaceFlinger-perComposition"><a href="#1-2-SurfaceFlinger-perComposition" class="headerlink" title="1.2 SurfaceFlinger:perComposition"></a>1.2 SurfaceFlinger:perComposition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;preComposition&quot;</span>);</span><br><span class="line">    <span class="comment">// 记录刷新时间</span></span><br><span class="line">    mRefreshStartTime = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.1 遍历所有layer, 处理处于Drawing状态的layer</span></span><br><span class="line">    <span class="comment">// 这里使用了lambda函数</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 1.2.3 判断Layer是否需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">            <span class="comment">// 如果有layer有frame更新，则标记该值为true，表示需要下一个vsync</span></span><br><span class="line">            <span class="comment">// 做合成</span></span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> SurfaceFlinger::State::<span class="built_in">traverseInZOrder</span>(<span class="type">const</span> LayerVector::Visitor&amp; visitor) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的mDrawingState里面的stateSet为StateSet::Drawing</span></span><br><span class="line">    layersSortedByZ.<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.h</span></span><br><span class="line">State mDrawingState&#123;LayerVector::StateSet::Drawing&#125;;</span><br></pre></td></tr></table></figure><p>layersSortedByZ中存储的layer都是SurfaceFlinger.addClientLayer过程中添加的。</p><h3 id="1-2-1-LayerVector-traverseInZOrder"><a href="#1-2-1-LayerVector-traverseInZOrder" class="headerlink" title="1.2.1 LayerVector:traverseInZOrder"></a>1.2.1 LayerVector:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerVector::traverseInZOrder</span><span class="params">(StateSet stateSet, <span class="type">const</span> Visitor&amp; visitor)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; layer = (*<span class="keyword">this</span>)[i];</span><br><span class="line">        <span class="comment">// 遍历所有layer，拿到合适State的Layer做处理</span></span><br><span class="line">        <span class="comment">// 这里是拿所有Drawing状态的Layer</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; state = (stateSet == StateSet::Current) ? layer-&gt;<span class="built_in">getCurrentState</span>()</span><br><span class="line">                                                      : layer-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">        <span class="comment">// zOrderRelativeOf中的layer是上层调用setRelativeLayer后添加的</span></span><br><span class="line">        <span class="comment">// 如果为非null，则表示此Surface的Z顺序相对于此进行解释</span></span><br><span class="line">        <span class="comment">// 默认是null的。</span></span><br><span class="line">        <span class="keyword">if</span> (state.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理Layer</span></span><br><span class="line">        layer-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-Layer-traverseInZOrder"><a href="#1-2-2-Layer-traverseInZOrder" class="headerlink" title="1.2.2 Layer:traverseInZOrder"></a>1.2.2 Layer:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::traverseInZOrder</span><span class="params">(LayerVector::StateSet stateSet, <span class="type">const</span> LayerVector::Visitor&amp; visitor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> skipRelativeZUsers = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.2.1 按顺序将当前Layer所有z轴相关的layer和子layer添加至列表</span></span><br><span class="line">    <span class="type">const</span> LayerVector list = <span class="built_in">makeTraversalList</span>(stateSet, &amp;skipRelativeZUsers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也就是说首先遍历Z轴相关的Layer</span></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意Layer的添加都是按照Z轴顺序插入排序的</span></span><br><span class="line">        <span class="comment">// 这里的意思就是首先要遍历并对所有z轴小于0的Layer调用onPreComposition方法</span></span><br><span class="line">        <span class="comment">// 所以需要理解z轴小于0的意义，什么时候z轴值才会小于0？</span></span><br><span class="line">        <span class="comment">// 因为P/Q上Layer组合的数据结构是：树形结构+Z轴排序。现在Z轴的大小一般为 [-2, 2]</span></span><br><span class="line">        <span class="comment">// Z轴小的在下面会被覆盖。现在可以理解了，这里为什么碰到z大于0就要退出循环了</span></span><br><span class="line">        <span class="keyword">if</span> (relative-&gt;<span class="built_in">getZ</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对本Layer做onPreComposition</span></span><br><span class="line">    <span class="built_in">visitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后对所有Z轴不小于0的Layer做onPreComposition</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visitor这个就是lambda表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.3 调用onPreComposition</span></span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总的来说就是按顺序依次调用layer的onPreComposition方法，标记其mRefreshPending为false。</p><h4 id="1-2-2-1-Layer-makeTraversalList"><a href="#1-2-2-1-Layer-makeTraversalList" class="headerlink" title="1.2.2.1 Layer:makeTraversalList"></a>1.2.2.1 Layer:makeTraversalList</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __attribute__((no_sanitize(&quot;unsigned-integer-overflow&quot;)))的意思</span></span><br><span class="line"><span class="comment">// 是不进行无符号int溢出检测</span></span><br><span class="line">__attribute__((<span class="built_in">no_sanitize</span>(<span class="string">&quot;unsigned-integer-overflow&quot;</span>))) <span class="function">LayerVector <span class="title">Layer::makeTraversalList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        LayerVector::StateSet stateSet, <span class="type">bool</span>* outSkipRelativeZUsers)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(stateSet == LayerVector::StateSet::Invalid,</span><br><span class="line">                        <span class="string">&quot;makeTraversalList received invalid stateSet&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里useDrawing为true</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> useDrawing = stateSet == LayerVector::StateSet::Drawing;</span><br><span class="line">    <span class="type">const</span> LayerVector&amp; children = useDrawing ? mDrawingChildren : mCurrentChildren;</span><br><span class="line">    <span class="type">const</span> State&amp; state = useDrawing ? mDrawingState : mCurrentState;</span><br><span class="line">    <span class="comment">// 假设没有zOrderRelatives，所以直接返回children</span></span><br><span class="line">    <span class="keyword">if</span> (state.zOrderRelatives.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        *outSkipRelativeZUsers = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在，则将相关的layer按照Z轴顺序加入stateSet.Drawing中</span></span><br><span class="line">    <span class="function">LayerVector <span class="title">traverse</span><span class="params">(stateSet)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> wp&lt;Layer&gt;&amp; weakRelative : state.zOrderRelatives) &#123;</span><br><span class="line">        sp&lt;Layer&gt; strongRelative = weakRelative.<span class="built_in">promote</span>();</span><br><span class="line">        <span class="keyword">if</span> (strongRelative != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            traverse.<span class="built_in">add</span>(strongRelative);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有children，将children的相关Layer添加至traverse</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;Layer&gt;&amp; child : children) &#123;</span><br><span class="line">        <span class="type">const</span> State&amp; childState = useDrawing ? child-&gt;mDrawingState : child-&gt;mCurrentState;</span><br><span class="line">        <span class="keyword">if</span> (childState.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse.<span class="built_in">add</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到1.2.2中。</p><h3 id="1-2-3-Layer-BufferLayer-onPreComposition"><a href="#1-2-3-Layer-BufferLayer-onPreComposition" class="headerlink" title="1.2.3 Layer:BufferLayer::onPreComposition"></a>1.2.3 Layer:BufferLayer::onPreComposition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="type">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        mFrameEventHistory.<span class="built_in">addPreComposition</span>(mCurrentFrameNumber, refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasReadyFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录开始刷新的时间，并返回该Layer是否具有可被合成的条件。</p><h4 id="1-2-3-1-Layer-BufferLayer-hasReadyFrame"><a href="#1-2-3-1-Layer-BufferLayer-hasReadyFrame" class="headerlink" title="1.2.3.1 Layer:BufferLayer::hasReadyFrame"></a>1.2.3.1 Layer:BufferLayer::hasReadyFrame</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::hasReadyFrame</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasFrameUpdate</span>() || <span class="built_in">getSidebandStreamChanged</span>() || <span class="built_in">getAutoRefresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-2-Layer-BufferLayer-BufferQueueLayer"><a href="#1-2-3-2-Layer-BufferLayer-BufferQueueLayer" class="headerlink" title="1.2.3.2 Layer:BufferLayer:BufferQueueLayer"></a>1.2.3.2 Layer:BufferLayer:BufferQueueLayer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::hasFrameUpdate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否具有绘制完成的frame</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getAutoRefresh</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAutoRefresh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getSidebandStreamChanged</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSidebandStreamChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-SurfaceFlinger-rebuildLayerStacks"><a href="#1-3-SurfaceFlinger-rebuildLayerStacks" class="headerlink" title="1.3 SurfaceFlinger:rebuildLayerStacks"></a>1.3 SurfaceFlinger:rebuildLayerStacks</h2><p>这个方法比较长，慢慢看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;rebuildLayerStacks&quot;</span>);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mDolphinStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个display重建其layer列表</span></span><br><span class="line">    <span class="comment">// mVisibleRegionsDirty的这个变量在如下条件会被置为true:</span></span><br><span class="line">    <span class="comment">// 1. 有layer的增删时</span></span><br><span class="line">    <span class="comment">// 2. layer可视化面积发生变化</span></span><br><span class="line">    <span class="comment">// 3. display显示设备变化</span></span><br><span class="line">    <span class="comment">// 4. set power mode on - 即亮屏时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;rebuildLayerStacks VR Dirty&quot;</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是将mGeometryInvalid置为true</span></span><br><span class="line">        <span class="comment">// 这个值影响后续是否需要hwc合成</span></span><br><span class="line">        <span class="built_in">invalidateHwcGeometry</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每一个Display做处理，适配多屏场景</span></span><br><span class="line">        <span class="comment">// mDisplays的类型是：std::map&lt;wp&lt;IBinder&gt;, sp&lt;DisplayDevice&gt;&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : mDisplays) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayDevice = pair.second;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            compositionengine::Output::OutputLayers layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            <span class="type">const</span> ui::Transform&amp; tr = displayState.transform;</span><br><span class="line">            <span class="type">const</span> Rect bounds = displayState.bounds;</span><br><span class="line">            <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">                <span class="comment">// 2.1 计算可视区域</span></span><br><span class="line">                <span class="built_in">computeVisibleRegions</span>(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 顺序遍历Z轴Layer</span></span><br><span class="line">                mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> compositionLayer = layer-&gt;<span class="built_in">getCompositionLayer</span>();</span><br><span class="line">                    <span class="keyword">if</span> (compositionLayer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> displayId = displayDevice-&gt;<span class="built_in">getId</span>();</span><br><span class="line">                    sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;<span class="built_in">getLayerFE</span>();</span><br><span class="line">                    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(layerFE.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">bool</span> needsOutputLayer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对属于给定图层堆栈上的layer, 将其可视区域与其所在Display相交</span></span><br><span class="line">                    <span class="comment">// 相交结果不为空，则说明其在或者其一部分在显示屏幕上</span></span><br><span class="line">                    <span class="comment">// needsOutputLayer标记为true</span></span><br><span class="line">                    <span class="keyword">if</span> (display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(),</span><br><span class="line">                                                 layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">                        Region <span class="built_in">drawRegion</span>(tr.<span class="built_in">transform</span>(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.<span class="built_in">andSelf</span>(bounds);</span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                            needsOutputLayer = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Layer有内容在屏幕上</span></span><br><span class="line">                    <span class="keyword">if</span> (needsOutputLayer) &#123;</span><br><span class="line">                        layersSortedByZ.<span class="built_in">emplace_back</span>(</span><br><span class="line">                                display-&gt;<span class="built_in">getOrCreateOutputLayer</span>(displayId, compositionLayer,</span><br><span class="line">                                                                layerFE));</span><br><span class="line">                        deprecated_layersSortedByZ.<span class="built_in">add</span>(layer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span>&amp; outputLayerState = layersSortedByZ.<span class="built_in">back</span>()-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                        outputLayerState.visibleRegion =</span><br><span class="line">                                tr.<span class="built_in">transform</span>(layer-&gt;visibleRegion.<span class="built_in">intersect</span>(displayState.viewport));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">                        <span class="comment">// 到这个分支里说明Layer之前有内容显示，但现在没有内容显示在屏幕上</span></span><br><span class="line">                        <span class="comment">// 此时我们需要清理该Layer对应的Fence，销毁HWC Layer</span></span><br><span class="line">                        <span class="type">bool</span> hasExistingOutputLayer =</span><br><span class="line">                                display-&gt;<span class="built_in">getOutputLayerForLayer</span>(compositionLayer.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// mLayersWithQueuedFrames 这个变量还记不，是在handlePageFlip方法中，顺序</span></span><br><span class="line">                        <span class="comment">// 遍历Z轴Layer时添加进入的。</span></span><br><span class="line">                        <span class="type">bool</span> hasQueuedFrames = std::<span class="built_in">find</span>(mLayersWithQueuedFrames.<span class="built_in">cbegin</span>(),</span><br><span class="line">                                                         mLayersWithQueuedFrames.<span class="built_in">cend</span>(),</span><br><span class="line">                                                         layer) != mLayersWithQueuedFrames.<span class="built_in">cend</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123;</span><br><span class="line">                            layersNeedingFences.<span class="built_in">add</span>(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据更新到Display中</span></span><br><span class="line">            display-&gt;<span class="built_in">setOutputLayersOrderedByZ</span>(std::<span class="built_in">move</span>(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">            displayDevice-&gt;<span class="built_in">setVisibleLayersSortedByZ</span>(deprecated_layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;<span class="built_in">setLayersNeedingFences</span>(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未定义的区域。也就是屏幕的大小减去屏幕的非透明区域opaqueRegion余下的部分。</span></span><br><span class="line">            Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">            undefinedRegion.<span class="built_in">subtractSelf</span>(tr.<span class="built_in">transform</span>(opaqueRegion));</span><br><span class="line"></span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().undefinedRegion = undefinedRegion;</span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">orSelf</span>(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，rebuildLayerStacks就是反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</p><h2 id="1-4-SurfaceFlinger-calculateWorkingSet"><a href="#1-4-SurfaceFlinger-calculateWorkingSet" class="headerlink" title="1.4 SurfaceFlinger::calculateWorkingSet"></a>1.4 SurfaceFlinger::calculateWorkingSet</h2><p>再看这个方法之前先瞄一眼各个Layer之前的关系：</p><p><img src="/images/SurfaceFlinger-5-composer/5_4_layer_list.png" alt="图片"></p><p>上图中标红的appId就是在此方法内的latchCompositionState方法中赋值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::calculateWorkingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立HWC中的Layer列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mGeometryInvalid)) &#123;</span><br><span class="line">        mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 同样需要针对各个Display做处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> zOrder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;<span class="built_in">getOutputLayersOrderedByZ</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; compositionState = layer-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                compositionState.forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                    compositionState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Z轴顺序依次递增</span></span><br><span class="line">                compositionState.z = zOrder++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新与显示无关的合成状态，其实就是将Layer的状态信息放在CompositionState中了。</span></span><br><span class="line">                <span class="comment">// 也就是frontEnd（LayerFECompositionState）中</span></span><br><span class="line">                layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">latchCompositionState</span>(layer-&gt;<span class="built_in">getLayer</span>().<span class="built_in">editState</span>().frontEnd,</span><br><span class="line">                                                          <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新计算OutputLayer的几何状态</span></span><br><span class="line">                <span class="comment">// 比如根据显示屏全局矩阵调整该Layer的DisplayFrame、</span></span><br><span class="line">                <span class="comment">// 变换窗口裁剪以匹配缓冲区坐标系等等。</span></span><br><span class="line">                layer-&gt;<span class="built_in">updateCompositionState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将Layer更新完毕的几何状态写入HWC</span></span><br><span class="line">                layer-&gt;<span class="built_in">writeStateToHWC</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每帧的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="keyword">if</span> (!displayId) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDrawingState.colorMatrixChanged) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setColorTransform</span>(mDrawingState.colorMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        Dataspace targetDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (useColorManagement) &#123;</span><br><span class="line">            ColorMode colorMode;</span><br><span class="line">            RenderIntent renderIntent;</span><br><span class="line">            <span class="built_in">pickColorMode</span>(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent);</span><br><span class="line">            display-&gt;<span class="built_in">setColorMode</span>(colorMode, targetDataspace, renderIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">            layer-&gt;<span class="built_in">setPerFrameData</span>(displayDevice, displayState.transform, displayState.viewport,</span><br><span class="line">                                   displayDevice-&gt;<span class="built_in">getSupportedPerFrameMetadata</span>(),</span><br><span class="line">                                   <span class="built_in">isHdrColorMode</span>(displayState.colorMode) ? Dataspace::UNKNOWN</span><br><span class="line">                                                                          : targetDataspace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; layerState = layer-&gt;<span class="built_in">getCompositionLayer</span>()-&gt;<span class="built_in">editState</span>().frontEnd;</span><br><span class="line">            layerState.compositionType = <span class="built_in">static_cast</span>&lt;Hwc2::IComposerClient::Composition&gt;(</span><br><span class="line">                    layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里建立HWC中的Layer列表： </p><ol><li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li><li>将Layer的mActiveBuffer设置到HWComposer中</li></ol><h2 id="1-5-SurfaceFlinger-beginFrame"><a href="#1-5-SurfaceFlinger-beginFrame" class="headerlink" title="1.5 SurfaceFlinger::beginFrame"></a>1.5 SurfaceFlinger::beginFrame</h2><p>开始合成前的准备。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::beginFrame</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有待更新的区域</span></span><br><span class="line">    <span class="type">bool</span> dirty = !display-&gt;<span class="built_in">getDirtyRegion</span>(<span class="literal">false</span>).<span class="built_in">isEmpty</span>();</span><br><span class="line">    <span class="comment">// 可见Layer数量是否为0</span></span><br><span class="line">    <span class="type">bool</span> empty = displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>().<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上次合成是否有可见Layer</span></span><br><span class="line">    <span class="type">bool</span> wasEmpty = !displayState.lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有变化时或者有变化但此时没有可见Layer且上次合成时也没有就跳过</span></span><br><span class="line">    <span class="type">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> flagPrefix[] = &#123;<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(flagPrefix);</span><br><span class="line">    <span class="built_in">ALOGV_IF</span>(displayDevice-&gt;<span class="built_in">isVirtual</span>(), <span class="string">&quot;%s: %s composition for %s (%cdirty %cempty %cwasEmpty)&quot;</span>,</span><br><span class="line">             __FUNCTION__, mustRecompose ? <span class="string">&quot;doing&quot;</span> : <span class="string">&quot;skipping&quot;</span>,</span><br><span class="line">             displayDevice-&gt;<span class="built_in">getDebugName</span>().<span class="built_in">c_str</span>(), flagPrefix[dirty], flagPrefix[empty],</span><br><span class="line">             flagPrefix[wasEmpty]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里面其实没有做什么特殊的操作，我们看一下DisplayDevice相关的类</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">beginFrame</span>(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/SurfaceFlinger-5-composer/5_5_DisplayDevice.png" alt="图片"></p><p>这个DiplayDevice是怎么初始化的呢，后续再看。</p><h2 id="1-6-SurfaceFlinger-doComposition"><a href="#1-6-SurfaceFlinger-doComposition" class="headerlink" title="1.6 SurfaceFlinger::doComposition"></a>1.6 SurfaceFlinger::doComposition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice, <span class="type">bool</span> repaintEverything)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="comment">// 将脏区转换为该屏幕的坐标空间</span></span><br><span class="line">        <span class="type">const</span> Region dirtyRegion = display-&gt;<span class="built_in">getDirtyRegion</span>(repaintEverything);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.6.1 请求buffer,做合成操作</span></span><br><span class="line">        <span class="built_in">doDisplayComposition</span>(displayDevice, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">        display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">flip</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fence同步相关处理，暂时忽略</span></span><br><span class="line">    <span class="built_in">postFramebuffer</span>(displayDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-1-SurfaceFlinger-doDisplayComposition"><a href="#1-6-1-SurfaceFlinger-doDisplayComposition" class="headerlink" title="1.6.1 SurfaceFlinger::doDisplayComposition"></a>1.6.1 SurfaceFlinger::doDisplayComposition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Region&amp; inDirtyRegion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅在以下情况下才需要实际构成显示：</span></span><br><span class="line">    <span class="comment">// 1）由HWC处理，它可能需要此操作以使其虚拟显示状态机保持同步</span></span><br><span class="line">    <span class="comment">// 2）有工作要做（脏区不为空）</span></span><br><span class="line">    <span class="keyword">if</span> (!displayDevice-&gt;<span class="built_in">getId</span>() &amp;&amp; inDirtyRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doDisplayComposition&quot;</span>);</span><br><span class="line">    base::unique_fd readyFence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.6.2 合成Surface</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">doComposeSurfaces</span>(displayDevice, Region::INVALID_REGION, &amp;readyFence)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲区，buffer已经被填充了合成所有Layer后的帧数据。</span></span><br><span class="line">    <span class="comment">// 将FrameBuffer发送给HWC, 也就是将内容渲染到硬件帧缓冲区中去</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">queueBuffer</span>(std::<span class="built_in">move</span>(readyFence));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-2-SurfaceFlinger-doComposeSurfaces"><a href="#1-6-2-SurfaceFlinger-doComposeSurfaces" class="headerlink" title="1.6.2 SurfaceFlinger::doComposeSurfaces"></a>1.6.2 SurfaceFlinger::doComposeSurfaces</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> Region&amp; debugRegion, base::unique_fd* readyFence)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposeSurfaces&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; renderEngine = <span class="built_in">getRenderEngine</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> supportProtectedContent = renderEngine.<span class="built_in">supportsProtectedContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Region <span class="title">bounds</span><span class="params">(displayState.bounds)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> DisplayRenderArea <span class="title">renderArea</span><span class="params">(displayDevice)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> hasClientComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;hasClientComposition&quot;</span>, hasClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> applyColorMatrix = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    renderengine::DisplaySettings clientCompositionDisplay;</span><br><span class="line">    std::vector&lt;renderengine::LayerSettings&gt; clientCompositionLayers;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    base::unique_fd fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;hasClientComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求GraphicBuffer, 通过ANativeWindow向GPU申请</span></span><br><span class="line">        buf = display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">dequeueBuffer</span>(&amp;fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Dequeuing buffer for display [%s] failed, bailing out of &quot;</span></span><br><span class="line">                  <span class="string">&quot;client composition for this frame&quot;</span>,</span><br><span class="line">                  displayDevice-&gt;<span class="built_in">getDisplayName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将DisplayState相关信息赋值给clientCompositionDisplay，以供HWC使用</span></span><br><span class="line">        clientCompositionDisplay.physicalDisplay = displayState.scissor;</span><br><span class="line">        clientCompositionDisplay.clip = displayState.scissor;</span><br><span class="line">        <span class="type">const</span> ui::Transform&amp; displayTransform = displayState.transform;</span><br><span class="line">        clientCompositionDisplay.globalTransform = displayTransform.<span class="built_in">asMatrix4</span>();</span><br><span class="line">        clientCompositionDisplay.orientation = displayState.orientation;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line">        Dataspace outputDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (profile-&gt;<span class="built_in">hasWideColorGamut</span>()) &#123;</span><br><span class="line">            outputDataspace = displayState.dataspace;</span><br><span class="line">        &#125;</span><br><span class="line">        clientCompositionDisplay.outputDataspace = outputDataspace;</span><br><span class="line">        clientCompositionDisplay.maxLuminance =</span><br><span class="line">                profile-&gt;<span class="built_in">getHdrCapabilities</span>().<span class="built_in">getDesiredMaxLuminance</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> hasDeviceComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> skipClientColorTransform =</span><br><span class="line">                <span class="built_in">getHwComposer</span>()</span><br><span class="line">                        .<span class="built_in">hasDisplayCapability</span>(displayId,</span><br><span class="line">                                              HWC2::DisplayCapability::SkipClientColorTransform);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the global color transform matrix.</span></span><br><span class="line">        applyColorMatrix = !hasDeviceComposition &amp;&amp; !skipClientColorTransform;</span><br><span class="line">        <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">            clientCompositionDisplay.colorTransform = displayState.colorTransformMat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 现在渲染以帧缓冲区为目标的图层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Rendering client layers&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> firstLayer = <span class="literal">true</span>;</span><br><span class="line">    Region clearRegion = Region::INVALID_REGION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可见Layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">viewportRegion</span><span class="params">(displayState.viewport)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">clip</span><span class="params">(viewportRegion.intersect(layer-&gt;visibleRegion))</span></span>;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Layer: %s&quot;</span>, layer-&gt;<span class="built_in">getName</span>().<span class="built_in">string</span>());</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;  Composition type: %s&quot;</span>, <span class="built_in">toString</span>(layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (!clip.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CLIENT: &#123;</span><br><span class="line">                    renderengine::LayerSettings layerSettings;</span><br><span class="line">                    <span class="comment">// 根据相关配置设置Layer状态：渲染区域、alpha通道、颜色变换等等</span></span><br><span class="line">                    <span class="type">bool</span> prepared =</span><br><span class="line">                            layer-&gt;<span class="built_in">prepareClientLayer</span>(renderArea, clip, clearRegion,</span><br><span class="line">                                                      supportProtectedContent, layerSettings);</span><br><span class="line">                    <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                        <span class="comment">// 放入clientCompositionLayers中备用</span></span><br><span class="line">                        clientCompositionLayers.<span class="built_in">push_back</span>(layerSettings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;  Skipping for empty clip&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        firstLayer = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasClientComposition为true说明使用GPU合成</span></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        clientCompositionDisplay.clearRegion = clearRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里提高GPU频率，因为会进行色彩空间转换，比较耗时。 </span></span><br><span class="line">        <span class="comment">// 提高了GPU频率，以便GPU合成可以及时完成。</span></span><br><span class="line">        <span class="comment">// 之后必须重新设置GPU频率，因为高频率会消耗额外的电池。</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> expensiveRenderingExpected =</span><br><span class="line">                clientCompositionDisplay.outputDataspace == Dataspace::DISPLAY_P3;</span><br><span class="line">        <span class="keyword">if</span> (expensiveRenderingExpected &amp;&amp; displayId) &#123;</span><br><span class="line">            mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用渲染引擎（renderengine/gl/GLESRenderEngine.cpp）合成所有Layer</span></span><br><span class="line">        renderEngine.<span class="built_in">drawLayers</span>(clientCompositionDisplay, clientCompositionLayers,</span><br><span class="line">                                buf-&gt;<span class="built_in">getNativeBuffer</span>(), <span class="comment">/*useFramebufferCache=*/</span><span class="literal">true</span>, std::<span class="built_in">move</span>(fd),</span><br><span class="line">                                readyFence);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">        mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先请求GraphicBuffer，然后通过GLESRenderEngine合成所有Layer.</p><h1 id="二-计算Layer可视区域"><a href="#二-计算Layer可视区域" class="headerlink" title="二. 计算Layer可视区域"></a>二. 计算Layer可视区域</h1><p>一般来讲，我们手机App Layer如下：<br><img src="/images/SurfaceFlinger-5-composer/5_2_appZ.png" alt="图片"></p><p>计算可视区域的时候，从Z轴大的开始遍历计算。这样做的好处是，如果计算到某一层Layer时，完全不透明的可视化区域已经占满整个屏幕，那么这之下的Layer可视化区域就可以不用计算了。</p><p>在开始阅读代码之前，还是有必要理清楚：</p><ol><li>可见区域（Visible Region）</li><li>透明区域（Transparent Region）</li><li>半透明区域（Translucent Region）</li><li>完全不透明区域（Opaque Region）</li><li>被覆盖区域（Covered Region）</li></ol><p>如下图:</p><p><img src="/images/SurfaceFlinger-5-composer/5_3_visiableregion.png" alt="图片"></p><p>如果A1为W2中半透明区域，A2在W1中全透明，W2中不透明，A3为W1中完全不透明区域。<br>则对于Surface W2而言，可见区域为W2-A1-A3.</p><h2 id="2-1-SurfaceFlinger-computeVisibleRegions"><a href="#2-1-SurfaceFlinger-computeVisibleRegions" class="headerlink" title="2.1 SurfaceFlinger:computeVisibleRegions"></a>2.1 SurfaceFlinger:computeVisibleRegions</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;computeVisibleRegions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    outDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先找到“感兴趣的”Layer，也就是这个layer是属于SecureDisplay的</span></span><br><span class="line">    <span class="comment">// 暂时没有找到相关的说明，忽略好了</span></span><br><span class="line">    Layer* layerOfInterest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> bIgnoreLayer = <span class="literal">false</span>;</span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">isSecureDisplay</span>()) &#123;</span><br><span class="line">            bIgnoreLayer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (displayDevice-&gt;<span class="built_in">isPrimary</span>()) &#123;</span><br><span class="line">                layerOfInterest = layer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向遍历Z轴计算可视化区域</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 获取当前绘制中的Surface</span></span><br><span class="line">        <span class="type">const</span> Layer::State&amp; <span class="built_in">s</span>(layer-&gt;<span class="built_in">getDrawingState</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只考虑给定图层堆栈上的layer</span></span><br><span class="line">        <span class="keyword">if</span> (!display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略SecureDisplay中的layer</span></span><br><span class="line">        <span class="keyword">if</span> (bIgnoreLayer &amp;&amp; layerOfInterest != layer) &#123;</span><br><span class="line">            Region visibleNonTransRegion;</span><br><span class="line">            visibleNonTransRegion.<span class="built_in">set</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(visibleNonTransRegion);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全不透明的Surface区域</span></span><br><span class="line">        Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕上可见且不完全透明的Surface区域。 </span></span><br><span class="line">        <span class="comment">// 这实际上是该层的足迹减去其上方的不透明区域。</span></span><br><span class="line">        <span class="comment">// 半透明Surface覆盖的区域被认为是可见的。</span></span><br><span class="line">        Region visibleRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被其上方所有可见区域覆盖的Surface区域（包括半透明区域）。</span></span><br><span class="line">        Region coveredRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暗示完全透明的表面区域。 这仅用于告诉图层何时没有可见的非透明区域，可以将其从图层列表中删除。 </span></span><br><span class="line">        <span class="comment">// 它不会影响此层或它下面的任何层的visibleRegion。 </span></span><br><span class="line">        <span class="comment">// 如果应用程序不遵守SurfaceView限制（不幸的是，有些不遵守），则提示可能不正确。</span></span><br><span class="line">        Region transparentRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理不可见或者被隐藏的Surface的方式就是将其可视化的区域设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_LIKELY</span>(layer-&gt;<span class="built_in">isVisible</span>())) &#123;</span><br><span class="line">            <span class="comment">// 如果该Surface不是完全不透明的，则视为半透明</span></span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> translucent = !layer-&gt;<span class="built_in">isOpaque</span>(s);</span><br><span class="line">            Rect <span class="built_in">bounds</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前Surface的可视区域默认为屏幕大小或者Surface在屏幕中的大小</span></span><br><span class="line">            visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            ui::Transform tr = layer-&gt;<span class="built_in">getTransform</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Region为空则说明没有可视区域</span></span><br><span class="line">            <span class="comment">// 注意 Region 是一个矩形（Rect）集合</span></span><br><span class="line">            <span class="keyword">if</span> (!visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="comment">// 首先从可见区域移除透明区域</span></span><br><span class="line">                <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">                    <span class="comment">// 函数preserveRects的返回值为false</span></span><br><span class="line">                    <span class="comment">// 说明需要忽略掉当前正在处理的应用程序窗口的透明区域</span></span><br><span class="line">                    <span class="keyword">if</span> (tr.<span class="built_in">preserveRects</span>()) &#123;</span><br><span class="line">                        <span class="comment">// 标记透明区域，这个透明区域就是transparentRegionHint遍历</span></span><br><span class="line">                        <span class="comment">// 在 SurfaceFlinger.setClientStateLocked过程中设置的</span></span><br><span class="line">                        transparentRegion = tr.<span class="built_in">transform</span>(layer-&gt;<span class="built_in">getActiveTransparentRegion</span>(s));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 转换太复杂，无法进行透明区域优化。</span></span><br><span class="line">                        transparentRegion.<span class="built_in">clear</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算不透明区域</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> layerOrientation = tr.<span class="built_in">getOrientation</span>();</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;<span class="built_in">getAlpha</span>() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                        layer-&gt;<span class="built_in">getRoundedCornerState</span>().radius == <span class="number">0.0f</span> &amp;&amp;</span><br><span class="line">                        ((layerOrientation &amp; ui::Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时</span></span><br><span class="line">                    <span class="comment">// 那么它的完全不透明区域opaqueRegion就等于计算所得到的可见区域visibleRegion</span></span><br><span class="line">                    opaqueRegion = visibleRegion;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Surface没有可视区域，则清空相关变量，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">clearVisibilityRegions</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将覆盖区域裁剪到可见区域</span></span><br><span class="line">        <span class="comment">// aboveCoveredLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的可见区域</span></span><br><span class="line">        <span class="comment">// 将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相交，就可以得到当前正在处理的应用程序窗口的被覆盖区域coveredRegion</span></span><br><span class="line">        <span class="comment">// 而将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相或一下，就可以得到下一个应用程序窗口的所有上层应用程序窗口所组成的可见区域aboveCoveredLayers。</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.<span class="built_in">intersect</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aboveOpaqueLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的完全不透明区域</span></span><br><span class="line">        aboveCoveredLayers.<span class="built_in">orSelf</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个区域从当前正在处理的应用程序窗口的可见区域visibleRegion减去后，就可以得到当前正在处理的应用程序窗口的最终可见区域visibleRegion。</span></span><br><span class="line">        visibleRegion.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算Layer的脏区域，所谓脏区域就是需要重新执行渲染操作的</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">            <span class="comment">// 成员变量contentDirty的值为true，则说明当前正在处理的Layer上一次的状态还未来得及处理</span></span><br><span class="line">            <span class="comment">// 即它当前的内容是脏的。在这个状况下，只需要将此次的可见区域与上一次的可见区域合并即可</span></span><br><span class="line">            dirty = visibleRegion;</span><br><span class="line">            <span class="comment">// as well, as the old visible region</span></span><br><span class="line">            dirty.<span class="built_in">orSelf</span>(layer-&gt;visibleRegion);</span><br><span class="line">            layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当上一次状态已经处理了，也就是显示内容没有更新,则无需重新渲染所有区域。</span></span><br><span class="line">            <span class="comment">// 现在只需要处理一下两种情况：</span></span><br><span class="line">            <span class="comment">// 1. 之前是被覆盖的区域，但现在不被覆盖了</span></span><br><span class="line">            <span class="comment">// 2. 由于窗口大小变化而引发的新增不被覆盖区域</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第一种情况:</span></span><br><span class="line">            <span class="comment">// 将当前可见区域visibleRegion与它的上一次被覆盖区域oldCoveredRegion相交</span></span><br><span class="line">            <span class="comment">// 就可以得到之前是被覆盖的而现在不被覆盖了的区域，即可以得到第一部分需要重新渲染的区域</span></span><br><span class="line">            <span class="comment">// 上一次可见区域和被覆盖区域分别oldVisibleRegion, oldCoveredRegion</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第二种情况:</span></span><br><span class="line">            <span class="comment">// 由于将一个应用程序窗口的当前可见区域减去被覆盖区域即为它的当前不被覆盖的区域newExposed</span></span><br><span class="line">            <span class="comment">// 同理上一次不被覆盖的区域oldExposed就是上一次可见区域减去上一次被覆盖区域</span></span><br><span class="line">            <span class="comment">// 那么将一个应用程序窗口的当前不被覆盖的区域newExposed减去它的上一次不被覆盖的区域oldExposed，就可以得到新增的不被覆盖区域</span></span><br><span class="line">            <span class="type">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">            <span class="type">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将第一部分和第二部分需要重新渲染的区域组合起来，就可以得到当前Layer的脏区域dirty。</span></span><br><span class="line">            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从该脏区域dirty减去上层的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 因为后者的渲染不需要当前Layer参与</span></span><br><span class="line">        dirty.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新的脏区域dirty累计到输出参数dirtyRegion中.</span></span><br><span class="line">        outDirtyRegion.<span class="built_in">orSelf</span>(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新计算到目前为止所得到的Layer的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 这个是方便下一层Layer的计算</span></span><br><span class="line">        aboveOpaqueLayers.<span class="built_in">orSelf</span>(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前正在处理的Layer的可见区域和被覆盖区域以及可见非透明区域.</span></span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleRegion</span>(visibleRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setCoveredRegion</span>(coveredRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(</span><br><span class="line">                visibleRegion.<span class="built_in">subtract</span>(transparentRegion));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前面所有的Layer组成的完全不透明区域aboveOpaqueLayers保存在输出参数opaqueRegion中</span></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>handleMessageRefresh – SF合成所有Layer大概步骤如下：</p><ol><li>preComposition<br>合成前遍历所有layer, 处理处于Drawing状态的Layer是否被更新了</li><li>rebuildLayerStacks<br>反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</li><li>calculateWorkingSet<br>这里建立HWC中的Layer列表： </li><li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li><li>将Layer的mActiveBuffer设置到HWComposer中</li><li>doComposition<br>正式的合成处理，使用渲染引擎合成所有layer，然后就是申请GraphicBuffer，向其中填充帧数据, 最终给到硬件帧缓冲区</li><li>postComposition &amp;&amp; clear mLayersWithQueuedFrames<br>回调每个layer的onPostComposition并清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</li></ol><p>大概流程搞清楚了，接下来细细分析比如GraphicBuffer和Fence机制的工作原理, 等等，HWC好像还没有了解，先看看这个是怎么工作的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>[Android Synchronization Fences – An Introduction]<a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li><li>[Android 4.0.3 显示系统深入理解]<a href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li><li>[Clang 10 documentation ATTRIBUTES IN CLANG]<a href="https://clang.llvm.org/docs/AttributeReference.html">https://clang.llvm.org/docs/AttributeReference.html</a></li><li>[「Android」SurfaceFlinger分析]<a href="https://www.cnblogs.com/1996swg/p/9790209.html">https://www.cnblogs.com/1996swg/p/9790209.html</a></li><li>[显示系统：第005课_Vsync机制:第007节_rebuildLayerStacks源码分析]<a href="http://www.pianshen.com/article/8541345041/">http://www.pianshen.com/article/8541345041/</a></li><li>[Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析]<a href="https://blog.csdn.net/luoshengyang/article/details/8079456">https://blog.csdn.net/luoshengyang/article/details/8079456</a></li><li>[Android Region代码分析]<a href="https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t">https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。&lt;br&gt;前面我们也稍微分析了一下，直接看handleMessageRefresh方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SurfaceFlinger-5-composer/5_1_sf_onVsync.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。&lt;br&gt;如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。&lt;/p&gt;
&lt;p&gt;这里重点分析handleMessageRefresh.&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(4)--Layer&amp;Surface</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-4-Layer-Surface/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-4-Layer-Surface/</id>
    <published>2022-04-04T01:57:56.000Z</published>
    <updated>2022-04-04T02:29:13.183Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Android Q</strong></p><p>前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。<br>接下来我们先看看SurfaceFlinger合成帧的部分。</p><span id="more"></span><h1 id="一-SF-EventThread接收vsync的准备"><a href="#一-SF-EventThread接收vsync的准备" class="headerlink" title="一. SF EventThread接收vsync的准备"></a>一. SF EventThread接收vsync的准备</h1><p>在SFEventThread一文中已经探明，当产生Vsync信号后，会通过BitTube发送事件(EventThreadConnection.postEvent):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::postEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event&amp; event)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就需要知道 mChannel 是被谁监听了。</p><h2 id="1-1-SurfaceFlinger-init"><a href="#1-1-SurfaceFlinger-init" class="headerlink" title="1.1 SurfaceFlinger.init"></a>1.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.1.1 创建SfEventThread以及EventThreadConnection</span></span><br><span class="line">    mSfConnectionHandle = mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;sf&quot;</span>, mPhaseOffsets-&gt;<span class="built_in">getCurrentSfOffset</span>(),</span><br><span class="line">                                                    resyncCallback, [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                        mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 赋值 BitTube, 用来通信</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventConnection</span>(mScheduler-&gt;<span class="built_in">getEventConnection</span>(mSfConnectionHandle));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mEventQueue是在SurfaceFlinger.onFirstRef中初始化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onFirstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    mEventQueue-&gt;<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::init</span><span class="params">(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">true</span>);</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="built_in">Handler</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Looper就是SurfaceFlinger主线程的Looper.</p><h3 id="1-1-1-Scheduler-createConnection"><a href="#1-1-1-Scheduler-createConnection" class="headerlink" title="1.1.1 Scheduler.createConnection"></a>1.1.1 Scheduler.createConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;Scheduler::ConnectionHandle&gt; <span class="title">Scheduler::createConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* connectionName, <span class="type">int64_t</span> phaseOffsetNs, ResyncCallback resyncCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">        impl::EventThread::InterceptVSyncsCallback interceptCallback)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> id = sNextId++;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating a connection handle with ID: %&quot;</span> PRId64 <span class="string">&quot;\n&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 sfEventThread</span></span><br><span class="line">    std::unique_ptr&lt;EventThread&gt; eventThread =</span><br><span class="line">            <span class="built_in">makeEventThread</span>(connectionName, mPrimaryDispSync.<span class="built_in">get</span>(), phaseOffsetNs,</span><br><span class="line">                            std::<span class="built_in">move</span>(interceptCallback));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventThreadConnection</span></span><br><span class="line">    <span class="keyword">auto</span> eventThreadConnection =</span><br><span class="line">            <span class="built_in">createConnectionInternal</span>(eventThread.<span class="built_in">get</span>(), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">    <span class="comment">// 保存创建的connection</span></span><br><span class="line">    mConnections.<span class="built_in">emplace</span>(id,</span><br><span class="line">                         std::<span class="built_in">make_unique</span>&lt;Connection&gt;(<span class="keyword">new</span> <span class="built_in">ConnectionHandle</span>(id),</span><br><span class="line">                                                      eventThreadConnection,</span><br><span class="line">                                                      std::<span class="built_in">move</span>(eventThread)));</span><br><span class="line">    <span class="keyword">return</span> mConnections[id]-&gt;handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-EventThread-createEventConnection"><a href="#1-1-2-EventThread-createEventConnection" class="headerlink" title="1.1.2 EventThread.createEventConnection"></a>1.1.2 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建了 BitTube, 此时是在SurfaceFlinger主线程</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-MessageQueue-setEventConnection"><a href="#1-2-MessageQueue-setEventConnection" class="headerlink" title="1.2 MessageQueue.setEventConnection"></a>1.2 MessageQueue.setEventConnection</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEvents = connection;</span><br><span class="line">    <span class="comment">// 1.2.1 通过BitTube建立与SFEventThread的通信通道</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 有vsync事件会回调cb_eventReceiver事件</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mLooper就是SurfaceFlinger主线程的Looper.</p><h3 id="1-2-1-EventThreadConnection-stealReceiveChannel"><a href="#1-2-1-EventThreadConnection-stealReceiveChannel" class="headerlink" title="1.2.1 EventThreadConnection.stealReceiveChannel"></a>1.2.1 EventThreadConnection.stealReceiveChannel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mChannel就是[1.1.2]中新建的BitTube</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-SF-EventThread接收vsync"><a href="#二-SF-EventThread接收vsync" class="headerlink" title="二. SF EventThread接收vsync"></a>二. SF EventThread接收vsync</h1><p>上面我们知道了，当SFEventThread发出Vsync信号时，会通过BitTube发送该消息至SurfaceFlinger主线程，并调用MessageQueue.cb_eventReceiver方法处理。</p><h2 id="2-1-MessageQueue-cb-eventReceiver"><a href="#2-1-MessageQueue-cb-eventReceiver" class="headerlink" title="2.1 MessageQueue.cb_eventReceiver"></a>2.1 MessageQueue.cb_eventReceiver</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 读取消息内容</span></span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 只关心VSYNC消息</span></span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="comment">// 2.2 触发composition</span></span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-MessageQueue-Handler-dispatchInvalidate"><a href="#2-2-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="2.2 MessageQueue.Handler.dispatchInvalidate"></a>2.2 MessageQueue.Handler.dispatchInvalidate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里通过Looper发送INVALIDATE消息</span></span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            <span class="comment">// 处理INVALIDATE消息</span></span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-SurfaceFlinger-onMessageReceived"><a href="#2-3-SurfaceFlinger-onMessageReceived" class="headerlink" title="2.3 SurfaceFlinger.onMessageReceived"></a>2.3 SurfaceFlinger.onMessageReceived</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="type">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            <span class="comment">// 通过fence机制来判断是否掉帧 </span></span><br><span class="line">            <span class="type">bool</span> frameMissed = <span class="built_in">previousFrameMissed</span>();</span><br><span class="line">            <span class="type">bool</span> hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="type">bool</span> gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;FrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;HwcFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(hwcFrameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;GpuFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(gpuFrameMissed));</span><br><span class="line">            <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line">                mFrameMissedCount++;</span><br><span class="line">                mTimeStats-&gt;<span class="built_in">incrementMissedFrames</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hwcFrameMissed) &#123;</span><br><span class="line">                mHwcFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gpuFrameMissed) &#123;</span><br><span class="line">                mGpuFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行相关参数更新，比如Vsync切换</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">performSetActiveConfig</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果丢帧，则不处理此次VSYNC</span></span><br><span class="line">            <span class="keyword">if</span> (frameMissed &amp;&amp; mPropagateBackpressure) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) ||</span><br><span class="line">                    mPropagateBackpressureClientComposition) &#123;</span><br><span class="line">                    <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">// transaction主要针对Layer和Display的变化更新脏区域</span></span><br><span class="line">            <span class="comment">// 通过Layer的变化来计算脏区域，目的是需要更新我才刷新</span></span><br><span class="line">            <span class="type">bool</span> refreshNeeded = <span class="built_in">handleMessageTransaction</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 主要是调用handlePageFlip()函数，该函数在systrace图上对应latchBuffer及其所包含的方法。</span></span><br><span class="line">            <span class="comment">// 作用是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域</span></span><br><span class="line">            <span class="comment">// 并且把GraphicBuffer映射为OpenGL的texture</span></span><br><span class="line">            refreshNeeded |= <span class="built_in">handleMessageInvalidate</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">updateCursorAsync</span>();</span><br><span class="line">            <span class="built_in">updateInputFlinger</span>();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">// 发送刷新合成请求</span></span><br><span class="line">                <span class="built_in">signalRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDolphinFuncsEnabled) &#123;</span><br><span class="line">                <span class="built_in">mDolphinRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.6 SF 处理合成</span></span><br><span class="line">            <span class="built_in">handleMessageRefresh</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先忽略Fence机制，先看看大致流程。</p><h2 id="2-4-SurfaceFlinger-handleMessageInvalidate"><a href="#2-4-SurfaceFlinger-handleMessageInvalidate" class="headerlink" title="2.4 SurfaceFlinger.handleMessageInvalidate"></a>2.4 SurfaceFlinger.handleMessageInvalidate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="type">bool</span> refreshNeeded = <span class="built_in">handlePageFlip</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty) &#123;</span><br><span class="line">        <span class="built_in">computeLayerBounds</span>();</span><br><span class="line">        <span class="keyword">if</span> (mTracingEnabled) &#123;</span><br><span class="line">            mTracing.<span class="built_in">notify</span>(<span class="string">&quot;visibleRegionsDirty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh) &#123;</span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">        <span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRefresh.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-SurfaceFlinger-handlePageFlip"><a href="#2-5-SurfaceFlinger-handlePageFlip" class="headerlink" title="2.5 SurfaceFlinger.handlePageFlip"></a>2.5 SurfaceFlinger.handlePageFlip</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;handlePageFlip&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> latchTime = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储需要更新的图层集。 当缓冲区被锁存时，不得更改，因为可能导致死锁。</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">            frameQueued = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">nsecs_t</span> expectedPresentTime;</span><br><span class="line">            expectedPresentTime = mScheduler-&gt;<span class="built_in">expectedPresentTime</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">shouldPresentNow</span>(expectedPresentTime)) &#123;</span><br><span class="line">                <span class="comment">// mLayersWithQueuedFrames用于标记那些已经有Frame的Layer</span></span><br><span class="line">                mLayersWithQueuedFrames.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;!layer-&gt;shouldPresentNow()&quot;</span>);</span><br><span class="line">                layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mLayersWithQueuedFrames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// mStateLock is needed for latchBuffer as LayerRejecter::reject()</span></span><br><span class="line">        <span class="comment">// writes to Layer current state. See also b/119481871</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime)) &#123;</span><br><span class="line">                mLayersPendingRefresh.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;<span class="built_in">useSurfaceDamage</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">isBufferLatched</span>()) &#123;</span><br><span class="line">                newDataLatched = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line">    <span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line">    <span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line">    <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.<span class="built_in">empty</span>() || !newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enter boot animation on first buffer latch</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Enter boot animation&quot;</span>);</span><br><span class="line">        mBootStage = BootStage::BOOTANIMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line">    <span class="keyword">return</span> !mLayersWithQueuedFrames.<span class="built_in">empty</span>() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-SurfaceFlinger-handleMessageRefresh"><a href="#2-6-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="2.6 SurfaceFlinger.handleMessageRefresh"></a>2.6 SurfaceFlinger.handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建layer堆栈, 提取可见的Laye并计算可见区域，为合成准备好数据材料。</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hwcomposer的设定</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); <span class="comment">//正式的合成处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line">    <span class="comment">// 将图像传递到物理屏幕。但是在下一个vsync信号才被消费。</span></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再继续分析之前，我们需要先了解Layer的结构，以及他是如何被添加至SurfaceFlinger中的。</p><h1 id="三-Layer的产生"><a href="#三-Layer的产生" class="headerlink" title="三. Layer的产生"></a>三. Layer的产生</h1><p>Layer, 即图层。Layer是图像合成中最重要的单元。图层是Surface和SurfaceControl的组合。<br>说到底也就是每个Window都有对应Surface，也就对应一个Layer;SurfaceFlinger的合成就是将所有图层按照顺序和特定属性合成一帧画面。<br>每个图层都有一组属性，用于定义它与其他图层的交互方式。 </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Positional</td><td>定义图层在其显示屏上显示的位置。 包括诸如图层边缘的位置及其相对于其他图层的Z顺序的信息</td></tr><tr><td>Content</td><td>定义图层上显示的内容应如何在位置属性定义的边界内显示。 包括裁剪和变换等信息</td></tr><tr><td>Composition</td><td>定义图层应如何与其他图层合成。 包括混合模式和alpha合成的图层范围Alpha值等信息</td></tr><tr><td>Optimization</td><td>提供正确合成图层非必要的信息，但硬件编写器（HWC）设备可以使用该信息来优化其执行合成的方式。 包括诸如图层的可见区域以及自上一帧以来图层的哪个部分已更新的信息。</td></tr></tbody></table><p>在创建Window或者Window产生变化时就会更新对应的Surface所属的Layer.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">    WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">    WindowManagerService.createSurfaceControl(...) --[SystemServer进程]</span><br><span class="line">    WindowStateAnimator.createSurfaceLocked(...) --[SystemServer进程] 这里传入Surface的FLAG</span><br><span class="line">    WindowSurfaceController.new() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface(WindowContainer) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Builder.build() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.new() --[SystemServer进程]</span><br><span class="line">        android_view_SurfaceControl:nativeCreate() --[JNI][SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:getDefault() --[SystemServer进程]</span><br><span class="line">            DefaultComposerClient:getComposerClient() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:onFirstRef() --[SystemServer进程]通过Binder从SF获取SurfaceComposerClient</span><br><span class="line">                SurfaceFlinger:createConnection() --[SurfaceFlinger进程] 创建SurfaceComposerClient</span><br><span class="line">        SurfaceComposerClient:createSurfaceChecked(...) --[SystemServer进程]Binder调用</span><br><span class="line">        Client:createSurface(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlinger:createLayer(...) --[SurfaceFlinger进程] 这里假设创建一个默认Surface</span><br><span class="line">            SurfaceFlinger:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlingerFactory:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            BufferQueueLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">                BufferLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">        SurfaceControl:<span class="keyword">new</span>(...) --[SystemServer进程]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_1.png" alt="图片"></p><p>Surface FLAG一览</p><table><thead><tr><th>名称</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>HIDDEN</td><td>0x00000004</td><td>Surface是隐藏的</td></tr><tr><td>SECURE</td><td>0x00000080</td><td>包含安全内容，禁止内容被其他进程复制。而且屏幕截图和VNC服务器将被禁用，但可能不会采用硬件加速。Window带有FLAG_SECURE标签，或者该应用禁止截图就会带有这个FLAG</td></tr><tr><td>NON_PREMULTIPLIED</td><td>0x00000100</td><td>预乘透明度，创建一个Surface，其中颜色分量被Alpha通道解释为“非预乘”。对于没有alpha通道的Surface，这个标志是没有意义的。 默认情况下，Surface是预乘的，这意味着每个颜色分量已经乘以其alpha值。</td></tr><tr><td>OPAQUE</td><td>0x00000400</td><td>表示Surface必须为不透明，即使其像素格式包含Alpha通道。</td></tr><tr><td>PROTECTED_APP</td><td>0x00000800</td><td>应用程序需要通过外部显示接收器的硬件保护路径。 如果硬件保护路径不可用，则此表面将不会显示在外部接收器上。</td></tr><tr><td>CURSOR_WINDOW</td><td>0x00002000</td><td>窗口表示光标字形。</td></tr><tr><td>FX_SURFACE_NORMAL</td><td>0x00000000</td><td>创建一个默认Surface</td></tr><tr><td>FX_SURFACE_DIM</td><td>0x00020000</td><td>创建一个暗淡的Surface。 此Surface后面的所有内容都会被{@link #setAlpha}中指定的数量调暗。 锁定Dim Surface是错误的，因为它没有后备存储。</td></tr><tr><td>FX_SURFACE_CONTAINER</td><td>创建容器Surface。 此Surface将没有缓冲区，仅用作其他Surface或其InputInfo的容器。</td><td></td></tr><tr><td>SURFACE_HIDDEN</td><td>0x01</td><td>隐藏该Surface, 等同于调用Surface.hide()</td></tr><tr><td>SURFACE_OPAQUE</td><td>0x02</td><td>尽可能不混合的复合材料。 更新Surface创建期间设置的值（请参阅{@link #OPAQUE}）。</td></tr></tbody></table><h2 id="3-1-SurfaceFlinger-createLayer"><a href="#3-1-SurfaceFlinger-createLayer" class="headerlink" title="3.1 SurfaceFlinger:createLayer"></a>3.1 SurfaceFlinger:createLayer</h2><p>当上次Window变化时，或者会创建Layer，并保存在SurfaceFlinger中.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 假设创建默认的Surface</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">            result = <span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                            format, handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 检查是否有访问SurfaceFlinger的权限</span></span><br><span class="line">    <span class="type">bool</span> addToCurrentState = <span class="built_in">callingThreadHasUnscopedSurfaceFlingerAccess</span>();</span><br><span class="line">    <span class="comment">// 3.2 保存新建的Layer</span></span><br><span class="line">    result = <span class="built_in">addClientLayer</span>(client, *handle, *gbp, layer, parentHandle, parentLayer,</span><br><span class="line">                            addToCurrentState);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-SurfaceFlinger-createBufferQueueLayer"><a href="#3-1-1-SurfaceFlinger-createBufferQueueLayer" class="headerlink" title="3.1.1 SurfaceFlinger.createBufferQueueLayer"></a>3.1.1 SurfaceFlinger.createBufferQueueLayer</h3><p>中间细琐流程略过，最终是创建了一个Layer对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Layer::<span class="built_in">Layer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">      : <span class="built_in">mFlinger</span>(args.flinger),</span><br><span class="line">        <span class="built_in">mName</span>(args.name),</span><br><span class="line">        <span class="built_in">mClientRef</span>(args.client),</span><br><span class="line">        <span class="built_in">mWindowType</span>(args.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>)) &#123;</span><br><span class="line">    mCurrentCrop.<span class="built_in">makeInvalid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> layerFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eHidden) layerFlags |= <span class="type">layer_state_t</span>::eLayerHidden;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eOpaque) layerFlags |= <span class="type">layer_state_t</span>::eLayerOpaque;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eSecure) layerFlags |= <span class="type">layer_state_t</span>::eLayerSecure;</span><br><span class="line"></span><br><span class="line">    mTransactionName = <span class="built_in">String8</span>(<span class="string">&quot;TX - &quot;</span>) + mName;</span><br><span class="line"></span><br><span class="line">    mCurrentState.active_legacy.w = args.w;</span><br><span class="line">    mCurrentState.active_legacy.h = args.h;</span><br><span class="line">    mCurrentState.flags = layerFlags;</span><br><span class="line">    mCurrentState.active_legacy.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.crop_legacy.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.requestedCrop_legacy = mCurrentState.crop_legacy;</span><br><span class="line">    mCurrentState.z = <span class="number">0</span>; <span class="comment">// 这里就是layer在Z轴的位置</span></span><br><span class="line">    mCurrentState.color.a = <span class="number">1.0f</span>;</span><br><span class="line">    mCurrentState.layerStack = <span class="number">0</span>; <span class="comment">// layer所在layerStack</span></span><br><span class="line">    mCurrentState.sequence = <span class="number">0</span>; <span class="comment">// layer序号</span></span><br><span class="line">    mCurrentState.requested_legacy = mCurrentState.active_legacy;</span><br><span class="line">    mCurrentState.active.w = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.h = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.transform = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.transformToDisplayInverse = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.crop.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.acquireFence = <span class="keyword">new</span> <span class="built_in">Fence</span>(<span class="number">-1</span>);</span><br><span class="line">    mCurrentState.dataspace = ui::Dataspace::UNKNOWN;</span><br><span class="line">    mCurrentState.hdrMetadata.validTypes = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.surfaceDamageRegion.<span class="built_in">clear</span>();</span><br><span class="line">    mCurrentState.cornerRadius = <span class="number">0.0f</span>;</span><br><span class="line">    mCurrentState.api = <span class="number">-1</span>;</span><br><span class="line">    mCurrentState.hasColorTransform = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.colorSpaceAgnostic = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.metadata = args.metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drawing state &amp; current state are identical</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    CompositorTiming compositorTiming;</span><br><span class="line">    args.flinger-&gt;<span class="built_in">getCompositorTiming</span>(&amp;compositorTiming);</span><br><span class="line">    mFrameEventHistory.<span class="built_in">initializeCompositorTiming</span>(compositorTiming);</span><br><span class="line">    mFrameTracker.<span class="built_in">setDisplayRefreshPeriod</span>(compositorTiming.interval);</span><br><span class="line"></span><br><span class="line">    mSchedulerLayerHandle = mFlinger-&gt;mScheduler-&gt;<span class="built_in">registerLayer</span>(mName.<span class="built_in">c_str</span>(), mWindowType);</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;<span class="built_in">onLayerCreated</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注的是：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>z</td><td>z-order，表示x,y,z轴的z轴上的顺序。数字越大，表示越在上面，数字越小，表示越在下面。</td></tr><tr><td>layerStack</td><td>layerStack是存储layer的容器,我们知道每个display只会有一个layerstack来存储他要显示的layer,但是不同的display可以使用同一个layerStack,也可以使用不同的layerStack。可以理解为组的含义。也就是说属于不同组的layer之间互不干扰。SurfaceFlinger中有一个DisplayDevice类，他表示用来显示的设备，譬如LCD或者是HDMI。DisplayDevice里也有一个成员变量mLayerStack，在进行composition的时候，只有和这个device的layerstack相同的layer才可能被显示在这个设备上。</td></tr><tr><td>sequence</td><td>sSequence是一个static的变量，所以递加的效果就是为每一个layer设置一个唯一且递增的序列号。</td></tr></tbody></table><h2 id="3-2-SurfaceFlinger-addClientLayer"><a href="#3-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2 SurfaceFlinger.addClientLayer"></a>3.2 SurfaceFlinger.addClientLayer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">const</span> sp&lt;IBinder&gt;&amp; handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc, <span class="type">const</span> sp&lt;Layer&gt;&amp; lbc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer, <span class="type">bool</span> addToCurrentState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// add this layer to the current state list</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mStateLock);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToCurrentState) &#123;</span><br><span class="line">            <span class="comment">// 3.2.1 将新创建的Layer按照Z轴顺序存储至队列中</span></span><br><span class="line">            mCurrentState.layersSortedByZ.<span class="built_in">add</span>(lbc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gbc != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            mGraphicBufferProducerList.<span class="built_in">insert</span>(IInterface::<span class="built_in">asBinder</span>(gbc).<span class="built_in">get</span>());</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mGraphicBufferProducerList.<span class="built_in">size</span>() &gt;</span><br><span class="line">                                        mMaxGraphicBufferProducerListSize,</span><br><span class="line">                                <span class="string">&quot;Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers&quot;</span>,</span><br><span class="line">                                mGraphicBufferProducerList.<span class="built_in">size</span>(),</span><br><span class="line">                                mMaxGraphicBufferProducerListSize, mNumLayers);</span><br><span class="line">        &#125;</span><br><span class="line">        mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.2 将该Layer保存至mClient的mLayers中,键为IBinder,供后续使用</span></span><br><span class="line">    client-&gt;<span class="built_in">attachLayer</span>(handle, lbc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞清楚Layer的Z轴顺序，对与我们理解Layer合成过程有很大帮助。<br>Layer排序建议参考：<a href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></p><h3 id="3-2-1-LayerVector-add"><a href="#3-2-1-LayerVector-add" class="headerlink" title="3.2.1 LayerVector.add"></a>3.2.1 LayerVector.add</h3><p>将新创建的Layer按照Z轴顺序存储至队列中.<br>LayerVector继承了SortedVector,并且重载了函数 do_compare.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LayerVector::do_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* lhs, <span class="type">const</span> <span class="type">void</span>* rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先对LayerStack排序，然后是Z轴排序，最后是序号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; l = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(lhs);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; r = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(rhs);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; lState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? l-&gt;<span class="built_in">getCurrentState</span>() : l-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; rState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? r-&gt;<span class="built_in">getCurrentState</span>() : r-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> ls = lState.layerStack;</span><br><span class="line">    <span class="type">uint32_t</span> rs = rState.layerStack;</span><br><span class="line">    <span class="keyword">if</span> (ls != rs)</span><br><span class="line">        <span class="keyword">return</span> (ls &gt; rs) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> lz = lState.z;</span><br><span class="line">    <span class="type">int32_t</span> rz = rState.z;</span><br><span class="line">    <span class="keyword">if</span> (lz != rz)</span><br><span class="line">        <span class="keyword">return</span> (lz &gt; rz) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;sequence == r-&gt;sequence)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (l-&gt;sequence &gt; r-&gt;sequence) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先比较layerstack，不同的layerstack分开。然后再比较z，假设都相同，就比较唯一的layer序列号。<br>但是至今为止，layerStack和z都还只是初始化时的0，所以在创建layer的时候，只是把他根据序列号放进layersSortedByZ而已，其实他的顺序还是没有设置的。</p><h3 id="3-2-2-SurfaceFlinger-addClientLayer"><a href="#3-2-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2.2 SurfaceFlinger:addClientLayer"></a>3.2.2 SurfaceFlinger:addClientLayer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Client::attachLayer</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLayers.<span class="built_in">add</span>(handle, layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Layer更新流程"><a href="#3-4-Layer更新流程" class="headerlink" title="3.4 Layer更新流程"></a>3.4 Layer更新流程</h2><p>当java层调用setLayer时就会确定对应Layer的Z-Order顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App进程]</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacement(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacementLoop() --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacement(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacementNoTrace(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">WindowManagerService.openSurfaceTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.openTransaction() --[SystemServer进程] 创建Transaction, 或者计数+<span class="number">1</span></span><br><span class="line">    android_view_SurfaceControl:nativeCreateTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">WindowManagerService.applySurfaceChangesTransaction(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.mergeToGlobalTransaction(Transaction) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.merge(Transaction) --[SystemServer进程]合并更新后的属性</span><br><span class="line">    android_view_SurfaceControl:nativeMergeTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:merge(Transaction) --[SystemServer进程]也就是保存新的属性</span><br><span class="line">WindowManagerService.closeSurfaceTransaction(String) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.closeTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.apply() --[SystemServer进程]</span><br><span class="line">    android_view_SurfaceControl:nativeApplyTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:apply(bool) --[SystemServer进程]</span><br><span class="line">    SurfaceFlinger:setTransactionState(...) --[SurfaceFlinger进程]传递更新后的属性到sf</span><br><span class="line">    SurfaceFlinger:applyTransactionState(...) --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:run() --[SurfaceFlinger进程]</span><br><span class="line">            TransactionCompletedThread:threadMain() --[SurfaceFlinger子线程]</span><br><span class="line">                mConditionVariable.wait(mMutex);<span class="comment">// 等待执行</span></span><br><span class="line">                TransactionCompletedListener:onTransactionCompleted(...)--[SurfaceFlinger子线程]</span><br><span class="line">        TransactionCompletedThread:addCallback() --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:sendCallbacks() --notify TransactionCompletedThread执行</span><br><span class="line">        SurfaceFlinger:setClientStateLocked(...) --[SurfaceFlinger进程]</span><br><span class="line">            Layer:setLayer(int32_t) --[SurfaceFlinger进程] 更新Layer所处Z轴的位置</span><br></pre></td></tr></table></figure><p>如图：<br><img src="/images/SurfaceFlinger-4-Layer-Surface/4_2.png" alt="图片"></p><p>到目前为止还只是创建了一个SurfaceControl，对应SurfaceFlinger中的BufferQueueLayer。<br>真正的Surface还没有被创建，那是什么时候创建的呢？</p><h1 id="四-Surface的生成"><a href="#四-Surface的生成" class="headerlink" title="四. Surface的生成"></a>四. Surface的生成</h1><p>一个ViewRootImpl对应一个Suface, 也就是一个Layer.<br>当我们创建了Layer之后，总要向其中填充数据内容，SurfaceFlinger才好做合成。<br>在RendererThread中，我们知道了Surface数据是通过渲染引擎OpenGL(android Q上是Vulkan)生成的。</p><h2 id="4-1-Suface的生成"><a href="#4-1-Suface的生成" class="headerlink" title="4.1 Suface的生成"></a>4.1 Suface的生成</h2><p>参阅：RenderThread深入分析(三)–绑定窗口对应的Surface到RenderThread的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals(...) --[App UI进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App UI进程]</span><br><span class="line">    mSurface.copyFrom(mSurfaceControl) 注意这里会将赋值mSurface</span><br><span class="line">    android_view_Surface:nativeCreateFromSurfaceControl(...) --[App UI进程]</span><br><span class="line">    SurfaceControl:createSurface() --[App UI进程]</span><br><span class="line">        SurfaceControl:generateSurfaceLocked()</span><br><span class="line">        Surface:<span class="keyword">new</span>() 这里创建了<span class="keyword">native</span> Surface</span><br><span class="line">ThreadedRenderer.initializeIfNeeded(...) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.initialize(Surface) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    HardwareRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    android_view_ThreadedRenderer:setSurface(...) --[App UI进程]</span><br><span class="line">        android_view_Surface:getSurface(...) --[App UI进程] 这里返回上面创建的<span class="keyword">native</span> Surface</span><br><span class="line">    RenderProxy:setSurface(Surface) --[App UI进程] 接下来转进RenderThread线程处理</span><br><span class="line">        CanvasContext:setSurface(...) --[RenderThread线程]</span><br><span class="line">        SkiaVulkanPipeline:setSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager:createSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanSurface:Create(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager.mGetPhysicalDeviceSurfaceCapabilitiesKHR(...)</span><br><span class="line">            获取Vulkan引擎中的Surface</span><br></pre></td></tr></table></figure><p>大致流程如下图：<br><img src="/images/SurfaceFlinger-4-Layer-Surface/4_3.png" alt="图片"></p><p>现在我们已经获取了渲染引擎中的Surface，向其中填充数据的过程就是performDraw的流程；<br>这个部分在RenderThread中有分析，不在赘述。</p><p>那当我们的Surface中已经被填充了数据后，是如何传递给SurfaceFlinger做合成的呢？<br>这个部分我们稍后详细分析，目前仅从trace上也可以看出来：</p><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_4_app.png" alt="图片"></p><p>上图中eglSwapBuffer最终就是通过binder通知到surfaceflinger中处理的：</p><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_4_sf.png" alt="图片"></p><h1 id="五-Layer实例"><a href="#五-Layer实例" class="headerlink" title="五. Layer实例"></a>五. Layer实例</h1><p>以如下图为例，看看对应Layer：</p><img src="/.io//screenshot_phone.png" width="100" hegiht="200" align="center"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Display 19260235133379457 HWC layers:</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> Layer name</span><br><span class="line">           Z |  Window Type |  Comp Type |  Transform |   Disp Frame (LTRB) |          Source Crop (LTRB)</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">  rel      0 |            1 |     DEVICE |          0 |    0    0 1080 2340 |    0.0    0.0 1080.0 2340.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> PopupWindow:b04e24#0</span><br><span class="line">  rel      0 |         1002 |     DEVICE |          0 |  646   56 1080  656 |    0.0    0.0  434.0  600.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> StatusBar#0</span><br><span class="line">  rel      0 |         2000 |     DEVICE |          0 |    0    0 1080   80 |    0.0    0.0 1080.0   80.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> NavigationBar0#0</span><br><span class="line">  rel      0 |         2019 |     DEVICE |          0 |    0 2214 1080 2340 |    0.0    0.0 1080.0  126.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlay#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0    0 1080  240 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlayBottom#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0 2100 1080 2340 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (5fd44db PopupWindow:b04e24#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        2, pos=(646,56), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ ContainerLayer (AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Task=5#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Task=5#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Stack=2#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;taskId:5&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Stack=2#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        5, pos=(0,0), size=(   0,   0), crop=[  0,   0, 1080, 2340], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        1, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Display Root#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Display Root#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000002, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=none</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br></pre></td></tr></table></figure><p>示意图如下：</p><p><img src="/images/SurfaceFlinger-4-Layer-Surface/screenshot_phone_layer.png" alt="图片"></p><p>总的来说就是，树形结构+Z order排序。</p><h1 id="六-类图"><a href="#六-类图" class="headerlink" title="六. 类图"></a>六. 类图</h1><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_5_classmap.png" alt="图片"></p><p>现在我们Surface有了，也有渲染的内容了，那SurfaceFlinger是如何将这些Surface对应的Layer合成为一帧并显示出来的呢?</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>[Android Synchronization Fences – An Introduction]<a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li><li>[Android中的GraphicBuffer同步机制-Fence]<a href="https://blog.csdn.net/jinzhuojun/article/details/39698317">https://blog.csdn.net/jinzhuojun/article/details/39698317</a></li><li>[深入浅出Android BufferQueue]<a href="https://blog.51cto.com/13591395/2380727">https://blog.51cto.com/13591395/2380727</a></li><li>[从systrace看app冷启动过程（三）-首帧的合成与送显]<a href="https://www.jianshu.com/p/3829158b4699">https://www.jianshu.com/p/3829158b4699</a></li><li>[Android显示Surface]<a href="https://www.jianshu.com/p/fc3c3d6f9bf7">https://www.jianshu.com/p/fc3c3d6f9bf7</a></li><li>[surfaceflinger中各个layer的排序]<a href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></li><li>[Android 4.0.3 显示系统深入理解]<a href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li><li>[Android窗口管理分析（3）：窗口分组及Z-order的确定]<a href="https://www.jianshu.com/p/90ede7b2a64a">https://www.jianshu.com/p/90ede7b2a64a</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Android Q&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。&lt;br&gt;接下来我们先看看SurfaceFlinger合成帧的部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(3)--AppEventThread接受vsync信号</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/</id>
    <published>2022-04-04T01:57:41.000Z</published>
    <updated>2022-04-04T02:28:58.320Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p>前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。</p><span id="more"></span><p>一图以概之：</p><p><img src="/images/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/3_1.png" alt="图片"></p><p>我们知道android app绘制是离不开编舞者 Choreographer 的，关于 Choreographer 这里就不赘叙，详细可以参考这篇博文。<br>接下来重点分析一下应用app进程是如何与sw vsync信号同步的。</p><h1 id="二-App进程与AppEventThread建立通信过程"><a href="#二-App进程与AppEventThread建立通信过程" class="headerlink" title="二. App进程与AppEventThread建立通信过程"></a>二. App进程与AppEventThread建立通信过程</h1><p>回忆一下，我们知道当应用进程的第一个具有布局的Activity启动时，会初始化Choreographer.</p><h2 id="2-1-Choerographer初始化"><a href="#2-1-Choerographer初始化" class="headerlink" title="2.1 Choerographer初始化"></a>2.1 Choerographer初始化</h2><p>Choerographer是个单例，意味着一个应用进程中只会存在一个实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread local storage for the choreographer.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Choreographer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主线程中初始化，注意传入的第二个参数 VSYNC_SOURCE_APP</span></span><br><span class="line">        <span class="comment">// 这个值是DisplayEventReceiver.VSYNC_SOURCE_APP 也就是 0</span></span><br><span class="line">        <span class="comment">// 与ISurfaceComposer.h中的VsyncSource.eVsyncSourceApp值保持同步</span></span><br><span class="line">        <span class="comment">// 代表的就是 AppEventThread.</span></span><br><span class="line">        <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">    <span class="comment">// 初始化 DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// USE_VSYNC 值默认为true，读取属性debug.choreographer.vsync</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-FrameDisplayEventReceiver初始化"><a href="#2-2-FrameDisplayEventReceiver初始化" class="headerlink" title="2.2 FrameDisplayEventReceiver初始化"></a>2.2 FrameDisplayEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(looper, vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameDisplayEventReceiver类继承了DisplayEventReceiver类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 转到jni层</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意FrameDisplayEventReceiver类是DisplayEventReceiver的子类。</p><h2 id="2-3-android-view-DisplayEventReceiver-cpp-nativeInit"><a href="#2-3-android-view-DisplayEventReceiver-cpp-nativeInit" class="headerlink" title="2.3 android_view_DisplayEventReceiver.cpp:nativeInit"></a>2.3 android_view_DisplayEventReceiver.cpp:nativeInit</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject messageQueueObj, jint vsyncSource)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = <span class="built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;MessageQueue is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.4 根据传入的参数初始化NativeDisplayEventReceiver</span></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> <span class="built_in">NativeDisplayEventReceiver</span>(env,</span><br><span class="line">            receiverWeak, messageQueue, vsyncSource);</span><br><span class="line">    <span class="comment">// 2.8 连接BitTube通信信道</span></span><br><span class="line">    <span class="type">status_t</span> status = receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.<span class="built_in">appendFormat</span>(<span class="string">&quot;Failed to initialize display event receiver.  status=%d&quot;</span>, status);</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;<span class="built_in">incStrong</span>(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-NativeDisplayEventReceiver-初始化"><a href="#2-4-NativeDisplayEventReceiver-初始化" class="headerlink" title="2.4 NativeDisplayEventReceiver 初始化"></a>2.4 NativeDisplayEventReceiver 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver::<span class="built_in">NativeDisplayEventReceiver</span>(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource) :</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="built_in">DisplayEventDispatcher</span>(messageQueue-&gt;<span class="built_in">getLooper</span>(),</span><br><span class="line">                <span class="comment">// 将传入的vsyncSource（0）强制转换为VsyncSource.eVsyncSourceApp</span></span><br><span class="line">                <span class="built_in">static_cast</span>&lt;ISurfaceComposer::VsyncSource&gt;(vsyncSource)),</span><br><span class="line">        <span class="built_in">mReceiverWeakGlobal</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(receiverWeak)),</span><br><span class="line">        <span class="built_in">mMessageQueue</span>(messageQueue) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Initializing display event receiver.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeDisplayEventReceiver 继承了 DisplayEventDispatcher。</p><h2 id="2-5-DisplayEventDispatcher-初始化"><a href="#2-5-DisplayEventDispatcher-初始化" class="headerlink" title="2.5 DisplayEventDispatcher 初始化"></a>2.5 DisplayEventDispatcher 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventDispatcher::<span class="built_in">DisplayEventDispatcher</span>(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper,</span><br><span class="line">        ISurfaceComposer::VsyncSource vsyncSource) :</span><br><span class="line">        <span class="comment">// 这里的looper是app主线程的looper，mReceiver是我们所寻找的纽带</span></span><br><span class="line">        <span class="built_in">mLooper</span>(looper), <span class="built_in">mReceiver</span>(vsyncSource), <span class="built_in">mWaitingForVsync</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Initializing display event dispatcher.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mReceiver是DisplayEventReceiver类型。</p><h2 id="2-6-DisplayEventReceiver初始化"><a href="#2-6-DisplayEventReceiver初始化" class="headerlink" title="2.6 DisplayEventReceiver初始化"></a>2.6 DisplayEventReceiver初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::<span class="built_in">DisplayEventReceiver</span>(ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// vsyncSource就是VsyncSource.eVsyncSourceApp</span></span><br><span class="line">        <span class="comment">// 2.6.1 通过binder通信，在surfaceFlinger中创建DisplayEventConnection</span></span><br><span class="line">        mEventConnection = sf-&gt;<span class="built_in">createDisplayEventConnection</span>(vsyncSource);</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.7 取出EventThread类中新创建的BitTube的Fd（文件描述符表索引）</span></span><br><span class="line">            mDataChannel = std::<span class="built_in">make_unique</span>&lt;gui::BitTube&gt;();</span><br><span class="line">            mEventConnection-&gt;<span class="built_in">stealReceiveChannel</span>(mDataChannel.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的博文中也分析了，这里的ComposerService就是获取的SurfaceFlinger服务。</p><h3 id="2-6-1-SurfaceFlinger-createDisplayEventConnection"><a href="#2-6-1-SurfaceFlinger-createDisplayEventConnection" class="headerlink" title="2.6.1 SurfaceFlinger.createDisplayEventConnection"></a>2.6.1 SurfaceFlinger.createDisplayEventConnection</h3><p>进入SurfaceFlinger主线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ISurfaceComposer::VsyncSource vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> resyncCallback = mScheduler-&gt;<span class="built_in">makeResyncCallback</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">        Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里的handle为mAppConnectionHandle</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; handle =</span><br><span class="line">            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;</span><br><span class="line">    <span class="comment">// 2.6.2 创建连接</span></span><br><span class="line">    <span class="keyword">return</span> mScheduler-&gt;<span class="built_in">createDisplayEventConnection</span>(handle, std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-Scheduler-cpp-createDisplayEventConnection"><a href="#2-6-2-Scheduler-cpp-createDisplayEventConnection" class="headerlink" title="2.6.2 Scheduler.cpp:createDisplayEventConnection"></a>2.6.2 Scheduler.cpp:createDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">Scheduler::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;Scheduler::ConnectionHandle&gt;&amp; handle, ResyncCallback resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_VALUE_IF_INVALID</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// mConnections是map类型，key值表示对应的EventThread类型</span></span><br><span class="line">    <span class="comment">// 这个初始化就是在SurfaceFlinger.init方法内，创建EventThread时同步生成的</span></span><br><span class="line">    <span class="comment">// 最终mConnections[handle-&gt;id]-&gt;thread.get()拿到的就是AppEventThread</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">createConnectionInternal</span>(mConnections[handle-&gt;id]-&gt;thread.<span class="built_in">get</span>(),</span><br><span class="line">                                    std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里传入的eventThread就是appEventThread</span></span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里mConnections[handle-&gt;id]-&gt;thread.get()拿到的是handle对应的EventThread.</p><h3 id="2-6-3-EventThread-createEventConnection"><a href="#2-6-3-EventThread-createEventConnection" class="headerlink" title="2.6.3 EventThread.createEventConnection"></a>2.6.3 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建的BitTube管道</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure><p>创建EventThreadConnection时新建了个BitTube管道，看来就是通信枢纽就是这个了。</p><p>注意到这个类有onFirstRef方法，在生成对象后，就会调用。</p><h3 id="2-6-4-EventThreadConnection-onFirstRef"><a href="#2-6-4-EventThreadConnection-onFirstRef" class="headerlink" title="2.6.4 EventThreadConnection.onFirstRef"></a>2.6.4 EventThreadConnection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThreadConnection::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-5-EventThread-registerDisplayEventConnection"><a href="#2-6-5-EventThread-registerDisplayEventConnection" class="headerlink" title="2.6.5 EventThread.registerDisplayEventConnection"></a>2.6.5 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should never happen</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(mDisplayEventConnections.<span class="built_in">cbegin</span>(),</span><br><span class="line">            mDisplayEventConnections.<span class="built_in">cend</span>(), connection);</span><br><span class="line">    <span class="keyword">if</span> (it != mDisplayEventConnections.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;DisplayEventConnection %p already exists&quot;</span>, connection.<span class="built_in">get</span>());</span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有新的连接了，就需要唤醒AppEventThread线程使能Vsync信号了。</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">push_back</span>(connection);</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在注意到我们仅仅是得到了一个BitTube，然而并没有用上这个管道。<br>接下来，回到[2.6 DisplayEventReceiver初始化] 创建DisplayEventReceiver的地方。</p><h2 id="2-7-EventThreadConnection-stealReceiveChannel"><a href="#2-7-EventThreadConnection-stealReceiveChannel" class="headerlink" title="2.7 EventThreadConnection.stealReceiveChannel"></a>2.7 EventThreadConnection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将新建的BitTube的Fd复制给outChannel, 也就是DisplayEventReceiver中的 mDataChannel.<br>虽然还是没有用上这个BitTube，不着急，继续看。</p><h2 id="2-8-BitTube信道连接过程"><a href="#2-8-BitTube信道连接过程" class="headerlink" title="2.8 BitTube信道连接过程"></a>2.8 BitTube信道连接过程</h2><h3 id="2-8-1-DisplayEventDispatcher-initialize"><a href="#2-8-1-DisplayEventDispatcher-initialize" class="headerlink" title="2.8.1 DisplayEventDispatcher.initialize"></a>2.8.1 DisplayEventDispatcher.initialize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventDispatcher::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mReceiver 就是DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// 这一步就是确认BitTube创建无误</span></span><br><span class="line">    <span class="type">status_t</span> result = mReceiver.<span class="built_in">initCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to initialize display event receiver, status=%d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个mLooper就是应用app进程的主线程Looper，所以这一步就是将</span></span><br><span class="line">    <span class="comment">// 创建的BitTube信道Fd添加到Looper中</span></span><br><span class="line">    <span class="type">int</span> rc = mLooper-&gt;<span class="built_in">addFd</span>(mReceiver.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个DisplayEventDispatcher是继承了LooperCallback, 所以这里的this方法就是handleEvent。</p><p>到这里这里整个Vsync流程已经跑通：</p><ol><li>SurfaceFlinger主线程收到硬件Vsync, 经过误差修正, 通知给DispSyncThread线程</li><li>DispSyncThread线程计算各个EventThread的SW Vsync信号时间并及时发出</li><li>AppEventThread收到sw Vsync信号，遍历各个Connection，调用sendEvent向对应BitTube管道发送事件</li><li>App进程的主线程收到事件，并处理</li></ol><p>接下来我们就看app收到sw vsync信号的处理过程。</p><h1 id="三-App进程收到SW-VSYNC信号"><a href="#三-App进程收到SW-VSYNC信号" class="headerlink" title="三. App进程收到SW VSYNC信号"></a>三. App进程收到SW VSYNC信号</h1><h2 id="3-1-DisplayEventDispatcher-handleEvent"><a href="#3-1-DisplayEventDispatcher-handleEvent" class="headerlink" title="3.1 DisplayEventDispatcher.handleEvent"></a>3.1 DisplayEventDispatcher.handleEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisplayEventDispatcher::handleEvent</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> events, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    PhysicalDisplayId vsyncDisplayId;</span><br><span class="line">    <span class="type">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="comment">// 3.1.1 读取BitTube管道中的数据，返回值为true表示读取到了数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">processPendingEvents</span>(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3.2 分发收到的sw vsync信号</span></span><br><span class="line">        <span class="built_in">dispatchVsync</span>(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-DisplayEventDispatcher-processPendingEvents"><a href="#3-1-1-DisplayEventDispatcher-processPendingEvents" class="headerlink" title="3.1.1 DisplayEventDispatcher.processPendingEvents"></a>3.1.1 DisplayEventDispatcher.processPendingEvents</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DisplayEventDispatcher::processPendingEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span>* outTimestamp, PhysicalDisplayId* outDisplayId, <span class="type">uint32_t</span>* outCount)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="comment">// 读取管道中的所有数据</span></span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.<span class="built_in">getEvents</span>(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Read %d events.&quot;</span>, <span class="keyword">this</span>, <span class="built_in">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// 拿到最新的sw vsync信号时间</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outDisplayId = ev.header.displayId;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                <span class="built_in">dispatchHotplug</span>(ev.header.timestamp, ev.header.displayId, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_CONFIG_CHANGED:</span><br><span class="line">                <span class="built_in">dispatchConfigChanged</span>(ev.header.timestamp, ev.header.displayId, ev.config.configId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;dispatcher %p ~ ignoring unknown event type %#x&quot;</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to get events from display event dispatcher, status=%d&quot;</span>, <span class="built_in">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-NativeDisplayEventReceiver-dispatchVsync"><a href="#3-2-NativeDisplayEventReceiver-dispatchVsync" class="headerlink" title="3.2 NativeDisplayEventReceiver.dispatchVsync"></a>3.2 NativeDisplayEventReceiver.dispatchVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="type">nsecs_t</span> timestamp, PhysicalDisplayId displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, jniGetReferent(env, mReceiverWeakGlobal))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Invoking vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, displayId, count);</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Returned from vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;dispatchVsync&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JNI回调到java层的DisplayEventReceiver.dispatchVsync方法</p><h2 id="3-3-DisplayEventReceiver-dispatchVsync"><a href="#3-3-DisplayEventReceiver-dispatchVsync" class="headerlink" title="3.3 DisplayEventReceiver.dispatchVsync"></a>3.3 DisplayEventReceiver.dispatchVsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    onVsync(timestampNanos, physicalDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考2.2中，这里的DisplayEventReceiver 对象就是其子类FrameDisplayEventReceiver的对象。</p><h2 id="3-4-FrameDisplayEventReceiver-onVsync"><a href="#3-4-FrameDisplayEventReceiver-onVsync" class="headerlink" title="3.4 FrameDisplayEventReceiver.onVsync"></a>3.4 FrameDisplayEventReceiver.onVsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    <span class="comment">// mHandler就是mFrameHandler，传入runnable立刻执行，也就是执行run里面的</span></span><br><span class="line">    <span class="comment">// doFrame方法。</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 进入Choreographer的绘图，接下来就是measure,layout,draw的过程了、</span></span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的VSYNC流程图如下：</p><p><img src="/images/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/Vsync.jpg" alt="图片"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li><li><a href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li><li><a href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h1&gt;&lt;p&gt;前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(2)--DispSync</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-2-DispSync/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-2-DispSync/</id>
    <published>2022-04-04T01:52:26.000Z</published>
    <updated>2022-04-04T02:28:38.138Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><h1 id="一-DispSync"><a href="#一-DispSync" class="headerlink" title="一. DispSync"></a>一. DispSync</h1><p>DispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。</p><p>接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。<br>我们先看DispSync线程的创建过程。</p><span id="more"></span><h1 id="二-DispSync初始化"><a href="#二-DispSync初始化" class="headerlink" title="二. DispSync初始化"></a>二. DispSync初始化</h1><h2 id="2-1-SurfaceFlinger"><a href="#2-1-SurfaceFlinger" class="headerlink" title="2.1 SurfaceFlinger"></a>2.1 SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFligner</span>(SurfaceFlinger::SkipInitializationTag)</span><br><span class="line">        :   <span class="built_in">BnSurfaceComposer</span>(),</span><br><span class="line">            <span class="built_in">mTransactionFlags</span>(<span class="number">0</span>),</span><br><span class="line">            ......</span><br><span class="line">            <span class="built_in">mPrimaryDispSync</span>(<span class="string">&quot;PrimaryDispSync&quot;</span>),</span><br><span class="line">            <span class="built_in">mPrimaryHWVsyncEnabled</span>(<span class="literal">false</span>),</span><br><span class="line">            ......</span><br><span class="line">            &#123;&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger初始化的时候创建的。</p><h2 id="2-2-DispSync创建"><a href="#2-2-DispSync创建" class="headerlink" title="2.2 DispSync创建"></a>2.2 DispSync创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DispSync::<span class="built_in">DispSync</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">      : <span class="built_in">mName</span>(name), <span class="built_in">mRefreshSkipCount</span>(<span class="number">0</span>), <span class="built_in">mThread</span>(<span class="keyword">new</span> <span class="built_in">DispSyncThread</span>(name)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DispSyncThread</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function">        : mName(name),</span></span><br><span class="line"><span class="function">        mStop(false),</span></span><br><span class="line"><span class="function">        mPeriod(<span class="number">0</span>), // 注意这里的mPeriod初始化为<span class="number">0</span></span></span><br><span class="line"><span class="function">        mPhase(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mReferenceTime(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mWakeupLatency(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mFrameNumber(<span class="number">0</span>) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-SurfaceFlinger-SurfaceFlinger"><a href="#2-3-SurfaceFlinger-SurfaceFlinger" class="headerlink" title="2.3 SurfaceFlinger::SurfaceFlinger"></a>2.3 SurfaceFlinger::SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFlinger</span>() : <span class="built_in">SurfaceFlinger</span>(SkipInitialization) &#123;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;SurfaceFlinger is starting&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    mPrimaryDispSync.<span class="built_in">init</span>(SurfaceFlinger::hasSyncFramework, </span><br><span class="line">            SurfaceFlinger::dispSyncPresentTimeOffset);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-DispSync-init"><a href="#2-4-DispSync-init" class="headerlink" title="2.4 DispSync.init"></a>2.4 DispSync.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::init</span><span class="params">(<span class="type">bool</span> hasSyncFramework, <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> </span>&#123;</span><br><span class="line">    mIgnorePresentFences = !hasSyncFramework;</span><br><span class="line">    mPresentTimeOffset = dispSyncPresentTimeOffset;</span><br><span class="line">    <span class="comment">// 线程改名为 DispSync，调整线程优先级</span></span><br><span class="line">    mThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;DispSync&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set DispSync to SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sched_setscheduler</span>(mThread-&gt;<span class="built_in">getTid</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for DispSyncThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re not getting present fences then the ZeroPhaseTracer</span></span><br><span class="line">        <span class="comment">// would prevent HW vsync event from ever being turned off.</span></span><br><span class="line">        <span class="comment">// Even if we&#x27;re just ignoring the fences, the zero-phase tracing is</span></span><br><span class="line">        <span class="comment">// not needed because any time there is an event registered we will</span></span><br><span class="line">        <span class="comment">// turn on the HW vsync events.</span></span><br><span class="line">        <span class="keyword">if</span> (!mIgnorePresentFences &amp;&amp; kEnableZeroPhaseTracer) &#123;</span><br><span class="line">            mZeroPhaseTracer = std::<span class="built_in">make_unique</span>&lt;ZeroPhaseTracer&gt;();</span><br><span class="line">            <span class="built_in">addEventListener</span>(<span class="string">&quot;ZeroPhaseTracer&quot;</span>, <span class="number">0</span>, mZeroPhaseTracer.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-DispSyncThread-threadLoop"><a href="#2-4-1-DispSyncThread-threadLoop" class="headerlink" title="2.4.1 DispSyncThread.threadLoop"></a>2.4.1 DispSyncThread.threadLoop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="comment">// 获取开机到现在的时长</span></span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于此时mPeriod为0，所以会进入该分支一直等待。</span></span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-enableVysncLocked后续"><a href="#三-enableVysncLocked后续" class="headerlink" title="三. enableVysncLocked后续"></a>三. enableVysncLocked后续</h1><p>SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked</p><h2 id="3-1-DispSync-addEventListener"><a href="#3-1-DispSync-addEventListener" class="headerlink" title="3.1 DispSync.addEventListener"></a>3.1 DispSync.addEventListener</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t DispSync::addEventListener(const char* name, nsecs_t phase, Callback* callback) &#123;</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    return mThread-&gt;addEventListener(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-DispSync-DispSyncThread-addEventListener"><a href="#3-2-DispSync-DispSyncThread-addEventListener" class="headerlink" title="3.2 DispSync.DispSyncThread.addEventListener"></a>3.2 DispSync.DispSyncThread.addEventListener</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, DispSync::Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEventListeners[i].mCallback == callback) &#123;</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventListener listener;</span><br><span class="line">    listener.mName = name;</span><br><span class="line">    listener.mPhase = phase;</span><br><span class="line">    listener.mCallback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to allow the firstmost future event to fire without</span></span><br><span class="line">    <span class="comment">// allowing any past events to fire</span></span><br><span class="line">    listener.mLastEventTime = <span class="built_in">systemTime</span>() - mPeriod / <span class="number">2</span> + mPhase - mWakeupLatency;</span><br><span class="line"></span><br><span class="line">    mEventListeners.<span class="built_in">push</span>(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threadLooper可以继续执行了</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里还是运行在SurfaceFlinger主线程，在mCond.signal之后，DispSync线程就可以继续执行了。<br>但是注意看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的continue意味着如果mPeriod为0，还是会一直等待。</p><h1 id="四-setPeriod"><a href="#四-setPeriod" class="headerlink" title="四. setPeriod"></a>四. setPeriod</h1><p>这样我们就需要看mPeriod是什么时候被更改的。<br>在SurfaceFlinger初始化Display后，会调用resyncToHardwareVsync跟硬件vsync进行同步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initializeDisplays();</span><br><span class="line">    flinger-&gt;onInitializeDisplays();</span><br><span class="line">        setPowerModeInternal()</span><br><span class="line">            resyncToHardwareVsync(true);</span><br><span class="line">                repaintEverything();</span><br></pre></td></tr></table></figure><h2 id="4-1-SurfaceFlinger-resyncToHardwareVsync"><a href="#4-1-SurfaceFlinger-resyncToHardwareVsync" class="headerlink" title="4.1 SurfaceFlinger.resyncToHardwareVsync"></a>4.1 SurfaceFlinger.resyncToHardwareVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">        <span class="comment">// mHWVsyncAvailable 表示 HW vsync 被 enable</span></span><br><span class="line">        mHWVsyncAvailable = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">        <span class="comment">// Hardware vsync is not currently available, so abort the resync</span></span><br><span class="line">        <span class="comment">// attempt for now</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得显示设备的刷新率，比如60HZ, 那么period就是16.6667ms,即每隔16.6667就会产生一个硬件vsync信号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; activeConfig = <span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">getActiveConfig</span>(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = activeConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是设置DispSync线程中的period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">// 4.2 设置period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mPrimaryHWVsyncEnabled表示当前的硬件vsync是否enable,</span></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        mPrimaryDispSync.<span class="built_in">beginResync</span>();</span><br><span class="line">        <span class="comment">// 如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC</span></span><br><span class="line">        <span class="comment">// 这个和DispSync的setVsyncEnabled是不一样的</span></span><br><span class="line">        <span class="comment">// 5.1 硬件Vsync控制</span></span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-DispSync-setPeriod"><a href="#4-2-DispSync-setPeriod" class="headerlink" title="4.2 DispSync.setPeriod"></a>4.2 DispSync.setPeriod</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::setPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = <span class="number">0</span>;</span><br><span class="line">    mReferenceTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Ignore recompute as mReferenceTime is zero.</span></span><br><span class="line">    <span class="comment">// mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mPeriod表示具体的硬件产生vsync的时间间隔。这样，之后的DispSync线程中的threadLoop就可以继续执行了。</p><h1 id="五-硬件Vsync的开关控制"><a href="#五-硬件Vsync的开关控制" class="headerlink" title="五. 硬件Vsync的开关控制"></a>五. 硬件Vsync的开关控制</h1><p>接上面 4.1，当设置DispSync的mPeriod之后，如果硬件Vsync开关是开启状态，则会通过EventControlThread打开HW Vsync<br>我们先看看EventControlThread线程的启动，其启动在SurfaceFlinger的初始化，EventThread启动之后，显示屏初始化之前。</p><h2 id="5-1-EventControlThread的启动"><a href="#5-1-EventControlThread的启动" class="headerlink" title="5.1 EventControlThread的启动"></a>5.1 EventControlThread的启动</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = std::<span class="built_in">make_unique</span>&lt;impl::EventControlThread&gt;(</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setVsyncEnabled</span>(HWC_DISPLAY_PRIMARY, enabled); &#125;);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化时传入了函数 setVsyncEnabled。</p><p>注意EventControlThread中线程的初始化是在成员变量中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be last so that everything is initialized before the thread starts.</span></span><br><span class="line">std::thread mThread&#123;&amp;EventControlThread::threadMain, <span class="keyword">this</span>&#125;;</span><br></pre></td></tr></table></figure><p>所以先调用threadMain，后调用构造函数。</p><h3 id="5-1-1-EventControlThread-threadMain"><a href="#5-1-1-EventControlThread-threadMain" class="headerlink" title="5.1.1 EventControlThread.threadMain"></a>5.1.1 EventControlThread.threadMain</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unfortunately std::unique_lock gives warnings with -Wthread-safety</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> keepRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> currentVsyncEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keepRunning) &#123;</span><br><span class="line">        <span class="comment">// 5.3 此时currentVsyncEnabled为false</span></span><br><span class="line">        <span class="built_in">mSetVSyncEnabled</span>(currentVsyncEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">// 在这里等待</span></span><br><span class="line">        mCondition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, currentVsyncEnabled, keepRunning]() NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">            <span class="keyword">return</span> currentVsyncEnabled != mVsyncEnabled || keepRunning != mKeepRunning;</span><br><span class="line">        &#125;);</span><br><span class="line">        currentVsyncEnabled = mVsyncEnabled;</span><br><span class="line">        keepRunning = mKeepRunning;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-EventControlThread初始化"><a href="#5-1-2-EventControlThread初始化" class="headerlink" title="5.1.2 EventControlThread初始化"></a>5.1.2 EventControlThread初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventControlThread::<span class="built_in">EventControlThread</span>(EventControlThread::SetVSyncEnabledFunction function)</span><br><span class="line">      : <span class="built_in">mSetVSyncEnabled</span>(function) &#123;</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), <span class="string">&quot;EventControlThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, tid, ANDROID_PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数里面设置了线程名和优先级</p><h2 id="5-2-EventControlThread-setVsyncEnabled"><a href="#5-2-EventControlThread-setVsyncEnabled" class="headerlink" title="5.2 EventControlThread.setVsyncEnabled"></a>5.2 EventControlThread.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::setVsyncEnabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mVsyncEnabled = enabled;</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mVsyncEnabled设置为true, 表明开启硬件Vsync.<br>mCondition.notify_all() 则通知EventControlThread线程继续执行，回到5.1.1的循环内。<br>mSetVSyncEnabled是传入的函数SurfaceFlinger.setVsyncEnabled.</p><h2 id="5-3-SurfaceFlinger-setVsyncEnabled"><a href="#5-3-SurfaceFlinger-setVsyncEnabled" class="headerlink" title="5.3 SurfaceFlinger.setVsyncEnabled"></a>5.3 SurfaceFlinger.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">getHwComposer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">getBE</span>().mHwc; &#125;</span><br><span class="line"><span class="function">SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br></pre></td></tr></table></figure><p>这里的disp &#x3D; HWC_DISPLAY_PRIMARY</p><h2 id="5-4-HWComposer-setVsyncEnabled"><a href="#5-4-HWComposer-setVsyncEnabled" class="headerlink" title="5.4 HWComposer.setVsyncEnabled"></a>5.4 HWComposer.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::setVsyncEnabled</span><span class="params">(DisplayId displayId, HWC2::Vsync enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_INVALID_DISPLAY</span>(displayId);</span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayData.isVirtual) &#123;</span><br><span class="line">        <span class="built_in">LOG_DISPLAY_ERROR</span>(displayId, <span class="string">&quot;Invalid operation on virtual display&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we use our own internal lock here because we have to call</span></span><br><span class="line">    <span class="comment">// into the HWC with the lock held, and we want to make sure</span></span><br><span class="line">    <span class="comment">// that even if HWC blocks (which it shouldn&#x27;t), it won&#x27;t</span></span><br><span class="line">    <span class="comment">// affect other threads.</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(displayData.vsyncEnabledLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enabled == displayData.vsyncEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">auto</span> error = displayData.hwcDisplay-&gt;<span class="built_in">setVsyncEnabled</span>(enabled);</span><br><span class="line">    <span class="built_in">RETURN_IF_HWC_ERROR</span>(error, displayId);</span><br><span class="line"></span><br><span class="line">    displayData.vsyncEnabled = enabled;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> tag = <span class="string">&quot;HW_VSYNC_ON_&quot;</span> + <span class="built_in">to_string</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(tag.<span class="built_in">c_str</span>(), enabled == HWC2::Vsync::Enable ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-硬件Vsync信号更新"><a href="#六-硬件Vsync信号更新" class="headerlink" title="六. 硬件Vsync信号更新"></a>六. 硬件Vsync信号更新</h1><p>经过HWComposer使能硬件Vsync信号后，只要有硬件Vsync信号产生，就可回调 hook_vsync函数。<br>hook_vsync函数在HWComposer的初始化的时候被注册的。</p><h2 id="6-1-HWC初始化"><a href="#6-1-HWC初始化" class="headerlink" title="6.1 HWC初始化"></a>6.1 HWC初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 获取硬件HWC</span><br><span class="line">    getBE().mHwc.reset(</span><br><span class="line">            new HWComposer(std::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));</span><br><span class="line">    // 注册回调</span><br><span class="line">    getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里这里先创建的是 Hwc2::impl::Composer,然后创建HWComposer</p><h3 id="6-1-1-ComposerHal-cpp-Composer"><a href="#6-1-1-ComposerHal-cpp-Composer" class="headerlink" title="6.1.1 ComposerHal.cpp:Composer"></a>6.1.1 ComposerHal.cpp:Composer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Composer::<span class="built_in">Composer</span>(<span class="type">const</span> std::string&amp; serviceName)</span><br><span class="line">    : <span class="built_in">mWriter</span>(kWriterInitialSize),</span><br><span class="line">      <span class="built_in">mIsUsingVrComposer</span>(serviceName == std::<span class="built_in">string</span>(<span class="string">&quot;vr&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    mComposer = V2_1::IComposer::<span class="built_in">getService</span>(serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mComposer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to get hwcomposer service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mComposer-&gt;<span class="built_in">createClient</span>(</span><br><span class="line">            [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="type">const</span> <span class="keyword">auto</span>&amp; tmpClient)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmpError == Error::NONE) &#123;</span><br><span class="line">                    mClient = tmpClient;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (mClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create composer client&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 support is optional</span></span><br><span class="line">    sp&lt;IComposer&gt; composer_2_2 = IComposer::<span class="built_in">castFrom</span>(mComposer);</span><br><span class="line">    <span class="keyword">if</span> (composer_2_2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mClient_2_2 = IComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mClient_2_2 == <span class="literal">nullptr</span>, <span class="string">&quot;IComposer 2.2 did not return IComposerClient 2.2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsUsingVrComposer) &#123;</span><br><span class="line">        sp&lt;IVrComposerClient&gt; vrClient = IVrComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="keyword">if</span> (vrClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create vr composer client&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取composer服务。</p><h3 id="6-1-2-HWComposer创建"><a href="#6-1-2-HWComposer创建" class="headerlink" title="6.1.2 HWComposer创建"></a>6.1.2 HWComposer创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::<span class="built_in">HWComposer</span>(std::unique_ptr&lt;android::Hwc2::Composer&gt; composer)</span><br><span class="line">      : <span class="built_in">mHwcDevice</span>(std::<span class="built_in">make_unique</span>&lt;HWC2::Device&gt;(std::<span class="built_in">move</span>(composer))) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-注册回调HWComposer-registerCallback"><a href="#6-2-注册回调HWComposer-registerCallback" class="headerlink" title="6.2 注册回调HWComposer.registerCallback"></a>6.2 注册回调HWComposer.registerCallback</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::registerCallback</span><span class="params">(HWC2::ComposerCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    mHwcDevice-&gt;<span class="built_in">registerCallback</span>(callback, sequenceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Device::registerCallback</span><span class="params">(ComposerCallback* callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRegisteredCallback) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Callback already registered. Ignored extra registration &quot;</span></span><br><span class="line">                <span class="string">&quot;attempt.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRegisteredCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">sp&lt;ComposerCallbackBridge&gt; <span class="title">callbackBridge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> ComposerCallbackBridge(callback, sequenceId))</span></span>;</span><br><span class="line">    mComposer-&gt;<span class="built_in">registerCallback</span>(callbackBridge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Composer::registerCallback</span><span class="params">(<span class="type">const</span> sp&lt;IComposerCallback&gt;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mClient就是composer服务在SurfaceFlinger中的客户端</span></span><br><span class="line">    <span class="keyword">auto</span> ret = mClient-&gt;<span class="built_in">registerCallback</span>(callback);</span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">isOk</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to register IComposerCallback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComposerCallbackBridge类就是实现onHotplug, onVsync等回调。<br>当HWC硬件产生vsync信号时，就会回调onVsync方法。</p><h2 id="6-3-Vsync信号更新"><a href="#6-3-Vsync信号更新" class="headerlink" title="6.3 Vsync信号更新"></a>6.3 Vsync信号更新</h2><h3 id="6-3-1-ComposerCallbackBridge-onVsync"><a href="#6-3-1-ComposerCallbackBridge-onVsync" class="headerlink" title="6.3.1 ComposerCallbackBridge.onVsync"></a>6.3.1 ComposerCallbackBridge.onVsync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onVsync</span><span class="params">(Hwc2::Display display, <span class="type">int64_t</span> timestamp)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mCallback-&gt;<span class="built_in">onVsyncReceived</span>(mSequenceId, display, timestamp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mCallback就是SurfaceFlinger[6.1].</p><h3 id="6-3-2-SurfaceFlinger-onVsyncReceived"><a href="#6-3-2-SurfaceFlinger-onVsyncReceived" class="headerlink" title="6.3.2 SurfaceFlinger.onVsyncReceived"></a>6.3.2 SurfaceFlinger.onVsyncReceived</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onVsyncReceived</span><span class="params">(<span class="type">int32_t</span> sequenceId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">hwc2_display_t</span> displayId, <span class="type">int64_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="comment">// Ignore any vsyncs from a previous hardware composer.</span></span><br><span class="line">    <span class="keyword">if</span> (sequenceId != <span class="built_in">getBE</span>().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> type;</span><br><span class="line">    <span class="comment">// 按条件决定是否过滤，记录此次HWC接收到的硬件Vsync</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">onVsync</span>(displayId, timestamp, &amp;type)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="comment">// DISPLAY_PRIMARY为0，mPrimaryHWVsyncEnabled为true</span></span><br><span class="line">        <span class="keyword">if</span> (type == DisplayDevice::DISPLAY_PRIMARY &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.<span class="built_in">addResyncSample</span>(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        <span class="built_in">enableHardwareVsync</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">disableHardwareVsync</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-3-DispSync-addResyncSample"><a href="#6-3-3-DispSync-addResyncSample" class="headerlink" title="6.3.3 DispSync.addResyncSample"></a>6.3.3 DispSync.addResyncSample</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DispSync::addResyncSample</span><span class="params">(<span class="type">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample(%&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>, mName, <span class="built_in">ns2us</span>(timestamp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MAX_RESYNC_SAMPLES = 32，即最大只保存32次硬件vsync时间戳，用来计算SW vsync模型.</span></span><br><span class="line">    <span class="comment">// mNumResyncSamples 表示已经有多少个硬件vsync 样本了 ，最多记录MAX_RESYNC_SAMPLES</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    mResyncSamples[idx] = timestamp;</span><br><span class="line">    <span class="comment">// 第一次收到Vsync信号，直接更新</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples == <span class="number">0</span>) &#123;</span><br><span class="line">        mPhase = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 参考时间设置为第一个硬件vsync的时间戳</span></span><br><span class="line">        mReferenceTime = timestamp;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] First resync sample: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = 0, &quot;</span></span><br><span class="line">              <span class="string">&quot;mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">              mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">        <span class="comment">// 6.3.5 通知更新DispSync线程收到Vsync信号</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新 mNumResyncSamples 或 mFirstResyncSample的值</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">        mNumResyncSamples++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFirstResyncSample = (mFirstResyncSample + <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.3.4 开始计算更新SW vsync 模型</span></span><br><span class="line">    <span class="built_in">updateModelLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">        <span class="built_in">resetErrorLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIgnorePresentFences) &#123;</span><br><span class="line">        <span class="comment">// If we don&#x27;t have the sync framework we will never have</span></span><br><span class="line">        <span class="comment">// addPresentFence called.  This means we have no way to know whether</span></span><br><span class="line">        <span class="comment">// or not we&#x27;re synchronized with the HW vsyncs, so we just request</span></span><br><span class="line">        <span class="comment">// that the HW vsync events be turned on whenever we need to generate</span></span><br><span class="line">        <span class="comment">// SW vsync events.</span></span><br><span class="line">        <span class="keyword">return</span> mThread-&gt;<span class="built_in">hasAnyEventListeners</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against kErrorThreshold / 2 to add some hysteresis before having to</span></span><br><span class="line">    <span class="comment">// resync again</span></span><br><span class="line">    <span class="type">bool</span> modelLocked = mModelUpdated &amp;&amp; mError &lt; (kErrorThreshold / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample returning %s&quot;</span>, mName, modelLocked ? <span class="string">&quot;locked&quot;</span> : <span class="string">&quot;unlocked&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !modelLocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是收到硬件Vsync信号, 在SurfaceFlinger主线程执行，在经过误差更正后，通知DispSync线程处理分发事件。</p><h3 id="6-3-4-DispSync-updateModelLocked"><a href="#6-3-4-DispSync-updateModelLocked" class="headerlink" title="6.3.4 DispSync.updateModelLocked"></a>6.3.4 DispSync.updateModelLocked</h3><p>这一步是计算模型参数如偏移、硬件Vsync更新间隔等。在分析前，我们先了解下几个重要参数的含义：</p><table><thead><tr><th>参数名</th><th>默认值</th><th>含义</th></tr></thead><tbody><tr><td>mNumResyncSamples</td><td>-</td><td>当前保存的硬件Vsyc信号数量，最大值为32</td></tr><tr><td>MIN_RESYNC_SAMPLES_FOR_UPDATE</td><td>6</td><td>更新模型参数的最小硬件Vsync数量</td></tr><tr><td>mPeriod</td><td>-</td><td>硬件刷新率，根据保存的Vsync去掉最大和最小求得的平均值</td></tr><tr><td>mPhase</td><td>-</td><td>偏移时间，仅作为针对mPeriod的一个偏移</td></tr><tr><td>mReferenceTime</td><td>第一个硬件Vsync事件</td><td>每次计算sw vsync模型时的基准时间，以减少误差</td></tr><tr><td>mRefreshSkipCount</td><td>0</td><td>多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::updateModelLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);</span><br><span class="line">    <span class="comment">// MIN_RESYNC_SAMPLES_FOR_UPDATE = 6, 也就是收到6次硬件Vsync之后，开始计算sw vsync模型</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Computing...&quot;</span>, mName);</span><br><span class="line">        <span class="type">nsecs_t</span> durationSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> minDuration = INT64_MAX;</span><br><span class="line">        <span class="type">nsecs_t</span> maxDuration = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里计算总时长，以及拿到最长和最短的硬件vsync间隔</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">            durationSum += duration;</span><br><span class="line">            minDuration = <span class="built_in">min</span>(minDuration, duration);</span><br><span class="line">            maxDuration = <span class="built_in">max</span>(maxDuration, duration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算平均间隔，去掉一个最大和一个最小的间隔</span></span><br><span class="line">        durationSum -= minDuration + maxDuration;</span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPeriod = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPeriod));</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> sampleAvgX = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> sampleAvgY = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="built_in">double</span>(mPeriod);</span><br><span class="line">        <span class="comment">// 跳过第一个Vsync，因为第一个Vsync已经更新到DispSync中了。</span></span><br><span class="line">        <span class="comment">// mReferenceTime是第一个Vsync的时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;</span><br><span class="line">            <span class="type">double</span> samplePhase = <span class="built_in">double</span>(sample % mPeriod) * scale;</span><br><span class="line">            sampleAvgX += <span class="built_in">cos</span>(samplePhase);</span><br><span class="line">            sampleAvgY += <span class="built_in">sin</span>(samplePhase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sampleAvgX /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line">        sampleAvgY /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        mPhase = <span class="built_in">nsecs_t</span>(<span class="built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        <span class="comment">// 如果偏移值是负值，绝对值超过了mPeroid的一半</span></span><br><span class="line">        <span class="comment">// 则调整偏移值为对应正值</span></span><br><span class="line">        <span class="keyword">if</span> (mPhase &lt; -(mPeriod / <span class="number">2</span>)) &#123;</span><br><span class="line">            mPhase += mPeriod;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Period&quot;</span>, mPeriod);</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Phase&quot;</span>, mPhase + mPeriod / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mRefreshSkipCount表示多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</span></span><br><span class="line">        mPeriod += mPeriod * mRefreshSkipCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.3.5 更新sw model. 这个方法会唤醒DispSync线程</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">        mModelUpdated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里算偏移还用上了反三角函数。mPeriod的含义就是圆周长，最终算出来的 mPhase 就是弧BC的长度。<br>也就是基于mPeriod的偏移值，如下图：</p><p><img src="/images/SurfaceFlinger-2-DispSync/2_1.png" alt="图片"></p><p>这个偏移值有什么用处呢？</p><h3 id="6-3-5-DispSync-DispSyncThread-updateModel"><a href="#6-3-5-DispSync-DispSyncThread-updateModel" class="headerlink" title="6.3.5 DispSync.DispSyncThread.updateModel"></a>6.3.5 DispSync.DispSyncThread.updateModel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateModel</span><span class="params">(<span class="type">nsecs_t</span> period, <span class="type">nsecs_t</span> phase, <span class="type">nsecs_t</span> referenceTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = phase;</span><br><span class="line">    mReferenceTime = referenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModel: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = %&quot;</span> PRId64</span><br><span class="line">          <span class="string">&quot; mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">          mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mPhase), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">    <span class="comment">// 这里通知正在等待的DispSync线程开始执行</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新mPeriod和时间戳。<br>mCond.signal 后转DispSyncThread线程[2.4.1]DispSyncThread.threadLoop继续执行</p><h1 id="七-SW-Vsync更新"><a href="#七-SW-Vsync更新" class="headerlink" title="七. SW Vsync更新"></a>七. SW Vsync更新</h1><p>硬件Vsync信号经过DispSync的简单加工，会将相应的值更新，然后唤醒DispSyncThread线程</p><h2 id="7-1-DispSync-DispSyncThread-threadLoop"><a href="#7-1-DispSync-DispSyncThread-threadLoop" class="headerlink" title="7.1 DispSync.DispSyncThread.threadLoop"></a>7.1 DispSync.DispSyncThread.threadLoop</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2 计算下一个SW Vsync时间点</span></span><br><span class="line">            targetTime = <span class="built_in">computeNextEventTimeLocked</span>(now);</span><br><span class="line">            <span class="type">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果计算出来的下一次vsync事件还没有到来，就等时间到了，才发送SW VSYNC信号</span></span><br><span class="line">            <span class="comment">// 可以看出 DispSyncThread的发送的vsync信号和真正硬件发生的vsync信号没有直接的关系，</span></span><br><span class="line">            <span class="comment">// 发送给app/sf的vsync信号都是由 DispSyncThread发送出去的.</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;DispSync waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetTime == INT64_MAX) &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting forever&quot;</span>, mName);</span><br><span class="line">                    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(targetTime));</span><br><span class="line">                    err = mCond.<span class="built_in">waitRelative</span>(mMutex, targetTime - now);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待超时，主动醒来，发送SW Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">                    isWakeup = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算wake up消耗的时间, 但是不能超过1.5 ms</span></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">nsecs_t</span> kMaxWakeupLatency = <span class="built_in">us2ns</span>(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">                <span class="comment">// 乍一看没明白为什么这么算。仔细想，每次wakeup时间是累加的，这个为了减小抖动？</span></span><br><span class="line">                mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) + (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">                mWakeupLatency = <span class="built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.3 搜集EventListener回调，一般就两个：SF和App EventThread</span></span><br><span class="line">            <span class="comment">// 并不是所有的wakeup都是等待了sw vsync的targetTime，如果SurfaceFlinger</span></span><br><span class="line">            <span class="comment">// 主线程收到硬件Vsync,也会唤醒此线程，此时isWakeup为false</span></span><br><span class="line">            <span class="comment">// 这里的callbackInvocations集合就为null，只有now&gt;=targetTime才不为null</span></span><br><span class="line">            callbackInvocations = <span class="built_in">gatherCallbackInvocationsLocked</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackInvocations.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fireCallbackInvocations</span>(callbackInvocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-DispSync-DispSyncThread-computeNextEventTimeLocked"><a href="#7-2-DispSync-DispSyncThread-computeNextEventTimeLocked" class="headerlink" title="7.2 DispSync.DispSyncThread.computeNextEventTimeLocked"></a>7.2 DispSync.DispSyncThread.computeNextEventTimeLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeNextEventTimeLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] computeNextEventTimeLocked&quot;</span>, mName);</span><br><span class="line">    <span class="type">nsecs_t</span> nextEventTime = INT64_MAX;</span><br><span class="line">    <span class="comment">// 对所有的EventListener进行分别计算，里面的mLastEventTime值不同</span></span><br><span class="line">    <span class="comment">// 找出一个最小的Vsync时间，即最近的时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], now);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; nextEventTime) &#123;</span><br><span class="line">            nextEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] nextEventTime = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(nextEventTime));</span><br><span class="line">    <span class="keyword">return</span> nextEventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的EventListeners里面只有两个，一个是SF EventThread，另一个就是App EventThread.</p><h3 id="7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked"><a href="#7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked" class="headerlink" title="7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked"></a>7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeListenerNextEventTimeLocked</span><span class="params">(<span class="type">const</span> EventListener&amp; listener, <span class="type">nsecs_t</span> baseTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listener.mLasteEventTime就是上次SW VSync的时间点，mWakeupLatency就是上次线程醒来的耗时</span></span><br><span class="line">    <span class="type">nsecs_t</span> lastEventTime = listener.mLastEventTime + mWakeupLatency;</span><br><span class="line">    <span class="comment">// 一般baseTime也就是nowTime, 是大于lasterEventTime，除了第一次进入   </span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; lastEventTime) &#123;</span><br><span class="line">        baseTime = lastEventTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// baseTime减去第一次硬件Vsync的时间，算duration时长</span></span><br><span class="line">    baseTime -= mReferenceTime;</span><br><span class="line">    <span class="comment">// 偏移就是SW Vsync本身的偏移值加上各EventThread本身的偏移</span></span><br><span class="line">    <span class="comment">// sf 使用的是 SF_VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="comment">// APP使用的VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="type">nsecs_t</span> phase = mPhase + listener.mPhase;</span><br><span class="line">    <span class="comment">// baseTime也减去偏移</span></span><br><span class="line">    baseTime -= phase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// baseTime小于0，只有第一次进入的时候才会发生。</span></span><br><span class="line">    <span class="comment">// 此时硬件Vsync已经发生了，所以设置baseTime为-mPeriod这样后面算的numPeriod为-1</span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        baseTime = -mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出下一个SW Vsync的时间点</span></span><br><span class="line">    <span class="comment">// 先得到baseTime对应第几个sw Vsync，也就是现在时间点发送了多少个sw Vsync</span></span><br><span class="line">    <span class="type">nsecs_t</span> numPeriods = baseTime / mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numberPeriods+1也就是下一个sw Vysnc，再加上偏移        </span></span><br><span class="line">    <span class="type">nsecs_t</span> t = (numPeriods + <span class="number">1</span>) * mPeriod + phase;</span><br><span class="line">    </span><br><span class="line">    t += mReferenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Absolute t = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个vsync距离上一个vsync时间小于3/5个mPeriod的话，</span></span><br><span class="line">    <span class="comment">// 为了避免连续的两个sw vsync, 那么这次sw vsync就放弃了，直接放到下一个周期里</span></span><br><span class="line">    <span class="keyword">if</span> (t - listener.mLastEventTime &lt; (<span class="number">3</span> * mPeriod / <span class="number">5</span>)) &#123;</span><br><span class="line">        t += mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出来的时间减掉wakeup累积时间，最大1.5ms</span></span><br><span class="line">    t -= mWakeupLatency;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="/images/SurfaceFlinger-2-DispSync/2_2.png" alt="图片"></p><p>看到这里就有一个疑问，sw vsync信号是在DispSyncThread收到第一个硬件Vsync更新sw model后就可以不依赖<br>硬件Vsync信号了，后续可以自己产生。那为什么google没有在这里disable硬件Vsync呢，因为sw vsync还是有误差<br>并不能与硬件Vsync完全保持一致，所以需要updateModelLocked持续消减误差。<br>重新梳理一下完整流程：</p><ol><li>SurfaceFlinger主线程收到硬件Vsync</li><li>DispSync.updateModelLocked及时更新sw model，并通知DispSyncThread线程</li><li>DispSyncThread线程更新mPeriod，mPhase等参数通过computeNextEventTimeLocked计算新的targetTime</li><li>继续等待直到新的targetTime，通知SF EventThread或者AppEventThread有sw vsync信号</li></ol><p>我们知道SF EventThread和App EventThread是有间隔的，并不同步，这里是如何实现的呢？<br>注意我们计算出来的targetTime是sf和app中最近的一次，那么继续看往下看。</p><h2 id="7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked"><a href="#7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked" class="headerlink" title="7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked"></a>7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked</h2><p>now是当前应该被触发的sw vsync时间点，可能是sf vsync也可能是app vsync。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为什么是拿一个vsync周期前的时间点呢？</span></span><br><span class="line">    <span class="type">nsecs_t</span> onePeriodAgo = now - mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算各个EventListener(也就是sf 和app EventThread)的对应的下一次vsync时间.</span></span><br><span class="line">    <span class="comment">// 因为对于时间点now来讲，sf 和 app的下一次vsync时间可能尚未到来。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], onePeriodAgo);</span><br><span class="line">        <span class="comment">// 如果下一次vsync时间尚未到达，这一次就不通知给对应EventListener</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;</span><br><span class="line">            CallbackInvocation ci;</span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">            ci.mEventTime = t;</span><br><span class="line">            callbackInvocations.<span class="built_in">push</span>(ci);</span><br><span class="line">            <span class="comment">// 记录本次sw Vsync时间点</span></span><br><span class="line">            mEventListeners.<span class="built_in">editItemAt</span>(i).mLastEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完这个方法，其实不难理解，DispSyncThread中的targetTime是变化的值，有可能是app EventThread的下一次sw vsync时间，也可能是sf的。如下图：</p><p><img src="/images/SurfaceFlinger-2-DispSync/2_3.png" alt="图片"></p><p>到这里，sw vsync的流程基本梳理完毕了。</p><p>接下来继续看EventThread.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li><li><a href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li><li><a href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-DispSync&quot;&gt;&lt;a href=&quot;#一-DispSync&quot; class=&quot;headerlink&quot; title=&quot;一. DispSync&quot;&gt;&lt;/a&gt;一. DispSync&lt;/h1&gt;&lt;p&gt;DispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。&lt;/p&gt;
&lt;p&gt;接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。&lt;br&gt;我们先看DispSync线程的创建过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(1)--SFEventThread</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-1-SFEventThread/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-1-SFEventThread/</id>
    <published>2022-04-04T01:52:04.000Z</published>
    <updated>2022-04-04T02:28:02.020Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><h1 id="一-SFEventThread"><a href="#一-SFEventThread" class="headerlink" title="一. SFEventThread"></a>一. SFEventThread</h1><ol><li>EventControlThread: 控制硬件vsync的开关</li><li>DispSyncThread: 软件产生vsync的线程</li><li>SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染</li><li>App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图</li></ol><p>从这4个线程，可以将vsync分为4种不同的类型</p><ol><li>HW vsync, 真实由硬件产生的vsync信号</li><li>SW vsync, 由DispSync产生的vsync信号</li><li>SF vsync,  SF接收到的vsync信号</li><li>App vsync, App接收到的vsync信号</li></ol><p>这里我们着重看看SF EventThread.</p><span id="more"></span><h2 id="1-1-BitTube"><a href="#1-1-BitTube" class="headerlink" title="1.1 BitTube"></a>1.1 BitTube</h2><p>先大致了解下BitTube，其实现是socketpairt套接字，用于传递消息。<br>Buffer大小是4KB。</p><h1 id="二-EventThread启动"><a href="#二-EventThread启动" class="headerlink" title="二. EventThread启动"></a>二. EventThread启动</h1><h2 id="2-1-SurfaceFlinger-init"><a href="#2-1-SurfaceFlinger-init" class="headerlink" title="2.1 SurfaceFlinger.init"></a>2.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    mEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,</span><br><span class="line">                                             <span class="literal">true</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">    mEventThread = std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                       [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                       impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>(),</span><br><span class="line">                                                       <span class="string">&quot;appEventThread&quot;</span>);</span><br><span class="line">    mSfEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,</span><br><span class="line">                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;sf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSFEventThread =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mSfEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                    mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                <span class="string">&quot;sfEventThread&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意传入的偏移是不同的。</p><ol><li>app EventThread : vsyncPhaseOffsetNs &#x3D; 2000000ns</li><li>sf EventThread : sfVsyncPhaseOffsetNs &#x3D; 6000000ns</li></ol><p>这个值是编译期间固定的，定义在BoardConfig.mk中</p><h2 id="2-2-EventThread初始化"><a href="#2-2-EventThread初始化" class="headerlink" title="2.2 EventThread初始化"></a>2.2 EventThread初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">EventThread::<span class="built_in">EventThread</span>(VSyncSource* src, ResyncWithRateLimitCallback resyncWithRateLimitCallback,</span><br><span class="line">                         InterceptVSyncsCallback interceptVSyncsCallback, <span class="type">const</span> <span class="type">char</span>* threadName)</span><br><span class="line">      : <span class="built_in">mVSyncSource</span>(src),</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>(resyncWithRateLimitCallback),</span><br><span class="line">        <span class="built_in">mInterceptVSyncsCallback</span>(interceptVSyncsCallback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; event : mVSyncEvent) &#123;</span><br><span class="line">        event.header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        event.header.id = <span class="number">0</span>;</span><br><span class="line">        event.header.timestamp = <span class="number">0</span>;</span><br><span class="line">        event.vsync.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定thread函数</span></span><br><span class="line">    mThread = std::<span class="built_in">thread</span>(&amp;EventThread::threadMain, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置thread名称</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), threadName);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> EVENT_THREAD_PRIORITY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = EVENT_THREAD_PRIORITY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_setschedparam</span>(mThread.<span class="built_in">native_handle</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for EventThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-EventThread-threadMain"><a href="#2-3-EventThread-threadMain" class="headerlink" title="2.3 EventThread.threadMain"></a>2.3 EventThread.threadMain</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (mKeepRunning) &#123;</span><br><span class="line">        DisplayEventReceiver::Event event;</span><br><span class="line">        Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">        <span class="comment">// 2.4 阻塞等待事件</span></span><br><span class="line">        signalConnections = <span class="built_in">waitForEventLocked</span>(&amp;lock, &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分发事件给connection</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> count = signalConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="function"><span class="type">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line">            <span class="comment">// 2.5 分发事件</span></span><br><span class="line">            <span class="type">status_t</span> err = conn-&gt;<span class="built_in">postEvent</span>(event);</span><br><span class="line">            <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">                <span class="comment">// The destination doesn&#x27;t accept events anymore, it&#x27;s probably</span></span><br><span class="line">                <span class="comment">// full. For now, we just drop the events on the floor.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> Note that some events cannot be dropped and would have</span></span><br><span class="line">                <span class="comment">// to be re-sent later.</span></span><br><span class="line">                <span class="comment">// Right-now we don&#x27;t have the ability to do this.</span></span><br><span class="line">                <span class="comment">//ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;, event.header.type,</span></span><br><span class="line">                <span class="comment">//      conn.get());</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// handle any other error on the pipe as fatal. the only</span></span><br><span class="line">                <span class="comment">// reasonable thing to do is to clean-up this connection.</span></span><br><span class="line">                <span class="comment">// The most common error we&#x27;ll get here is -EPIPE.</span></span><br><span class="line">                <span class="built_in">removeDisplayEventConnectionLocked</span>(signalConnections[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-EventThread-waitForEventLocked"><a href="#2-4-EventThread-waitForEventLocked" class="headerlink" title="2.4 EventThread.waitForEventLocked"></a>2.4 EventThread.waitForEventLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will return when (1) a vsync event has been received, and (2) there was</span></span><br><span class="line"><span class="comment">// at least one connection interested in receiving it when we started waiting.</span></span><br><span class="line">Vector&lt;sp&lt;EventThread::Connection&gt; &gt; EventThread::<span class="built_in">waitForEventLocked</span>(</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt;* lock, DisplayEventReceiver::Event* event) &#123;</span><br><span class="line">    Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (signalConnections.<span class="built_in">isEmpty</span>() &amp;&amp; mKeepRunning) &#123;</span><br><span class="line">        <span class="type">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// 当timestamp不为0时，说明有事件发生</span></span><br><span class="line">                <span class="keyword">if</span> (mInterceptVSyncsCallback) &#123;</span><br><span class="line">                    <span class="built_in">mInterceptVSyncsCallback</span>(timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                <span class="comment">// 置timestamp为0，标记为当前事件被消费</span></span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mDisplayEventConnections保存的是注册的Connection的,</span></span><br><span class="line">        <span class="comment">// SF EventThread线程里只有一个Connection, 而这个Connection主要是用来渲染</span></span><br><span class="line">        <span class="comment">// 而如果是APP EventThread, 这里会有多个connection</span></span><br><span class="line">        <span class="type">size_t</span> count = mDisplayEventConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; count) &#123;</span><br><span class="line">            <span class="comment">// 没有vsync事件， 来看下是否有其它pending的event, 这里主要是hotplug的事件</span></span><br><span class="line">            eventPending = !mPendingEvents.<span class="built_in">isEmpty</span>();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;</span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];</span><br><span class="line">                mPendingEvents.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count;) &#123;</span><br><span class="line">            <span class="function">sp&lt;Connection&gt; <span class="title">connection</span><span class="params">(mDisplayEventConnections[i].promote())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// Connection-&gt;count的值大小含义如下：</span></span><br><span class="line">                <span class="comment">// 1. &gt;=1:  表示持续接收Vsync信号</span></span><br><span class="line">                <span class="comment">// 2. ==0:  只接收一次Vsync信号</span></span><br><span class="line">                <span class="comment">// 3. ==-1: 不接收Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果有 connection-&gt;count &gt;= 0，说明需要Vsync信号</span></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123; <span class="comment">// 大于0.说明有事件</span></span><br><span class="line">                        <span class="comment">// 处理本次事件</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                   (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don&#x27;t have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn&#x27;t promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.<span class="built_in">removeAt</span>(i);</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 收到Vsync信号，但是没有Connection监听，所以关闭Vsync</span></span><br><span class="line">            <span class="built_in">disableVSyncLocked</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 有Connection监听，但是还没有Vsync信号，所以打开Vsync</span></span><br><span class="line">            <span class="built_in">enableVSyncLocked</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有事件发生</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123; <span class="comment">// 如果有connection监听，则需要等待Vsync事件</span></span><br><span class="line">                <span class="comment">// 以防止硬件Driver出问题，设置一个超时时间16ms</span></span><br><span class="line">                <span class="type">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line">                <span class="keyword">auto</span> timeout = softwareSync ? <span class="number">16</span>ms : <span class="number">1000</span>ms;</span><br><span class="line">                <span class="keyword">if</span> (mCondition.<span class="built_in">wait_for</span>(*lock, timeout) == std::cv_status::timeout) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        <span class="built_in">ALOGW</span>(<span class="string">&quot;Timed out waiting for hw vsync; faking it&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有connection监听，也没有收到事件，则一直等待</span></span><br><span class="line">                mCondition.<span class="built_in">wait</span>(*lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we&#x27;re guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we&#x27;ll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当EventThread初始化进入时，由于没有Connection，timestamp也为0，直接进入waitForEventLocked一直等待。</p><h2 id="2-5-EventThread-Connection-postEvent"><a href="#2-5-EventThread-Connection-postEvent" class="headerlink" title="2.5 EventThread.Connection.postEvent"></a>2.5 EventThread.Connection.postEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">postEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过BitTube发送事件。</p><h1 id="三-SF-EventThread-添加Connection"><a href="#三-SF-EventThread-添加Connection" class="headerlink" title="三. SF EventThread 添加Connection"></a>三. SF EventThread 添加Connection</h1><h2 id="3-1-SurfaceFlinger-init"><a href="#3-1-SurfaceFlinger-init" class="headerlink" title="3.1 SurfaceFlinger.init"></a>3.1 SurfaceFlinger.init</h2><p>sfEventThread添加Connection是在这个线程启动后就添加的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// mEventQueue就是MessageQueue类的对象</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventThread</span>(mSFEventThread.<span class="built_in">get</span>());</span><br><span class="line">    mVsyncModulator.<span class="built_in">setEventThreads</span>(mSFEventThread.<span class="built_in">get</span>(), mEventThread.<span class="built_in">get</span>());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-MessageQueue-setEventThread"><a href="#3-2-MessageQueue-setEventThread" class="headerlink" title="3.2 MessageQueue.setEventThread"></a>3.2 MessageQueue.setEventThread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(android::EventThread* eventThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventThread == eventThread) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    <span class="comment">// 3.3 创建Connection</span></span><br><span class="line">    mEvents = eventThread-&gt;<span class="built_in">createEventConnection</span>();</span><br><span class="line">    <span class="comment">// 3.4 建立BitTube连接</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 3.5 接受BitTube事件，调用cb_eventReceiver方法</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-EventThread-createEventConnection"><a href="#3-3-EventThread-createEventConnection" class="headerlink" title="3.3 EventThread.createEventConnection"></a>3.3 EventThread.createEventConnection</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;BnDisplayEventConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Connection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThread::Connection::<span class="built_in">Connection</span>(EventThread* eventThread)</span><br><span class="line">      <span class="comment">// 注意这里的count是被赋值为-1，也就是不接收Vsync事件</span></span><br><span class="line">      : <span class="built_in">count</span>(<span class="number">-1</span>), <span class="built_in">mEventThread</span>(eventThread), <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-EventThread-Connection-onFirstRef"><a href="#3-3-1-EventThread-Connection-onFirstRef" class="headerlink" title="3.3.1 EventThread.Connection.onFirstRef"></a>3.3.1 EventThread.Connection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> EventThread::Connection::<span class="built_in">onFirstRef</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Connection对象生成之后，就被注册到其对应的EventThread中</p><h3 id="3-3-2-EventThread-registerDisplayEventConnection"><a href="#3-3-2-EventThread-registerDisplayEventConnection" class="headerlink" title="3.3.2 EventThread.registerDisplayEventConnection"></a>3.3.2 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 添加到mDisplayEventConnections集合中</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">    <span class="comment">// waitForEventLocked 可以继续执行了。</span></span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册connection后，waitForEventLocked便可以开始继续执行了。但是由于只有这一个connection，而且这个connection.count 还是 -1，所以最后还是会在waitForEventLocked中一直等待Vsync事件</p><h2 id="3-4-EventThread-Connection-stealReceiveChannel"><a href="#3-4-EventThread-Connection-stealReceiveChannel" class="headerlink" title="3.4  EventThread.Connection.stealReceiveChannel"></a>3.4  EventThread.Connection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">stealReceiveChannel</span>(gui::BitTube* outChannel) &#123;</span><br><span class="line">    <span class="comment">// 将Connection的mChannel复制</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-SF-EventThread-connection开始监听Vsync信号"><a href="#3-5-SF-EventThread-connection开始监听Vsync信号" class="headerlink" title="3.5 SF EventThread connection开始监听Vsync信号"></a>3.5 SF EventThread connection开始监听Vsync信号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::initializeDisplays</span><br><span class="line">    SurfaceFlinger::onInitializeDisplays</span><br><span class="line">        SurfaceFlinger::setTransactionState</span><br><span class="line">            SurfaceFlinger::setTransactionFlags</span><br><span class="line">                SurfaceFlinger::signalTransaction</span><br><span class="line">                    MessageQueue::invalidate</span><br><span class="line">                        EventThread::Connection::requestNextVsync</span><br><span class="line">                            EventThread::requestNextVsync</span><br></pre></td></tr></table></figure><p>也就是说当显示屏准备完毕，sfEventThread就可以开始监听Vsync信号了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResyncWithRateLimitCallback) &#123;</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>; <span class="comment">// 只接受一次Vsync信号</span></span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-MessageQueue-cb-eventReceiver-处理Vsync信号"><a href="#3-6-MessageQueue-cb-eventReceiver-处理Vsync信号" class="headerlink" title="3.6 MessageQueue.cb_eventReceiver 处理Vsync信号"></a>3.6 MessageQueue.cb_eventReceiver 处理Vsync信号</h2><p>当SF EventThread收到Vsync信号时，最终会通过BitTube发送给对应connection的receiver[2.5]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-1-MessageQueue-Handler-dispatchInvalidate"><a href="#3-6-1-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="3.6.1 MessageQueue.Handler.dispatchInvalidate"></a>3.6.1 MessageQueue.Handler.dispatchInvalidate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到SufaceFlinger主线程中处理了。</p><h1 id="四-开启硬件Vsync"><a href="#四-开启硬件Vsync" class="headerlink" title="四. 开启硬件Vsync"></a>四. 开启硬件Vsync</h1><h2 id="4-1-EventThread-enableVSyncLocked"><a href="#4-1-EventThread-enableVSyncLocked" class="headerlink" title="4.1 EventThread.enableVSyncLocked"></a>4.1 EventThread.enableVSyncLocked</h2><p>当显示屏准备完毕后，SF EventThread请求一次Vsync信号。那么走到waitForEventLocked中，会调用enableVSyncLocked方法开启硬件Vsync信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::enableVSyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mUseSoftwareVSync) &#123; </span><br><span class="line">        <span class="comment">// mUseSoftwareVSync也就是显示屏power状态</span></span><br><span class="line">        <span class="comment">// 灭屏为true，亮屏置为false</span></span><br><span class="line">        <span class="keyword">if</span> (!mVsyncEnabled) &#123;</span><br><span class="line">            mVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setCallback</span>(<span class="keyword">this</span>);</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setVSyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mDebugVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-DispSyncSource-setVSyncEnabled"><a href="#4-2-DispSyncSource-setVSyncEnabled" class="headerlink" title="4.2 DispSyncSource.setVSyncEnabled"></a>4.2 DispSyncSource.setVSyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSyncSource::setVSyncEnabled</span><span class="params">(<span class="type">bool</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mVsyncMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">addEventListener</span>(mName, mPhaseOffset,</span><br><span class="line">                                                   <span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                   mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error registering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 1);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">removeEventListener</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                      &amp;mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error unregistering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启Vsync信号就是添加EventListener，关闭就是将这个listener移除</p><h2 id="4-3-DispSync-addEventListener"><a href="#4-3-DispSync-addEventListener" class="headerlink" title="4.3 DispSync.addEventListener"></a>4.3 DispSync.addEventListener</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DispSync::addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> mThread-&gt;<span class="built_in">addEventListener</span>(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是到了DispSync部分了。</p><p>大致流程如下：</p><p><img src="/images/SurfaceFlinger-1-SFEventThread/1_1.png" alt="图片"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-SFEventThread&quot;&gt;&lt;a href=&quot;#一-SFEventThread&quot; class=&quot;headerlink&quot; title=&quot;一. SFEventThread&quot;&gt;&lt;/a&gt;一. SFEventThread&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;EventControlThread: 控制硬件vsync的开关&lt;/li&gt;
&lt;li&gt;DispSyncThread: 软件产生vsync的线程&lt;/li&gt;
&lt;li&gt;SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染&lt;/li&gt;
&lt;li&gt;App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这4个线程，可以将vsync分为4种不同的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HW vsync, 真实由硬件产生的vsync信号&lt;/li&gt;
&lt;li&gt;SW vsync, 由DispSync产生的vsync信号&lt;/li&gt;
&lt;li&gt;SF vsync,  SF接收到的vsync信号&lt;/li&gt;
&lt;li&gt;App vsync, App接收到的vsync信号&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们着重看看SF EventThread.&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>App申请帧率(4)--SF切换帧率</title>
    <link href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/"/>
    <id>https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/</id>
    <published>2022-02-26T19:54:03.000Z</published>
    <updated>2022-02-26T20:00:41.253Z</updated>
    
    <content type="html"><![CDATA[<p>以下分析基于Android R.</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。</p><p>接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。</p><span id="more"></span><h1 id="一-SurfaceFlinger接受帧率变化"><a href="#一-SurfaceFlinger接受帧率变化" class="headerlink" title="一. SurfaceFlinger接受帧率变化"></a>一. SurfaceFlinger接受帧率变化</h1><p>接上一章，从 SurfaceFlinger::setDesiredActiveConfig 开始. </p><p>这里的ActiveConfigInfo就是SurfaceFlinger根据Framework传入的帧率范围以及各个Layer投票计算的最终帧率信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ActiveConfigInfo</span> &#123;</span><br><span class="line">        HwcConfigIndexType configId;</span><br><span class="line">        Scheduler::ConfigEvent event = Scheduler::ConfigEvent::None;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ActiveConfigInfo&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> configId != other.configId || event != other.event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="1-1-SurfaceFlinger-setDesiredActiveConfig"><a href="#1-1-SurfaceFlinger-setDesiredActiveConfig" class="headerlink" title="1.1 SurfaceFlinger.setDesiredActiveConfig"></a>1.1 SurfaceFlinger.setDesiredActiveConfig</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setDesiredActiveConfig</span><span class="params">(<span class="type">const</span> ActiveConfigInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate = mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(info.configId);</span><br><span class="line">    mVsyncPeriod = refreshRate.<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;setDesiredActiveConfig(%s)&quot;</span>, refreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mActiveConfigLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mDesiredActiveConfigChanged) &#123;</span><br><span class="line">        <span class="comment">// 如果帧率切换正在发生，缓存此次帧率切换</span></span><br><span class="line">        <span class="type">const</span> Scheduler::ConfigEvent prevConfig = mDesiredActiveConfig.event;</span><br><span class="line">        mDesiredActiveConfig = info;</span><br><span class="line">        mDesiredActiveConfig.event = mDesiredActiveConfig.event | prevConfig;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前帧率已经是请求的帧率了，直接返回</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">        <span class="keyword">if</span> (!display || display-&gt;<span class="built_in">getActiveConfig</span>() == refreshRate.<span class="built_in">getConfigId</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记正在做帧率切换</span></span><br><span class="line">        mDesiredActiveConfigChanged = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 存储即将切换的帧率配置信息</span></span><br><span class="line">        mDesiredActiveConfig = info;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 触发HWC刷新而不重置空闲计时器。</span></span><br><span class="line">        <span class="built_in">repaintEverythingForHWC</span>();</span><br><span class="line">        <span class="comment">// 1.3 现在开始接收vsync样本，这可以检测到硬件周期切换。</span></span><br><span class="line">        mScheduler-&gt;<span class="built_in">resyncToHardwareVsync</span>(<span class="literal">true</span>, refreshRate.<span class="built_in">getVsyncPeriod</span>());</span><br><span class="line">        <span class="comment">// 1.4 调用onRefreshRateChangeCompleted, 通知更新偏移量</span></span><br><span class="line">        mVSyncModulator-&gt;<span class="built_in">onRefreshRateChangeInitiated</span>();</span><br><span class="line">        <span class="comment">// 保存即将更新的Fps</span></span><br><span class="line">        mPhaseConfiguration-&gt;<span class="built_in">setRefreshRateFps</span>(refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line">        <span class="comment">// 1.5 再次更新偏移量, 不过这一次是根据即将更新的Fps拿到的固定偏移量</span></span><br><span class="line">        mVSyncModulator-&gt;<span class="built_in">setPhaseOffsets</span>(mPhaseConfiguration-&gt;<span class="built_in">getCurrentOffsets</span>());</span><br><span class="line">        mScheduler-&gt;<span class="built_in">setConfigChangePending</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRefreshRateOverlay) &#123;</span><br><span class="line">        mRefreshRateOverlay-&gt;<span class="built_in">changeRefreshRate</span>(refreshRate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-SurfaceFlinger-repaintEverythingForHWC"><a href="#1-2-SurfaceFlinger-repaintEverythingForHWC" class="headerlink" title="1.2 SurfaceFlinger.repaintEverythingForHWC"></a>1.2 SurfaceFlinger.repaintEverythingForHWC</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::repaintEverythingForHWC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记全部重绘制</span></span><br><span class="line">    mRepaintEverything = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 通知Power模组, Display将更新，OEM厂商自行实现这个标准接口</span></span><br><span class="line">    mPowerAdvisor.<span class="built_in">notifyDisplayUpdateImminent</span>();</span><br><span class="line">    <span class="comment">// EventThread请求下一帧Vsync</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-Scheduler-resyncToHardwareVsync"><a href="#1-3-Scheduler-resyncToHardwareVsync" class="headerlink" title="1.3 Scheduler.resyncToHardwareVsync"></a>1.3 Scheduler.resyncToHardwareVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scheduler::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable, <span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">            mHWVsyncAvailable = makeAvailable;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">            <span class="comment">// 硬件Vsync被禁止，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数不合法</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知到软件Vsync产生模块，更新Vsync周期</span></span><br><span class="line">    <span class="built_in">setVsyncPeriod</span>(period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-1-Scheduler-setVsyncPeriod"><a href="#1-3-1-Scheduler-setVsyncPeriod" class="headerlink" title="1.3.1 Scheduler.setVsyncPeriod"></a>1.3.1 Scheduler.setVsyncPeriod</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scheduler::setVsyncPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">    <span class="comment">// 1.3.2 更新软件Vsync周期</span></span><br><span class="line">    mPrimaryDispSync-&gt;<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        <span class="comment">// 硬件Vsync关闭的情况下, 直接更改软件vsync周期，这里我们加上是开启的</span></span><br><span class="line">        mPrimaryDispSync-&gt;<span class="built_in">beginResync</span>();</span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在R上软件Vsync产生更改了架构，由Q上DispSync改成VSyncReactor, 不过原理不变就不分析了, 具体可以参考文章-SurfaceFlinger(2)–DispSync。</p><p>可以通过将属性debug.sf.vsync_reactor置为false后重启，切回Q上的DispSync机制</p><h3 id="1-3-2-VSyncReactor-setPeriod"><a href="#1-3-2-VSyncReactor-setPeriod" class="headerlink" title="1.3.2 VSyncReactor.setPeriod"></a>1.3.2 VSyncReactor.setPeriod</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::setPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;VSR-setPeriod&quot;</span>, period);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mLastHwVsync.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mSupportKernelIdleTimer的是由属性控制的，Google源码中默认是true的</span></span><br><span class="line">    <span class="comment">// PRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.surface_flinger.support_kernel_idle_timer=true</span></span><br><span class="line">    <span class="keyword">if</span> (!mSupportKernelIdleTimer &amp;&amp; period == <span class="built_in">getPeriod</span>()) &#123;</span><br><span class="line">        <span class="built_in">endPeriodTransition</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 开始更新</span></span><br><span class="line">        <span class="built_in">startPeriodTransition</span>(period);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-VSyncReactor-startPeriodTransition"><a href="#1-3-3-VSyncReactor-startPeriodTransition" class="headerlink" title="1.3.3 VSyncReactor.startPeriodTransition"></a>1.3.3 VSyncReactor.startPeriodTransition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::startPeriodTransition</span><span class="params">(<span class="type">nsecs_t</span> newPeriod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记各个变量，并记录待更新的Fps对应一帧的刷新时长</span></span><br><span class="line">    mPeriodConfirmationInProgress = <span class="literal">true</span>;</span><br><span class="line">    mPeriodTransitioningTo = newPeriod;</span><br><span class="line">    mMoreSamplesNeeded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 忽略当前Fence，其实就是清空mUnfiredFences中的fence</span></span><br><span class="line">    <span class="built_in">setIgnorePresentFencesInternal</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::setIgnorePresentFencesInternal</span><span class="params">(<span class="type">bool</span> ignoration)</span> </span>&#123;</span><br><span class="line">    mInternalIgnoreFences = ignoration;</span><br><span class="line">    <span class="built_in">updateIgnorePresentFencesInternal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::updateIgnorePresentFencesInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExternalIgnoreFences || mInternalIgnoreFences) &#123;</span><br><span class="line">        mUnfiredFences.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-VSyncModulator-onRefreshRateChangeInitiated"><a href="#1-4-VSyncModulator-onRefreshRateChangeInitiated" class="headerlink" title="1.4 VSyncModulator.onRefreshRateChangeInitiated"></a>1.4 VSyncModulator.onRefreshRateChangeInitiated</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::onRefreshRateChangeInitiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRefreshRateChangePending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshRateChangePending = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">updateOffsets</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::updateOffsets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="built_in">updateOffsetsLocked</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::updateOffsetsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.4.1 选择偏移量</span></span><br><span class="line">    <span class="type">const</span> Offsets&amp; offsets = <span class="built_in">getNextOffsets</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.2 更新对应的偏移量，这个mPhaseOffsetControl其实就是Scheduler</span></span><br><span class="line">    mPhaseOffsetControl.<span class="built_in">setPhaseOffset</span>(mSfConnectionHandle, offsets.sf);</span><br><span class="line">    mPhaseOffsetControl.<span class="built_in">setPhaseOffset</span>(mAppConnectionHandle, offsets.app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新偏移量</span></span><br><span class="line">    mOffsets = offsets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个trace的debug开关是由属性: debug.sf.vsync_trace_detailed_info 0/1 决定的</span></span><br><span class="line">    <span class="keyword">if</span> (!mTraceDetailedInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isEarly = &amp;offsets == &amp;mOffsetsConfig.early;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isEarlyGl = &amp;offsets == &amp;mOffsetsConfig.earlyGl;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isLate = &amp;offsets == &amp;mOffsetsConfig.late;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-EarlyOffsetsOn&quot;</span>, isEarly);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-EarlyGLOffsetsOn&quot;</span>, isEarlyGl);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-LateOffsetsOn&quot;</span>, isLate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-1-VSyncModulator-getNextOffsets"><a href="#1-4-1-VSyncModulator-getNextOffsets" class="headerlink" title="1.4.1 VSyncModulator.getNextOffsets"></a>1.4.1 VSyncModulator.getNextOffsets</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> VSyncModulator::Offsets&amp; <span class="title">VSyncModulator::getNextOffsets</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行刷新率更改，或者最近开始了一个事务，则使用early偏移量。</span></span><br><span class="line">    <span class="keyword">if</span> (mExplicitEarlyWakeup || mTransactionStart == Scheduler::TransactionStart::EarlyEnd ||</span><br><span class="line">        mRemainingEarlyFrameCount &gt; <span class="number">0</span> || mRefreshRateChangePending) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.early;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mRemainingRenderEngineUsageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.earlyGl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.late;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-DispSyncSource-setPhaseOffset"><a href="#1-4-2-DispSyncSource-setPhaseOffset" class="headerlink" title="1.4.2 DispSyncSource.setPhaseOffset"></a>1.4.2 DispSyncSource.setPhaseOffset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSyncSource::setPhaseOffset</span><span class="params">(<span class="type">nsecs_t</span> phaseOffset)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mVsyncMutex)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = mDispSync-&gt;<span class="built_in">getPeriod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常来讲偏移量在 [-period, period) 之间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numPeriods = phaseOffset / period;</span><br><span class="line">    phaseOffset -= numPeriods * period;</span><br><span class="line">    <span class="keyword">if</span> (mPhaseOffset == phaseOffset) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPhaseOffset = phaseOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尚未使能，就不需要通知给各个listener</span></span><br><span class="line">    <span class="keyword">if</span> (!mEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.3 DispSyncSource是继承了DispSync::Callback的</span></span><br><span class="line">    <span class="type">status_t</span> err =</span><br><span class="line">            mDispSync-&gt;<span class="built_in">changePhaseOffset</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>), mPhaseOffset);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;error changing vsync offset: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-VSyncReactor-changePhaseOffset"><a href="#1-4-3-VSyncReactor-changePhaseOffset" class="headerlink" title="1.4.3 VSyncReactor.changePhaseOffset"></a>1.4.3 VSyncReactor.changePhaseOffset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">VSyncReactor::changePhaseOffset</span><span class="params">(DispSync::Callback* callback, <span class="type">nsecs_t</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> it = mCallbacks.<span class="built_in">find</span>(callback);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(it == mCallbacks.<span class="built_in">end</span>(), <span class="string">&quot;callback was %p not registered&quot;</span>, callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用start，更新VSyncDispatchTimerQueue中相关信息</span></span><br><span class="line">    it-&gt;second-&gt;<span class="built_in">start</span>(phase);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-VSyncReactor-CallbackRepeater-start"><a href="#1-4-4-VSyncReactor-CallbackRepeater-start" class="headerlink" title="1.4.4 VSyncReactor.CallbackRepeater.start"></a>1.4.4 VSyncReactor.CallbackRepeater.start</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">nsecs_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mStopped = <span class="literal">false</span>;</span><br><span class="line">    mOffset = offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> schedule_result = mRegistration.<span class="built_in">schedule</span>(<span class="built_in">calculateWorkload</span>(), mLastCallTime);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>((schedule_result != ScheduleResult::Scheduled),</span><br><span class="line">                        <span class="string">&quot;Error scheduling callback: rc %X&quot;</span>, schedule_result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-5-VSyncCallbackRegistration-schedule"><a href="#1-4-5-VSyncCallbackRegistration-schedule" class="headerlink" title="1.4.5 VSyncCallbackRegistration.schedule"></a>1.4.5 VSyncCallbackRegistration.schedule</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ScheduleResult <span class="title">VSyncCallbackRegistration::schedule</span><span class="params">(<span class="type">nsecs_t</span> workDuration, <span class="type">nsecs_t</span> earliestVsync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mValidToken) &#123;</span><br><span class="line">        <span class="keyword">return</span> ScheduleResult::Error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDispatch.<span class="built_in">get</span>().<span class="built_in">schedule</span>(mToken, workDuration, earliestVsync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ScheduleResult <span class="title">VSyncDispatchTimerQueue::schedule</span><span class="params">(CallbackToken token, <span class="type">nsecs_t</span> workDuration,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">nsecs_t</span> earliestVsync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = ScheduleResult::Error;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;<span class="title">decltype</span><span class="params">(mMutex)</span>&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = mCallbacks.<span class="built_in">find</span>(token);</span><br><span class="line">        <span class="keyword">if</span> (it == mCallbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>&amp; callback = it-&gt;second;</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> now = mTimeKeeper-&gt;<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计时器线程即将运行，通过回调计时器重新计算应用此工作更新，以避免取消即将触发的回调。</span></span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> rearmImminent = now &gt; mIntendedWakeupTime;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(rearmImminent)) &#123;</span><br><span class="line">            callback-&gt;<span class="built_in">addPendingWorkloadUpdate</span>(workDuration, earliestVsync);</span><br><span class="line">            <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = callback-&gt;<span class="built_in">schedule</span>(workDuration, earliestVsync, mTracker, now);</span><br><span class="line">        <span class="keyword">if</span> (result == ScheduleResult::CannotSchedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback-&gt;<span class="built_in">wakeupTime</span>() &lt; mIntendedWakeupTime - mTimerSlack) &#123;</span><br><span class="line">            <span class="built_in">rearmTimerSkippingUpdateFor</span>(now, it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ScheduleResult <span class="title">VSyncDispatchTimerQueueEntry::schedule</span><span class="params">(<span class="type">nsecs_t</span> workDuration, <span class="type">nsecs_t</span> earliestVsync,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      VSyncTracker&amp; tracker, <span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> nextVsyncTime =</span><br><span class="line">            tracker.<span class="built_in">nextAnticipatedVSyncTimeFrom</span>(std::<span class="built_in">max</span>(earliestVsync, now + workDuration));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="type">const</span> wouldSkipAVsyncTarget =</span><br><span class="line">            mArmedInfo &amp;&amp; (nextVsyncTime &gt; (mArmedInfo-&gt;mActualVsyncTime + mMinVsyncDistance));</span><br><span class="line">    <span class="keyword">if</span> (wouldSkipAVsyncTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="type">const</span> alreadyDispatchedForVsync = mLastDispatchTime &amp;&amp;</span><br><span class="line">            ((*mLastDispatchTime + mMinVsyncDistance) &gt;= nextVsyncTime &amp;&amp;</span><br><span class="line">             (*mLastDispatchTime - mMinVsyncDistance) &lt;= nextVsyncTime);</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedForVsync) &#123;</span><br><span class="line">        nextVsyncTime =</span><br><span class="line">                tracker.<span class="built_in">nextAnticipatedVSyncTimeFrom</span>(*mLastDispatchTime + mMinVsyncDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> nextWakeupTime = nextVsyncTime - workDuration;</span><br><span class="line">    mWorkDuration = workDuration;</span><br><span class="line">    mEarliestVsync = earliestVsync;</span><br><span class="line">    mArmedInfo = &#123;nextWakeupTime, nextVsyncTime&#125;;</span><br><span class="line">    <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-VSyncModulator-setPhaseOffsets"><a href="#1-5-VSyncModulator-setPhaseOffsets" class="headerlink" title="1.5 VSyncModulator.setPhaseOffsets"></a>1.5 VSyncModulator.setPhaseOffsets</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::setPhaseOffsets</span><span class="params">(<span class="type">const</span> OffsetsConfig&amp; config)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mOffsetsConfig = config;</span><br><span class="line">    <span class="comment">// 见 1.4 流程</span></span><br><span class="line">    <span class="built_in">updateOffsetsLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的OffsetsConfig是通过PhaseOffsets拿到的</p><h3 id="1-5-1-PhaseOffsets-getCurrentOffsets"><a href="#1-5-1-PhaseOffsets-getCurrentOffsets" class="headerlink" title="1.5.1 PhaseOffsets.getCurrentOffsets"></a>1.5.1 PhaseOffsets.getCurrentOffsets</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Offsets <span class="title">getCurrentOffsets</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getOffsetsForRefreshRate</span>(mRefreshRateFps); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PhaseOffsets::Offsets <span class="title">PhaseOffsets::getOffsetsForRefreshRate</span><span class="params">(<span class="type">float</span> fps)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> iter = std::<span class="built_in">find_if</span>(mOffsets.<span class="built_in">begin</span>(), mOffsets.<span class="built_in">end</span>(),</span><br><span class="line">                                   [&amp;fps](<span class="type">const</span> std::pair&lt;<span class="type">float</span>, Offsets&gt;&amp; candidateFps) &#123;</span><br><span class="line">                                       <span class="keyword">return</span> <span class="built_in">fpsEqualsWithMargin</span>(fps, candidateFps.first);</span><br><span class="line">                                   &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter != mOffsets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unknown refresh rate. This might happen if we get a hotplug event for an external display.</span></span><br><span class="line">    <span class="comment">// In this case just construct the offset.</span></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;Can&#x27;t find offset for %.2f fps&quot;</span>, fps);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getPhaseOffsets</span>(fps, <span class="built_in">static_cast</span>&lt;<span class="type">nsecs_t</span>&gt;(<span class="number">1e9</span>f / fps));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PhaseOffsets::Offsets <span class="title">PhaseOffsets::getPhaseOffsets</span><span class="params">(<span class="type">float</span> fps, <span class="type">nsecs_t</span> vsyncPeriod)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里根据帧率大小，分两种情况获取偏移量，具体就不看了，和参数配置相关</span></span><br><span class="line">    <span class="keyword">if</span> (fps &gt; <span class="number">65.0f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHighFpsOffsets</span>(vsyncPeriod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDefaultOffsets</span>(vsyncPeriod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦吼，到这里setDesiredActiveConfig的流程也算是差不多分析完了，主要做的事情也就下面这些：</p><ol><li>触发HWC刷新而不重置空闲计时器。</li><li>软件Vsync产生模块记录更新的Vsync周期到mPeriodTransitioningTo中，且开始接收硬件vsync，这可以检测到硬件刷新率切换。</li><li>调用onRefreshRateChangeCompleted, 通知更新偏移量</li><li>保存即将更新的Fps到mPhaseConfiguration中</li><li>再次根据即将更新的Fps拿到的固定偏移量更新偏移量</li></ol><h1 id="二-硬件切换帧率"><a href="#二-硬件切换帧率" class="headerlink" title="二. 硬件切换帧率"></a>二. 硬件切换帧率</h1><p>上面的流程跑完后，实际上硬件帧率在哪儿切换还是没有看到，包括mPeriodTransitioningTo是怎么更新到实际软件Vsync中的呢？</p><p>注意到在步骤#1.2中也就是repaintEverythingForHWC会请求下一帧的Vsync，很自然的想法就是实际帧率切换应该是在下一帧到来的时候才开始的。</p><p>我们知道SurfaceFlinger接受到Vsync信号后，会调用onMessageInvalidate（Q上是onMessageReceived）方法开始更新、合成Layer。</p><p>回顾这个方法，很快就可以找到实际vsync切换在这一块代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先注意到这个参数默认是false的，也就是说</span></span><br><span class="line"><span class="comment">// 调用setDesiredActiveConfig方法后的第一帧是无法进入该分支的</span></span><br><span class="line"><span class="comment">// 我们先跳过这段代码</span></span><br><span class="line"><span class="keyword">if</span> (mSetActiveConfigPending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (framePending) &#123;</span><br><span class="line">        mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从HWC收到了当前的fence，假设它成功地更新了配置，因此更新SF各个状态</span></span><br><span class="line">    mSetActiveConfigPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 2.2 更新SurfaceFlinger的状态，此时HWC是已经更新了帧率</span></span><br><span class="line">    <span class="built_in">ON_MAIN_THREAD</span>(<span class="built_in">setActiveConfigInternal</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="comment">// 因为Layer更新刷新率, 重新来选择刷新率</span></span><br><span class="line">    <span class="comment">// 这里涉及到Layer的VoteType、权限等记录，有兴趣自行研究</span></span><br><span class="line">    mScheduler-&gt;<span class="built_in">chooseRefreshRateForContent</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 更新当前帧率设置</span></span><br><span class="line"><span class="built_in">ON_MAIN_THREAD</span>(<span class="built_in">performSetActiveConfig</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><h2 id="2-1-SurfaceFlinger-performSetActiveConfig"><a href="#2-1-SurfaceFlinger-performSetActiveConfig" class="headerlink" title="2.1 SurfaceFlinger.performSetActiveConfig"></a>2.1 SurfaceFlinger.performSetActiveConfig</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::performSetActiveConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;performSetActiveConfig&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断mDesiredActiveConfigChanged是否为true，获取变量mDesiredActiveConfig</span></span><br><span class="line">    <span class="comment">// 否则返回nullopt, 说明不需要帧率切换</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> desiredActiveConfig = <span class="built_in">getDesiredActiveConfig</span>();</span><br><span class="line">    <span class="keyword">if</span> (!desiredActiveConfig) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在需要切换的帧率配置(mDesiredActiveConfig)，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(desiredActiveConfig-&gt;configId);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;performSetActiveConfig changing active config to %d(%s)&quot;</span>,</span><br><span class="line">          refreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>(), refreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">    <span class="keyword">if</span> (!display || display-&gt;<span class="built_in">getActiveConfig</span>() == desiredActiveConfig-&gt;configId) &#123;</span><br><span class="line">        <span class="comment">// 显示设备无效，或者已经处于请求的帧率模式下，标记帧率请求已经完成</span></span><br><span class="line">        <span class="built_in">desiredActiveConfigChangeDone</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所需的活动配置已设置，它与当前使用的配置不同，但是在处理刷新时，允许的配置可能已更改。</span></span><br><span class="line">    <span class="comment">// 确保所需的配置仍然被允许</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isDisplayConfigAllowed</span>(desiredActiveConfig-&gt;configId)) &#123;</span><br><span class="line">        <span class="built_in">desiredActiveConfigChangeDone</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUpcomingActiveConfig = *desiredActiveConfig;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!displayId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;ActiveConfigFPS_HWC&quot;</span>, refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/142753666) use constrains</span></span><br><span class="line">    hal::VsyncPeriodChangeConstraints constraints;</span><br><span class="line">    constraints.desiredTimeNanos = <span class="built_in">systemTime</span>();</span><br><span class="line">    constraints.seamlessRequired = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1.1 通知HWC更新帧率</span></span><br><span class="line">    hal::VsyncPeriodChangeTimeline outTimeline;</span><br><span class="line">    <span class="keyword">auto</span> status =</span><br><span class="line">            <span class="built_in">getHwComposer</span>().<span class="built_in">setActiveConfigWithConstraints</span>(*displayId,</span><br><span class="line">                                                           mUpcomingActiveConfig.configId.<span class="built_in">value</span>(),</span><br><span class="line">                                                           constraints, &amp;outTimeline);</span><br><span class="line">    <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// setActiveConfigWithConstraints may fail if a hotplug event is just about</span></span><br><span class="line">        <span class="comment">// to be sent. We just log the error in this case.</span></span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;setActiveConfigWithConstraints failed: %d&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScheduler-&gt;<span class="built_in">onNewVsyncPeriodChangeTimeline</span>(outTimeline);</span><br><span class="line">    <span class="comment">// 如果需要，Scheduler将向HWC提交一个空帧，回到onMessageInvalidate中处理</span></span><br><span class="line">    <span class="comment">// 也就是在下一帧会处理，距离调用setDesiredActiveConfig就是第二个帧了。</span></span><br><span class="line">    mSetActiveConfigPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做一些合法性判断，最重要的是告诉HWC去更新帧率了。</p><h2 id="2-1-1-HWComposer-setActiveConfigWithConstraints"><a href="#2-1-1-HWComposer-setActiveConfigWithConstraints" class="headerlink" title="2.1.1 HWComposer.setActiveConfigWithConstraints"></a>2.1.1 HWComposer.setActiveConfigWithConstraints</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">HWComposer::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        DisplayId displayId, <span class="type">size_t</span> configId, <span class="type">const</span> hal::VsyncPeriodChangeConstraints&amp; constraints,</span></span></span><br><span class="line"><span class="params"><span class="function">        hal::VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_INVALID_DISPLAY</span>(displayId, BAD_INDEX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line">    <span class="keyword">if</span> (displayData.configMap.<span class="built_in">count</span>(configId) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DISPLAY_ERROR</span>(displayId, (<span class="string">&quot;Invalid config &quot;</span> + std::<span class="built_in">to_string</span>(configId)).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hwcDisplay是HWC2::impl::Display，用来描述硬件显示设备的</span></span><br><span class="line">    <span class="keyword">auto</span> error =</span><br><span class="line">            displayData.hwcDisplay-&gt;<span class="built_in">setActiveConfigWithConstraints</span>(displayData.configMap[configId],</span><br><span class="line">                                                                   constraints, outTimeline);</span><br><span class="line">    <span class="built_in">RETURN_IF_HWC_ERROR</span>(error, displayId, UNKNOWN_ERROR);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-HWC2-impl-Display-setActiveConfigWithConstraints"><a href="#2-1-2-HWC2-impl-Display-setActiveConfigWithConstraints" class="headerlink" title="2.1.2 HWC2::impl::Display.setActiveConfigWithConstraints"></a>2.1.2 HWC2::impl::Display.setActiveConfigWithConstraints</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Display::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> HWC2::Display::Config&gt;&amp; config,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> VsyncPeriodChangeConstraints&amp; constraints, VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%&quot;</span> PRIu64 <span class="string">&quot;] setActiveConfigWithConstraints&quot;</span>, mId);</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;<span class="built_in">getDisplayId</span>() != mId) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;setActiveConfigWithConstraints received config %u for the wrong display %&quot;</span> PRIu64</span><br><span class="line">              <span class="string">&quot; (expected %&quot;</span> PRIu64 <span class="string">&quot;)&quot;</span>,</span><br><span class="line">              config-&gt;<span class="built_in">getId</span>(), config-&gt;<span class="built_in">getDisplayId</span>(), mId);</span><br><span class="line">        <span class="keyword">return</span> Error::BAD_CONFIG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持Vsync Period切换</span></span><br><span class="line">    <span class="comment">// 我们假设支持，其实不支持的话无非是换成调用setActiveConfig</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isVsyncPeriodSwitchSupported</span>()) &#123;</span><br><span class="line">        Hwc2::IComposerClient::VsyncPeriodChangeConstraints hwc2Constraints;</span><br><span class="line">        hwc2Constraints.desiredTimeNanos = constraints.desiredTimeNanos;</span><br><span class="line">        hwc2Constraints.seamlessRequired = constraints.seamlessRequired;</span><br><span class="line"></span><br><span class="line">        Hwc2::VsyncPeriodChangeTimeline vsyncPeriodChangeTimeline = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 2.2.2 通知HWComposer切换帧率</span></span><br><span class="line">        <span class="keyword">auto</span> intError =</span><br><span class="line">                mComposer.<span class="built_in">setActiveConfigWithConstraints</span>(mId, config-&gt;<span class="built_in">getId</span>(), hwc2Constraints,</span><br><span class="line">                                                         &amp;vsyncPeriodChangeTimeline);</span><br><span class="line">        outTimeline-&gt;newVsyncAppliedTimeNanos = vsyncPeriodChangeTimeline.newVsyncAppliedTimeNanos;</span><br><span class="line">        outTimeline-&gt;refreshRequired = vsyncPeriodChangeTimeline.refreshRequired;</span><br><span class="line">        outTimeline-&gt;refreshTimeNanos = vsyncPeriodChangeTimeline.refreshTimeNanos;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Error&gt;(intError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-ComposerHal-setActiveConfigWithConstraints"><a href="#2-1-3-ComposerHal-setActiveConfigWithConstraints" class="headerlink" title="2.1.3 ComposerHal.setActiveConfigWithConstraints"></a>2.1.3 ComposerHal.setActiveConfigWithConstraints</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V2_4::Error <span class="title">Composer::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Display display, Config config,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> IComposerClient::VsyncPeriodChangeConstraints&amp; vsyncPeriodChangeConstraints,</span></span></span><br><span class="line"><span class="params"><span class="function">        VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Error = V2_4::Error;</span><br><span class="line">    <span class="keyword">if</span> (!mClient_2_4) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error::UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Error error = kDefaultError_2_4;</span><br><span class="line">    <span class="comment">// 转到composer service处理. 也就是给硬件厂商实现</span></span><br><span class="line">    mClient_2_4-&gt;<span class="built_in">setActiveConfigWithConstraints</span>(display, config, vsyncPeriodChangeConstraints,</span><br><span class="line">                                                [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="type">const</span> <span class="keyword">auto</span>&amp; tmpTimeline) &#123;</span><br><span class="line">                                                    error = tmpError;</span><br><span class="line">                                                    <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">                                                        <span class="keyword">return</span>;</span><br><span class="line">                                                    &#125;</span><br><span class="line"></span><br><span class="line">                                                    *outTimeline = tmpTimeline;</span><br><span class="line">                                                &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里HWC切换帧率已经完成了。</p><h2 id="2-2-SurfaceFlinger-setActiveConfigInternal"><a href="#2-2-SurfaceFlinger-setActiveConfigInternal" class="headerlink" title="2.2 SurfaceFlinger.setActiveConfigInternal"></a>2.2 SurfaceFlinger.setActiveConfigInternal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setActiveConfigInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">    <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; oldRefreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(display-&gt;<span class="built_in">getActiveConfig</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mActiveConfigLock)</span></span>;</span><br><span class="line">    <span class="comment">// 更新配置为最新的帧率信息</span></span><br><span class="line">    mRefreshRateConfigs-&gt;<span class="built_in">setCurrentConfigId</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    mRefreshRateStats-&gt;<span class="built_in">setConfigMode</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    <span class="comment">// 将新的帧率保存在DisplayDevice中</span></span><br><span class="line">    display-&gt;<span class="built_in">setActiveConfig</span>(mUpcomingActiveConfig.configId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    <span class="keyword">if</span> (refreshRate.<span class="built_in">getVsyncPeriod</span>() != oldRefreshRate.<span class="built_in">getVsyncPeriod</span>()) &#123;</span><br><span class="line">        <span class="comment">// 前后帧率不一致，记录此次帧率切换，就是次数（refreshRateSwitches）+1</span></span><br><span class="line">        mTimeStats-&gt;<span class="built_in">incrementRefreshRateSwitches</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偏移量管理类也要更新FPS信息</span></span><br><span class="line">    mPhaseConfiguration-&gt;<span class="built_in">setRefreshRateFps</span>(refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line">    <span class="comment">// HWC更新帧率了，偏移量再次更新</span></span><br><span class="line">    mVSyncModulator-&gt;<span class="built_in">setPhaseOffsets</span>(mPhaseConfiguration-&gt;<span class="built_in">getCurrentOffsets</span>());</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;ActiveConfigFPS&quot;</span>, refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的event就是:Scheduler::ConfigEvent::Changed</span></span><br><span class="line">    <span class="keyword">if</span> (mUpcomingActiveConfig.event != Scheduler::ConfigEvent::None) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">nsecs_t</span> vsyncPeriod =</span><br><span class="line">                mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(mUpcomingActiveConfig.configId)</span><br><span class="line">                        .<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">        <span class="comment">// 更新AppEventThread中的Vsync间隔信息</span></span><br><span class="line">        mScheduler-&gt;<span class="built_in">onPrimaryDisplayConfigChanged</span>(mAppConnectionHandle, display-&gt;<span class="built_in">getId</span>()-&gt;value,</span><br><span class="line">                                                  mUpcomingActiveConfig.configId, vsyncPeriod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此帧率切换的过程，差不多就告一段落，当然这里面还有很对细节的部分。</p><p>比如硬件Vsync是怎么影响到VsyncRecator产生软件Vsync的，或者软件Vsync和硬件Vsync是怎么校准的。</p><p>不过我们先总结一下：</p><ol><li>SurfaceFlinger收到setDesiredDisplayConfigSpecs更新帧率配置后，根据传入的帧率配置以及当前Layer选择一个最佳帧率</li><li>将这个最佳帧率信息存储在mDesiredActiveConfig中，然后请求下一帧Vsync，顺便更新一下偏移量</li><li>下一帧Vsync到来后，首先根据Layer再次计算一下最佳帧率，然后通知HWC更新帧率，在等待下一帧</li><li>第二个Vsync到来后，实际此时硬件HWC的Vsync已经更新了，现在就是同步更新SurfaceFlinger中各个变量中的状态，然后通知给AppEventThread更新</li></ol><p>所以一个完整的帧率切换至少包含2个Vsync周期，不过这两个Vsync周期并不相同哦</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下分析基于Android R.&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。&lt;/p&gt;
&lt;p&gt;接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/categories/Android/Vsync/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
  </entry>
  
</feed>
