<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SwallowJoe的博客</title>
  
  <subtitle>Be a real go-getter,&lt;br&gt;NEVER SETTLE!</subtitle>
  <link href="https://swallowjoe.github.io/atom.xml" rel="self"/>
  
  <link href="https://swallowjoe.github.io/"/>
  <updated>2022-04-04T02:44:23.947Z</updated>
  <id>https://swallowjoe.github.io/</id>
  
  <author>
    <name>SwallowJoe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Binder(5)--binder驱动响应ioctl</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/</id>
    <published>2022-04-04T02:38:44.000Z</published>
    <updated>2022-04-04T02:44:23.947Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，我们现在了解了binder驱动的加载过程，回过头继续分析App使用Binder通信的过程。</p><p>先回顾下App使用binder通信的大致过程：</p><ol><li>创建AIDL文件，定义接口函数并在服务端app中实现,并注册进SystemServer</li><li>客户端app通过SystemServer获取服务端注册的Service所代表的IBinder(BpBinder)<ol><li>Client app &lt;–&gt; SystemServer &lt;–&gt; Server app</li><li>Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。</li></ol></li><li>客户端app通过该IBinder与服务端app直接通信。</li></ol><p>之前我们分析到最后一步是：IPCThreadState#talkWithDriver</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Finished read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面我们也了解了ioctl的用法，简单回顾下:</p><blockquote><p>int ioctl(int fd, unsigned long request, …);</p></blockquote><ol><li>fd 必须是打开文件描述符。</li><li>cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作</li><li>argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。</li></ol><p>这里我们还不知道此处的ioctl是怎么和binder驱动勾搭上的，是因为我们之前分析客户端app使用ioctl的时候忽略了IPCThreadState的初始化。</p><p>传入的参数mProcess-&gt;mDriverFD这个文件描述符是怎么获取的呢，接下来先看IPCThreadState的初始化。</p><h1 id="一-IPCThreadState的初始化"><a href="#一-IPCThreadState的初始化" class="headerlink" title="一. IPCThreadState的初始化"></a>一. IPCThreadState的初始化</h1><p>我们在调用transact的时候，会先调用self()函数，这个函数就是初始化用的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br></pre></td></tr></table></figure><h2 id="1-1-IPCThreadState-self"><a href="#1-1-IPCThreadState-self" class="headerlink" title="1.1 IPCThreadState::self"></a>1.1 IPCThreadState::self</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> gTLSMutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; <span class="title">gHaveTLS</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_key_t</span> gTLS = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; gShutdown = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> std::atomic&lt;<span class="type">bool</span>&gt; gDisableBackgroundScheduling = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">IPCThreadState* <span class="title">IPCThreadState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// gHaveTLS为true说明之前已经初始化过</span></span><br><span class="line">    <span class="comment">// 或者说pthread_key_create有被调用过，及本线程私有数据内存空间已开辟</span></span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS.<span class="built_in">load</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="type">const</span> <span class="type">pthread_key_t</span> k = gTLS;</span><br><span class="line">        <span class="comment">// 取得本线程对应关键字gTLS所关联的私有数据空间首址</span></span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)<span class="built_in">pthread_getspecific</span>(k);</span><br><span class="line">        <span class="comment">// 如果不为null,直接返回, 当然如果是第一次进入肯定为null的。</span></span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="comment">// 1.2 实例化IPCThreadState</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处于shutdown时直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (gShutdown.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">        <span class="comment">// 创建关键字gTLS及其对应的内存释放函数threadDestructor</span></span><br><span class="line">        <span class="comment">// 关键字关联线程私有数据空间首址，初始化时是NULL</span></span><br><span class="line">        <span class="type">int</span> key_create_value = <span class="built_in">pthread_key_create</span>(&amp;gTLS, threadDestructor);</span><br><span class="line">        <span class="keyword">if</span> (key_create_value != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;</span>,</span><br><span class="line">                    <span class="built_in">strerror</span>(key_create_value));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表明线程私有数据内存空间已开辟</span></span><br><span class="line">        gHaveTLS.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;gTLSMutex);</span><br><span class="line">    <span class="comment">// 回到restart中准备实例化IPCThreadState</span></span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在Linux 中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone() 。<br>该系统copy 了一个和原先进程完全一样的进程，并在这个进程中执行线程函数。不过这个copy过程和fork不一样。<br>copy 后的进程和原先的进程共享了所有的变量，运行环境（clone的实现是可以指定新进程与老进程之间的共享关系，100%共享就表示创建了一个线程）。<br>这样，原先进程中的变量变动在copy 后的进程中便能体现出来。</p></blockquote><h2 id="1-2-IPCThreadState实例化"><a href="#1-2-IPCThreadState实例化" class="headerlink" title="1.2 IPCThreadState实例化"></a>1.2 IPCThreadState实例化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::<span class="built_in">IPCThreadState</span>()</span><br><span class="line">    <span class="comment">// 1.2.1 创建ProcessState</span></span><br><span class="line">    : <span class="built_in">mProcess</span>(ProcessState::<span class="built_in">self</span>()),</span><br><span class="line">      <span class="built_in">mServingStackPointer</span>(<span class="literal">nullptr</span>),</span><br><span class="line">      <span class="built_in">mWorkSource</span>(kUnsetWorkSource),</span><br><span class="line">      <span class="built_in">mPropagateWorkSource</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mStrictModePolicy</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mLastTransactionBinderFlags</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mCallRestriction</span>(mProcess-&gt;mCallRestriction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将自身存入关键字gTLS对应的线程私有数据空间中，缓存以备后续使用</span></span><br><span class="line">    <span class="built_in">pthread_setspecific</span>(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">clearCaller</span>();</span><br><span class="line">    mIn.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">    mOut.<span class="built_in">setDataCapacity</span>(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-３-ProcessState-self"><a href="#1-３-ProcessState-self" class="headerlink" title="1.３ ProcessState::self"></a>1.３ ProcessState::self</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ANDROID_VNDK__</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* kDefaultDriver = <span class="string">&quot;/dev/vndbinder&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* kDefaultDriver = <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;ProcessState&gt; <span class="title">ProcessState::self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里假定kDefaultDriver为&quot;/dev/binder&quot;</span></span><br><span class="line">    gProcess = <span class="keyword">new</span> <span class="built_in">ProcessState</span>(kDefaultDriver);</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-４-ProcessState实例化"><a href="#1-４-ProcessState实例化" class="headerlink" title="1.４ ProcessState实例化"></a>1.４ ProcessState实例化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="type">const</span> <span class="type">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    <span class="comment">// 1.5 打开binder驱动，获取其文件描述符</span></span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))</span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mCallRestriction</span>(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-open-driver-打开binder驱动"><a href="#1-5-open-driver-打开binder驱动" class="headerlink" title="1.5 open_driver - 打开binder驱动"></a>1.5 open_driver - 打开binder驱动</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">open_driver</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.5.1 打开/dev/binder驱动</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.5.2 ioctl通信!!!</span></span><br><span class="line">        <span class="type">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// #define DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line">        <span class="comment">// 默认最大binder线程数目是15个</span></span><br><span class="line">        <span class="type">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">// 1.5.2 ioctl通信，设置当前进程的最大binder线程数为15</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先使用open函数打开对应目录的驱动文件，成功打开后调用ioctl函数获取Binder版本，最后还是通过ioctl设置最大binder线程。</p><p>我们常听闻在Linux中，一切皆文件，这里就体现出来了。回顾下binder驱动注册进文件系统时的操作函数集:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android/kernel/msm-4.19/drivers/android/binder.c</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> binder_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.poll = binder_poll,</span><br><span class="line">.unlocked_ioctl = binder_ioctl,</span><br><span class="line">.compat_ioctl = binder_ioctl,</span><br><span class="line">.mmap = binder_mmap,</span><br><span class="line">.open = binder_open,</span><br><span class="line">.flush = binder_flush,</span><br><span class="line">.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-5-1-open函数-binder-open"><a href="#1-5-1-open函数-binder-open" class="headerlink" title="1.5.1 open函数-binder_open"></a>1.5.1 open函数-binder_open</h3><p>在app进程中通过open函数打开&#x2F;dev&#x2F;binder文件，就会调用到binder.c中的binder_open函数了。</p><p>我们来看看这个open的时候驱动里面具体做了什么吧，至于用户进程中调用open进而使用系统调用进入内核态调用到binder_open的方式我们后续分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_open</span><span class="params">(<span class="keyword">struct</span> inode *nodp, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// binder_proc代表一个进程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_device</span> *binder_dev;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *binder_binderfs_dir_entry_proc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">binder_debug</span>(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;%s: %d:%d\n&quot;</span>, __func__,</span><br><span class="line">     current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    <span class="comment">// 给binder_proc分配内核内存</span></span><br><span class="line">proc = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">// 初始化自旋锁lock,其实是将自旋锁指针lock 指向SPIN_LOCK_UNLOCKED宏</span></span><br><span class="line">    <span class="comment">// 该宏的定义在内核文件spinlock_types.h中，它表示自旋锁的状态为未加锁</span></span><br><span class="line"><span class="built_in">spin_lock_init</span>(&amp;proc-&gt;inner_lock);</span><br><span class="line"><span class="built_in">spin_lock_init</span>(&amp;proc-&gt;outer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// current是一个内核宏，它是当前进程的指针</span></span><br><span class="line">    <span class="comment">// get_task_struct的最终实现是将传入的task_struct的usage加1:</span></span><br><span class="line">    <span class="comment">//  #define get_task_struct(tsk) do &#123; atomic_inc(&amp;(tsk)-&gt;usage); &#125; while(0)</span></span><br><span class="line">    <span class="comment">// 这个宏的作用是标记传入的task_struct，当期有人在用。</span></span><br><span class="line">    <span class="comment">// usage的数量代表正在使用该task_struct的程序数量。</span></span><br><span class="line"><span class="built_in">get_task_struct</span>(current-&gt;group_leader);</span><br><span class="line">    <span class="comment">// 将binder_proc的tsk标记为当前进程的主进程</span></span><br><span class="line">proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    <span class="comment">// 加上互斥锁</span></span><br><span class="line"><span class="built_in">mutex_init</span>(&amp;proc-&gt;files_lock);</span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;todo);</span><br><span class="line">    <span class="comment">// 确定进程调度策略</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binder_supported_policy</span>(current-&gt;policy)) &#123;</span><br><span class="line">proc-&gt;default_priority.sched_policy = current-&gt;policy;</span><br><span class="line">proc-&gt;default_priority.prio = current-&gt;normal_prio;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">proc-&gt;default_priority.sched_policy = SCHED_NORMAL;</span><br><span class="line">proc-&gt;default_priority.prio = <span class="built_in">NICE_TO_PRIO</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断nodp是否是binder_device:</span></span><br><span class="line">    <span class="comment">//  inode-&gt;i_sb-&gt;s_magic == BINDERFS_SUPER_MAGIC</span></span><br><span class="line">    <span class="comment">// s_magic是在binderfs_fill_super也就是binder驱动挂载时赋值的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is_binderfs_device</span>(nodp)) &#123;</span><br><span class="line">        <span class="comment">// 如果是binder_device:</span></span><br><span class="line">        <span class="comment">// 回忆下上一篇文章3.4 binderfs.c#binderfs_binder_device_create</span></span><br><span class="line">        <span class="comment">// 我们将创建的binder_device存入了i_private数据中</span></span><br><span class="line">binder_dev = nodp-&gt;i_private;</span><br><span class="line">info = nodp-&gt;i_sb-&gt;s_fs_info;</span><br><span class="line">binder_binderfs_dir_entry_proc = info-&gt;proc_log_dir;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">binder_dev = <span class="built_in">container_of</span>(filp-&gt;private_data,</span><br><span class="line">  <span class="keyword">struct</span> binder_device, miscdev);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 标记binder_device的引用计数+1</span></span><br><span class="line"><span class="built_in">refcount_inc</span>(&amp;binder_dev-&gt;ref);</span><br><span class="line">    <span class="comment">// binder_proc的上下文</span></span><br><span class="line">proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line"><span class="built_in">binder_alloc_init</span>(&amp;proc-&gt;alloc);</span><br><span class="line">    <span class="comment">// binder_stats中BINDER_STAT_PROC类型的创建数加+1</span></span><br><span class="line"><span class="built_in">binder_stats_created</span>(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">// binder_proc的pid为当前进程的主进程的pid</span></span><br><span class="line">proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;delivered_death);</span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;proc-&gt;waiting_threads);</span><br><span class="line">filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mutex_lock</span>(&amp;binder_procs_lock);</span><br><span class="line">    <span class="comment">// 将当前binder_proc的proc_node加入binder_procs列表中</span></span><br><span class="line">    <span class="comment">// binder_procs是binder驱动中存储一系列binder_proc的链表</span></span><br><span class="line">    <span class="comment">// 关于binder_proc是如何插入链表中的，我们后续分析，涉及‘传说中’的红黑树操作</span></span><br><span class="line">    <span class="comment">// 注意当前虽然是在应用进程中，但此时已经进入内核态了。</span></span><br><span class="line"><span class="built_in">hlist_add_head</span>(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line"><span class="built_in">mutex_unlock</span>(&amp;binder_procs_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sys/kernel/debug/binder/proc目录存在时</span></span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line"><span class="type">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(strbuf, <span class="built_in">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line"><span class="comment">// proc调试条目是在上下文之间共享的</span></span><br><span class="line">        <span class="comment">// 创建当前binder_proc的目录，可以看到在sys/kernel/debug/binder/proc目录下有很多pid的目录</span></span><br><span class="line">proc-&gt;debugfs_entry = <span class="built_in">debugfs_create_file</span>(strbuf, <span class="number">0444</span>,</span><br><span class="line">binder_debugfs_dir_entry_proc,</span><br><span class="line">(<span class="type">void</span> *)(<span class="type">unsigned</span> <span class="type">long</span>)proc-&gt;pid,</span><br><span class="line">&amp;proc_fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也是binderfs_fill_super中创建的一个目录：/dev/binderfs/binder_logs/proc</span></span><br><span class="line"><span class="keyword">if</span> (binder_binderfs_dir_entry_proc) &#123;</span><br><span class="line"><span class="type">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *binderfs_entry;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(strbuf, <span class="built_in">sizeof</span>(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line"><span class="comment">// 与debugfs类似，进程特定的日志文件在上下文之间共享。</span></span><br><span class="line">        <span class="comment">// 如果已经为进程创建了文件，如果同一进程的另一个上下文调用binder_open（）</span></span><br><span class="line">        <span class="comment">// 则以下binderfs_create_file（）调用将失败，错误代码为EEXIST。</span></span><br><span class="line">        <span class="comment">// 因为与debugfs相同，日志文件将包含给定PID的所有上下文的信息。</span></span><br><span class="line">binderfs_entry = <span class="built_in">binderfs_create_file</span>(binder_binderfs_dir_entry_proc,</span><br><span class="line">strbuf, &amp;proc_fops, (<span class="type">void</span> *)(<span class="type">unsigned</span> <span class="type">long</span>)proc-&gt;pid);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(binderfs_entry)) &#123;</span><br><span class="line">proc-&gt;binderfs_entry = binderfs_entry;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = <span class="built_in">PTR_ERR</span>(binderfs_entry);</span><br><span class="line"><span class="keyword">if</span> (error != -EEXIST) &#123;</span><br><span class="line"><span class="built_in">pr_warn</span>(<span class="string">&quot;Unable to create file %s in binderfs (error %d)\n&quot;</span>,</span><br><span class="line">strbuf, error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_open的函数做的事情也不复杂：</p><ol><li>创建binder_proc, 其pid为当前进程的主进程pid</li><li>标记binder_device的引用计数+1</li><li>将当前binder_proc的proc_node加入binder_procs列表中</li><li>创建当前binder_proc的目录，目录名为: sys&#x2F;kernel&#x2F;debug&#x2F;binder&#x2F;proc&#x2F;pid</li><li>&#x2F;dev&#x2F;binderfs&#x2F;binder_logs&#x2F;proc存在时，也在这个目录下创建对应pid目录</li></ol><p>顺便说一下很多Linux内核宏都用 do { code; } while(0) 的形式,这个是确保code不会被打乱，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> demo do &#123; codeA; codeB; &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (A) </span><br><span class="line"> demo; <span class="comment">//这里展开就不会因为宏内有多行代码而出现逻辑异常</span></span><br><span class="line">nextCodeLine;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-binder-ioctl-BINDER-VERSION-amp-BINDER-SET-CONTEXT-MGR-EXT"><a href="#1-5-2-binder-ioctl-BINDER-VERSION-amp-BINDER-SET-CONTEXT-MGR-EXT" class="headerlink" title="1.5.2 binder_ioctl - BINDER_VERSION &amp; BINDER_SET_CONTEXT_MGR_EXT"></a>1.5.2 binder_ioctl - BINDER_VERSION &amp; BINDER_SET_CONTEXT_MGR_EXT</h3><blockquote><p>status_t result &#x3D; ioctl(fd, BINDER_VERSION, &amp;vers);</p></blockquote><p>从参数名称可以看到，这里是获取binder版本号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_thread</span> *thread;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line"><span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*pr_info(&quot;binder_ioctl: %d:%d %x %lx\n&quot;,</span></span><br><span class="line"><span class="comment">proc-&gt;pid, current-&gt;pid, cmd, arg);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配BUFFER_NUM buffers以覆盖所有页面对齐情况，然后以所有可能的顺序释放它们。</span></span><br><span class="line">    <span class="comment">// 检查页面是否正确分配，在释放缓冲区时放在lru上，在调用binder_alloc_free_page时释放。</span></span><br><span class="line"><span class="built_in">binder_selftest_alloc</span>(&amp;proc-&gt;alloc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">trace_binder_ioctl</span>(cmd, arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_stop_on_user_error是一个int变量，当出现binder_stop_on_user_error错误</span></span><br><span class="line">    <span class="comment">// 时为2, 这里的意思是只要这个不为2,使得cpu不休眠。</span></span><br><span class="line">ret = <span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_unlocked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据binder_proc获取binder_thread, 后续分析</span></span><br><span class="line">thread = <span class="built_in">binder_get_thread</span>(proc);</span><br><span class="line"><span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR_EXT: &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> fbo;</span><br><span class="line">        <span class="comment">// 从用户空间拷贝ubuf内容至fbo中，其实就是15，单个进程的最大binder线程数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;fbo, ubuf, <span class="built_in">sizeof</span>(fbo))) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 设置单个进程的最大binder数目，默认是15个(app进程)</span></span><br><span class="line">ret = <span class="built_in">binder_ioctl_set_ctx_mgr</span>(filp, &amp;fbo);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> BINDER_VERSION: &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_version</span> __user *ver = ubuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_version)) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 从内核空间获取BINDER_CURRENT_PROTOCOL_VERSION拷贝到用户空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">put_user</span>(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">     &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_from_user函数的目的是从用户空间拷贝数据到内核空间，<strong>失败返回没有被拷贝的字节数，成功返回0</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(void *to, const void __user *from, unsigned long n)</span><br><span class="line">1. *to         将数据拷贝到内核的地址</span><br><span class="line">2. *from       需要拷贝数据的地址</span><br><span class="line">3. n           拷贝数据的长度（字节）</span><br><span class="line"></span><br><span class="line">也就是将from地址中的数据拷贝到to地址中去，拷贝长度是n</span><br></pre></td></tr></table></figure><h1 id="二-ioctl-BINDER-WRITE-READ"><a href="#二-ioctl-BINDER-WRITE-READ" class="headerlink" title="二. ioctl - BINDER_WRITE_READ"></a>二. ioctl - BINDER_WRITE_READ</h1><p>现在万事具备了，我们继续分析进程间的ioctl通信传输数据, 回到最开始：IPCThreadState#talkWithDriver</p><p>其实我们在open_driver - 打开binder驱动的过程中就有分析看到ioctl了。</p><p>从代码的角度理解为什么说binder跨进程通信只需要一次内存拷贝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">    err = NO_ERROR;</span><br></pre></td></tr></table></figure><h2 id="2-1-binder-ioctl-BINDER-WRITE-READ"><a href="#2-1-binder-ioctl-BINDER-WRITE-READ" class="headerlink" title="2.1 binder_ioctl - BINDER_WRITE_READ"></a>2.1 binder_ioctl - BINDER_WRITE_READ</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">binder_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ:</span><br><span class="line">        <span class="comment">// thread是根据binder_proc获取的binder_thread</span></span><br><span class="line">        <span class="comment">// 这里的arg就是上面的ioctl的最后一个参数bwr的地址</span></span><br><span class="line">ret = <span class="built_in">binder_ioctl_write_read</span>(filp, cmd, arg, thread);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"><span class="keyword">if</span> (thread)</span><br><span class="line">thread-&gt;looper_need_return = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">wait_event_interruptible</span>(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line"><span class="built_in">pr_info</span>(<span class="string">&quot;%d:%d ioctl %x %lx returned %d\n&quot;</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line"><span class="built_in">trace_binder_ioctl_done</span>(ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-binder-c-binder-ioctl-write-read"><a href="#2-2-binder-c-binder-ioctl-write-read" class="headerlink" title="2.2 binder.c:binder_ioctl_write_read"></a>2.2 binder.c:binder_ioctl_write_read</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_ioctl_write_read</span><span class="params">(<span class="keyword">struct</span> file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_proc</span> *proc = filp-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line"><span class="type">void</span> __user *ubuf = (<span class="type">void</span> __user *)arg;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_write_read</span> bwr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(<span class="keyword">struct</span> binder_write_read)) &#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 从用户空间拷贝ubuf内容至bwr中, 一次拷贝：从用户空间到内核空间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;bwr, ubuf, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">     <span class="string">&quot;%d:%d write %lld at %016llx, read %lld at %016llx\n&quot;</span>,</span><br><span class="line">     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">     (u64)bwr.write_size, (u64)bwr.write_buffer,</span><br><span class="line">     (u64)bwr.read_size, (u64)bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还记得么，这个bwr是在IPCThreadState#talkWithDriver中填充的数据</span></span><br><span class="line">    <span class="comment">// write_size 代表 binder in parcel数据大小</span></span><br><span class="line">    <span class="comment">// read_size 代表 binder out parcel数据大小</span></span><br><span class="line"><span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理用户进程传来的数据</span></span><br><span class="line">ret = <span class="built_in">binder_thread_write</span>(proc, thread,</span><br><span class="line">  bwr.write_buffer,</span><br><span class="line">  bwr.write_size,</span><br><span class="line">  &amp;bwr.write_consumed);</span><br><span class="line"><span class="built_in">trace_binder_write_done</span>(ret);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理需要回传的数据</span></span><br><span class="line">ret = <span class="built_in">binder_thread_read</span>(proc, thread, bwr.read_buffer,</span><br><span class="line"> bwr.read_size,</span><br><span class="line"> &amp;bwr.read_consumed,</span><br><span class="line"> filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line"><span class="built_in">trace_binder_read_done</span>(ret);</span><br><span class="line"><span class="built_in">binder_inner_proc_lock</span>(proc);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">binder_worklist_empty_ilocked</span>(&amp;proc-&gt;todo))</span><br><span class="line"><span class="built_in">binder_wakeup_proc_ilocked</span>(proc);</span><br><span class="line"><span class="built_in">binder_inner_proc_unlock</span>(proc);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr)))</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">binder_debug</span>(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">     <span class="string">&quot;%d:%d wrote %lld of %lld, read return %lld of %lld\n&quot;</span>,</span><br><span class="line">     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">     (u64)bwr.write_consumed, (u64)bwr.write_size,</span><br><span class="line">     (u64)bwr.read_consumed, (u64)bwr.read_size);</span><br><span class="line">    <span class="comment">// 将从内核空间拷贝bwr内容至ubuf中, 一次拷贝：从内核空间到用户空间</span></span><br><span class="line">    <span class="comment">// 但是这里是新的数据了，不算是内容的重复拷贝，如果说不需要回传数据，oneway的方式，这个拷贝也不是必要的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(ubuf, &amp;bwr, <span class="built_in">sizeof</span>(bwr))) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_from_user函数的目的是从内核空间拷贝数据到用户空间，失败返回没有被拷贝的字节数，成功返回0.</p><p>unsigned long copy_to_user(void *to, const void *from, unsigned long n)</p><ol><li>*to            目标地址（用户空间）</li><li>*from          源地址（内核空间）</li><li>n              将要拷贝数据的字节数</li></ol><p>返回：成功返回0，失败返回没有拷贝成功的数据字节数</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以看到用户进程IPCThreadState的初始化之后会将binder驱动与进程内存映射，提供一块虚拟地址空间来接收binder驱动数据。<br>这里就拿到了binder的fd, 保存在用户进程的mDriverFD中, 现在就可以愉快的通信了。</p><p>鉴于 binder_thread_write 和 binder_thread_read 函数都特别大，接下来单开两篇分开论述。</p><p>之前看 <strong>红茶一杯话Binder（传输机制篇_中）</strong> 有一张图特别清晰的展现了这里的流程，在此贴出:</p><p><img src="/images/Binder-5-binder%E9%A9%B1%E5%8A%A8%E5%93%8D%E5%BA%94ioctl/5_1_%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="图片"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>module_init解析及内核initcall的初始化顺序 <a href="https://www.cnblogs.com/chaozhu/p/6410271.html">https://www.cnblogs.com/chaozhu/p/6410271.html</a></li><li>各种initcall的执行先后顺序 <a href="https://blog.csdn.net/fenzhikeji/article/details/6860143">https://blog.csdn.net/fenzhikeji/article/details/6860143</a></li><li>binder 驱动的操作 <a href="https://blog.csdn.net/qq_15893929/article/details/103965668">https://blog.csdn.net/qq_15893929/article/details/103965668</a></li><li>Android的IPC机制Binder的各个部分 <a href="http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml">http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml</a></li><li>字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 <a href="https://blog.csdn.net/weixin_42314225/article/details/81112217">https://blog.csdn.net/weixin_42314225/article/details/81112217</a></li><li>linux文件系统 - 初始化(一) <a href="https://www.cnblogs.com/alantu2018/p/8447303.html">https://www.cnblogs.com/alantu2018/p/8447303.html</a></li><li>mount过程分析之五(mount_bdev-&gt;fill_super) <a href="https://blog.csdn.net/ZR_Lang/article/details/40115013">https://blog.csdn.net/ZR_Lang/article/details/40115013</a></li><li>VFS四大对象之一 struct super_block <a href="https://www.cnblogs.com/linhaostudy/p/7427027.html">https://www.cnblogs.com/linhaostudy/p/7427027.html</a></li><li>Linux字符设备驱动file_operations <a href="https://www.cnblogs.com/chen-farsight/p/6181341.html">https://www.cnblogs.com/chen-farsight/p/6181341.html</a></li><li>一种linux线程私有数据技术 <a href="http://blog.163.com/william_djj@126/blog/static/3516650120085111193035/">http://blog.163.com/william_djj@126/blog/static/3516650120085111193035/</a></li><li>pthread_key_t和pthread_key_create()详解 <a href="https://www.cnblogs.com/klcf0220/p/5807148.html">https://www.cnblogs.com/klcf0220/p/5807148.html</a></li><li>腾讯面试题——谈一谈Binder的原理和实现一次拷贝的流程 <a href="https://blog.csdn.net/AndroidStudyDay/article/details/93749470">https://blog.csdn.net/AndroidStudyDay/article/details/93749470</a></li><li>红茶一杯话Binder（传输机制篇_中） <a href="https://my.oschina.net/youranhongcha/blog/152963">https://my.oschina.net/youranhongcha/blog/152963</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，我们现在了解了binder驱动的加载过程，回过头继续分析App使用Binder通信的过程。&lt;/p&gt;
&lt;p&gt;先回顾下App使用binder通信的大致过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建AIDL文件，定义接口函数并在服务端app中实现,并注册进SystemServer&lt;/li&gt;
&lt;li&gt;客户端app通过SystemServer获取服务端注册的Service所代表的IBinder(BpBinder)&lt;ol&gt;
&lt;li&gt;Client app &amp;lt;–&amp;gt; SystemServer &amp;lt;–&amp;gt; Server app&lt;/li&gt;
&lt;li&gt;Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;客户端app通过该IBinder与服务端app直接通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前我们分析到最后一步是：IPCThreadState#talkWithDriver&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(4)--binder驱动的加载</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-4-binder%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-4-binder%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD/</id>
    <published>2022-04-04T02:38:31.000Z</published>
    <updated>2022-04-04T02:43:26.817Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，想要了解binder驱动的工作原理，我们从binder驱动加载过程开始：</p><p>在android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c中，我们可以看到有这么一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_initcall(binder_init);</span><br></pre></td></tr></table></figure><p>在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它的initcall 的level为6。</p><p>他可以将驱动设备加载进内核中，以供后续使用。</p><span id="more"></span><h1 id="一-Linux内核init-call过程"><a href="#一-Linux内核init-call过程" class="headerlink" title="一. Linux内核init call过程"></a>一. Linux内核init call过程</h1><p>在<a href="https://blog.csdn.net/u014535072/article/details/82936972">Android开机流程(一)</a>一文中有阐述Android开机过程。</p><p>我们知道系统加电自检后，引导程序执行完毕，内核映像被加载到内存并获得控制权之后，会启动kernel_init。</p><h2 id="1-1-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c"><a href="#1-1-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c" class="headerlink" title="1.1 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c"></a>1.1 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 初始化kernel参数</span></span><br><span class="line"><span class="built_in">kernel_init_freeable</span>()</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-kernel-init-freeable"><a href="#1-2-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-kernel-init-freeable" class="headerlink" title="1.2 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:kernel_init_freeable"></a>1.2 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:kernel_init_freeable</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> noinline <span class="type">void</span> __init <span class="title">kernel_init_freeable</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="built_in">do_basic_setup</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_basic_setup</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 调用各种initcall</span></span><br><span class="line"><span class="built_in">do_initcalls</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_initcalls</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> level;</span><br><span class="line">    <span class="comment">// initcall_levels 的大小是9，所以这里level是从0到7的</span></span><br><span class="line"><span class="keyword">for</span> (level = <span class="number">0</span>; level &lt; <span class="built_in">ARRAY_SIZE</span>(initcall_levels) - <span class="number">1</span>; level++)</span><br><span class="line"><span class="built_in">do_initcall_level</span>(level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-do-initcall-level"><a href="#1-3-android-x2F-kernel-x2F-msm-4-9-x2F-init-x2F-main-c-do-initcall-level" class="headerlink" title="1.3 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:do_initcall_level"></a>1.3 android&#x2F;kernel&#x2F;msm-4.9&#x2F;init&#x2F;main.c:do_initcall_level</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keep these in sync with initcalls in include/linux/init.h */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *initcall_level_names[] __initdata = &#123;</span><br><span class="line"><span class="string">&quot;pure&quot;</span>,</span><br><span class="line"><span class="string">&quot;core&quot;</span>,</span><br><span class="line"><span class="string">&quot;postcore&quot;</span>,</span><br><span class="line"><span class="string">&quot;arch&quot;</span>,</span><br><span class="line"><span class="string">&quot;subsys&quot;</span>,</span><br><span class="line"><span class="string">&quot;fs&quot;</span>,</span><br><span class="line"><span class="string">&quot;device&quot;</span>,</span><br><span class="line"><span class="string">&quot;late&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> __init <span class="title">do_initcall_level</span><span class="params">(<span class="type">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 按顺序执行initcall_levels，其实就是initcall_level_names中的顺序。</span></span><br><span class="line"><span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line"><span class="built_in">do_one_initcall</span>(<span class="built_in">initcall_from_entry</span>(fn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实Andorid开机过程中的init.rc中各种init进程和这里类似。</p><h1 id="二-binder驱动的初始化"><a href="#二-binder驱动的初始化" class="headerlink" title="二. binder驱动的初始化"></a>二. binder驱动的初始化</h1><p>在了解Linux内核各种init call之后, 我们注意到binder.c最后几行代码中有这么一行:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">device_initcall</span>(binder_init);</span><br></pre></td></tr></table></figure><p>而在android&#x2F;kernel&#x2F;msm-4.9&#x2F;include&#x2F;linux&#x2F;init.h中可以看到定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pure_initcall(fn)__define_initcall(fn, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall(fn)__define_initcall(fn, 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> core_initcall_sync(fn)__define_initcall(fn, 1s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall(fn)__define_initcall(fn, 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> postcore_initcall_sync(fn)__define_initcall(fn, 2s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall(fn)__define_initcall(fn, 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_initcall_sync(fn)__define_initcall(fn, 3s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall(fn)__define_initcall(fn, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> subsys_initcall_sync(fn)__define_initcall(fn, 4s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall(fn)__define_initcall(fn, 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs_initcall_sync(fn)__define_initcall(fn, 5s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rootfs_initcall(fn)__define_initcall(fn, rootfs)</span></span><br><span class="line"><span class="comment">// HERE!!!</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall(fn)__define_initcall(fn, 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> device_initcall_sync(fn)__define_initcall(fn, 6s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall(fn)__define_initcall(fn, 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> late_initcall_sync(fn)__define_initcall(fn, 7s)</span></span><br></pre></td></tr></table></figure><p>所以binder驱动的加载时机是先于Android的init进程的，在Linux内核启动中是以level为6（device）的优先级加载的。</p><h2 id="2-1-binder-c-binder-init"><a href="#2-1-binder-c-binder-init" class="headerlink" title="2.1 binder.c:binder_init"></a>2.1 binder.c:binder_init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">binder_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">char</span> *device_name, *device_tmp;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_device</span> *device;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hlist_node</span> *tmp;</span><br><span class="line"><span class="type">char</span> *device_names = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化binder缓冲区,其实就是一个list_lru结构体:binder_alloc_lru</span></span><br><span class="line">ret = <span class="built_in">binder_alloc_shrinker_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建binder相关文件</span></span><br><span class="line">    <span class="comment">// 在sys/kernel/debug目录下，创建binder目录　- debugfs是一种用户内核调试的虚拟文件系统</span></span><br><span class="line">binder_debugfs_dir_entry_root = <span class="built_in">debugfs_create_dir</span>(<span class="string">&quot;binder&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建sys/kernel/debug/binder/proc目录</span></span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">binder_debugfs_dir_entry_proc = <span class="built_in">debugfs_create_dir</span>(<span class="string">&quot;proc&quot;</span>,</span><br><span class="line"> binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建其余文件</span></span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;state&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="comment">// 2.1.1 操作函数的定义</span></span><br><span class="line">    &amp;binder_state_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;stats&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;binder_stats_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;transactions&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;binder_transactions_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;transaction_log&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    &amp;binder_transaction_log,</span><br><span class="line">    &amp;binder_transaction_log_fops);</span><br><span class="line"><span class="built_in">debugfs_create_file</span>(<span class="string">&quot;failed_transaction_log&quot;</span>,</span><br><span class="line">    <span class="number">0444</span>,</span><br><span class="line">    binder_debugfs_dir_entry_root,</span><br><span class="line">    &amp;binder_transaction_log_failed,</span><br><span class="line">    &amp;binder_transaction_log_fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CONFIG_ANDROID_BINDERFS是编译配置,一般都是定义的，所以这个分支不进入</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_ENABLED</span>(CONFIG_ANDROID_BINDERFS) &amp;&amp;</span><br><span class="line">    <span class="built_in">strcmp</span>(binder_devices_param, <span class="string">&quot;&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 初始化binder文件系统</span></span><br><span class="line">ret = <span class="built_in">init_binderfs</span>();</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是创建了sys&#x2F;kernel&#x2F;debug&#x2F;binder目录，以及其子目录或文件:</p><ol><li>proc:记录调用Binder各个进程的内容</li><li>state:记录状态信息，操作函数binder_state_fops</li><li>stats:记录统计信息，操作函数binder_stats_fops</li><li>transactions:记录transaction相关信息，操作函数binder_transactions_fops</li><li>transaction_log:记录transaction日志，操作函数binder_transaction_log_fops</li><li>failed_transaction_log:记录失败的transaction日志信息，操作函数binder_transaction_log_fops</li></ol><p>这里比较奇怪的是没有找到创建文件(目录)时的操作函数的定义,比如binder_state_fops。</p><h3 id="2-1-1-操作函数的定义"><a href="#2-1-1-操作函数的定义" class="headerlink" title="2.1.1 操作函数的定义"></a>2.1.1 操作函数的定义</h3><p>以binder_state_fops为例，其实这些函数的定义是通过宏定义统一实现的。</p><p>在文件android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h中我们可以看到有如下函数的声明:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_stats_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_stats);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_state_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_state);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_transactions_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_transactions);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binder_transaction_log_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *unused)</span></span>;</span><br><span class="line"><span class="built_in">DEFINE_SHOW_ATTRIBUTE</span>(binder_transaction_log);</span><br></pre></td></tr></table></figure><p>我们看binder_state_show这个函数下面的DEFINE_SHOW_ATTRIBUTE这个宏。</p><h3 id="2-1-2-DEFINE-SHOW-ATTRIBUTE"><a href="#2-1-2-DEFINE-SHOW-ATTRIBUTE" class="headerlink" title="2.1.2 DEFINE_SHOW_ATTRIBUTE"></a>2.1.2 DEFINE_SHOW_ATTRIBUTE</h3><p>这个宏的申明是在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;include&#x2F;linux&#x2F;seq_file.h#148</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_SHOW_ATTRIBUTE(__name)\</span></span><br><span class="line"><span class="meta">static int __name ## _open(struct inode *inode, struct file *file)\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">return single_open(file, __name ## _show, inode-&gt;i_private);\</span></span><br><span class="line"><span class="meta">&#125;\</span></span><br><span class="line"><span class="meta">\</span></span><br><span class="line"><span class="meta">static const struct file_operations __name ## _fops = &#123;\</span></span><br><span class="line"><span class="meta">.owner= THIS_MODULE,\</span></span><br><span class="line"><span class="meta">.open= __name ## _open,\</span></span><br><span class="line"><span class="meta">.read= seq_read,\</span></span><br><span class="line"><span class="meta">.llseek= seq_lseek,\</span></span><br><span class="line"><span class="meta">.release= single_release,\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>把这个宏展开就是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __name_open(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> single_open(file, __name_show, inode-&gt;i_private);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> __<span class="title">name_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.open= __name_open,</span><br><span class="line">.read= seq_read,</span><br><span class="line">.llseek= seq_lseek,</span><br><span class="line">.release= single_release,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当声明函数binder_state_show时，也就通过DEFINE_SHOW_ATTRIBUTE(binder_state)申明了：</p><ol><li>函数:   binder_state_open</li><li>结构体: binder_state_fops</li></ol><h2 id="2-2-init-binderfs-初始化binder文件系统"><a href="#2-2-init-binderfs-初始化binder文件系统" class="headerlink" title="2.2 init_binderfs 初始化binder文件系统"></a>2.2 init_binderfs 初始化binder文件系统</h2><p>在文件:android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder_internal.h#init_binderfs</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ANDROID_BINDERFS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __init <span class="title function_">init_binderfs</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __init <span class="title function_">init_binderfs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里的CONFIG_ANDROID_BINDERFS就对应内核编译时的配置:android-base.config#20</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_ANDROID_BINDERFS=y</span><br></pre></td></tr></table></figure><p>y就是定义该宏。</p><p>这里是引用了外部文件的函数: init_binderfs, 在该头文件的同目录下的文件binderfs.c可以找到对应函数实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __init <span class="title">init_binderfs</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_devices_param是定义在binder.c文件中的：</span></span><br><span class="line">    <span class="comment">//  char *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES;</span></span><br><span class="line">    <span class="comment">// 而CONFIG_ANDROID_BINDER_DEVICES 是编译配置: </span></span><br><span class="line">    <span class="comment">//  CONFIG_ANDROID_BINDER_DEVICES=&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line"><span class="comment">// 所以这里的name就是&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line">    name = binder_devices_param;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证默认的binderfs设备名是否合法有效</span></span><br><span class="line">    <span class="comment">// 检验的方式是判断名字中是否含有字符&#x27;,&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>); len &gt; <span class="number">0</span>; len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// BINDERFS_MAX_NAME = 255</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; BINDERFS_MAX_NAME)</span><br><span class="line"><span class="keyword">return</span> -E2BIG;</span><br><span class="line">name += len;</span><br><span class="line"><span class="keyword">if</span> (*name == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">name++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配binder设备编号</span></span><br><span class="line">ret = <span class="built_in">alloc_chrdev_region</span>(&amp;binderfs_dev, <span class="number">0</span>, BINDERFS_MAX_MINOR,</span><br><span class="line">  <span class="string">&quot;binder&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2.1 注册binder文件系统</span></span><br><span class="line">ret = <span class="built_in">register_filesystem</span>(&amp;binder_fs_type);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="built_in">unregister_chrdev_region</span>(binderfs_dev, BINDERFS_MAX_MINOR);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_system_type</span> binder_fs_type = &#123;</span><br><span class="line">.name= <span class="string">&quot;binder&quot;</span>,</span><br><span class="line">.mount= binderfs_mount,</span><br><span class="line">.kill_sb= binderfs_kill_super,</span><br><span class="line">.fs_flags= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化binder文件系统，三件事：</p><ol><li>验证binder_devices_param也就是编译配置文件中的：CONFIG_ANDROID_BINDER_DEVICES是否合法</li><li>分配binder设备编号</li><li>注册binder文件系统</li></ol><p>在这一步之后我们就可以通过　cat proc&#x2F;devices 查到binder驱动对应的设备号了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SS9805:/ # cat proc/devices</span><br><span class="line">Character devices:</span><br><span class="line">......</span><br><span class="line">488 binder</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>比如这次我们机器中binder驱动的设备号为488，而且还可以看到这里是注册成字符设备的。</p><blockquote><p>Linux 中的设备有2种类型：字符设备(无缓冲且只能顺序存取)、块设备(有缓冲且可以随机存取)。</p></blockquote><p>在Linux下，一切皆文件，设备也不例外，为了管理这些设备，系统为它们各自都编了号，而每个设备号又分为主设备号和次设备号。主设备号用来区分不同类型的设备，而次设备号用来区分同一类型内的多个设备（及其设备分区）。</p><h3 id="2-2-1-register-filesystem"><a href="#2-2-1-register-filesystem" class="headerlink" title="2.2.1 register_filesystem"></a>2.2.1 register_filesystem</h3><p>定义在android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;filesystems.c中:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_system_type</span> ** p;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BUG_ON</span>(<span class="built_in">strchr</span>(fs-&gt;name, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"><span class="keyword">if</span> (fs-&gt;next)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="built_in">write_lock</span>(&amp;file_systems_lock);</span><br><span class="line">    <span class="comment">// 在file_systems链表中找到合适位置，插入</span></span><br><span class="line">p = <span class="built_in">find_filesystem</span>(fs-&gt;name, <span class="built_in">strlen</span>(fs-&gt;name));</span><br><span class="line"><span class="comment">// 如果不为空，说明已经注册过了，不能重复注册</span></span><br><span class="line">    <span class="keyword">if</span> (*p)</span><br><span class="line">res = -EBUSY;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*p = fs;</span><br><span class="line"><span class="built_in">write_unlock</span>(&amp;file_systems_lock);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(register_filesystem);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_system_type</span> **<span class="built_in">find_filesystem</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file_system_type</span> **p;</span><br><span class="line"><span class="keyword">for</span> (p = &amp;file_systems; *p; p = &amp;(*p)-&gt;next)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>((*p)-&gt;name, name, len) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    !(*p)-&gt;name[len])</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是将传入的fs插入file_systems链表的末尾，且不能重复注册。</p><h1 id="三-binder设备创建及挂载－debugfs挂载"><a href="#三-binder设备创建及挂载－debugfs挂载" class="headerlink" title="三.binder设备创建及挂载－debugfs挂载"></a>三.binder设备创建及挂载－debugfs挂载</h1><p>上面的步骤我们分析了binder驱动的初始化，最后会注册binder文件系统。这一过程都是在kernel初始化的device_initcall中完成的。</p><p>当kernel启动到一定程度，将文件系统挂载后，自然binder驱动会运作起来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct file_system_type binder_fs_type = &#123;</span><br><span class="line">.name= &quot;binder&quot;,</span><br><span class="line">.mount= binderfs_mount, // 文件系统挂载后调用函数</span><br><span class="line">.kill_sb= binderfs_kill_super,</span><br><span class="line">.fs_flags= FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>文件系统挂载后，就会调用binderfs_mount函数.</p><h2 id="3-1-binderfs-c-binderfs-mount"><a href="#3-1-binderfs-c-binderfs-mount" class="headerlink" title="3.1 binderfs.c#binderfs_mount"></a>3.1 binderfs.c#binderfs_mount</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">dentry</span> *<span class="built_in">binderfs_mount</span>(<span class="keyword">struct</span> file_system_type *fs_type,</span><br><span class="line">     <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name,</span><br><span class="line">     <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 留意这个binderfs_fill_super</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mount_nodev</span>(fs_type, flags, data, binderfs_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-android-x2F-kernel-x2F-msm-4-19-x2F-fs-x2F-super-c-mount-nodev"><a href="#3-2-android-x2F-kernel-x2F-msm-4-19-x2F-fs-x2F-super-c-mount-nodev" class="headerlink" title="3.2 android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;super.c#mount_nodev"></a>3.2 android&#x2F;kernel&#x2F;msm-4.19&#x2F;fs&#x2F;super.c#mount_nodev</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *<span class="built_in">mount_nodev</span>(<span class="keyword">struct</span> file_system_type *fs_type,</span><br><span class="line"><span class="type">int</span> flags, <span class="type">void</span> *data,</span><br><span class="line"><span class="built_in">int</span> (*fill_super)(<span class="keyword">struct</span> super_block *, <span class="type">void</span> *, <span class="type">int</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line">    <span class="comment">// 获取超级块</span></span><br><span class="line">    <span class="comment">// 超级块代表了整个文件系统，超级块是文件系统的控制块，有整个文件系统信息</span></span><br><span class="line">    <span class="comment">// 一个文件系统所有的inode都要连接到超级块上，可以说，一个超级块就代表了一个文件系统。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">super_block</span> *s = <span class="built_in">sget</span>(fs_type, <span class="literal">NULL</span>, set_anon_super, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(s))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ERR_CAST</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用传入的函数fill_super</span></span><br><span class="line">error = <span class="built_in">fill_super</span>(s, data, flags &amp; SB_SILENT ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="built_in">deactivate_locked_super</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ERR_PTR</span>(error);</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;s_flags |= SB_ACTIVE;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dget</span>(s-&gt;s_root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(mount_nodev);</span><br></pre></td></tr></table></figure><p>这些设计文件系统挂载知识，后续我们在研究一下。</p><p>调用mount_nodev后，获取超级块如果一切正常，会调用传入的fill_super函数，这里对应的就是binderfs_fill_super!</p><h2 id="3-3-binderfs-c-binderfs-fill-super"><a href="#3-3-binderfs-c-binderfs-fill-super" class="headerlink" title="3.3 binderfs.c#binderfs_fill_super"></a>3.3 binderfs.c#binderfs_fill_super</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binderfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_device</span> device_info = &#123; &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件系统中数据块大小，以字节单位为一页(一般为4096)</span></span><br><span class="line">sb-&gt;s_blocksize = PAGE_SIZE;</span><br><span class="line">sb-&gt;s_blocksize_bits = PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// kmalloc用于内核空间申请内存，申请的内存位于物理内存映射区域，而且在物理上也是连续的</span></span><br><span class="line">    <span class="comment">// 与真实的物理地址只有一个固定的偏移,因为存在较简单的转换关系，所以对申请的内存大小有限制，不能超过128KB。</span></span><br><span class="line">    <span class="comment">// GFP_KERNEL —— 正常分配内存；</span></span><br><span class="line">sb-&gt;s_fs_info = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> binderfs_info), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// inode 保存的其实是实际的数据的一些信息，这些信息称为“元数据”(也就是对文件属性的描述)。</span></span><br><span class="line">    <span class="comment">// 例如：文件大小，设备标识符，用户标识符，用户组标识符，文件模式，扩展属性，文件读取或</span></span><br><span class="line">    <span class="comment">// 修改的时间戳，链接数量，指向存储该内容的磁盘区块的指针，文件分类等等。</span></span><br><span class="line">inode = <span class="built_in">new_inode</span>(sb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此函数在@sb引用的binderfs中创建一个新的binderfs控制设备节点。</span></span><br><span class="line">ret = <span class="built_in">binderfs_binder_ctl_create</span>(sb);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">name = binder_devices_param;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并创建所有binder设备，三种:&quot;binder,hwbinder,vndbinder&quot;</span></span><br><span class="line">    <span class="comment">// 1. binder</span></span><br><span class="line">    <span class="comment">// 2. hwbinder</span></span><br><span class="line">    <span class="comment">// 3. vndbinder</span></span><br><span class="line"><span class="keyword">for</span> (len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>); len &gt; <span class="number">0</span>; len = <span class="built_in">strcspn</span>(name, <span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line"><span class="built_in">strscpy</span>(device_info.name, name, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.4 创建对应binder设备</span></span><br><span class="line">ret = <span class="built_in">binderfs_binder_device_create</span>(inode, <span class="literal">NULL</span>, &amp;device_info);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">name += len;</span><br><span class="line"><span class="keyword">if</span> (*name == <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">name++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info-&gt;mount_opts.stats_mode == STATS_GLOBAL)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">init_binder_logs</span>(sb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-binderfs-c-binderfs-binder-device-create"><a href="#3-4-binderfs-c-binderfs-binder-device-create" class="headerlink" title="3.4 binderfs.c#binderfs_binder_device_create"></a>3.4 binderfs.c#binderfs_binder_device_create</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binderfs_binder_device_create</span><span class="params">(<span class="keyword">struct</span> inode *ref_inode,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">struct</span> binderfs_device __user *userp,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">struct</span> binderfs_device *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> minor, ret;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dentry</span> *dentry, *root;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binder_device</span> *device;</span><br><span class="line"><span class="type">char</span> *name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">size_t</span> name_len;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">super_block</span> *sb = ref_inode-&gt;i_sb;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">binderfs_info</span> *info = sb-&gt;s_fs_info;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给binder_device分配内核内存空间</span></span><br><span class="line">device = <span class="built_in">kzalloc</span>(<span class="built_in">sizeof</span>(*device), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!device)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 创建一个新的inode节点</span></span><br><span class="line">inode = <span class="built_in">new_inode</span>(sb);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重点,　这里将加载文件操作集－binder操作</span></span><br><span class="line">inode-&gt;i_fop = &amp;binder_fops;</span><br><span class="line">inode-&gt;i_uid = info-&gt;root_uid;</span><br><span class="line">inode-&gt;i_gid = info-&gt;root_gid;</span><br><span class="line"></span><br><span class="line">req-&gt;name[BINDERFS_MAX_NAME] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* NUL-terminate */</span></span><br><span class="line">name_len = <span class="built_in">strlen</span>(req-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一块长度为name_len + 1的内存（kmalloc+gfp）</span></span><br><span class="line">    <span class="comment">// 然后将req-&gt;name到(req-&gt;name + len)内存的内容copy到新分配的内存中</span></span><br><span class="line">    <span class="comment">// 最后后返回该内存的首地址</span></span><br><span class="line">name = <span class="built_in">kmemdup</span>(req-&gt;name, name_len + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!name)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化binder_device的相关设置</span></span><br><span class="line"><span class="built_in">refcount_set</span>(&amp;device-&gt;ref, <span class="number">1</span>);</span><br><span class="line">device-&gt;binderfs_inode = inode;</span><br><span class="line">device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">device-&gt;context.name = name;</span><br><span class="line">device-&gt;miscdev.name = name;<span class="comment">// 分别是binder, hwbinder, vndbinder</span></span><br><span class="line">device-&gt;miscdev.minor = minor;</span><br><span class="line"><span class="built_in">mutex_init</span>(&amp;device-&gt;context.context_mgr_node_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 将创建的binder_device保存在inode中</span></span><br><span class="line">inode-&gt;i_private = device;</span><br><span class="line"><span class="built_in">d_instantiate</span>(dentry, inode);</span><br><span class="line"><span class="built_in">fsnotify_create</span>(root-&gt;d_inode, dentry);</span><br><span class="line"><span class="built_in">inode_unlock</span>(<span class="built_in">d_inode</span>(root));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建binder_device的步骤分为:</p><ol><li>给binder_device分配内核内存空间</li><li>根据超级块创建一个新的inode节点</li><li>加载文件操作集－binder_fops 至inode中</li><li>初始化binder_device的相关设置</li><li>将创建的binder_device保存在inode中</li></ol><p>最重要的是关注步骤3,这里我们还要看看binder_fops的文件操作集具体指向的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// android/kernel/msm-4.19/drivers/android/binder.c</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> binder_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.poll = binder_poll,</span><br><span class="line">.unlocked_ioctl = binder_ioctl,</span><br><span class="line">.compat_ioctl = binder_ioctl,</span><br><span class="line">.mmap = binder_mmap,</span><br><span class="line">.open = binder_open,</span><br><span class="line">.flush = binder_flush,</span><br><span class="line">.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哦偶, 终于看到ioctl了，这里先解释下文件操作集的含义及作用:</p><blockquote><p>Linux使用file_operations结构访问驱动程序的函数，这个结构的每一个成员的名字都对应着一个调用。<br>用户进程利用在对设备文件进行诸如read&#x2F;write操作的时候，系统调用通过设备文件的主设备号找到相应的设备<br>驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数，这是Linux的设备驱动程序工作的基本原理。</p></blockquote><p>其实驱动程序可以理解为一个被动服务，当有上层调用时，才会进入，内核调用的具体实现后续分析。</p><p>比如我们在应用进程中调用ioctl，通过syscall进入内核态，但此时进程上下文还是该应用进程的上下文，对应进程状态为S状态。</p><p>所以我们在上一篇文章中 ##1.6 IPCThreadState#talkWithDriver 里面调用ioctl最后是调用了binder_ioctl这个函数！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>module_init解析及内核initcall的初始化顺序 <a href="https://www.cnblogs.com/chaozhu/p/6410271.html">https://www.cnblogs.com/chaozhu/p/6410271.html</a></li><li>各种initcall的执行先后顺序 <a href="https://blog.csdn.net/fenzhikeji/article/details/6860143">https://blog.csdn.net/fenzhikeji/article/details/6860143</a></li><li>binder 驱动的操作 <a href="https://blog.csdn.net/qq_15893929/article/details/103965668">https://blog.csdn.net/qq_15893929/article/details/103965668</a></li><li>Android的IPC机制Binder的各个部分 <a href="http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml">http://tech.it168.com/a2009/0331/2703/000000270388_all.shtml</a></li><li>字符设备驱动-使用alloc_chrdev_region+cdev注册设备驱动 <a href="https://blog.csdn.net/weixin_42314225/article/details/81112217">https://blog.csdn.net/weixin_42314225/article/details/81112217</a></li><li>linux文件系统 - 初始化(一) <a href="https://www.cnblogs.com/alantu2018/p/8447303.html">https://www.cnblogs.com/alantu2018/p/8447303.html</a></li><li>mount过程分析之五(mount_bdev-&gt;fill_super) <a href="https://blog.csdn.net/ZR_Lang/article/details/40115013">https://blog.csdn.net/ZR_Lang/article/details/40115013</a></li><li>VFS四大对象之一 struct super_block <a href="https://www.cnblogs.com/linhaostudy/p/7427027.html">https://www.cnblogs.com/linhaostudy/p/7427027.html</a></li><li>Linux字符设备驱动file_operations <a href="https://www.cnblogs.com/chen-farsight/p/6181341.html">https://www.cnblogs.com/chen-farsight/p/6181341.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，想要了解binder驱动的工作原理，我们从binder驱动加载过程开始：&lt;/p&gt;
&lt;p&gt;在android&amp;#x2F;kernel&amp;#x2F;msm-4.19&amp;#x2F;drivers&amp;#x2F;android&amp;#x2F;binder.c中，我们可以看到有这么一行：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;device_initcall(binder_init);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在Linux内核的启动过程中，一个驱动的注册用module_init调用，即device_initcall，它的initcall 的level为6。&lt;/p&gt;
&lt;p&gt;他可以将驱动设备加载进内核中，以供后续使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(3)--sayHello之ioctl</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-3-sayHello%E4%B9%8Bioctl/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-3-sayHello%E4%B9%8Bioctl/</id>
    <published>2022-04-04T02:38:20.000Z</published>
    <updated>2022-04-04T02:51:16.414Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，首先回顾一下IBinder相关接口的类图：</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png" alt="2_4_IBinder全类图"></p><p>我们知道在Client App中获取的IBinder实际上是BinderProxy类型的对象。那么在上一文中Client App调用sayHello方法过程的的#2.3.2中，我们卡住了，现在可以继续了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>        <span class="title">transact</span><span class="params">(   <span class="type">uint32_t</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Parcel* reply,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="一-IBinder-transact"><a href="#一-IBinder-transact" class="headerlink" title="一. IBinder.transact"></a>一. IBinder.transact</h1><ol><li>Service.onServiceConnected</li><li>IDemoInterface.Stub.Proxy.sayHello</li><li>BinderProxy.transact(Stub.TRANSACTION_sayHello, ……)</li></ol><h2 id="1-1-BinderProxy-transact"><a href="#1-1-BinderProxy-transact" class="headerlink" title="1.1 BinderProxy.transact"></a>1.1 BinderProxy.transact</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 不多废话，直接开始, 注意我们现在的进程环境是Client App哦</span></span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-android-util-Binder-android-os-BinderProxy-transact"><a href="#1-2-android-util-Binder-android-os-BinderProxy-transact" class="headerlink" title="1.2 android_util_Binder#android_os_BinderProxy_transact"></a>1.2 android_util_Binder#android_os_BinderProxy_transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 获取IBinder对象，这里我们已经知道了，是BinderProxy对应Native的IBinder对象</span></span><br><span class="line">    <span class="comment">// 也就是对应Server App存入的JavaBBinder, 是Parcel:flattenBinder中存入cookie的BBinder</span></span><br><span class="line">    <span class="comment">// 然后在通信过程中经过Binder驱动转成了对应的BpBinder</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 上一篇文章我们就分析了，这个target就是BpBinder</span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-BpBinder-transact"><a href="#1-3-BpBinder-transact" class="headerlink" title="1.3 BpBinder#transact"></a>1.3 BpBinder#transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOLINTNEXTLINE(google-default-arguments)</span></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一旦Binder对象死掉，就不会复活</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.4 IPCThreadState!</span></span><br><span class="line">        <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-IPCThreadState-transact"><a href="#1-4-IPCThreadState-transact" class="headerlink" title="1.4 IPCThreadState#transact"></a>1.4 IPCThreadState#transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="type">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="type">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.1 将数据写入mOut中存储, cmd 是BC_TRANSACTION</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// TF_ONE_WAY 是代表这个binder调用是one_way的，不需要等待回传</span></span><br><span class="line">        <span class="comment">// 这个分支表示需要回传数据</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            <span class="comment">// 1.5 当传入的reply Parcel不为null时</span></span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当直接传入一个null的Parcel作为reply时</span></span><br><span class="line">            <span class="comment">// 创建一个假的Parcel接收可能的回写数据</span></span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要回传数据</span></span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>transaction的flag一共有四种：</p><table><thead><tr><th>name</th><th>value</th><th>function</th></tr></thead><tbody><tr><td>TF_ONE_WAY</td><td>0x01</td><td>代表oneway的binder调用，不需要回传数据</td></tr><tr><td>TF_ROOT_OBJECT</td><td>0x04</td><td>内容是组件的根对象</td></tr><tr><td>TF_STATUS_CODE</td><td>0x08</td><td>内容是32位的状态代码</td></tr><tr><td>TF_ACCEPT_FDS</td><td>0x10</td><td>允许使用文件描述符答复</td></tr></tbody></table><p>首先将需要传递的数据写入out中存储，然后去和binder driver通信。</p><p>这里我们先忽略IPCThreadState的初始化过程。</p><h3 id="1-4-1-IPCThreadState-writeTransactionData"><a href="#1-4-1-IPCThreadState-writeTransactionData" class="headerlink" title="1.4.1 IPCThreadState#writeTransactionData"></a>1.4.1 IPCThreadState#writeTransactionData</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="type">int32_t</span> cmd, <span class="type">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> handle, <span class="type">uint32_t</span> code, <span class="type">const</span> Parcel&amp; data, <span class="type">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// cmd为BC_TRANSACTION</span></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    <span class="comment">// 将data保存在mOut中</span></span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里折后就是将数据保存在mOut中，这里是怎么保证多线程并发的时的处理呢？稍后我们研究IPC的初始化就知道了。</p><h2 id="1-5-IPCThreadState-waitForResponse"><a href="#1-5-IPCThreadState-waitForResponse" class="headerlink" title="1.5 IPCThreadState#waitForResponse"></a>1.5 IPCThreadState#waitForResponse</h2><p>从名字也可以猜出来，这里应该就是与binder.c驱动通信。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="type">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cmd;</span><br><span class="line">    <span class="type">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 1.6 显而易见, 与驱动通信</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// #1.6中已经通过ioctl与binder驱动通信了，回传的输入也写入了mIn中</span></span><br><span class="line">        <span class="comment">// 读取的第一个uint32_t的数据代表binder通信类型</span></span><br><span class="line">        cmd = (<span class="type">uint32_t</span>)mIn.<span class="built_in">readInt32</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            err = FAILED_TRANSACTION;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(acquireResult != <span class="literal">NULL</span>, <span class="string">&quot;Unexpected brACQUIRE_RESULT&quot;</span>);</span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> result = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">                <span class="keyword">if</span> (!acquireResult) <span class="keyword">continue</span>;</span><br><span class="line">                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="comment">// 一般非oneway的通信就是走的这里</span></span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                <span class="comment">// 读取从binder驱动回传的数据</span></span><br><span class="line">                err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in">sizeof</span>(tr));</span><br><span class="line">                <span class="built_in">ALOG_ASSERT</span>(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 将回传的数据存入reply中</span></span><br><span class="line">                        reply-&gt;<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">freeBuffer</span>(<span class="literal">nullptr</span>,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;<span class="built_in">setError</span>(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-IPCThreadState-talkWithDriver"><a href="#1-6-IPCThreadState-talkWithDriver" class="headerlink" title="1.6 IPCThreadState#talkWithDriver"></a>1.6 IPCThreadState#talkWithDriver</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="type">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_write_read是一个保存了传输数据以及回传数据信息的结构体</span></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断读缓冲区是否为空</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仍在从输入缓冲区中剩余的数据中读取数据，并且调用者已请求读取下一个数据，则不编写任何内容</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将待传入的数据存入bwr中，以便通过binder驱动传输</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="type">uintptr_t</span>)mOut.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要回传的数据时</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        <span class="comment">// 读缓冲区大小设置为可接受的最大大小</span></span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        <span class="comment">// 将bwr中读缓冲区指针指向mIn中的data，后续驱动直接将数据填充到这里</span></span><br><span class="line">        bwr.read_buffer = (<span class="type">uintptr_t</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// 使用ioctl与binder驱动通信, 将bwr存储的信息传输给binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;Finished read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在回传的数据，则标记</span></span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok, 到这里我们对Binder通信已经有了一个初步的认知,最核心跨进程的通信手段是通过ioctl这个东东。</p><h1 id="二-ioctl介绍"><a href="#二-ioctl介绍" class="headerlink" title="二. ioctl介绍"></a>二. ioctl介绍</h1><p>本身对Linux内核驱动不太了解，可以参考这篇博文: <a href="https://blog.csdn.net/qq_19923217/article/details/82698787">https://blog.csdn.net/qq_19923217/article/details/82698787</a></p><p>ioctl（）系统调用操作特殊文件的底层设备参数。特别是，字符特殊文件（例如终端）的许多操作特性可以通过ioctl（）请求来控制。</p><blockquote><p>ioctl 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>fd</td><td>文件描述符</td></tr><tr><td>cmd</td><td>交互协议，设备驱动将根据 cmd 执行对应操作</td></tr><tr><td>…</td><td>可变参数 arg，依赖 cmd 指定长度以及类型</td></tr></tbody></table><h2 id="2-1-API"><a href="#2-1-API" class="headerlink" title="2.1 API"></a>2.1 API</h2><ol><li>头文件: #include &lt;sys&#x2F;ioctl.h&gt;, 用于指定ioctl（）请求的宏和定义位于文件&lt;sys&#x2F;ioctl.h&gt;中。</li><li>参数:  int ioctl(int fd, unsigned long request, …);<ol><li>fd 必须是打开文件描述符。</li><li>cmd 是依赖于设备的请求代码, 即交互协议，设备驱动将根据 cmd 执行对应操作</li><li>argp(…) 是指向内存的非类型指针, 它传统上是char*argp, ioctl（）请求在其中编码了参数是in参数还是out参数，参数argp的大小以字节为单位。</li></ol></li><li>返回值: ioctl() 函数执行成功时返回 0，失败则返回 -1 并设置全局变量 errorno 值<ol><li>EBADF  fd不是有效的文件描述符。</li><li>EFAULT 默认argp引用不可访问的内存区域。</li><li>EINVAL 请求或argp无效。</li><li>ENOTTY fd与字符专用设备不关联。</li><li>ENOTTY 指定的请求不适用于文件描述符fd引用的对象类型。</li></ol></li></ol><h2 id="2-2-ioctl用户与驱动之间的协议"><a href="#2-2-ioctl用户与驱动之间的协议" class="headerlink" title="2.2 ioctl用户与驱动之间的协议"></a>2.2 ioctl用户与驱动之间的协议</h2><blockquote><p>参考:<a href="https://blog.csdn.net/zifehng/article/details/59576539">https://blog.csdn.net/zifehng/article/details/59576539</a></p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过这个sayHello的过程，我们对binder通信有了基本概念。知道BBinder, BpBinder, IBinder, IInterface等等类的作用。</p><p>接下来我们先看看Binder驱动的加载过程，之后在继续分析ioctl接下来的流程：比如Client发送请求后，binder驱动是怎么找到对应Server的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li><li>msm-4.14 Code <a href="https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c">https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c</a></li><li>linux 内核 - ioctl 函数详解 <a href="https://blog.csdn.net/qq_19923217/article/details/82698787">https://blog.csdn.net/qq_19923217/article/details/82698787</a></li><li>ioctl(2) — Linux manual page <a href="https://man7.org/linux/man-pages/man2/ioctl.2.html">https://man7.org/linux/man-pages/man2/ioctl.2.html</a></li><li>ioctl()分析——从用户空间到设备驱动 <a href="https://blog.csdn.net/zifehng/article/details/59576539">https://blog.csdn.net/zifehng/article/details/59576539</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，首先回顾一下IBinder相关接口的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png&quot; alt=&quot;2_4_IBinder全类图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道在Client App中获取的IBinder实际上是BinderProxy类型的对象。那么在上一文中Client App调用sayHello方法过程的的#2.3.2中，我们卡住了，现在可以继续了：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;status_t&lt;/span&gt;        &lt;span class=&quot;title&quot;&gt;transact&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(   &lt;span class=&quot;type&quot;&gt;uint32_t&lt;/span&gt; code,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                        &lt;span class=&quot;type&quot;&gt;const&lt;/span&gt; Parcel&amp;amp; data,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                        Parcel* reply,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;function&quot;&gt;                                        &lt;span class=&quot;type&quot;&gt;uint32_t&lt;/span&gt; flags = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(2)--sayHello之BinderProxy的创建过程</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-04T02:38:09.000Z</published>
    <updated>2022-04-04T02:50:23.037Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>接上文，首先回顾一下IBinder相关接口的类图：</p><p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png" alt="DemoInterfac"></p><p>现在我们Client进程已经拿到Server端IDemoInterface中的IBinder对象，但是这个IBinder对象到底是哪个呢，Stub本身？还是Proxy亦或是Proxy中的mRemote？</p><p>还是看sayHello的调用过程先:</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">    <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">    <span class="comment">// 1.1 这个asInterface是做了什么操作呢？</span></span><br><span class="line">    <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.1 sayHello!</span></span><br><span class="line">        mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="一-asInterface方法"><a href="#一-asInterface方法" class="headerlink" title="一. asInterface方法"></a>一. asInterface方法</h1><h2 id="1-1-IDemoInterface-Stub-asInterface"><a href="#1-1-IDemoInterface-Stub-asInterface" class="headerlink" title="1.1 IDemoInterface.Stub.asInterface"></a>1.1 IDemoInterface.Stub.asInterface</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2 生成IInterface</span></span><br><span class="line">    android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.oneplus.opbench.server.IDemoInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.oneplus.opbench.server.IDemoInterface)iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.3 转换成Proxy对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是自动生成的，看起来就是通过IBinder生成一个IInterface或者Proxy？</p><h2 id="1-2-Binder-queryLocalInterface"><a href="#1-2-Binder-queryLocalInterface" class="headerlink" title="1.2 Binder.queryLocalInterface"></a>1.2 Binder.queryLocalInterface</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> IInterface <span class="title function_">queryLocalInterface</span><span class="params">(<span class="meta">@NonNull</span> String descriptor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDescriptor != <span class="literal">null</span> &amp;&amp; mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachInterface</span><span class="params">(<span class="meta">@Nullable</span> IInterface owner, <span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">    mOwner = owner;</span><br><span class="line">    mDescriptor = descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看类图我们也知道，只有Binder实现了IBinder接口，而也只有IDemoInterface.Stub继承了Binder。这么说起来，SystemServer回传的IBinder对象实际上是服务端的IDemoInterface.Stub？然而mOwner此时还是null的，注意我们现在在Client进程中。这里我们直接debug client进程发现queryLocalInterface返回的null值，而且传入的IBinder的类型居然是BinderProxy的！这里什么时候返回非null，传入的IBinder是什么时候变成BinderProxy的呢，先留个疑问。</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_1_IBinder%E7%B1%BB%E5%9B%BE.png" alt="2_1_IBinder类图"></p><h2 id="1-3-创建IDemoInterface-Stub-Proxy对象"><a href="#1-3-创建IDemoInterface-Stub-Proxy对象" class="headerlink" title="1.3 创建IDemoInterface.Stub.Proxy对象"></a>1.3 创建IDemoInterface.Stub.Proxy对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">Proxy(android.os.IBinder remote)</span><br><span class="line">&#123;</span><br><span class="line">  mRemote = remote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白了，现在这个mRemote对象实际上是指代的BinderProxy!</p><h1 id="二-sayHello"><a href="#二-sayHello" class="headerlink" title="二. sayHello"></a>二. sayHello</h1><h2 id="2-1-Proxy-sayHello"><a href="#2-1-Proxy-sayHello" class="headerlink" title="2.1 Proxy.sayHello"></a>2.1 Proxy.sayHello</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">  android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">  android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 按顺序写入参数, 注意DESCRIPTOR</span></span><br><span class="line">    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">    _data.writeLong(aLong);</span><br><span class="line">    _data.writeString(aString);</span><br><span class="line">    <span class="comment">// 2.2 实质上是mRemote起作用的，在1.3中我们通过Debug知道这个其实是BinderProxy对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">      getDefaultImpl().sayHello(aLong, aString);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _reply.readException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-BinderProxy-transact"><a href="#2-2-BinderProxy-transact" class="headerlink" title="2.2 BinderProxy.transact"></a>2.2 BinderProxy.transact</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">transact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3 忽略其他代码，这个是call了一个native方法，通过JNI调用</span></span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-android-util-Binder-cpp-android-os-BinderProxy-transact"><a href="#2-3-android-util-Binder-cpp-android-os-BinderProxy-transact" class="headerlink" title="2.3 android_util_Binder.cpp#android_os_BinderProxy_transact"></a>2.3 android_util_Binder.cpp#android_os_BinderProxy_transact</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3.1 首先从名字中可以推出是获取远程通信的目标</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 2.3.2 继续</span></span><br><span class="line">    <span class="type">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-android-util-Binder-cpp-getBPNativeData"><a href="#2-3-1-android-util-Binder-cpp-getBPNativeData" class="headerlink" title="2.3.1 android_util_Binder.cpp#getBPNativeData"></a>2.3.1 android_util_Binder.cpp#getBPNativeData</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinderProxyNativeData</span> &#123;</span><br><span class="line">    <span class="comment">// Both fields are constant and not null once javaObjectForIBinder returns this as</span></span><br><span class="line">    <span class="comment">// part of a BinderProxy.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The native IBinder proxied by this BinderProxy.</span></span><br><span class="line">    sp&lt;IBinder&gt; mObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Death recipients for mObject. Reference counted only because DeathRecipients</span></span><br><span class="line">    <span class="comment">// hold a weak reference that can be temporarily promoted.</span></span><br><span class="line">    sp&lt;DeathRecipientList&gt; mOrgue;  <span class="comment">// Death recipients for mObject.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">binderproxy_offsets_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mGetInstance;</span><br><span class="line">    jmethodID mSendDeathNotice;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    jfieldID mNativeData;  <span class="comment">// Field holds native pointer to BinderProxyNativeData.</span></span><br><span class="line">&#125; gBinderProxyOffsets;</span><br><span class="line"></span><br><span class="line"><span class="function">BinderProxyNativeData* <span class="title">getBPNativeData</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其实就是读取BinderProxy对象中保存的long类型的mNativeData数据</span></span><br><span class="line">    <span class="comment">// 然后强制转换成BinderProxyNativeData类型</span></span><br><span class="line">    <span class="keyword">return</span> (BinderProxyNativeData *) env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderProxyOffsets.mNativeData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并不知道BinderProxy从哪儿来的，Native层也没有定义，应该就是指代java层的BinderProxy。</p><h3 id="2-3-2-IBinder-transact"><a href="#2-3-2-IBinder-transact" class="headerlink" title="2.3.2 IBinder#transact"></a>2.3.2 IBinder#transact</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">status_t</span>        <span class="title">transact</span><span class="params">(   <span class="type">uint32_t</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Parcel* reply,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint32_t</span> flags = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里我们知道getBpNativeData中的mObject是IBinder类型的。但是是一个虚函数，没有具体实现，怎么往下查呢。</p><p>Native的Debug方式也有，但是总归不方便，那我们先梳理一下Native层关于IBinder的类图吧。注意现在我们还是在Client进程内的。</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_2_NativeIBinder%E7%B1%BB%E5%9B%BE.png" alt="2_2_NativeIBinder类图"></p><p>IBinder相关类之间的关系大致理清楚了，从这个函数名称getBPNativeData可以猜出来应该是指代的BpBinder!</p><p>但是怎么确认呢，那我们回到Client App和Server App建立通信的过程中，溯源BinderProxy。</p><h1 id="三-BinderProxy的创建过程"><a href="#三-BinderProxy的创建过程" class="headerlink" title="三. BinderProxy的创建过程"></a>三. BinderProxy的创建过程</h1><h2 id="3-1-publishServiceLocked"><a href="#3-1-publishServiceLocked" class="headerlink" title="3.1 publishServiceLocked"></a>3.1 publishServiceLocked</h2><ol><li>ServerApp:        ActivityThread.handleBindService(BindServiceData data)</li><li>SystemServer: ActivityManagerService.publishService(IBinder token, Intent intent, IBinder service)</li><li>SystemServer: ActiveService.publishServiceLocked(ServiceRecord r, Intent intent, IBinder service)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleBindService</span><span class="params">(BindServiceData data)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个mService就是Service在被调用onCreate方法的时候存入的</span></span><br><span class="line">    <span class="type">Service</span> <span class="variable">s</span> <span class="operator">=</span> mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">&quot;handleBindService s=&quot;</span> + s + <span class="string">&quot; rebind=&quot;</span> + data.rebind);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;</span><br><span class="line">                    <span class="comment">// 3.1.1 所以这个onBind，就是Service中我们实现的onBind方法了</span></span><br><span class="line">                    <span class="comment">// 这里的binder就是对应我们实现的IDemoInterface.Stub</span></span><br><span class="line">                    <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> s.onBind(data.intent);</span><br><span class="line">                    <span class="comment">// 告诉SystemServer该服务已准备就绪</span></span><br><span class="line">                    ActivityManager.getService().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里就是rebind</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    ActivityManager.getService().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-服务端的Stub初始化"><a href="#3-1-1-服务端的Stub初始化" class="headerlink" title="3.1.1 服务端的Stub初始化"></a>3.1.1 服务端的Stub初始化</h3><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoBinder</span>:<span class="type">IDemoInterface.Stub</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(aLong: <span class="type">Long</span>, aString: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;DemoService&quot;</span>, <span class="string">&quot;<span class="variable">$aString</span>:<span class="variable">$aLong</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看这个Stub的初始化过程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binder = DemoBinder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">    <span class="comment">// 所以Service中的onBind含义就是通知到AMS</span></span><br><span class="line">    <span class="comment">// 本服务已准备继续，随时可以工作</span></span><br><span class="line">    <span class="keyword">return</span> binder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要注意的是，初始化DemoBinder过程，会调用父类的构造函数哦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attachInterface</span><span class="params">(<span class="meta">@Nullable</span> IInterface owner, <span class="meta">@Nullable</span> String descriptor)</span> &#123;</span><br><span class="line">    <span class="comment">// 噢噢，这个mOwner就是在这里保存的！</span></span><br><span class="line">    <span class="comment">// 它代表的就是IDemoInterface.Stub类的对象，其实就是DemoBinder</span></span><br><span class="line">    mOwner = owner;</span><br><span class="line">    mDescriptor = descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里还是没有找到BinderProxy对象的创建。不过我们知道，Binder通信是通过往Parcel中写入数据的；</p><p>而AMS.publishService函数中最后一个参数就是IBinder类型的。</p><h2 id="3-2-publishService写入参数"><a href="#3-2-publishService写入参数" class="headerlink" title="3.2 publishService写入参数"></a>3.2 publishService写入参数</h2><p>通过查看IActivityManager.aidl文件编译后生成的IActivityManager.Stub.Proxy.class(想想为啥不是Stub而是Proxy)文件可以知道这个函数的具体内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">  <span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">  <span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _data.writeInterfaceToken(<span class="string">&quot;android.app.IActivityManager&quot;</span>);</span><br><span class="line">    _data.writeStrongBinder(token);</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="literal">null</span>) &#123;</span><br><span class="line">      _data.writeInt(<span class="number">1</span>);</span><br><span class="line">      intent.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.1.3 IBinder对象是通过writeStrongBinder方法写入的</span></span><br><span class="line">    <span class="comment">// 注意这个IBinder就是Service实现的onBind方法中返回的, 就是IDemoInterface.Stub类型</span></span><br><span class="line">    _data.writeStrongBinder(service);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> <span class="built_in">this</span>.mRemote.transact(<span class="number">32</span>, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; IActivityManager.Stub.getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">      IActivityManager.Stub.getDefaultImpl().publishService(token, intent, service);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    _reply.readException();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-Parcel-writeStrongBinder"><a href="#3-2-1-Parcel-writeStrongBinder" class="headerlink" title="3.2.1 Parcel.writeStrongBinder"></a>3.2.1 Parcel.writeStrongBinder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeStrongBinder</span><span class="params">(IBinder val)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的mNativePtr就是此Parcel在Native的对应标识</span></span><br><span class="line">    nativeWriteStrongBinder(mNativePtr, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子直接去了Native层干活去了。</p><h3 id="3-2-2-android-os-Parcel-android-os-Parcel-writeStrongBinder"><a href="#3-2-2-android-os-Parcel-android-os-Parcel-writeStrongBinder" class="headerlink" title="3.2.2 android_os_Parcel#android_os_Parcel_writeStrongBinder"></a>3.2.2 android_os_Parcel#android_os_Parcel_writeStrongBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 转成Native的Parcel</span></span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.2.1 注意这个ibinderForJavaObject方法，将java层IBinder转成Native层的</span></span><br><span class="line">        <span class="comment">// 3.2.3 然后是保存这个Native的IBinder</span></span><br><span class="line">        <span class="type">const</span> <span class="type">status_t</span> err = parcel-&gt;<span class="built_in">writeStrongBinder</span>(<span class="built_in">ibinderForJavaObject</span>(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">signalExceptionForError</span>(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-1-android-util-Binder-ibinderForJavaObject"><a href="#3-2-2-1-android-util-Binder-ibinderForJavaObject" class="headerlink" title="3.2.2.1 android_util_Binder#ibinderForJavaObject"></a>3.2.2.1 android_util_Binder#ibinderForJavaObject</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance of Binder?</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="comment">// 3.2.2.2 返回一个IBinder</span></span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instance of BinderProxy?</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块首次出现了BinderProxy，不过当前我们还处于Service App进程对吧，而且上层传入的IBinder明显只是一个IDemoInterface.Stub类型。</p><p>所以这里还是将这个jobject转换成了JavaBBinderHolder！不过我们有理由猜测，BinderProxy是在AMS所处的SystemServer进程中转换的。</p><h4 id="3-2-2-2-android-util-Binder-JavaBBinderHolder-get"><a href="#3-2-2-2-android-util-Binder-JavaBBinderHolder-get" class="headerlink" title="3.2.2.2 android_util_Binder#JavaBBinderHolder#get"></a>3.2.2.2 android_util_Binder#JavaBBinderHolder#get</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;JavaBBinder&gt; <span class="title">get</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    sp&lt;JavaBBinder&gt; b = mBinder.<span class="built_in">promote</span>();</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.2.3 创建JavaBBinder</span></span><br><span class="line">        b = <span class="keyword">new</span> <span class="built_in">JavaBBinder</span>(env, obj);</span><br><span class="line">        <span class="keyword">if</span> (mVintf) &#123;</span><br><span class="line">            ::android::internal::Stability::<span class="built_in">markVintf</span>(b.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mExtension != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            b.<span class="built_in">get</span>()-&gt;<span class="built_in">setExtension</span>(mExtension);</span><br><span class="line">        &#125;</span><br><span class="line">        mBinder = b;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBinder %p (refs %p) for Object %p, weakCount=%&quot;</span> PRId32 <span class="string">&quot;\n&quot;</span>,</span><br><span class="line">                b.<span class="built_in">get</span>(), b-&gt;<span class="built_in">getWeakRefs</span>(), obj, b-&gt;<span class="built_in">getWeakRefs</span>()-&gt;<span class="built_in">getWeakCount</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回的JavaBBinder,说明JavaBBinder继承了IBinder</span></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-3-创建Native层的IBinder对象-JavaBBinder"><a href="#3-2-2-3-创建Native层的IBinder对象-JavaBBinder" class="headerlink" title="3.2.2.3 创建Native层的IBinder对象-JavaBBinder"></a>3.2.2.3 创建Native层的IBinder对象-JavaBBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JavaBBinder</span>(JNIEnv* env, jobject <span class="comment">/* Java Binder */</span> object)</span><br><span class="line">        : <span class="built_in">mVM</span>(<span class="built_in">jnienv_to_javavm</span>(env)), <span class="built_in">mObject</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(object))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating JavaBBinder %p\n&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 这些先不管</span></span><br><span class="line">    gNumLocalRefsCreated.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">gcIfManyNewRefs</span>(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在看看现在Native层和IBinder有关系的类的类图:</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_3_IBinder%E7%B1%BB%E5%9B%BE_JavaBBinder.png" alt="2_3_IBinder类图_JavaBBinder.png"></p><p>果然JavaBBinder继承了IBinder。回到#3.2.2中，继续往下就是writeStrongBinder了。</p><h3 id="3-2-3-Parcel-writeStrongBinder"><a href="#3-2-3-Parcel-writeStrongBinder" class="headerlink" title="3.2.3 Parcel#writeStrongBinder"></a>3.2.3 Parcel#writeStrongBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::writeStrongBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">flattenBinder</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::flattenBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.2.3.1 是local还是remote？</span></span><br><span class="line">        BBinder *local = binder-&gt;<span class="built_in">localBinder</span>();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进入！</span></span><br><span class="line">            <span class="keyword">if</span> (local-&gt;<span class="built_in">isRequestingSid</span>()) &#123;</span><br><span class="line">                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意这里的type，是BINDER_TYPE_BINDER！</span></span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            <span class="comment">// 保存BBinder的弱引用，这个是干啥用的?</span></span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            <span class="comment">// 保存BBinder对象</span></span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="number">0</span>;</span><br><span class="line">        obj.cookie = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.4 完成IBinder的写入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">finishFlattenBinder</span>(binder, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对local和remote存在不同的处理方式，不过我们先仅仅关注其中一个分支。</p><h4 id="3-2-3-1-IBinder-localBinder"><a href="#3-2-3-1-IBinder-localBinder" class="headerlink" title="3.2.3.1 IBinder#localBinder"></a>3.2.3.1 IBinder#localBinder</h4><p>我们这里的IBinder就是JavaBBinder类的对象，前面我们看过了JavaBBinder的初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BBinder* <span class="title">IBinder::localBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意IBinder调用的是这个</span></span><br><span class="line"><span class="function">BBinder* <span class="title">BBinder::localBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里的IBinder指针是指向其子类的子类JavaBBinder,然后其子类BBinder实现了虚函数localBinder，而JavaBBinder并没有。</p><p>所以这里是local的！</p><h3 id="3-2-4-Parcel-finishFlattenBinder"><a href="#3-2-4-Parcel-finishFlattenBinder" class="headerlink" title="3.2.4 Parcel#finishFlattenBinder"></a>3.2.4 Parcel#finishFlattenBinder</h3><p>flatten的意思是压平，其实可以理解为打包，将JavaBBinder打包然后发送出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::finishFlattenBinder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="type">const</span> flat_binder_object&amp; flat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 写入内存区域，这一块没有接触过，暂时先不管，后面研究</span></span><br><span class="line">    <span class="comment">// 理解为将IBinder保存到内存中的某个特定区域</span></span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">writeObject</span>(flat, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    internal::Stability::<span class="built_in">tryMarkCompilationUnit</span>(binder.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">writeInt32</span>(internal::Stability::<span class="built_in">get</span>(binder.<span class="built_in">get</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里我们知道了Java层的IBinder对象是如何通过Parcel保存到Native中的。</p><h2 id="3-3-SystemServer接收参数"><a href="#3-3-SystemServer接收参数" class="headerlink" title="3.3 SystemServer接收参数"></a>3.3 SystemServer接收参数</h2><p>这里我们先不去细究通信的过程，因为这本身就是一次Binder通信。先看AMS收到Server App发布Service的IBinder对象是什么。</p><p>还是通过看编译后生成的IActivityManager.Stub.Class文件中对应的publishService方法，注意我们现在切换到了SystemServer进程(忽略进程切换过程)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, Parcel data, Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    data.enforceInterface(descriptor);</span><br><span class="line">    <span class="comment">// 读取IBinder对象，不过这个是token, 不是我们想要的Service的IBinder</span></span><br><span class="line">    <span class="comment">// 用过Binder通信知道，是按顺序来读写的，所以我们看最后一个IBinder</span></span><br><span class="line">    iBinder11 = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != data.readInt()) &#123;</span><br><span class="line">      intent6 = (Intent)Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      intent6 = <span class="literal">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 3.3.1 这里就是我们想要的Service的IBinder了</span></span><br><span class="line">    iBinder26 = data.readStrongBinder();</span><br><span class="line">    publishService(iBinder11, intent6, iBinder26);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-Parcel-readStrongBinder"><a href="#3-3-1-Parcel-readStrongBinder" class="headerlink" title="3.3.1 Parcel.readStrongBinder"></a>3.3.1 Parcel.readStrongBinder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title function_">readStrongBinder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeReadStrongBinder(mNativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是直接切到Native.</p><h3 id="3-3-2-android-os-Parcel-android-os-Parcel-readStrongBinder"><a href="#3-3-2-android-os-Parcel-android-os-Parcel-readStrongBinder" class="headerlink" title="3.3.2 android_os_Parcel#android_os_Parcel_readStrongBinder"></a>3.3.2 android_os_Parcel#android_os_Parcel_readStrongBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">android_os_Parcel_readStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.3.2.1 先看Parce-&gt;readStrongBinder</span></span><br><span class="line">        <span class="comment">// 3.3.3  将IBinder转换成jobject</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">javaObjectForIBinder</span>(env, parcel-&gt;<span class="built_in">readStrongBinder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-1-Parcel-readStrongBinder"><a href="#3-3-2-1-Parcel-readStrongBinder" class="headerlink" title="3.3.2.1 Parcel#readStrongBinder"></a>3.3.2.1 Parcel#readStrongBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">Parcel::readStrongBinder</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    <span class="comment">// 暂时不明确IBinder指代的是具体哪个子类吼</span></span><br><span class="line">    <span class="built_in">readNullableStrongBinder</span>(&amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">readNullableStrongBinder</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (status == OK &amp;&amp; !val-&gt;<span class="built_in">get</span>()) &#123;</span><br><span class="line">        status = UNEXPECTED_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::readNullableStrongBinder</span><span class="params">(sp&lt;IBinder&gt;* val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 来了，解压的过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unflattenBinder</span>(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-2-Parcel-unflattenBinder"><a href="#3-3-2-2-Parcel-unflattenBinder" class="headerlink" title="3.3.2.2 Parcel#unflattenBinder"></a>3.3.2.2 Parcel#unflattenBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::unflattenBinder</span><span class="params">(sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从内存区域中读取当前位置的数据</span></span><br><span class="line">    <span class="type">const</span> flat_binder_object* flat = <span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="comment">// 我们在flatten中的Type就是这个！</span></span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">                <span class="comment">// 转成IBinder，没有问题，我们存入的JavaBBinder，其父类的父类就是IBinder</span></span><br><span class="line">                sp&lt;IBinder&gt; binder = <span class="built_in">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="comment">// 3.3.2.3 完成数据解压</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">                sp&lt;IBinder&gt; binder =</span><br><span class="line">                    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方留个心眼哦，这里的flat-&gt;hdr.type真的还是原来的BINDER_TYPE_BINDER吗？</p><h4 id="3-3-2-3-Parcel-finishUnflattenBinder"><a href="#3-3-2-3-Parcel-finishUnflattenBinder" class="headerlink" title="3.3.2.3 Parcel#finishUnflattenBinder"></a>3.3.2.3 Parcel#finishUnflattenBinder</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::finishUnflattenBinder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> sp&lt;IBinder&gt;&amp; binder, sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> stability;</span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">readInt32</span>(&amp;stability);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    status = internal::Stability::<span class="built_in">set</span>(binder.<span class="built_in">get</span>(), stability, <span class="literal">true</span> <span class="comment">/*log*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (status != OK) <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// out指向这个内存区域</span></span><br><span class="line">    *out = binder;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个IBinder到底是什么类型的呢？先回到#3.3.2中，继续readStrongBinder的过程</p><h3 id="3-3-3-android-util-Binder-javaObjectForIBinder"><a href="#3-3-3-android-util-Binder-javaObjectForIBinder" class="headerlink" title="3.3.3 android_util_Binder#javaObjectForIBinder"></a>3.3.3 android_util_Binder#javaObjectForIBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">javaObjectForIBinder</span><span class="params">(JNIEnv* env, <span class="type">const</span> sp&lt;IBinder&gt;&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 3.3.3.1 这里决定是不是直接返回JavaBBinder的类型</span></span><br><span class="line">    <span class="keyword">if</span> (val-&gt;<span class="built_in">checkSubclass</span>(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a JavaBBinder created by ibinderForJavaObject. Already has Java object.</span></span><br><span class="line">        jobject object = <span class="built_in">static_cast</span>&lt;JavaBBinder*&gt;(val.<span class="built_in">get</span>())-&gt;<span class="built_in">object</span>();</span><br><span class="line">        <span class="built_in">LOGDEATH</span>(<span class="string">&quot;objectForBinder %p: it&#x27;s our own %p!\n&quot;</span>, val.<span class="built_in">get</span>(), object);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3.4 终于看到和BinderProxy相关的了, 至少名字上看都有关系</span></span><br><span class="line">    BinderProxyNativeData* nativeData = <span class="keyword">new</span> <span class="built_in">BinderProxyNativeData</span>();</span><br><span class="line">    nativeData-&gt;mOrgue = <span class="keyword">new</span> DeathRecipientList;</span><br><span class="line">    <span class="comment">// 将从内存中读取的IBinder对象存起来</span></span><br><span class="line">    nativeData-&gt;mObject = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3.5 调用到java方法mGetInstance，生成BinderProxy！</span></span><br><span class="line">    jobject object = env-&gt;<span class="built_in">CallStaticObjectMethod</span>(gBinderProxyOffsets.mClass,</span><br><span class="line">            gBinderProxyOffsets.mGetInstance, (jlong) nativeData, (jlong) val.<span class="built_in">get</span>());</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 所以这里最终返回是BinderProxy对象对应JNI的jobject.</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-1-IBinder-checkSubclass"><a href="#3-3-3-1-IBinder-checkSubclass" class="headerlink" title="3.3.3.1 IBinder#checkSubclass"></a>3.3.3.1 IBinder#checkSubclass</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IBinder::checkSubclass</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* <span class="comment">/*subclassID*/</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaBBinder:</span></span><br><span class="line"><span class="function"><span class="type">bool</span>    <span class="title">checkSubclass</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* subclassID)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 3.3.3.2 gBinderOffsets的初始化</span></span><br><span class="line">    <span class="keyword">return</span> subclassID == &amp;gBinderOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里思考一个问题，注意我们现在已经处于SystemServer进程了，这里的IBinder指向一块内存区域，是从Server App中拷贝而来的，与JavaBBinder数据保持一致。</p><p>那我们强制转换转成了IBinder，然后调用IBinder中的函数是调用IBinder中函数实现还是JavaBBinder中的函数实现呢？</p><h4 id="3-3-3-2-android-util-Binder-int-register-android-os-Binder"><a href="#3-3-3-2-android-util-Binder-int-register-android-os-Binder" class="headerlink" title="3.3.3.2 android_util_Binder#int_register_android_os_Binder"></a>3.3.3.2 android_util_Binder#int_register_android_os_Binder</h4><p>首先gBinderOffsets是bindernative_offsets_t类型的结构体，其在int_register_android_os_Binder中被填充数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);</span><br><span class="line"></span><br><span class="line">    gBinderOffsets.mClass = <span class="built_in">MakeGlobalRefOrDie</span>(env, clazz);</span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">    gBinderOffsets.mGetInterfaceDescriptor = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;getInterfaceDescriptor&quot;</span>,</span><br><span class="line">        <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">    gBinderOffsets.mObject = <span class="built_in">GetFieldIDOrDie</span>(env, clazz, <span class="string">&quot;mObject&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在Java中，每个进程都有自己的虚拟机环境，所以对于不同进程来说，JNIEnv肯定也是不同的，这就导致gBinderOffsets也是不同的。</p><p>所以对于3.3.3.1中checkSubclass来说，返回的就是false了。</p><h3 id="3-3-4-创建BinderProxyNativeData"><a href="#3-3-4-创建BinderProxyNativeData" class="headerlink" title="3.3.4 创建BinderProxyNativeData"></a>3.3.4 创建BinderProxyNativeData</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinderProxyNativeData</span> &#123;</span><br><span class="line">    <span class="comment">// Both fields are constant and not null once javaObjectForIBinder returns this as</span></span><br><span class="line">    <span class="comment">// part of a BinderProxy.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The native IBinder proxied by this BinderProxy.</span></span><br><span class="line">    sp&lt;IBinder&gt; mObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Death recipients for mObject. Reference counted only because DeathRecipients</span></span><br><span class="line">    <span class="comment">// hold a weak reference that can be temporarily promoted.</span></span><br><span class="line">    sp&lt;DeathRecipientList&gt; mOrgue;  <span class="comment">// Death recipients for mObject.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哦噢，空欢喜？这里只是一个结构体，将IBinder和DeathRecipientList组合起来。</p><h3 id="3-3-5-gBinderProxyOffsets-mGetInstance-x3D-gt-BinderProxy-getInstance"><a href="#3-3-5-gBinderProxyOffsets-mGetInstance-x3D-gt-BinderProxy-getInstance" class="headerlink" title="3.3.5 gBinderProxyOffsets.mGetInstance &#x3D;&gt; BinderProxy.getInstance"></a>3.3.5 gBinderProxyOffsets.mGetInstance &#x3D;&gt; BinderProxy.getInstance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BinderProxy <span class="title function_">getInstance</span><span class="params">(<span class="type">long</span> nativeData, <span class="type">long</span> iBinder)</span> &#123;</span><br><span class="line">    BinderProxy result;</span><br><span class="line">    <span class="keyword">synchronized</span> (sProxyMap) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = sProxyMap.get(iBinder);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建BinderProxy对象！</span></span><br><span class="line">            result = <span class="keyword">new</span> <span class="title class_">BinderProxy</span>(nativeData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// We&#x27;re throwing an exception (probably OOME); don&#x27;t drop nativeData.</span></span><br><span class="line">            NativeAllocationRegistry.applyFreeFunction(NoImagePreloadHolder.sNativeFinalizer,</span><br><span class="line">                    nativeData);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        NoImagePreloadHolder.sRegistry.registerNativeAllocation(result, nativeData);</span><br><span class="line">        <span class="comment">// The registry now owns nativeData, even if registration threw an exception.</span></span><br><span class="line">        sProxyMap.set(iBinder, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">BinderProxy</span><span class="params">(<span class="type">long</span> nativeData)</span> &#123;</span><br><span class="line">    <span class="comment">// 所以这个nativeData原来是代表的BinderProxyNativeData</span></span><br><span class="line">    mNativeData = nativeData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JNI调用到Java方法，最终生成BinderProxy对象。</p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h1><p>到这里我们就理清了BinderProxy这个是怎么来的了。总结一下：</p><ol><li>Server App实现Service的onBind方法，返回一个IBinder对象，这个IBinder对象是继承了某个aidl接口的Stub类，记为StubIBinder</li><li>Server App调用publishService，将StubIBinder通过一系列方法，在Native层转成JavaBBinder，保存在Parce的内存区域中</li><li>Binder驱动拷贝Parcel并将其传给SystemServer进程(这个过程我们稍后分析)</li><li>SystemServer接收到Parcel内存数据，将其中JavaBBinder所在的内存区域强制转成IBinder类型，并将其保存为Java层的BinderProxy对象</li></ol><p>同理我们知道Client App通过调用bindService获取了一个IBinder对象，那这个IBinder对象也是BinderProxy类型的, 只不过这里有点点小差异:</p><p>SystemServer通过IServiceConnection向Client App发送Server App注册的BinderProxy对象时，在Parcel.writeStrongBinder过程中，存入cookie的是BinderProxy:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ibinderForJavaObject</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为Binder对象</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;<span class="built_in">GetLongField</span>(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh-&gt;<span class="built_in">get</span>(env, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否为BinderProxy对象</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;<span class="built_in">IsInstanceOf</span>(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="comment">// SystemServer向Client App发送Server App的BinderProxy对象，走这里</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;ibinderForJavaObject: %p is not a Binder object&quot;</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在接下来打包flattenBinder的过程中, type 的类型其实是 BINDER_TYPE_HANDLE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::flattenBinder</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; binder)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// ......</span></span></span><br><span class="line"><span class="function">        <span class="comment">// 注意此时我们身处SystemServer进程，传入的IBinder实际上是对应BinderProxy</span></span></span><br><span class="line"><span class="function">        BBinder *local </span>= binder-&gt;<span class="built_in">localBinder</span>();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;<span class="built_in">remoteBinder</span>();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">const</span> <span class="type">int32_t</span> handle = proxy ? proxy-&gt;<span class="built_in">handle</span>() : <span class="number">0</span>;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (local-&gt;<span class="built_in">isRequestingSid</span>()) &#123;</span><br><span class="line">                obj.flags |= FLAT_BINDER_FLAG_TXN_SECURITY_CTX;</span><br><span class="line">            &#125;</span><br><span class="line">            obj.hdr.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local-&gt;<span class="built_in">getWeakRefs</span>());</span><br><span class="line">            obj.cookie = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-新的疑问"><a href="#4-1-新的疑问" class="headerlink" title="4.1 新的疑问"></a>4.1 新的疑问</h2><p>哦吼，新的问题来了，这个binder-&gt;localBinder()调用的到底是那个方法呢？IBinder, BBinder中都有实现。</p><p>如果是直接拷贝的话，那么按理说也是会调用到BBinder的localBinder，这样这里还是个local!</p><p>如果拷贝后在新进程中调用的是IBinder的localBinder，那么接下来的remoteBinder也是IBinder的，还是返回null！</p><p>这样也说不通，因为如果remoteBinder返回的也是空，那么打包后传入的信息就不能识别Server App的IDemoInterface了。</p><p>这里曾困扰我一段时间，这个IBinder到底是什么是我们理解Binder通信的基础。</p><p>按照网上一大堆的文章来说，从Binder通信到了另一个进程，那么BBinder就会转成了BpBinder。</p><p>然而我们梳理了上层代码，并没有发现这个转变过程。在Parcel整个压缩和解包的过程中都没有发现将IBinder强制转成BpBinder。</p><h2 id="4-2-binder驱动"><a href="#4-2-binder驱动" class="headerlink" title="4.2 binder驱动"></a>4.2 binder驱动</h2><p>其实这里是在驱动层做的处理：android&#x2F;kernel&#x2F;msm-4.19&#x2F;drivers&#x2F;android&#x2F;binder.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">binder_transaction</span><span class="params">(<span class="keyword">struct</span> binder_proc *proc,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">struct</span> binder_thread *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">struct</span> binder_transaction_data *tr, <span class="type">int</span> reply,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="type">binder_size_t</span> extra_buffers_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> (buffer_offset = off_start_offset; buffer_offset &lt; off_end_offset;</span><br><span class="line">            buffer_offset += <span class="built_in">sizeof</span>(<span class="type">binder_size_t</span>)) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">flat_binder_object</span> *fp;</span><br><span class="line"></span><br><span class="line">                fp = <span class="built_in">to_flat_binder_object</span>(hdr);</span><br><span class="line">                ret = <span class="built_in">binder_translate_binder</span>(fp, t, thread);</span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">binder_translate_binder</span><span class="params">(<span class="keyword">struct</span> flat_binder_object *fp,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> binder_transaction *t,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;hdr.type == BINDER_TYPE_BINDER)</span><br><span class="line">        <span class="comment">// 这里，如果读取的hdr.type是BINDER_TYPE_BINDER</span></span><br><span class="line">        <span class="comment">// 将会被改成BINDER_TYPE_HANDLE！！！</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_HANDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fp-&gt;hdr.type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在驱动层传输数据的时候会加工一次！怪不得上层找不到任何信息，这个可真的是太容易误导了。</p><h2 id="4-3-SystemServer-x3D-gt-Parcel-unflattenBinder"><a href="#4-3-SystemServer-x3D-gt-Parcel-unflattenBinder" class="headerlink" title="4.3 SystemServer &#x3D;&gt; Parcel#unflattenBinder"></a>4.3 SystemServer &#x3D;&gt; Parcel#unflattenBinder</h2><p>所以在 #3.3.2.2 中 Parcel#unflattenBinder 解包数据时，对IBinder对象的处理是另外一条路径了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">Parcel::unflattenBinder</span><span class="params">(sp&lt;IBinder&gt;* out)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 从内存区域中读取当前位置的数据</span></span><br><span class="line">    <span class="type">const</span> flat_binder_object* flat = <span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 存在</span></span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;hdr.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER: &#123;</span><br><span class="line">                sp&lt;IBinder&gt; binder = <span class="built_in">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE: &#123;</span><br><span class="line">                <span class="comment">// 注意此时收到的数据是经过Binder驱动加工过的，我们现在是在SystemServer进程</span></span><br><span class="line">                <span class="comment">// 所以这个hdr.type从BINDER_TYPE_BINDER转成了BINDER_TYPE_HANDLE！</span></span><br><span class="line">                <span class="comment">// 这里解包，注意flat_binder_object这个结构体，他里面的binder和handle是被组合成union结构的!</span></span><br><span class="line">                <span class="comment">// 所以封包的时候写存入的binder就是此时读取的handle，这也代表了Server App中对应的BBinder</span></span><br><span class="line">                sp&lt;IBinder&gt; binder =</span><br><span class="line">                    ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="comment">// 这里我们在回到#3.3.2中android_os_Parcel#android_os_Parcel_readStrongBinder</span></span><br><span class="line">                <span class="comment">// 就可以知道，其实SystemServer自始至终都是保存了来自Server App的BBinder相同数据但是转成了BpBinder的IBinder对象</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finishUnflattenBinder</span>(binder, out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个疑问吼，我们看这个flat_binder_object结构的内容:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __u32 <span class="type">binder_size_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span><span class="title">hdr</span>;</span></span><br><span class="line">__u32flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8 bytes of data. */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">binder_uintptr_t</span>binder;<span class="comment">/* local object */</span></span><br><span class="line">__u32handle;<span class="comment">/* remote object */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extra data associated with local object */</span></span><br><span class="line"><span class="type">binder_uintptr_t</span>cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个handle是一个__u32类型的数据，说明该变量占4字节。</p><h3 id="4-3-1-ProcessState-getStrongProxyForHandle-int32-t-handle"><a href="#4-3-1-ProcessState-getStrongProxyForHandle-int32-t-handle" class="headerlink" title="4.3.1 ProcessState#getStrongProxyForHandle(int32_t handle)"></a>4.3.1 ProcessState#getStrongProxyForHandle(int32_t handle)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getStrongProxyForHandle</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">// 4.3.2 从mHandleToObject中获取handle对应的handle_entry</span></span><br><span class="line">    handle_entry* e = <span class="built_in">lookupHandleLocked</span>(handle);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="comment">// 第一次当然是null的</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">nullptr</span> || !e-&gt;refs-&gt;<span class="built_in">attemptIncWeak</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle == <span class="number">0</span>) &#123;</span><br><span class="line">                Parcel data;</span><br><span class="line">                <span class="type">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">                        <span class="number">0</span>, IBinder::PING_TRANSACTION, data, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (status == DEAD_OBJECT)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4.3.3 创建BpBinder!!!</span></span><br><span class="line">            b = BpBinder::<span class="built_in">create</span>(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;<span class="built_in">getWeakRefs</span>();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;<span class="built_in">decWeak</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个result就是新创建的BpBinder,或者之前创建缓存的BpBinder</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-ProcessState-lookupHandleLocked"><a href="#4-3-2-ProcessState-lookupHandleLocked" class="headerlink" title="4.3.2 ProcessState#lookupHandleLocked"></a>4.3.2 ProcessState#lookupHandleLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ProcessState::handle_entry* <span class="title">ProcessState::lookupHandleLocked</span><span class="params">(<span class="type">int32_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mHandleToObject 是Vector类型的数据集合</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> N=mHandleToObject.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="type">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">nullptr</span>;</span><br><span class="line">        e.refs = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">status_t</span> err = mHandleToObject.<span class="built_in">insertAt</span>(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.<span class="built_in">editItemAt</span>(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的handle其实是Server App在打包数据时，获取的：obj.binder &#x3D; reinterpret_cast<uintptr_t>(local-&gt;getWeakRefs()), 然后经过驱动加工，可以视为BBinder的映射BpBinder的Token. 这里的细节我们后面分析。</uintptr_t></p><p>一般来说每个BBinder都不一样(为什么呢，涉及到binder驱动以及Android的智能指针)，所以，这里的mHandleToObject是缓存IBinder对象，防止频繁创建销毁消耗资源。</p><h3 id="4-3-3-创建BpBinder"><a href="#4-3-3-创建BpBinder" class="headerlink" title="4.3.3 创建BpBinder"></a>4.3.3 创建BpBinder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BpBinder* <span class="title">BpBinder::create</span><span class="params">(<span class="type">int32_t</span> handle)</span> </span>&#123;</span><br><span class="line">    <span class="type">int32_t</span> trackedUid = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// sCountByUidEnabled默认是false的，SystemServer进程是再开机过程中打开的</span></span><br><span class="line">    <span class="keyword">if</span> (sCountByUidEnabled) &#123;</span><br><span class="line">        <span class="comment">// 获取Server App的UID</span></span><br><span class="line">        trackedUid = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>();</span><br><span class="line">        <span class="comment">// 接下来是判断Server App是否存在过多的binder proxy对象</span></span><br><span class="line">        <span class="comment">// 默认2500个, 对于SystemServer进程是6000个(也是开机过程中设置的nSetBinderProxyCountWatermarks)</span></span><br><span class="line">        AutoMutex _l(sTrackingLock);</span><br><span class="line">        <span class="type">uint32_t</span> trackedValue = sTrackingMap[trackedUid];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(trackedValue &amp; LIMIT_REACHED_MASK)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((trackedValue &amp; COUNTING_VALUE_MASK) &gt;= sBinderProxyCountHighWatermark) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)&quot;</span>,</span><br><span class="line">                      <span class="built_in">getuid</span>(), trackedUid, trackedValue);</span><br><span class="line">                sTrackingMap[trackedUid] |= LIMIT_REACHED_MASK;</span><br><span class="line">                <span class="keyword">if</span> (sLimitCallback) <span class="built_in">sLimitCallback</span>(trackedUid);</span><br><span class="line">                <span class="keyword">if</span> (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                    <span class="built_in">ALOGI</span>(<span class="string">&quot;Throttling binder proxy creates from uid %d in uid %d until binder proxy&quot;</span></span><br><span class="line">                          <span class="string">&quot; count drops below %d&quot;</span>,</span><br><span class="line">                          trackedUid, <span class="built_in">getuid</span>(), sBinderProxyCountLowWatermark);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 该UID创建了新的BpBinder</span></span><br><span class="line">        sTrackingMap[trackedUid]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BpBinder</span>(handle, trackedUid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BpBinder::<span class="built_in">BpBinder</span>(<span class="type">int32_t</span> handle, <span class="type">int32_t</span> trackedUid)</span><br><span class="line">    : <span class="built_in">mHandle</span>(handle)</span><br><span class="line">    , <span class="built_in">mStability</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mAlive</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mObitsSent</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mObituaries</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mTrackedUid</span>(trackedUid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating BpBinder %p handle %d\n&quot;</span>, <span class="keyword">this</span>, mHandle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">extendObjectLifetime</span>(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    <span class="comment">// 给此BpBinder新增一个弱引用</span></span><br><span class="line">    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">incWeakHandle</span>(handle, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后补上一张IBinder类图:</p><p><img src="/images/Binder-2-sayHello%E4%B9%8BBinderProxy%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/2_4_IBinder%E5%85%A8%E7%B1%BB%E5%9B%BE.png" alt="2_4_IBinder全类图"></p><p>了解了IBinder转换过程的原理，BinderProxy的生成过程，也知道了BBinder和BpBinder的映射关系，接下来就是在Client App和Server App之间的通信了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li><li>msm-4.14 Code <a href="https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c">https://github.com/android-linux-stable/msm-4.14/blob/9c4b6ed1b229cfc35e5c3e5815e297b7f519cf93/drivers/android/binder.c</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;接上文，首先回顾一下IBinder相关接口的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png&quot; alt=&quot;DemoInterfac&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在我们Client进程已经拿到Server端IDemoInterface中的IBinder对象，但是这个IBinder对象到底是哪个呢，Stub本身？还是Proxy亦或是Proxy中的mRemote？&lt;/p&gt;
&lt;p&gt;还是看sayHello的调用过程先:&lt;/p&gt;
&lt;figure class=&quot;highlight kt&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onServiceConnected&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(p0: &lt;span class=&quot;type&quot;&gt;ComponentName&lt;/span&gt;?, p1: &lt;span class=&quot;type&quot;&gt;IBinder&lt;/span&gt;?)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Log.d(&lt;span class=&quot;string&quot;&gt;&amp;quot;Client&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;DemoService connected&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 远程服务连接成功，打个招呼&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.1 这个asInterface是做了什么操作呢？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; mProxyBinder = IDemoInterface.Stub.asInterface(p1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 2.1 sayHello!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mProxyBinder.sayHello(&lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello?&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (e:RemoteException) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Binder(1)--App使用Binder通信</title>
    <link href="https://swallowjoe.github.io/2022/04/04/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/"/>
    <id>https://swallowjoe.github.io/2022/04/04/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/</id>
    <published>2022-04-04T02:37:56.000Z</published>
    <updated>2022-04-04T02:56:11.761Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在初学Android的时候，一般是从四大组件开始学起的。最开始学，是通过追代码流程的方式快速熟悉Android系统框架。</p><p>在这个速学的过程中，很多细节部分就被忽略掉了(这也是必须的，否则学起来极其痛苦且缓慢)。</p><p>比如四大组件之一的Service，在跨进程通信的时候，我们只知道是通过Binder通信的。至于内部实现是如何就不甚了了。</p><p>接下来我们通过一个简单的Demo深入探究这个跨进程通信的过程。</p><span id="more"></span><h1 id="一-在App之间使用Binder通信"><a href="#一-在App之间使用Binder通信" class="headerlink" title="一. 在App之间使用Binder通信"></a>一. 在App之间使用Binder通信</h1><p>目标是在AppClient中给AppServer发送一个简单的字符串</p><h2 id="1-1-创建Interface"><a href="#1-1-创建Interface" class="headerlink" title="1.1 创建Interface"></a>1.1 创建Interface</h2><p>首先在服务端提供接口文件：IDemoInterface. </p><p>Android Studio中通过”File-&gt;New-&gt;AIDL”创建这个 aidl 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface IDemoInterface &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void sayHello(long aLong, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建之后需要在 “Build-&gt;Rebuild Project”, 生成对应可用的文件</p><h2 id="1-2-实现服务端接口"><a href="#1-2-实现服务端接口" class="headerlink" title="1.2 实现服务端接口"></a>1.2 实现服务端接口</h2><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> mName = <span class="string">&quot;DemoService&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DemoBinder</span>:<span class="type">IDemoInterface.Stub</span></span>() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">(aLong: <span class="type">Long</span>, aString: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;DemoService&quot;</span>, <span class="string">&quot;<span class="variable">$aString</span>:<span class="variable">$aLong</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binder = DemoBinder()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123;</span><br><span class="line">        <span class="keyword">return</span> binder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，就是将传入的字符串输出出来。但是这个地方就有一个疑问，为啥是继承IDemoInterface.Stub呢？直接看这个文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.oneplus.opbench.server;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDemoInterface</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.IInterface</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/** Default implementation for IDemoInterface. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Default</span> <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">         * and return values in AIDL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Stub</span> <span class="keyword">extends</span> <span class="title class_">android</span>.os.Binder <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.<span class="type">String</span> <span class="variable">DESCRIPTOR</span> <span class="operator">=</span> <span class="string">&quot;com.oneplus.opbench.server.IDemoInterface&quot;</span>;</span><br><span class="line">    <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stub</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">this</span>.attachInterface(<span class="built_in">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cast an IBinder object into an com.oneplus.opbench.server.IDemoInterface interface,</span></span><br><span class="line"><span class="comment">     * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.<span class="type">IInterface</span> <span class="variable">iin</span> <span class="operator">=</span> obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="literal">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.oneplus.opbench.server.IDemoInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.oneplus.opbench.server.IDemoInterface)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onTransact</span><span class="params">(<span class="type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="type">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">      java.lang.<span class="type">String</span> <span class="variable">descriptor</span> <span class="operator">=</span> DESCRIPTOR;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(descriptor);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_sayHello:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          <span class="type">long</span> _arg0;</span><br><span class="line">          _arg0 = data.readLong();</span><br><span class="line">          java.lang.String _arg1;</span><br><span class="line">          _arg1 = data.readString();</span><br><span class="line">          <span class="built_in">this</span>.sayHello(_arg0, _arg1);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">com</span>.oneplus.opbench.server.IDemoInterface</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote)</span><br><span class="line">      &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> android.os.IBinder <span class="title function_">asBinder</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> java.lang.String <span class="title function_">getInterfaceDescriptor</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">           * and return values in AIDL.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">      &#123;</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_data</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        android.os.<span class="type">Parcel</span> <span class="variable">_reply</span> <span class="operator">=</span> android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          _data.writeLong(aLong);</span><br><span class="line">          _data.writeString(aString);</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">_status</span> <span class="operator">=</span> mRemote.transact(Stub.TRANSACTION_sayHello, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            getDefaultImpl().sayHello(aLong, aString);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANSACTION_sayHello</span> <span class="operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setDefaultImpl</span><span class="params">(com.oneplus.opbench.server.IDemoInterface impl)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Stub.Proxy.sDefaultImpl == <span class="literal">null</span> &amp;&amp; impl != <span class="literal">null</span>) &#123;</span><br><span class="line">        Stub.Proxy.sDefaultImpl = impl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.oneplus.opbench.server.IDemoInterface <span class="title function_">getDefaultImpl</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Stub.Proxy.sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">       * and return values in AIDL.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">long</span> aLong, java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释的就很清楚，是自动生成的文件。Stub是一个静态内部抽象类，继承了Binder和接口IDemoInterface。</p><h2 id="1-3-客户端调用"><a href="#1-3-客户端调用" class="headerlink" title="1.3 客户端调用"></a>1.3 客户端调用</h2><p>注意把服务端aidl文件夹内容拷贝到客户端项目的aidl文件内，然后客户端也rebuild一下project.</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        &lt;!-- for binder(aidl) --&gt;</span></span><br><span class="line"><span class="comment">        &lt;service android:name=&quot;.server.DemoService&quot;</span></span><br><span class="line"><span class="comment">            android:process=&quot;.DemoService&quot;</span></span><br><span class="line"><span class="comment">            android:enabled=&quot;true&quot;</span></span><br><span class="line"><span class="comment">            android:exported=&quot;true&quot; &gt;</span></span><br><span class="line"><span class="comment">            &lt;intent-filter&gt;</span></span><br><span class="line"><span class="comment">                &lt;action android:name=&quot;android.intent.action.DemoService&quot;/&gt;</span></span><br><span class="line"><span class="comment">            &lt;/intent-filter&gt;</span></span><br><span class="line"><span class="comment">        &lt;/service&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">attemptToBindService</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> intent = Intent()</span><br><span class="line">      Log.e(<span class="string">&quot;client&quot;</span>, <span class="string">&quot; connected now&quot;</span>)</span><br><span class="line">      intent.action = <span class="string">&quot;android.intent.action.DemoService&quot;</span> <span class="comment">//服务类的Action</span></span><br><span class="line">      intent.`<span class="keyword">package</span>` = <span class="string">&quot;com.oneplus.opbench&quot;</span> <span class="comment">//服务端包名</span></span><br><span class="line">      <span class="comment">// 建立通信</span></span><br><span class="line">      bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mDemoServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindingDied</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService died!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(p0: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService disconnected!&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">          Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">          <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">          <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="相关类图"><a href="#相关类图" class="headerlink" title="相关类图"></a>相关类图</h2><p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_1_DemoInterface%E7%B1%BB%E5%9B%BE.png" alt="DemoInterface"></p><p>接下来我们从客户端的bindService建立远程连接开始看看是怎么通信的，当然这里我们重点是binder通信，而不是service的bind流程。</p><h1 id="二-通信过程"><a href="#二-通信过程" class="headerlink" title="二. 通信过程"></a>二. 通信过程</h1><p>分析跨进程通信的过程，一定要时刻谨记当前代码所处的进程哦, 为了方便和聚焦, 忽略非紧要代码。</p><h2 id="2-1-Client-x3D-gt-ContextImpl-bindService"><a href="#2-1-Client-x3D-gt-ContextImpl-bindService" class="headerlink" title="2.1 Client&#x3D;&gt;ContextImpl.bindService"></a>2.1 Client&#x3D;&gt;ContextImpl.bindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">bindService</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    <span class="keyword">return</span> bindServiceCommon(service, conn, flags, <span class="literal">null</span>, mMainThread.getHandler(), <span class="literal">null</span>,</span><br><span class="line">            getUser());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        String instanceName, Handler handler, Executor executor, UserHandle user)</span> &#123;</span><br><span class="line">    <span class="comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), executor, flags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.1 获取IServiceConnection对象</span></span><br><span class="line">            sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .......</span></span><br><span class="line">        <span class="comment">// 2.2 看来是先与Android系统中的AMS服务通信</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> ActivityManager.getService().bindIsolatedService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, instanceName, getOpPackageName(), user.getIdentifier());</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-1-LoadedApk-getServiceDispatcher"><a href="#2-1-1-LoadedApk-getServiceDispatcher" class="headerlink" title="2.1.1 LoadedApk.getServiceDispatcher"></a>2.1.1 LoadedApk.getServiceDispatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title function_">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">        Context context, Handler handler, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getServiceDispatcherCommon(c, context, handler, <span class="literal">null</span>, flags);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> IServiceConnection <span class="title function_">getServiceDispatcherCommon</span><span class="params">(ServiceConnection c,</span></span><br><span class="line"><span class="params">        Context context, Handler handler, Executor executor, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Returning existing dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, executor, flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第一次建立连接，当然需要新建</span></span><br><span class="line">                sd = <span class="keyword">new</span> <span class="title class_">ServiceDispatcher</span>(c, context, handler, flags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">&quot;Creating new dispatcher &quot;</span> + sd + <span class="string">&quot; for conn &quot;</span> + c);</span><br><span class="line">            <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回的是ServiceDispatcher里的mIServiceConnection对象,是InnerConnection</span></span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是将ServiceConnection做一个打包，存起来，隐藏细节，注意到返回的是 InnerConnection 类型哦。<br>相关类图如下：</p><p><img src="/images/Binder-1-App%E4%BD%BF%E7%94%A8Binder%E9%80%9A%E4%BF%A1/1_2_InnerConnection%E7%B1%BB%E5%9B%BE.png" alt="InnerConnection"></p><h2 id="2-2-SytemServer-x3D-gt-AMS-bindIsolatedService"><a href="#2-2-SytemServer-x3D-gt-AMS-bindIsolatedService" class="headerlink" title="2.2 SytemServer&#x3D;&gt;AMS.bindIsolatedService"></a>2.2 SytemServer&#x3D;&gt;AMS.bindIsolatedService</h2><p>这里其实就存在Binder通信，但是我们先不看，假设直接call过来了（四大组件之Service）.</p><p>我们知道，当服务端app进程没有启动时，会先将进程启动，然后继续进行bindService操作，为了方便，这里假设服务端进程已启动。</p><p>这里忽略中间一系列调用，走到ActiveServices.bindServiceLocked中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span><br><span class="line"><span class="params">            String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            String instanceName, String callingPackage, <span class="keyword">final</span> <span class="type">int</span> userId)</span></span><br><span class="line">            <span class="keyword">throws</span> TransactionTooLargeException &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 注意这里传入的connection是IServiceConnection</span></span><br><span class="line">    <span class="comment">// retrieveServiceLocked是从已安装的package中找到对应包以及指定Service组件</span></span><br><span class="line">    <span class="type">ServiceLookupResult</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">            retrieveServiceLocked(service, instanceName, resolvedType, callingPackage,</span><br><span class="line">                    Binder.getCallingPid(), Binder.getCallingUid(), userId, <span class="literal">true</span>,</span><br><span class="line">                    callerFg, isBindExternal, allowInstant);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">ServiceRecord</span> <span class="variable">s</span> <span class="operator">=</span> res.record;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 根据我们之前的研究过的Service知识，这个AppBindRecord就是记录App之间Service通信的</span></span><br><span class="line">        <span class="type">AppBindRecord</span> <span class="variable">b</span> <span class="operator">=</span> s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        <span class="type">ConnectionRecord</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionRecord</span>(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent,</span><br><span class="line">                callerApp.uid, callerApp.processName, callingPackage);</span><br><span class="line">        <span class="comment">// 注意这里的connection.asBinder调用的就是IServiceConnection.Stub.Proxy.asBinder</span></span><br><span class="line">        <span class="comment">// 返回的就是mRemote</span></span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">binder</span> <span class="operator">=</span> connection.asBinder();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="literal">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line">          <span class="comment">// Service is already running, so we can immediately</span></span><br><span class="line">          <span class="comment">// publish the connection.</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// c.conn就是Client端传入的IServiceConnection</span></span><br><span class="line">              <span class="comment">// 所以这里又调回去Client进程了，注意传入的b.intent.binder对象</span></span><br><span class="line">              <span class="comment">// 这个传入的b.intent.binder对象就是服务端App发布Service时传入的（publishServiceLocked）</span></span><br><span class="line">              <span class="comment">// 其实可以猜得到是这个就是对应服务端App的IDemoInterface对象</span></span><br><span class="line">              <span class="comment">// 2.3 转到Client进程</span></span><br><span class="line">              c.conn.connected(s.name, b.intent.binder, <span class="literal">false</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              Slog.w(TAG, <span class="string">&quot;Failure sending service &quot;</span> + s.shortInstanceName</span><br><span class="line">                      + <span class="string">&quot; to connection &quot;</span> + c.conn.asBinder()</span><br><span class="line">                      + <span class="string">&quot; (in &quot;</span> + c.binding.client.processName + <span class="string">&quot;)&quot;</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Client-x3D-gt-LoadedApk-ServiceDispatcher-InnerConnection-connected"><a href="#2-3-Client-x3D-gt-LoadedApk-ServiceDispatcher-InnerConnection-connected" class="headerlink" title="2.3 Client&#x3D;&gt;LoadedApk.ServiceDispatcher.InnerConnection.connected"></a>2.3 Client&#x3D;&gt;LoadedApk.ServiceDispatcher.InnerConnection.connected</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    LoadedApk.<span class="type">ServiceDispatcher</span> <span class="variable">sd</span> <span class="operator">=</span> mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="literal">null</span>) &#123;</span><br><span class="line">        sd.connected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-1-LoadedApk-ServiceDispatcher-connected"><a href="#2-3-1-LoadedApk-ServiceDispatcher-connected" class="headerlink" title="2.3.1 LoadedApk.ServiceDispatcher.connected"></a>2.3.1 LoadedApk.ServiceDispatcher.connected</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityExecutor != <span class="literal">null</span>) &#123;</span><br><span class="line">        mActivityExecutor.execute(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mActivityThread != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.3.2 这里其实最后还是调用到了doConnected</span></span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> <span class="title class_">RunConnection</span>(name, service, <span class="number">0</span>, dead));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service, dead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-LoadedApk-ServiceDispatcher-doConnected"><a href="#2-3-2-LoadedApk-ServiceDispatcher-doConnected" class="headerlink" title="2.3.2 LoadedApk.ServiceDispatcher.doConnected"></a>2.3.2 LoadedApk.ServiceDispatcher.doConnected</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConnected</span><span class="params">(ComponentName name, IBinder service, <span class="type">boolean</span> dead)</span> &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个service就是服务端App中的DemoBinder中的mRemote了</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mDemoServiceConnection通知已经建立连接</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The binding machinery worked, but the remote returned null from onBind().</span></span><br><span class="line">        mConnection.onNullBinding(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-客户端的ServiceConnection"><a href="#2-3-3-客户端的ServiceConnection" class="headerlink" title="2.3.3 客户端的ServiceConnection"></a>2.3.3 客户端的ServiceConnection</h3><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(p0: <span class="type">ComponentName</span>?, p1: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;Client&quot;</span>, <span class="string">&quot;DemoService connected&quot;</span>)</span><br><span class="line">    <span class="comment">// 远程服务连接成功，打个招呼</span></span><br><span class="line">    <span class="keyword">val</span> mProxyBinder = IDemoInterface.Stub.asInterface(p1)</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mProxyBinder.sayHello(<span class="number">5000</span>, <span class="string">&quot;Hello?&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e:RemoteException) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，Android系统中两个进程通过四大组件之一的Service进行跨进程通信的连接已经建立了。</p><p>简单来说这个过程借助了SystemServer的帮助：Client app &lt;–&gt; SystemServer &lt;–&gt; Server app</p><p>Server App将Service的IBinder保存在SystemServer中，在Client App通过bindService的时候，传入。这样Client App就有了和Server App通信的基础。</p><p>搞清楚是怎么建立连接的过程，接下来深入探究下mProxyBinder.sayHello调用到不同进程对应的方法的细节。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Android Binder详解 <a href="https://mr-cao.gitbooks.io/android/content/android-binder.html">https://mr-cao.gitbooks.io/android/content/android-binder.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在初学Android的时候，一般是从四大组件开始学起的。最开始学，是通过追代码流程的方式快速熟悉Android系统框架。&lt;/p&gt;
&lt;p&gt;在这个速学的过程中，很多细节部分就被忽略掉了(这也是必须的，否则学起来极其痛苦且缓慢)。&lt;/p&gt;
&lt;p&gt;比如四大组件之一的Service，在跨进程通信的时候，我们只知道是通过Binder通信的。至于内部实现是如何就不甚了了。&lt;/p&gt;
&lt;p&gt;接下来我们通过一个简单的Demo深入探究这个跨进程通信的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/categories/Android/Binder/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Binder" scheme="https://swallowjoe.github.io/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(5)--composer</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-5-composer/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-5-composer/</id>
    <published>2022-04-04T01:58:09.000Z</published>
    <updated>2022-04-04T02:30:13.509Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><p>接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。<br>前面我们也稍微分析了一下，直接看handleMessageRefresh方法：</p><p><img src="/images/SurfaceFlinger-5-composer/5_1_sf_onVsync.png" alt="图片"></p><p>从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。<br>如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。</p><p>这里重点分析handleMessageRefresh.</p><span id="more"></span><h1 id="一-handleMessageRefresh"><a href="#一-handleMessageRefresh" class="headerlink" title="一. handleMessageRefresh"></a>一. handleMessageRefresh</h1><h2 id="1-1-SurfaceFlinger-handleMessageRefresh"><a href="#1-1-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="1.1 SurfaceFlinger:handleMessageRefresh"></a>1.1 SurfaceFlinger:handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 1.2 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3 重建layer堆栈, 提取可见的Laye并计算可见区域</span></span><br><span class="line">    <span class="comment">// 并将数据更新给对应的Display</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4 hwcomposer的设定，将Layer数据更新给HWC</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有Display，依次合成处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="comment">// 1.5 其实beginFrame和prepareFrame最终都是调用到FrameBufferSurface中，没有做特别的事情</span></span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="comment">// 1.6 正式的合成处理，简单来说就是申请GraphicBuffer，向其中填充帧数据</span></span><br><span class="line">        <span class="comment">// 最终给到硬件帧缓冲区</span></span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知composer,即HWC</span></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据状况决定是否更新Vsync Offset</span></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</span></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-SurfaceFlinger-perComposition"><a href="#1-2-SurfaceFlinger-perComposition" class="headerlink" title="1.2 SurfaceFlinger:perComposition"></a>1.2 SurfaceFlinger:perComposition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;preComposition&quot;</span>);</span><br><span class="line">    <span class="comment">// 记录刷新时间</span></span><br><span class="line">    mRefreshStartTime = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.1 遍历所有layer, 处理处于Drawing状态的layer</span></span><br><span class="line">    <span class="comment">// 这里使用了lambda函数</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 1.2.3 判断Layer是否需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">            <span class="comment">// 如果有layer有frame更新，则标记该值为true，表示需要下一个vsync</span></span><br><span class="line">            <span class="comment">// 做合成</span></span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> SurfaceFlinger::State::<span class="built_in">traverseInZOrder</span>(<span class="type">const</span> LayerVector::Visitor&amp; visitor) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 这里的mDrawingState里面的stateSet为StateSet::Drawing</span></span><br><span class="line">    layersSortedByZ.<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SurfaceFlinger.h</span></span><br><span class="line">State mDrawingState&#123;LayerVector::StateSet::Drawing&#125;;</span><br></pre></td></tr></table></figure><p>layersSortedByZ中存储的layer都是SurfaceFlinger.addClientLayer过程中添加的。</p><h3 id="1-2-1-LayerVector-traverseInZOrder"><a href="#1-2-1-LayerVector-traverseInZOrder" class="headerlink" title="1.2.1 LayerVector:traverseInZOrder"></a>1.2.1 LayerVector:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LayerVector::traverseInZOrder</span><span class="params">(StateSet stateSet, <span class="type">const</span> Visitor&amp; visitor)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; layer = (*<span class="keyword">this</span>)[i];</span><br><span class="line">        <span class="comment">// 遍历所有layer，拿到合适State的Layer做处理</span></span><br><span class="line">        <span class="comment">// 这里是拿所有Drawing状态的Layer</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; state = (stateSet == StateSet::Current) ? layer-&gt;<span class="built_in">getCurrentState</span>()</span><br><span class="line">                                                      : layer-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">        <span class="comment">// zOrderRelativeOf中的layer是上层调用setRelativeLayer后添加的</span></span><br><span class="line">        <span class="comment">// 如果为非null，则表示此Surface的Z顺序相对于此进行解释</span></span><br><span class="line">        <span class="comment">// 默认是null的。</span></span><br><span class="line">        <span class="keyword">if</span> (state.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理Layer</span></span><br><span class="line">        layer-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-Layer-traverseInZOrder"><a href="#1-2-2-Layer-traverseInZOrder" class="headerlink" title="1.2.2 Layer:traverseInZOrder"></a>1.2.2 Layer:traverseInZOrder</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Layer::traverseInZOrder</span><span class="params">(LayerVector::StateSet stateSet, <span class="type">const</span> LayerVector::Visitor&amp; visitor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> skipRelativeZUsers = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1.2.2.1 按顺序将当前Layer所有z轴相关的layer和子layer添加至列表</span></span><br><span class="line">    <span class="type">const</span> LayerVector list = <span class="built_in">makeTraversalList</span>(stateSet, &amp;skipRelativeZUsers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也就是说首先遍历Z轴相关的Layer</span></span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意Layer的添加都是按照Z轴顺序插入排序的</span></span><br><span class="line">        <span class="comment">// 这里的意思就是首先要遍历并对所有z轴小于0的Layer调用onPreComposition方法</span></span><br><span class="line">        <span class="comment">// 所以需要理解z轴小于0的意义，什么时候z轴值才会小于0？</span></span><br><span class="line">        <span class="comment">// 因为P/Q上Layer组合的数据结构是：树形结构+Z轴排序。现在Z轴的大小一般为 [-2, 2]</span></span><br><span class="line">        <span class="comment">// Z轴小的在下面会被覆盖。现在可以理解了，这里为什么碰到z大于0就要退出循环了</span></span><br><span class="line">        <span class="keyword">if</span> (relative-&gt;<span class="built_in">getZ</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对本Layer做onPreComposition</span></span><br><span class="line">    <span class="built_in">visitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后对所有Z轴不小于0的Layer做onPreComposition</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; relative = list[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipRelativeZUsers &amp;&amp; relative-&gt;<span class="built_in">usingRelativeZ</span>(stateSet)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        relative-&gt;<span class="built_in">traverseInZOrder</span>(stateSet, visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visitor这个就是lambda表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2.3 调用onPreComposition</span></span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;<span class="built_in">onPreComposition</span>(mRefreshStartTime)) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总的来说就是按顺序依次调用layer的onPreComposition方法，标记其mRefreshPending为false。</p><h4 id="1-2-2-1-Layer-makeTraversalList"><a href="#1-2-2-1-Layer-makeTraversalList" class="headerlink" title="1.2.2.1 Layer:makeTraversalList"></a>1.2.2.1 Layer:makeTraversalList</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __attribute__((no_sanitize(&quot;unsigned-integer-overflow&quot;)))的意思</span></span><br><span class="line"><span class="comment">// 是不进行无符号int溢出检测</span></span><br><span class="line">__attribute__((<span class="built_in">no_sanitize</span>(<span class="string">&quot;unsigned-integer-overflow&quot;</span>))) <span class="function">LayerVector <span class="title">Layer::makeTraversalList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        LayerVector::StateSet stateSet, <span class="type">bool</span>* outSkipRelativeZUsers)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(stateSet == LayerVector::StateSet::Invalid,</span><br><span class="line">                        <span class="string">&quot;makeTraversalList received invalid stateSet&quot;</span>);</span><br><span class="line">    <span class="comment">// 这里useDrawing为true</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> useDrawing = stateSet == LayerVector::StateSet::Drawing;</span><br><span class="line">    <span class="type">const</span> LayerVector&amp; children = useDrawing ? mDrawingChildren : mCurrentChildren;</span><br><span class="line">    <span class="type">const</span> State&amp; state = useDrawing ? mDrawingState : mCurrentState;</span><br><span class="line">    <span class="comment">// 假设没有zOrderRelatives，所以直接返回children</span></span><br><span class="line">    <span class="keyword">if</span> (state.zOrderRelatives.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        *outSkipRelativeZUsers = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在，则将相关的layer按照Z轴顺序加入stateSet.Drawing中</span></span><br><span class="line">    <span class="function">LayerVector <span class="title">traverse</span><span class="params">(stateSet)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> wp&lt;Layer&gt;&amp; weakRelative : state.zOrderRelatives) &#123;</span><br><span class="line">        sp&lt;Layer&gt; strongRelative = weakRelative.<span class="built_in">promote</span>();</span><br><span class="line">        <span class="keyword">if</span> (strongRelative != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            traverse.<span class="built_in">add</span>(strongRelative);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有children，将children的相关Layer添加至traverse</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> sp&lt;Layer&gt;&amp; child : children) &#123;</span><br><span class="line">        <span class="type">const</span> State&amp; childState = useDrawing ? child-&gt;mDrawingState : child-&gt;mCurrentState;</span><br><span class="line">        <span class="keyword">if</span> (childState.zOrderRelativeOf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse.<span class="built_in">add</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到1.2.2中。</p><h3 id="1-2-3-Layer-BufferLayer-onPreComposition"><a href="#1-2-3-Layer-BufferLayer-onPreComposition" class="headerlink" title="1.2.3 Layer:BufferLayer::onPreComposition"></a>1.2.3 Layer:BufferLayer::onPreComposition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="type">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        mFrameEventHistory.<span class="built_in">addPreComposition</span>(mCurrentFrameNumber, refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasReadyFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录开始刷新的时间，并返回该Layer是否具有可被合成的条件。</p><h4 id="1-2-3-1-Layer-BufferLayer-hasReadyFrame"><a href="#1-2-3-1-Layer-BufferLayer-hasReadyFrame" class="headerlink" title="1.2.3.1 Layer:BufferLayer::hasReadyFrame"></a>1.2.3.1 Layer:BufferLayer::hasReadyFrame</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferLayer::hasReadyFrame</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasFrameUpdate</span>() || <span class="built_in">getSidebandStreamChanged</span>() || <span class="built_in">getAutoRefresh</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-2-Layer-BufferLayer-BufferQueueLayer"><a href="#1-2-3-2-Layer-BufferLayer-BufferQueueLayer" class="headerlink" title="1.2.3.2 Layer:BufferLayer:BufferQueueLayer"></a>1.2.3.2 Layer:BufferLayer:BufferQueueLayer</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::hasFrameUpdate</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否具有绘制完成的frame</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getAutoRefresh</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mAutoRefresh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferQueueLayer::getSidebandStreamChanged</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSidebandStreamChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-SurfaceFlinger-rebuildLayerStacks"><a href="#1-3-SurfaceFlinger-rebuildLayerStacks" class="headerlink" title="1.3 SurfaceFlinger:rebuildLayerStacks"></a>1.3 SurfaceFlinger:rebuildLayerStacks</h2><p>这个方法比较长，慢慢看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;rebuildLayerStacks&quot;</span>);</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mDolphinStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个display重建其layer列表</span></span><br><span class="line">    <span class="comment">// mVisibleRegionsDirty的这个变量在如下条件会被置为true:</span></span><br><span class="line">    <span class="comment">// 1. 有layer的增删时</span></span><br><span class="line">    <span class="comment">// 2. layer可视化面积发生变化</span></span><br><span class="line">    <span class="comment">// 3. display显示设备变化</span></span><br><span class="line">    <span class="comment">// 4. set power mode on - 即亮屏时</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;rebuildLayerStacks VR Dirty&quot;</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 就是将mGeometryInvalid置为true</span></span><br><span class="line">        <span class="comment">// 这个值影响后续是否需要hwc合成</span></span><br><span class="line">        <span class="built_in">invalidateHwcGeometry</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每一个Display做处理，适配多屏场景</span></span><br><span class="line">        <span class="comment">// mDisplays的类型是：std::map&lt;wp&lt;IBinder&gt;, sp&lt;DisplayDevice&gt;&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : mDisplays) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayDevice = pair.second;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">            Region opaqueRegion;</span><br><span class="line">            Region dirtyRegion;</span><br><span class="line">            compositionengine::Output::OutputLayers layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; deprecated_layersSortedByZ;</span><br><span class="line">            Vector&lt;sp&lt;Layer&gt;&gt; layersNeedingFences;</span><br><span class="line">            <span class="type">const</span> ui::Transform&amp; tr = displayState.transform;</span><br><span class="line">            <span class="type">const</span> Rect bounds = displayState.bounds;</span><br><span class="line">            <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">                <span class="comment">// 2.1 计算可视区域</span></span><br><span class="line">                <span class="built_in">computeVisibleRegions</span>(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 顺序遍历Z轴Layer</span></span><br><span class="line">                mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> compositionLayer = layer-&gt;<span class="built_in">getCompositionLayer</span>();</span><br><span class="line">                    <span class="keyword">if</span> (compositionLayer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> displayId = displayDevice-&gt;<span class="built_in">getId</span>();</span><br><span class="line">                    sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;<span class="built_in">getLayerFE</span>();</span><br><span class="line">                    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(layerFE.<span class="built_in">get</span>() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">bool</span> needsOutputLayer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对属于给定图层堆栈上的layer, 将其可视区域与其所在Display相交</span></span><br><span class="line">                    <span class="comment">// 相交结果不为空，则说明其在或者其一部分在显示屏幕上</span></span><br><span class="line">                    <span class="comment">// needsOutputLayer标记为true</span></span><br><span class="line">                    <span class="keyword">if</span> (display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(),</span><br><span class="line">                                                 layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">                        Region <span class="built_in">drawRegion</span>(tr.<span class="built_in">transform</span>(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        drawRegion.<span class="built_in">andSelf</span>(bounds);</span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                            needsOutputLayer = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Layer有内容在屏幕上</span></span><br><span class="line">                    <span class="keyword">if</span> (needsOutputLayer) &#123;</span><br><span class="line">                        layersSortedByZ.<span class="built_in">emplace_back</span>(</span><br><span class="line">                                display-&gt;<span class="built_in">getOrCreateOutputLayer</span>(displayId, compositionLayer,</span><br><span class="line">                                                                layerFE));</span><br><span class="line">                        deprecated_layersSortedByZ.<span class="built_in">add</span>(layer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span>&amp; outputLayerState = layersSortedByZ.<span class="built_in">back</span>()-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                        outputLayerState.visibleRegion =</span><br><span class="line">                                tr.<span class="built_in">transform</span>(layer-&gt;visibleRegion.<span class="built_in">intersect</span>(displayState.viewport));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">                        <span class="comment">// 到这个分支里说明Layer之前有内容显示，但现在没有内容显示在屏幕上</span></span><br><span class="line">                        <span class="comment">// 此时我们需要清理该Layer对应的Fence，销毁HWC Layer</span></span><br><span class="line">                        <span class="type">bool</span> hasExistingOutputLayer =</span><br><span class="line">                                display-&gt;<span class="built_in">getOutputLayerForLayer</span>(compositionLayer.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// mLayersWithQueuedFrames 这个变量还记不，是在handlePageFlip方法中，顺序</span></span><br><span class="line">                        <span class="comment">// 遍历Z轴Layer时添加进入的。</span></span><br><span class="line">                        <span class="type">bool</span> hasQueuedFrames = std::<span class="built_in">find</span>(mLayersWithQueuedFrames.<span class="built_in">cbegin</span>(),</span><br><span class="line">                                                         mLayersWithQueuedFrames.<span class="built_in">cend</span>(),</span><br><span class="line">                                                         layer) != mLayersWithQueuedFrames.<span class="built_in">cend</span>();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123;</span><br><span class="line">                            layersNeedingFences.<span class="built_in">add</span>(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将数据更新到Display中</span></span><br><span class="line">            display-&gt;<span class="built_in">setOutputLayersOrderedByZ</span>(std::<span class="built_in">move</span>(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">            displayDevice-&gt;<span class="built_in">setVisibleLayersSortedByZ</span>(deprecated_layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;<span class="built_in">setLayersNeedingFences</span>(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未定义的区域。也就是屏幕的大小减去屏幕的非透明区域opaqueRegion余下的部分。</span></span><br><span class="line">            Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">            undefinedRegion.<span class="built_in">subtractSelf</span>(tr.<span class="built_in">transform</span>(opaqueRegion));</span><br><span class="line"></span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().undefinedRegion = undefinedRegion;</span><br><span class="line">            display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">orSelf</span>(dirtyRegion);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，rebuildLayerStacks就是反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</p><h2 id="1-4-SurfaceFlinger-calculateWorkingSet"><a href="#1-4-SurfaceFlinger-calculateWorkingSet" class="headerlink" title="1.4 SurfaceFlinger::calculateWorkingSet"></a>1.4 SurfaceFlinger::calculateWorkingSet</h2><p>再看这个方法之前先瞄一眼各个Layer之前的关系：</p><p><img src="/images/SurfaceFlinger-5-composer/5_4_layer_list.png" alt="图片"></p><p>上图中标红的appId就是在此方法内的latchCompositionState方法中赋值的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::calculateWorkingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立HWC中的Layer列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mGeometryInvalid)) &#123;</span><br><span class="line">        mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 同样需要针对各个Display做处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> zOrder = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;<span class="built_in">getOutputLayersOrderedByZ</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; compositionState = layer-&gt;<span class="built_in">editState</span>();</span><br><span class="line">                compositionState.forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                    compositionState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Z轴顺序依次递增</span></span><br><span class="line">                compositionState.z = zOrder++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新与显示无关的合成状态，其实就是将Layer的状态信息放在CompositionState中了。</span></span><br><span class="line">                <span class="comment">// 也就是frontEnd（LayerFECompositionState）中</span></span><br><span class="line">                layer-&gt;<span class="built_in">getLayerFE</span>().<span class="built_in">latchCompositionState</span>(layer-&gt;<span class="built_in">getLayer</span>().<span class="built_in">editState</span>().frontEnd,</span><br><span class="line">                                                          <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新计算OutputLayer的几何状态</span></span><br><span class="line">                <span class="comment">// 比如根据显示屏全局矩阵调整该Layer的DisplayFrame、</span></span><br><span class="line">                <span class="comment">// 变换窗口裁剪以匹配缓冲区坐标系等等。</span></span><br><span class="line">                layer-&gt;<span class="built_in">updateCompositionState</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将Layer更新完毕的几何状态写入HWC</span></span><br><span class="line">                layer-&gt;<span class="built_in">writeStateToHWC</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每帧的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        <span class="keyword">if</span> (!displayId) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDrawingState.colorMatrixChanged) &#123;</span><br><span class="line">            display-&gt;<span class="built_in">setColorTransform</span>(mDrawingState.colorMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        Dataspace targetDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (useColorManagement) &#123;</span><br><span class="line">            ColorMode colorMode;</span><br><span class="line">            RenderIntent renderIntent;</span><br><span class="line">            <span class="built_in">pickColorMode</span>(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent);</span><br><span class="line">            display-&gt;<span class="built_in">setColorMode</span>(colorMode, targetDataspace, renderIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">            layer-&gt;<span class="built_in">setPerFrameData</span>(displayDevice, displayState.transform, displayState.viewport,</span><br><span class="line">                                   displayDevice-&gt;<span class="built_in">getSupportedPerFrameMetadata</span>(),</span><br><span class="line">                                   <span class="built_in">isHdrColorMode</span>(displayState.colorMode) ? Dataspace::UNKNOWN</span><br><span class="line">                                                                          : targetDataspace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; layerState = layer-&gt;<span class="built_in">getCompositionLayer</span>()-&gt;<span class="built_in">editState</span>().frontEnd;</span><br><span class="line">            layerState.compositionType = <span class="built_in">static_cast</span>&lt;Hwc2::IComposerClient::Composition&gt;(</span><br><span class="line">                    layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里建立HWC中的Layer列表： </p><ol><li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li><li>将Layer的mActiveBuffer设置到HWComposer中</li></ol><h2 id="1-5-SurfaceFlinger-beginFrame"><a href="#1-5-SurfaceFlinger-beginFrame" class="headerlink" title="1.5 SurfaceFlinger::beginFrame"></a>1.5 SurfaceFlinger::beginFrame</h2><p>开始合成前的准备。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::beginFrame</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有待更新的区域</span></span><br><span class="line">    <span class="type">bool</span> dirty = !display-&gt;<span class="built_in">getDirtyRegion</span>(<span class="literal">false</span>).<span class="built_in">isEmpty</span>();</span><br><span class="line">    <span class="comment">// 可见Layer数量是否为0</span></span><br><span class="line">    <span class="type">bool</span> empty = displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>().<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上次合成是否有可见Layer</span></span><br><span class="line">    <span class="type">bool</span> wasEmpty = !displayState.lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有变化时或者有变化但此时没有可见Layer且上次合成时也没有就跳过</span></span><br><span class="line">    <span class="type">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> flagPrefix[] = &#123;<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(flagPrefix);</span><br><span class="line">    <span class="built_in">ALOGV_IF</span>(displayDevice-&gt;<span class="built_in">isVirtual</span>(), <span class="string">&quot;%s: %s composition for %s (%cdirty %cempty %cwasEmpty)&quot;</span>,</span><br><span class="line">             __FUNCTION__, mustRecompose ? <span class="string">&quot;doing&quot;</span> : <span class="string">&quot;skipping&quot;</span>,</span><br><span class="line">             displayDevice-&gt;<span class="built_in">getDebugName</span>().<span class="built_in">c_str</span>(), flagPrefix[dirty], flagPrefix[empty],</span><br><span class="line">             flagPrefix[wasEmpty]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里面其实没有做什么特殊的操作，我们看一下DisplayDevice相关的类</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">beginFrame</span>(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/SurfaceFlinger-5-composer/5_5_DisplayDevice.png" alt="图片"></p><p>这个DiplayDevice是怎么初始化的呢，后续再看。</p><h2 id="1-6-SurfaceFlinger-doComposition"><a href="#1-6-SurfaceFlinger-doComposition" class="headerlink" title="1.6 SurfaceFlinger::doComposition"></a>1.6 SurfaceFlinger::doComposition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice, <span class="type">bool</span> repaintEverything)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="comment">// 将脏区转换为该屏幕的坐标空间</span></span><br><span class="line">        <span class="type">const</span> Region dirtyRegion = display-&gt;<span class="built_in">getDirtyRegion</span>(repaintEverything);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.6.1 请求buffer,做合成操作</span></span><br><span class="line">        <span class="built_in">doDisplayComposition</span>(displayDevice, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        display-&gt;<span class="built_in">editState</span>().dirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line">        display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">flip</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fence同步相关处理，暂时忽略</span></span><br><span class="line">    <span class="built_in">postFramebuffer</span>(displayDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-1-SurfaceFlinger-doDisplayComposition"><a href="#1-6-1-SurfaceFlinger-doDisplayComposition" class="headerlink" title="1.6.1 SurfaceFlinger::doDisplayComposition"></a>1.6.1 SurfaceFlinger::doDisplayComposition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> Region&amp; inDirtyRegion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅在以下情况下才需要实际构成显示：</span></span><br><span class="line">    <span class="comment">// 1）由HWC处理，它可能需要此操作以使其虚拟显示状态机保持同步</span></span><br><span class="line">    <span class="comment">// 2）有工作要做（脏区不为空）</span></span><br><span class="line">    <span class="keyword">if</span> (!displayDevice-&gt;<span class="built_in">getId</span>() &amp;&amp; inDirtyRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Skipping display composition&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doDisplayComposition&quot;</span>);</span><br><span class="line">    base::unique_fd readyFence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.6.2 合成Surface</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">doComposeSurfaces</span>(displayDevice, Region::INVALID_REGION, &amp;readyFence)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换缓冲区，buffer已经被填充了合成所有Layer后的帧数据。</span></span><br><span class="line">    <span class="comment">// 将FrameBuffer发送给HWC, 也就是将内容渲染到硬件帧缓冲区中去</span></span><br><span class="line">    display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">queueBuffer</span>(std::<span class="built_in">move</span>(readyFence));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-2-SurfaceFlinger-doComposeSurfaces"><a href="#1-6-2-SurfaceFlinger-doComposeSurfaces" class="headerlink" title="1.6.2 SurfaceFlinger::doComposeSurfaces"></a>1.6.2 SurfaceFlinger::doComposeSurfaces</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> Region&amp; debugRegion, base::unique_fd* readyFence)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;doComposeSurfaces&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;<span class="built_in">getState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; renderEngine = <span class="built_in">getRenderEngine</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> supportProtectedContent = renderEngine.<span class="built_in">supportsProtectedContent</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Region <span class="title">bounds</span><span class="params">(displayState.bounds)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> DisplayRenderArea <span class="title">renderArea</span><span class="params">(displayDevice)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> hasClientComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;hasClientComposition&quot;</span>, hasClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> applyColorMatrix = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    renderengine::DisplaySettings clientCompositionDisplay;</span><br><span class="line">    std::vector&lt;renderengine::LayerSettings&gt; clientCompositionLayers;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    base::unique_fd fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;hasClientComposition&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求GraphicBuffer, 通过ANativeWindow向GPU申请</span></span><br><span class="line">        buf = display-&gt;<span class="built_in">getRenderSurface</span>()-&gt;<span class="built_in">dequeueBuffer</span>(&amp;fd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Dequeuing buffer for display [%s] failed, bailing out of &quot;</span></span><br><span class="line">                  <span class="string">&quot;client composition for this frame&quot;</span>,</span><br><span class="line">                  displayDevice-&gt;<span class="built_in">getDisplayName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将DisplayState相关信息赋值给clientCompositionDisplay，以供HWC使用</span></span><br><span class="line">        clientCompositionDisplay.physicalDisplay = displayState.scissor;</span><br><span class="line">        clientCompositionDisplay.clip = displayState.scissor;</span><br><span class="line">        <span class="type">const</span> ui::Transform&amp; displayTransform = displayState.transform;</span><br><span class="line">        clientCompositionDisplay.globalTransform = displayTransform.<span class="built_in">asMatrix4</span>();</span><br><span class="line">        clientCompositionDisplay.orientation = displayState.orientation;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>* profile = display-&gt;<span class="built_in">getDisplayColorProfile</span>();</span><br><span class="line">        Dataspace outputDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (profile-&gt;<span class="built_in">hasWideColorGamut</span>()) &#123;</span><br><span class="line">            outputDataspace = displayState.dataspace;</span><br><span class="line">        &#125;</span><br><span class="line">        clientCompositionDisplay.outputDataspace = outputDataspace;</span><br><span class="line">        clientCompositionDisplay.maxLuminance =</span><br><span class="line">                profile-&gt;<span class="built_in">getHdrCapabilities</span>().<span class="built_in">getDesiredMaxLuminance</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> hasDeviceComposition = <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> skipClientColorTransform =</span><br><span class="line">                <span class="built_in">getHwComposer</span>()</span><br><span class="line">                        .<span class="built_in">hasDisplayCapability</span>(displayId,</span><br><span class="line">                                              HWC2::DisplayCapability::SkipClientColorTransform);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compute the global color transform matrix.</span></span><br><span class="line">        applyColorMatrix = !hasDeviceComposition &amp;&amp; !skipClientColorTransform;</span><br><span class="line">        <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">            clientCompositionDisplay.colorTransform = displayState.colorTransformMat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 现在渲染以帧缓冲区为目标的图层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Rendering client layers&quot;</span>);</span><br><span class="line">    <span class="type">bool</span> firstLayer = <span class="literal">true</span>;</span><br><span class="line">    Region clearRegion = Region::INVALID_REGION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可见Layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;<span class="built_in">getVisibleLayersSortedByZ</span>()) &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">viewportRegion</span><span class="params">(displayState.viewport)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> Region <span class="title">clip</span><span class="params">(viewportRegion.intersect(layer-&gt;visibleRegion))</span></span>;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Layer: %s&quot;</span>, layer-&gt;<span class="built_in">getName</span>().<span class="built_in">string</span>());</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;  Composition type: %s&quot;</span>, <span class="built_in">toString</span>(layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (!clip.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (layer-&gt;<span class="built_in">getCompositionType</span>(displayDevice)) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CLIENT: &#123;</span><br><span class="line">                    renderengine::LayerSettings layerSettings;</span><br><span class="line">                    <span class="comment">// 根据相关配置设置Layer状态：渲染区域、alpha通道、颜色变换等等</span></span><br><span class="line">                    <span class="type">bool</span> prepared =</span><br><span class="line">                            layer-&gt;<span class="built_in">prepareClientLayer</span>(renderArea, clip, clearRegion,</span><br><span class="line">                                                      supportProtectedContent, layerSettings);</span><br><span class="line">                    <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                        <span class="comment">// 放入clientCompositionLayers中备用</span></span><br><span class="line">                        clientCompositionLayers.<span class="built_in">push_back</span>(layerSettings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;  Skipping for empty clip&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        firstLayer = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasClientComposition为true说明使用GPU合成</span></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        clientCompositionDisplay.clearRegion = clearRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里提高GPU频率，因为会进行色彩空间转换，比较耗时。 </span></span><br><span class="line">        <span class="comment">// 提高了GPU频率，以便GPU合成可以及时完成。</span></span><br><span class="line">        <span class="comment">// 之后必须重新设置GPU频率，因为高频率会消耗额外的电池。</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> expensiveRenderingExpected =</span><br><span class="line">                clientCompositionDisplay.outputDataspace == Dataspace::DISPLAY_P3;</span><br><span class="line">        <span class="keyword">if</span> (expensiveRenderingExpected &amp;&amp; displayId) &#123;</span><br><span class="line">            mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用渲染引擎（renderengine/gl/GLESRenderEngine.cpp）合成所有Layer</span></span><br><span class="line">        renderEngine.<span class="built_in">drawLayers</span>(clientCompositionDisplay, clientCompositionLayers,</span><br><span class="line">                                buf-&gt;<span class="built_in">getNativeBuffer</span>(), <span class="comment">/*useFramebufferCache=*/</span><span class="literal">true</span>, std::<span class="built_in">move</span>(fd),</span><br><span class="line">                                readyFence);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">        mPowerAdvisor.<span class="built_in">setExpensiveRenderingExpected</span>(*displayId, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先请求GraphicBuffer，然后通过GLESRenderEngine合成所有Layer.</p><h1 id="二-计算Layer可视区域"><a href="#二-计算Layer可视区域" class="headerlink" title="二. 计算Layer可视区域"></a>二. 计算Layer可视区域</h1><p>一般来讲，我们手机App Layer如下：<br><img src="/images/SurfaceFlinger-5-composer/5_2_appZ.png" alt="图片"></p><p>计算可视区域的时候，从Z轴大的开始遍历计算。这样做的好处是，如果计算到某一层Layer时，完全不透明的可视化区域已经占满整个屏幕，那么这之下的Layer可视化区域就可以不用计算了。</p><p>在开始阅读代码之前，还是有必要理清楚：</p><ol><li>可见区域（Visible Region）</li><li>透明区域（Transparent Region）</li><li>半透明区域（Translucent Region）</li><li>完全不透明区域（Opaque Region）</li><li>被覆盖区域（Covered Region）</li></ol><p>如下图:</p><p><img src="/images/SurfaceFlinger-5-composer/5_3_visiableregion.png" alt="图片"></p><p>如果A1为W2中半透明区域，A2在W1中全透明，W2中不透明，A3为W1中完全不透明区域。<br>则对于Surface W2而言，可见区域为W2-A1-A3.</p><h2 id="2-1-SurfaceFlinger-computeVisibleRegions"><a href="#2-1-SurfaceFlinger-computeVisibleRegions" class="headerlink" title="2.1 SurfaceFlinger:computeVisibleRegions"></a>2.1 SurfaceFlinger:computeVisibleRegions</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="type">const</span> sp&lt;<span class="type">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;computeVisibleRegions&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line"></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    outDirtyRegion.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先找到“感兴趣的”Layer，也就是这个layer是属于SecureDisplay的</span></span><br><span class="line">    <span class="comment">// 暂时没有找到相关的说明，忽略好了</span></span><br><span class="line">    Layer* layerOfInterest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> bIgnoreLayer = <span class="literal">false</span>;</span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">isSecureDisplay</span>()) &#123;</span><br><span class="line">            bIgnoreLayer = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (displayDevice-&gt;<span class="built_in">isPrimary</span>()) &#123;</span><br><span class="line">                layerOfInterest = layer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反向遍历Z轴计算可视化区域</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInReverseZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// 获取当前绘制中的Surface</span></span><br><span class="line">        <span class="type">const</span> Layer::State&amp; <span class="built_in">s</span>(layer-&gt;<span class="built_in">getDrawingState</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只考虑给定图层堆栈上的layer</span></span><br><span class="line">        <span class="keyword">if</span> (!display-&gt;<span class="built_in">belongsInOutput</span>(layer-&gt;<span class="built_in">getLayerStack</span>(), layer-&gt;<span class="built_in">getPrimaryDisplayOnly</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略SecureDisplay中的layer</span></span><br><span class="line">        <span class="keyword">if</span> (bIgnoreLayer &amp;&amp; layerOfInterest != layer) &#123;</span><br><span class="line">            Region visibleNonTransRegion;</span><br><span class="line">            visibleNonTransRegion.<span class="built_in">set</span>(<span class="built_in">Rect</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(visibleNonTransRegion);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全不透明的Surface区域</span></span><br><span class="line">        Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在屏幕上可见且不完全透明的Surface区域。 </span></span><br><span class="line">        <span class="comment">// 这实际上是该层的足迹减去其上方的不透明区域。</span></span><br><span class="line">        <span class="comment">// 半透明Surface覆盖的区域被认为是可见的。</span></span><br><span class="line">        Region visibleRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 被其上方所有可见区域覆盖的Surface区域（包括半透明区域）。</span></span><br><span class="line">        Region coveredRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暗示完全透明的表面区域。 这仅用于告诉图层何时没有可见的非透明区域，可以将其从图层列表中删除。 </span></span><br><span class="line">        <span class="comment">// 它不会影响此层或它下面的任何层的visibleRegion。 </span></span><br><span class="line">        <span class="comment">// 如果应用程序不遵守SurfaceView限制（不幸的是，有些不遵守），则提示可能不正确。</span></span><br><span class="line">        Region transparentRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理不可见或者被隐藏的Surface的方式就是将其可视化的区域设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_LIKELY</span>(layer-&gt;<span class="built_in">isVisible</span>())) &#123;</span><br><span class="line">            <span class="comment">// 如果该Surface不是完全不透明的，则视为半透明</span></span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> translucent = !layer-&gt;<span class="built_in">isOpaque</span>(s);</span><br><span class="line">            Rect <span class="built_in">bounds</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前Surface的可视区域默认为屏幕大小或者Surface在屏幕中的大小</span></span><br><span class="line">            visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            ui::Transform tr = layer-&gt;<span class="built_in">getTransform</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Region为空则说明没有可视区域</span></span><br><span class="line">            <span class="comment">// 注意 Region 是一个矩形（Rect）集合</span></span><br><span class="line">            <span class="keyword">if</span> (!visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                <span class="comment">// 首先从可见区域移除透明区域</span></span><br><span class="line">                <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">                    <span class="comment">// 函数preserveRects的返回值为false</span></span><br><span class="line">                    <span class="comment">// 说明需要忽略掉当前正在处理的应用程序窗口的透明区域</span></span><br><span class="line">                    <span class="keyword">if</span> (tr.<span class="built_in">preserveRects</span>()) &#123;</span><br><span class="line">                        <span class="comment">// 标记透明区域，这个透明区域就是transparentRegionHint遍历</span></span><br><span class="line">                        <span class="comment">// 在 SurfaceFlinger.setClientStateLocked过程中设置的</span></span><br><span class="line">                        transparentRegion = tr.<span class="built_in">transform</span>(layer-&gt;<span class="built_in">getActiveTransparentRegion</span>(s));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 转换太复杂，无法进行透明区域优化。</span></span><br><span class="line">                        transparentRegion.<span class="built_in">clear</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算不透明区域</span></span><br><span class="line">                <span class="type">const</span> <span class="type">int32_t</span> layerOrientation = tr.<span class="built_in">getOrientation</span>();</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;<span class="built_in">getAlpha</span>() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                        layer-&gt;<span class="built_in">getRoundedCornerState</span>().radius == <span class="number">0.0f</span> &amp;&amp;</span><br><span class="line">                        ((layerOrientation &amp; ui::Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时</span></span><br><span class="line">                    <span class="comment">// 那么它的完全不透明区域opaqueRegion就等于计算所得到的可见区域visibleRegion</span></span><br><span class="line">                    opaqueRegion = visibleRegion;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Surface没有可视区域，则清空相关变量，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (visibleRegion.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">clearVisibilityRegions</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将覆盖区域裁剪到可见区域</span></span><br><span class="line">        <span class="comment">// aboveCoveredLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的可见区域</span></span><br><span class="line">        <span class="comment">// 将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相交，就可以得到当前正在处理的应用程序窗口的被覆盖区域coveredRegion</span></span><br><span class="line">        <span class="comment">// 而将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相或一下，就可以得到下一个应用程序窗口的所有上层应用程序窗口所组成的可见区域aboveCoveredLayers。</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.<span class="built_in">intersect</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aboveOpaqueLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的完全不透明区域</span></span><br><span class="line">        aboveCoveredLayers.<span class="built_in">orSelf</span>(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个区域从当前正在处理的应用程序窗口的可见区域visibleRegion减去后，就可以得到当前正在处理的应用程序窗口的最终可见区域visibleRegion。</span></span><br><span class="line">        visibleRegion.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算Layer的脏区域，所谓脏区域就是需要重新执行渲染操作的</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">            <span class="comment">// 成员变量contentDirty的值为true，则说明当前正在处理的Layer上一次的状态还未来得及处理</span></span><br><span class="line">            <span class="comment">// 即它当前的内容是脏的。在这个状况下，只需要将此次的可见区域与上一次的可见区域合并即可</span></span><br><span class="line">            dirty = visibleRegion;</span><br><span class="line">            <span class="comment">// as well, as the old visible region</span></span><br><span class="line">            dirty.<span class="built_in">orSelf</span>(layer-&gt;visibleRegion);</span><br><span class="line">            layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当上一次状态已经处理了，也就是显示内容没有更新,则无需重新渲染所有区域。</span></span><br><span class="line">            <span class="comment">// 现在只需要处理一下两种情况：</span></span><br><span class="line">            <span class="comment">// 1. 之前是被覆盖的区域，但现在不被覆盖了</span></span><br><span class="line">            <span class="comment">// 2. 由于窗口大小变化而引发的新增不被覆盖区域</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第一种情况:</span></span><br><span class="line">            <span class="comment">// 将当前可见区域visibleRegion与它的上一次被覆盖区域oldCoveredRegion相交</span></span><br><span class="line">            <span class="comment">// 就可以得到之前是被覆盖的而现在不被覆盖了的区域，即可以得到第一部分需要重新渲染的区域</span></span><br><span class="line">            <span class="comment">// 上一次可见区域和被覆盖区域分别oldVisibleRegion, oldCoveredRegion</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 针对第二种情况:</span></span><br><span class="line">            <span class="comment">// 由于将一个应用程序窗口的当前可见区域减去被覆盖区域即为它的当前不被覆盖的区域newExposed</span></span><br><span class="line">            <span class="comment">// 同理上一次不被覆盖的区域oldExposed就是上一次可见区域减去上一次被覆盖区域</span></span><br><span class="line">            <span class="comment">// 那么将一个应用程序窗口的当前不被覆盖的区域newExposed减去它的上一次不被覆盖的区域oldExposed，就可以得到新增的不被覆盖区域</span></span><br><span class="line">            <span class="type">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">            <span class="type">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">            <span class="type">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将第一部分和第二部分需要重新渲染的区域组合起来，就可以得到当前Layer的脏区域dirty。</span></span><br><span class="line">            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从该脏区域dirty减去上层的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 因为后者的渲染不需要当前Layer参与</span></span><br><span class="line">        dirty.<span class="built_in">subtractSelf</span>(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新的脏区域dirty累计到输出参数dirtyRegion中.</span></span><br><span class="line">        outDirtyRegion.<span class="built_in">orSelf</span>(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新计算到目前为止所得到的Layer的完全不透明区域</span></span><br><span class="line">        <span class="comment">// 这个是方便下一层Layer的计算</span></span><br><span class="line">        aboveOpaqueLayers.<span class="built_in">orSelf</span>(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存当前正在处理的Layer的可见区域和被覆盖区域以及可见非透明区域.</span></span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleRegion</span>(visibleRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setCoveredRegion</span>(coveredRegion);</span><br><span class="line">        layer-&gt;<span class="built_in">setVisibleNonTransparentRegion</span>(</span><br><span class="line">                visibleRegion.<span class="built_in">subtract</span>(transparentRegion));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前面所有的Layer组成的完全不透明区域aboveOpaqueLayers保存在输出参数opaqueRegion中</span></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-小结"><a href="#三-小结" class="headerlink" title="三. 小结"></a>三. 小结</h1><p>handleMessageRefresh – SF合成所有Layer大概步骤如下：</p><ol><li>preComposition<br>合成前遍历所有layer, 处理处于Drawing状态的Layer是否被更新了</li><li>rebuildLayerStacks<br>反向遍历Z轴计算各个Layer的可视区域，之后 顺序遍历Z轴Layer将相关信息更新到对应Diplay中。</li><li>calculateWorkingSet<br>这里建立HWC中的Layer列表： </li><li>按照Z轴的顺序，依次给可见OutputLayer在HWC中建立映射也就是将Layer的状态信息放在CompositionState中，并重新计算OutputLayer的几何状态，写入HWC</li><li>将Layer的mActiveBuffer设置到HWComposer中</li><li>doComposition<br>正式的合成处理，使用渲染引擎合成所有layer，然后就是申请GraphicBuffer，向其中填充帧数据, 最终给到硬件帧缓冲区</li><li>postComposition &amp;&amp; clear mLayersWithQueuedFrames<br>回调每个layer的onPostComposition并清空mLayersWithQueuedFrames，下一次vsync来到时，会在handlePageFlip中重新添加</li></ol><p>大概流程搞清楚了，接下来细细分析比如GraphicBuffer和Fence机制的工作原理, 等等，HWC好像还没有了解，先看看这个是怎么工作的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>[Android Synchronization Fences – An Introduction]<a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li><li>[Android 4.0.3 显示系统深入理解]<a href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li><li>[Clang 10 documentation ATTRIBUTES IN CLANG]<a href="https://clang.llvm.org/docs/AttributeReference.html">https://clang.llvm.org/docs/AttributeReference.html</a></li><li>[「Android」SurfaceFlinger分析]<a href="https://www.cnblogs.com/1996swg/p/9790209.html">https://www.cnblogs.com/1996swg/p/9790209.html</a></li><li>[显示系统：第005课_Vsync机制:第007节_rebuildLayerStacks源码分析]<a href="http://www.pianshen.com/article/8541345041/">http://www.pianshen.com/article/8541345041/</a></li><li>[Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析]<a href="https://blog.csdn.net/luoshengyang/article/details/8079456">https://blog.csdn.net/luoshengyang/article/details/8079456</a></li><li>[Android Region代码分析]<a href="https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t">https://blog.csdn.net/fuyajun01/article/details/25551717?_t=t</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着上文，当我们接收到来自App RenderThread线程渲染后的Surface之后，会在SurfaceFlinger收到下一次Vsync时做合成。&lt;br&gt;前面我们也稍微分析了一下，直接看handleMessageRefresh方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/SurfaceFlinger-5-composer/5_1_sf_onVsync.png&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面trace上也可以看出收到Vsync后，sf首先调用handleMessageInvalidate检查时候需要进行合成。&lt;br&gt;如果需要就会调用方法handleMessageRefresh去做合成，最后将合成后的图像送入屏幕显示。&lt;/p&gt;
&lt;p&gt;这里重点分析handleMessageRefresh.&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(4)--Layer&amp;Surface</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-4-Layer-Surface/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-4-Layer-Surface/</id>
    <published>2022-04-04T01:57:56.000Z</published>
    <updated>2022-04-04T02:29:13.183Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Android Q</strong></p><p>前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。<br>接下来我们先看看SurfaceFlinger合成帧的部分。</p><span id="more"></span><h1 id="一-SF-EventThread接收vsync的准备"><a href="#一-SF-EventThread接收vsync的准备" class="headerlink" title="一. SF EventThread接收vsync的准备"></a>一. SF EventThread接收vsync的准备</h1><p>在SFEventThread一文中已经探明，当产生Vsync信号后，会通过BitTube发送事件(EventThreadConnection.postEvent):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::postEvent</span><span class="params">(<span class="type">const</span> DisplayEventReceiver::Event&amp; event)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就需要知道 mChannel 是被谁监听了。</p><h2 id="1-1-SurfaceFlinger-init"><a href="#1-1-SurfaceFlinger-init" class="headerlink" title="1.1 SurfaceFlinger.init"></a>1.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.1.1 创建SfEventThread以及EventThreadConnection</span></span><br><span class="line">    mSfConnectionHandle = mScheduler-&gt;<span class="built_in">createConnection</span>(<span class="string">&quot;sf&quot;</span>, mPhaseOffsets-&gt;<span class="built_in">getCurrentSfOffset</span>(),</span><br><span class="line">                                                    resyncCallback, [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                        mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 赋值 BitTube, 用来通信</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventConnection</span>(mScheduler-&gt;<span class="built_in">getEventConnection</span>(mSfConnectionHandle));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mEventQueue是在SurfaceFlinger.onFirstRef中初始化的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onFirstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    mEventQueue-&gt;<span class="built_in">init</span>(<span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::init</span><span class="params">(<span class="type">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">true</span>);</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="built_in">Handler</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个Looper就是SurfaceFlinger主线程的Looper.</p><h3 id="1-1-1-Scheduler-createConnection"><a href="#1-1-1-Scheduler-createConnection" class="headerlink" title="1.1.1 Scheduler.createConnection"></a>1.1.1 Scheduler.createConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;Scheduler::ConnectionHandle&gt; <span class="title">Scheduler::createConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">char</span>* connectionName, <span class="type">int64_t</span> phaseOffsetNs, ResyncCallback resyncCallback,</span></span></span><br><span class="line"><span class="params"><span class="function">        impl::EventThread::InterceptVSyncsCallback interceptCallback)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> id = sNextId++;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Creating a connection handle with ID: %&quot;</span> PRId64 <span class="string">&quot;\n&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 sfEventThread</span></span><br><span class="line">    std::unique_ptr&lt;EventThread&gt; eventThread =</span><br><span class="line">            <span class="built_in">makeEventThread</span>(connectionName, mPrimaryDispSync.<span class="built_in">get</span>(), phaseOffsetNs,</span><br><span class="line">                            std::<span class="built_in">move</span>(interceptCallback));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建EventThreadConnection</span></span><br><span class="line">    <span class="keyword">auto</span> eventThreadConnection =</span><br><span class="line">            <span class="built_in">createConnectionInternal</span>(eventThread.<span class="built_in">get</span>(), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">    <span class="comment">// 保存创建的connection</span></span><br><span class="line">    mConnections.<span class="built_in">emplace</span>(id,</span><br><span class="line">                         std::<span class="built_in">make_unique</span>&lt;Connection&gt;(<span class="keyword">new</span> <span class="built_in">ConnectionHandle</span>(id),</span><br><span class="line">                                                      eventThreadConnection,</span><br><span class="line">                                                      std::<span class="built_in">move</span>(eventThread)));</span><br><span class="line">    <span class="keyword">return</span> mConnections[id]-&gt;handle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-EventThread-createEventConnection"><a href="#1-1-2-EventThread-createEventConnection" class="headerlink" title="1.1.2 EventThread.createEventConnection"></a>1.1.2 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建了 BitTube, 此时是在SurfaceFlinger主线程</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-MessageQueue-setEventConnection"><a href="#1-2-MessageQueue-setEventConnection" class="headerlink" title="1.2 MessageQueue.setEventConnection"></a>1.2 MessageQueue.setEventConnection</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEvents = connection;</span><br><span class="line">    <span class="comment">// 1.2.1 通过BitTube建立与SFEventThread的通信通道</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 有vsync事件会回调cb_eventReceiver事件</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mLooper就是SurfaceFlinger主线程的Looper.</p><h3 id="1-2-1-EventThreadConnection-stealReceiveChannel"><a href="#1-2-1-EventThreadConnection-stealReceiveChannel" class="headerlink" title="1.2.1 EventThreadConnection.stealReceiveChannel"></a>1.2.1 EventThreadConnection.stealReceiveChannel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mChannel就是[1.1.2]中新建的BitTube</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-SF-EventThread接收vsync"><a href="#二-SF-EventThread接收vsync" class="headerlink" title="二. SF EventThread接收vsync"></a>二. SF EventThread接收vsync</h1><p>上面我们知道了，当SFEventThread发出Vsync信号时，会通过BitTube发送该消息至SurfaceFlinger主线程，并调用MessageQueue.cb_eventReceiver方法处理。</p><h2 id="2-1-MessageQueue-cb-eventReceiver"><a href="#2-1-MessageQueue-cb-eventReceiver" class="headerlink" title="2.1 MessageQueue.cb_eventReceiver"></a>2.1 MessageQueue.cb_eventReceiver</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">// 读取消息内容</span></span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 只关心VSYNC消息</span></span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="comment">// 2.2 触发composition</span></span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-MessageQueue-Handler-dispatchInvalidate"><a href="#2-2-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="2.2 MessageQueue.Handler.dispatchInvalidate"></a>2.2 MessageQueue.Handler.dispatchInvalidate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里通过Looper发送INVALIDATE消息</span></span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            <span class="comment">// 处理INVALIDATE消息</span></span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-SurfaceFlinger-onMessageReceived"><a href="#2-3-SurfaceFlinger-onMessageReceived" class="headerlink" title="2.3 SurfaceFlinger.onMessageReceived"></a>2.3 SurfaceFlinger.onMessageReceived</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="type">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            <span class="comment">// 通过fence机制来判断是否掉帧 </span></span><br><span class="line">            <span class="type">bool</span> frameMissed = <span class="built_in">previousFrameMissed</span>();</span><br><span class="line">            <span class="type">bool</span> hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="type">bool</span> gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;FrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;HwcFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(hwcFrameMissed));</span><br><span class="line">            <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;GpuFrameMissed&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(gpuFrameMissed));</span><br><span class="line">            <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line">                mFrameMissedCount++;</span><br><span class="line">                mTimeStats-&gt;<span class="built_in">incrementMissedFrames</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hwcFrameMissed) &#123;</span><br><span class="line">                mHwcFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (gpuFrameMissed) &#123;</span><br><span class="line">                mGpuFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行相关参数更新，比如Vsync切换</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">performSetActiveConfig</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果丢帧，则不处理此次VSYNC</span></span><br><span class="line">            <span class="keyword">if</span> (frameMissed &amp;&amp; mPropagateBackpressure) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) ||</span><br><span class="line">                    mPropagateBackpressureClientComposition) &#123;</span><br><span class="line">                    <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="comment">// transaction主要针对Layer和Display的变化更新脏区域</span></span><br><span class="line">            <span class="comment">// 通过Layer的变化来计算脏区域，目的是需要更新我才刷新</span></span><br><span class="line">            <span class="type">bool</span> refreshNeeded = <span class="built_in">handleMessageTransaction</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 主要是调用handlePageFlip()函数，该函数在systrace图上对应latchBuffer及其所包含的方法。</span></span><br><span class="line">            <span class="comment">// 作用是从各Layer对应的BufferQueue中拿图形缓冲区数据，并根据内容更新脏区域</span></span><br><span class="line">            <span class="comment">// 并且把GraphicBuffer映射为OpenGL的texture</span></span><br><span class="line">            refreshNeeded |= <span class="built_in">handleMessageInvalidate</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">updateCursorAsync</span>();</span><br><span class="line">            <span class="built_in">updateInputFlinger</span>();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; <span class="built_in">CC_LIKELY</span>(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">// 发送刷新合成请求</span></span><br><span class="line">                <span class="built_in">signalRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDolphinFuncsEnabled) &#123;</span><br><span class="line">                <span class="built_in">mDolphinRefresh</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.6 SF 处理合成</span></span><br><span class="line">            <span class="built_in">handleMessageRefresh</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先忽略Fence机制，先看看大致流程。</p><h2 id="2-4-SurfaceFlinger-handleMessageInvalidate"><a href="#2-4-SurfaceFlinger-handleMessageInvalidate" class="headerlink" title="2.4 SurfaceFlinger.handleMessageInvalidate"></a>2.4 SurfaceFlinger.handleMessageInvalidate</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="type">bool</span> refreshNeeded = <span class="built_in">handlePageFlip</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVisibleRegionsDirty) &#123;</span><br><span class="line">        <span class="built_in">computeLayerBounds</span>();</span><br><span class="line">        <span class="keyword">if</span> (mTracingEnabled) &#123;</span><br><span class="line">            mTracing.<span class="built_in">notify</span>(<span class="string">&quot;visibleRegionsDirty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh) &#123;</span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;<span class="built_in">getScreenBounds</span>());</span><br><span class="line">        <span class="built_in">invalidateLayerStack</span>(layer, visibleReg);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRefresh.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-SurfaceFlinger-handlePageFlip"><a href="#2-5-SurfaceFlinger-handlePageFlip" class="headerlink" title="2.5 SurfaceFlinger.handlePageFlip"></a>2.5 SurfaceFlinger.handlePageFlip</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;handlePageFlip&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">nsecs_t</span> latchTime = <span class="built_in">systemTime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储需要更新的图层集。 当缓冲区被锁存时，不得更改，因为可能导致死锁。</span></span><br><span class="line">    mDrawingState.<span class="built_in">traverseInZOrder</span>([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;<span class="built_in">hasReadyFrame</span>()) &#123;</span><br><span class="line">            frameQueued = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">nsecs_t</span> expectedPresentTime;</span><br><span class="line">            expectedPresentTime = mScheduler-&gt;<span class="built_in">expectedPresentTime</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">shouldPresentNow</span>(expectedPresentTime)) &#123;</span><br><span class="line">                <span class="comment">// mLayersWithQueuedFrames用于标记那些已经有Frame的Layer</span></span><br><span class="line">                mLayersWithQueuedFrames.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;!layer-&gt;shouldPresentNow()&quot;</span>);</span><br><span class="line">                layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;<span class="built_in">useEmptyDamage</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mLayersWithQueuedFrames.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// mStateLock is needed for latchBuffer as LayerRejecter::reject()</span></span><br><span class="line">        <span class="comment">// writes to Layer current state. See also b/119481871</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">latchBuffer</span>(visibleRegions, latchTime)) &#123;</span><br><span class="line">                mLayersPendingRefresh.<span class="built_in">push_back</span>(layer);</span><br><span class="line">            &#125;</span><br><span class="line">            layer-&gt;<span class="built_in">useSurfaceDamage</span>();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;<span class="built_in">isBufferLatched</span>()) &#123;</span><br><span class="line">                newDataLatched = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line">    <span class="comment">// queued frame that shouldn&#x27;t be displayed during this vsync period, wake</span></span><br><span class="line">    <span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line">    <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.<span class="built_in">empty</span>() || !newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">signalLayerUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enter boot animation on first buffer latch</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123;</span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;Enter boot animation&quot;</span>);</span><br><span class="line">        mBootStage = BootStage::BOOTANIMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line">    <span class="keyword">return</span> !mLayersWithQueuedFrames.<span class="built_in">empty</span>() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-SurfaceFlinger-handleMessageRefresh"><a href="#2-6-SurfaceFlinger-handleMessageRefresh" class="headerlink" title="2.6 SurfaceFlinger.handleMessageRefresh"></a>2.6 SurfaceFlinger.handleMessageRefresh</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> repaintEverything = mRepaintEverything.<span class="built_in">exchange</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 合成前再过一遍Layer是否被更新了</span></span><br><span class="line">    <span class="comment">// 如果有则触发signalLayerUpdate()，通过EventThread安排一次invalidate sf vsync。</span></span><br><span class="line">    <span class="built_in">preComposition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重建layer堆栈, 提取可见的Laye并计算可见区域，为合成准备好数据材料。</span></span><br><span class="line">    <span class="built_in">rebuildLayerStacks</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hwcomposer的设定</span></span><br><span class="line">    <span class="built_in">calculateWorkingSet</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        <span class="built_in">beginFrame</span>(display);</span><br><span class="line">        <span class="built_in">prepareFrame</span>(display);</span><br><span class="line">        <span class="built_in">doDebugFlashRegions</span>(display, repaintEverything);</span><br><span class="line">        <span class="built_in">doComposition</span>(display, repaintEverything); <span class="comment">//正式的合成处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">logLayerStats</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postFrame</span>();</span><br><span class="line">    <span class="comment">// 将图像传递到物理屏幕。但是在下一个vsync信号才被消费。</span></span><br><span class="line">    <span class="comment">// 回调每个layer的onPostComposition</span></span><br><span class="line">    <span class="built_in">postComposition</span>();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;<span class="built_in">getCompositionDisplay</span>();</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasClientComposition</span>(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || <span class="built_in">getHwComposer</span>().<span class="built_in">hasDeviceComposition</span>(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.<span class="built_in">onRefreshed</span>(mHadClientComposition);</span><br><span class="line"></span><br><span class="line">    mLayersWithQueuedFrames.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再继续分析之前，我们需要先了解Layer的结构，以及他是如何被添加至SurfaceFlinger中的。</p><h1 id="三-Layer的产生"><a href="#三-Layer的产生" class="headerlink" title="三. Layer的产生"></a>三. Layer的产生</h1><p>Layer, 即图层。Layer是图像合成中最重要的单元。图层是Surface和SurfaceControl的组合。<br>说到底也就是每个Window都有对应Surface，也就对应一个Layer;SurfaceFlinger的合成就是将所有图层按照顺序和特定属性合成一帧画面。<br>每个图层都有一组属性，用于定义它与其他图层的交互方式。 </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Positional</td><td>定义图层在其显示屏上显示的位置。 包括诸如图层边缘的位置及其相对于其他图层的Z顺序的信息</td></tr><tr><td>Content</td><td>定义图层上显示的内容应如何在位置属性定义的边界内显示。 包括裁剪和变换等信息</td></tr><tr><td>Composition</td><td>定义图层应如何与其他图层合成。 包括混合模式和alpha合成的图层范围Alpha值等信息</td></tr><tr><td>Optimization</td><td>提供正确合成图层非必要的信息，但硬件编写器（HWC）设备可以使用该信息来优化其执行合成的方式。 包括诸如图层的可见区域以及自上一帧以来图层的哪个部分已更新的信息。</td></tr></tbody></table><p>在创建Window或者Window产生变化时就会更新对应的Surface所属的Layer.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">    WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">    WindowManagerService.createSurfaceControl(...) --[SystemServer进程]</span><br><span class="line">    WindowStateAnimator.createSurfaceLocked(...) --[SystemServer进程] 这里传入Surface的FLAG</span><br><span class="line">    WindowSurfaceController.new() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface() --[SystemServer进程]</span><br><span class="line">        WindowContainer.makeSurface(WindowContainer) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Builder.build() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.new() --[SystemServer进程]</span><br><span class="line">        android_view_SurfaceControl:nativeCreate() --[JNI][SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:getDefault() --[SystemServer进程]</span><br><span class="line">            DefaultComposerClient:getComposerClient() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">            SurfaceComposerClient:onFirstRef() --[SystemServer进程]通过Binder从SF获取SurfaceComposerClient</span><br><span class="line">                SurfaceFlinger:createConnection() --[SurfaceFlinger进程] 创建SurfaceComposerClient</span><br><span class="line">        SurfaceComposerClient:createSurfaceChecked(...) --[SystemServer进程]Binder调用</span><br><span class="line">        Client:createSurface(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlinger:createLayer(...) --[SurfaceFlinger进程] 这里假设创建一个默认Surface</span><br><span class="line">            SurfaceFlinger:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            SurfaceFlingerFactory:createBufferQueueLayer(...) --[SurfaceFlinger进程]</span><br><span class="line">            BufferQueueLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">                BufferLayer:<span class="keyword">new</span>(LayerCreationArgs) --[SurfaceFlinger进程]</span><br><span class="line">        SurfaceControl:<span class="keyword">new</span>(...) --[SystemServer进程]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_1.png" alt="图片"></p><p>Surface FLAG一览</p><table><thead><tr><th>名称</th><th>值</th><th>作用</th></tr></thead><tbody><tr><td>HIDDEN</td><td>0x00000004</td><td>Surface是隐藏的</td></tr><tr><td>SECURE</td><td>0x00000080</td><td>包含安全内容，禁止内容被其他进程复制。而且屏幕截图和VNC服务器将被禁用，但可能不会采用硬件加速。Window带有FLAG_SECURE标签，或者该应用禁止截图就会带有这个FLAG</td></tr><tr><td>NON_PREMULTIPLIED</td><td>0x00000100</td><td>预乘透明度，创建一个Surface，其中颜色分量被Alpha通道解释为“非预乘”。对于没有alpha通道的Surface，这个标志是没有意义的。 默认情况下，Surface是预乘的，这意味着每个颜色分量已经乘以其alpha值。</td></tr><tr><td>OPAQUE</td><td>0x00000400</td><td>表示Surface必须为不透明，即使其像素格式包含Alpha通道。</td></tr><tr><td>PROTECTED_APP</td><td>0x00000800</td><td>应用程序需要通过外部显示接收器的硬件保护路径。 如果硬件保护路径不可用，则此表面将不会显示在外部接收器上。</td></tr><tr><td>CURSOR_WINDOW</td><td>0x00002000</td><td>窗口表示光标字形。</td></tr><tr><td>FX_SURFACE_NORMAL</td><td>0x00000000</td><td>创建一个默认Surface</td></tr><tr><td>FX_SURFACE_DIM</td><td>0x00020000</td><td>创建一个暗淡的Surface。 此Surface后面的所有内容都会被{@link #setAlpha}中指定的数量调暗。 锁定Dim Surface是错误的，因为它没有后备存储。</td></tr><tr><td>FX_SURFACE_CONTAINER</td><td>创建容器Surface。 此Surface将没有缓冲区，仅用作其他Surface或其InputInfo的容器。</td><td></td></tr><tr><td>SURFACE_HIDDEN</td><td>0x01</td><td>隐藏该Surface, 等同于调用Surface.hide()</td></tr><tr><td>SURFACE_OPAQUE</td><td>0x02</td><td>尽可能不混合的复合材料。 更新Surface创建期间设置的值（请参阅{@link #OPAQUE}）。</td></tr></tbody></table><h2 id="3-1-SurfaceFlinger-createLayer"><a href="#3-1-SurfaceFlinger-createLayer" class="headerlink" title="3.1 SurfaceFlinger:createLayer"></a>3.1 SurfaceFlinger:createLayer</h2><p>当上次Window变化时，或者会创建Layer，并保存在SurfaceFlinger中.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="type">const</span> String8&amp; name, <span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">uint32_t</span> h, PixelFormat format, <span class="type">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 假设创建默认的Surface</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">            result = <span class="built_in">createBufferQueueLayer</span>(client, uniqueName, w, h, flags, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                            format, handle, gbp, &amp;layer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 检查是否有访问SurfaceFlinger的权限</span></span><br><span class="line">    <span class="type">bool</span> addToCurrentState = <span class="built_in">callingThreadHasUnscopedSurfaceFlingerAccess</span>();</span><br><span class="line">    <span class="comment">// 3.2 保存新建的Layer</span></span><br><span class="line">    result = <span class="built_in">addClientLayer</span>(client, *handle, *gbp, layer, parentHandle, parentLayer,</span><br><span class="line">                            addToCurrentState);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    mInterceptor-&gt;<span class="built_in">saveSurfaceCreation</span>(layer);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTransactionFlags</span>(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-SurfaceFlinger-createBufferQueueLayer"><a href="#3-1-1-SurfaceFlinger-createBufferQueueLayer" class="headerlink" title="3.1.1 SurfaceFlinger.createBufferQueueLayer"></a>3.1.1 SurfaceFlinger.createBufferQueueLayer</h3><p>中间细琐流程略过，最终是创建了一个Layer对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Layer::<span class="built_in">Layer</span>(<span class="type">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">      : <span class="built_in">mFlinger</span>(args.flinger),</span><br><span class="line">        <span class="built_in">mName</span>(args.name),</span><br><span class="line">        <span class="built_in">mClientRef</span>(args.client),</span><br><span class="line">        <span class="built_in">mWindowType</span>(args.metadata.<span class="built_in">getInt32</span>(METADATA_WINDOW_TYPE, <span class="number">0</span>)) &#123;</span><br><span class="line">    mCurrentCrop.<span class="built_in">makeInvalid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> layerFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eHidden) layerFlags |= <span class="type">layer_state_t</span>::eLayerHidden;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eOpaque) layerFlags |= <span class="type">layer_state_t</span>::eLayerOpaque;</span><br><span class="line">    <span class="keyword">if</span> (args.flags &amp; ISurfaceComposerClient::eSecure) layerFlags |= <span class="type">layer_state_t</span>::eLayerSecure;</span><br><span class="line"></span><br><span class="line">    mTransactionName = <span class="built_in">String8</span>(<span class="string">&quot;TX - &quot;</span>) + mName;</span><br><span class="line"></span><br><span class="line">    mCurrentState.active_legacy.w = args.w;</span><br><span class="line">    mCurrentState.active_legacy.h = args.h;</span><br><span class="line">    mCurrentState.flags = layerFlags;</span><br><span class="line">    mCurrentState.active_legacy.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.crop_legacy.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.requestedCrop_legacy = mCurrentState.crop_legacy;</span><br><span class="line">    mCurrentState.z = <span class="number">0</span>; <span class="comment">// 这里就是layer在Z轴的位置</span></span><br><span class="line">    mCurrentState.color.a = <span class="number">1.0f</span>;</span><br><span class="line">    mCurrentState.layerStack = <span class="number">0</span>; <span class="comment">// layer所在layerStack</span></span><br><span class="line">    mCurrentState.sequence = <span class="number">0</span>; <span class="comment">// layer序号</span></span><br><span class="line">    mCurrentState.requested_legacy = mCurrentState.active_legacy;</span><br><span class="line">    mCurrentState.active.w = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.h = UINT32_MAX;</span><br><span class="line">    mCurrentState.active.transform.<span class="built_in">set</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mCurrentState.transform = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.transformToDisplayInverse = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.crop.<span class="built_in">makeInvalid</span>();</span><br><span class="line">    mCurrentState.acquireFence = <span class="keyword">new</span> <span class="built_in">Fence</span>(<span class="number">-1</span>);</span><br><span class="line">    mCurrentState.dataspace = ui::Dataspace::UNKNOWN;</span><br><span class="line">    mCurrentState.hdrMetadata.validTypes = <span class="number">0</span>;</span><br><span class="line">    mCurrentState.surfaceDamageRegion.<span class="built_in">clear</span>();</span><br><span class="line">    mCurrentState.cornerRadius = <span class="number">0.0f</span>;</span><br><span class="line">    mCurrentState.api = <span class="number">-1</span>;</span><br><span class="line">    mCurrentState.hasColorTransform = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.colorSpaceAgnostic = <span class="literal">false</span>;</span><br><span class="line">    mCurrentState.metadata = args.metadata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drawing state &amp; current state are identical</span></span><br><span class="line">    mDrawingState = mCurrentState;</span><br><span class="line"></span><br><span class="line">    CompositorTiming compositorTiming;</span><br><span class="line">    args.flinger-&gt;<span class="built_in">getCompositorTiming</span>(&amp;compositorTiming);</span><br><span class="line">    mFrameEventHistory.<span class="built_in">initializeCompositorTiming</span>(compositorTiming);</span><br><span class="line">    mFrameTracker.<span class="built_in">setDisplayRefreshPeriod</span>(compositorTiming.interval);</span><br><span class="line"></span><br><span class="line">    mSchedulerLayerHandle = mFlinger-&gt;mScheduler-&gt;<span class="built_in">registerLayer</span>(mName.<span class="built_in">c_str</span>(), mWindowType);</span><br><span class="line"></span><br><span class="line">    mFlinger-&gt;<span class="built_in">onLayerCreated</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注的是：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>z</td><td>z-order，表示x,y,z轴的z轴上的顺序。数字越大，表示越在上面，数字越小，表示越在下面。</td></tr><tr><td>layerStack</td><td>layerStack是存储layer的容器,我们知道每个display只会有一个layerstack来存储他要显示的layer,但是不同的display可以使用同一个layerStack,也可以使用不同的layerStack。可以理解为组的含义。也就是说属于不同组的layer之间互不干扰。SurfaceFlinger中有一个DisplayDevice类，他表示用来显示的设备，譬如LCD或者是HDMI。DisplayDevice里也有一个成员变量mLayerStack，在进行composition的时候，只有和这个device的layerstack相同的layer才可能被显示在这个设备上。</td></tr><tr><td>sequence</td><td>sSequence是一个static的变量，所以递加的效果就是为每一个layer设置一个唯一且递增的序列号。</td></tr></tbody></table><h2 id="3-2-SurfaceFlinger-addClientLayer"><a href="#3-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2 SurfaceFlinger.addClientLayer"></a>3.2 SurfaceFlinger.addClientLayer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::addClientLayer</span><span class="params">(<span class="type">const</span> sp&lt;Client&gt;&amp; client, <span class="type">const</span> sp&lt;IBinder&gt;&amp; handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc, <span class="type">const</span> sp&lt;Layer&gt;&amp; lbc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> sp&lt;Layer&gt;&amp; parentLayer, <span class="type">bool</span> addToCurrentState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// add this layer to the current state list</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mStateLock);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">nullptr</span> &amp;&amp; addToCurrentState) &#123;</span><br><span class="line">            <span class="comment">// 3.2.1 将新创建的Layer按照Z轴顺序存储至队列中</span></span><br><span class="line">            mCurrentState.layersSortedByZ.<span class="built_in">add</span>(lbc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">isRemovedFromCurrentState</span>()) &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">            lbc-&gt;<span class="built_in">onRemovedFromCurrentState</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent-&gt;<span class="built_in">addChild</span>(lbc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gbc != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            mGraphicBufferProducerList.<span class="built_in">insert</span>(IInterface::<span class="built_in">asBinder</span>(gbc).<span class="built_in">get</span>());</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mGraphicBufferProducerList.<span class="built_in">size</span>() &gt;</span><br><span class="line">                                        mMaxGraphicBufferProducerListSize,</span><br><span class="line">                                <span class="string">&quot;Suspected IGBP leak: %zu IGBPs (%zu max), %zu Layers&quot;</span>,</span><br><span class="line">                                mGraphicBufferProducerList.<span class="built_in">size</span>(),</span><br><span class="line">                                mMaxGraphicBufferProducerListSize, mNumLayers);</span><br><span class="line">        &#125;</span><br><span class="line">        mLayersAdded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.2 将该Layer保存至mClient的mLayers中,键为IBinder,供后续使用</span></span><br><span class="line">    client-&gt;<span class="built_in">attachLayer</span>(handle, lbc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞清楚Layer的Z轴顺序，对与我们理解Layer合成过程有很大帮助。<br>Layer排序建议参考：<a href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></p><h3 id="3-2-1-LayerVector-add"><a href="#3-2-1-LayerVector-add" class="headerlink" title="3.2.1 LayerVector.add"></a>3.2.1 LayerVector.add</h3><p>将新创建的Layer按照Z轴顺序存储至队列中.<br>LayerVector继承了SortedVector,并且重载了函数 do_compare.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LayerVector::do_compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* lhs, <span class="type">const</span> <span class="type">void</span>* rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先对LayerStack排序，然后是Z轴排序，最后是序号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; l = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(lhs);</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; r = *<span class="keyword">reinterpret_cast</span>&lt;<span class="type">const</span> sp&lt;Layer&gt;*&gt;(rhs);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; lState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? l-&gt;<span class="built_in">getCurrentState</span>() : l-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; rState =</span><br><span class="line">            (mStateSet == StateSet::Current) ? r-&gt;<span class="built_in">getCurrentState</span>() : r-&gt;<span class="built_in">getDrawingState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> ls = lState.layerStack;</span><br><span class="line">    <span class="type">uint32_t</span> rs = rState.layerStack;</span><br><span class="line">    <span class="keyword">if</span> (ls != rs)</span><br><span class="line">        <span class="keyword">return</span> (ls &gt; rs) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> lz = lState.z;</span><br><span class="line">    <span class="type">int32_t</span> rz = rState.z;</span><br><span class="line">    <span class="keyword">if</span> (lz != rz)</span><br><span class="line">        <span class="keyword">return</span> (lz &gt; rz) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;sequence == r-&gt;sequence)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (l-&gt;sequence &gt; r-&gt;sequence) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先比较layerstack，不同的layerstack分开。然后再比较z，假设都相同，就比较唯一的layer序列号。<br>但是至今为止，layerStack和z都还只是初始化时的0，所以在创建layer的时候，只是把他根据序列号放进layersSortedByZ而已，其实他的顺序还是没有设置的。</p><h3 id="3-2-2-SurfaceFlinger-addClientLayer"><a href="#3-2-2-SurfaceFlinger-addClientLayer" class="headerlink" title="3.2.2 SurfaceFlinger:addClientLayer"></a>3.2.2 SurfaceFlinger:addClientLayer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Client::attachLayer</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; handle, <span class="type">const</span> sp&lt;Layer&gt;&amp; layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    mLayers.<span class="built_in">add</span>(handle, layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Layer更新流程"><a href="#3-4-Layer更新流程" class="headerlink" title="3.4 Layer更新流程"></a>3.4 Layer更新流程</h2><p>当java层调用setLayer时就会确定对应Layer的Z-Order顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals() --[App进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App进程]</span><br><span class="line">Session.relayout(...) --[App进程] 通过binder与WMS通信:窗口属性有更新</span><br><span class="line">WindowManagerService.relayoutWindow(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacement(...) --[SystemServer进程]</span><br><span class="line">WindowSurfacePlacer.performSurfacePlacementLoop() --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacement(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">RootWindowContainer.performSurfacePlacementNoTrace(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">WindowManagerService.openSurfaceTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.openTransaction() --[SystemServer进程] 创建Transaction, 或者计数+<span class="number">1</span></span><br><span class="line">    android_view_SurfaceControl:nativeCreateTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:<span class="keyword">new</span>() --[SystemServer进程]</span><br><span class="line">WindowManagerService.applySurfaceChangesTransaction(<span class="type">boolean</span>) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.mergeToGlobalTransaction(Transaction) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.merge(Transaction) --[SystemServer进程]合并更新后的属性</span><br><span class="line">    android_view_SurfaceControl:nativeMergeTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:merge(Transaction) --[SystemServer进程]也就是保存新的属性</span><br><span class="line">WindowManagerService.closeSurfaceTransaction(String) --[SystemServer进程]</span><br><span class="line">    SurfaceControl.closeTransaction() --[SystemServer进程]</span><br><span class="line">    SurfaceControl.Transaction.apply() --[SystemServer进程]</span><br><span class="line">    android_view_SurfaceControl:nativeApplyTransaction(...) --[SystemServer进程]</span><br><span class="line">    SurfaceComposerClient:Transaction:apply(bool) --[SystemServer进程]</span><br><span class="line">    SurfaceFlinger:setTransactionState(...) --[SurfaceFlinger进程]传递更新后的属性到sf</span><br><span class="line">    SurfaceFlinger:applyTransactionState(...) --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:run() --[SurfaceFlinger进程]</span><br><span class="line">            TransactionCompletedThread:threadMain() --[SurfaceFlinger子线程]</span><br><span class="line">                mConditionVariable.wait(mMutex);<span class="comment">// 等待执行</span></span><br><span class="line">                TransactionCompletedListener:onTransactionCompleted(...)--[SurfaceFlinger子线程]</span><br><span class="line">        TransactionCompletedThread:addCallback() --[SurfaceFlinger进程]</span><br><span class="line">        TransactionCompletedThread:sendCallbacks() --notify TransactionCompletedThread执行</span><br><span class="line">        SurfaceFlinger:setClientStateLocked(...) --[SurfaceFlinger进程]</span><br><span class="line">            Layer:setLayer(int32_t) --[SurfaceFlinger进程] 更新Layer所处Z轴的位置</span><br></pre></td></tr></table></figure><p>如图：<br><img src="/images/SurfaceFlinger-4-Layer-Surface/4_2.png" alt="图片"></p><p>到目前为止还只是创建了一个SurfaceControl，对应SurfaceFlinger中的BufferQueueLayer。<br>真正的Surface还没有被创建，那是什么时候创建的呢？</p><h1 id="四-Surface的生成"><a href="#四-Surface的生成" class="headerlink" title="四. Surface的生成"></a>四. Surface的生成</h1><p>一个ViewRootImpl对应一个Suface, 也就是一个Layer.<br>当我们创建了Layer之后，总要向其中填充数据内容，SurfaceFlinger才好做合成。<br>在RendererThread中，我们知道了Surface数据是通过渲染引擎OpenGL(android Q上是Vulkan)生成的。</p><h2 id="4-1-Suface的生成"><a href="#4-1-Suface的生成" class="headerlink" title="4.1 Suface的生成"></a>4.1 Suface的生成</h2><p>参阅：RenderThread深入分析(三)–绑定窗口对应的Surface到RenderThread的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl.performTraversals(...) --[App UI进程] 绘制三部曲</span><br><span class="line">ViewRootImpl.relayoutWindow(...) --[App UI进程]</span><br><span class="line">    mSurface.copyFrom(mSurfaceControl) 注意这里会将赋值mSurface</span><br><span class="line">    android_view_Surface:nativeCreateFromSurfaceControl(...) --[App UI进程]</span><br><span class="line">    SurfaceControl:createSurface() --[App UI进程]</span><br><span class="line">        SurfaceControl:generateSurfaceLocked()</span><br><span class="line">        Surface:<span class="keyword">new</span>() 这里创建了<span class="keyword">native</span> Surface</span><br><span class="line">ThreadedRenderer.initializeIfNeeded(...) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.initialize(Surface) --[App UI进程]</span><br><span class="line">    ThreadedRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    HardwareRenderer.setSurface(Surface) --[App UI进程]</span><br><span class="line">    android_view_ThreadedRenderer:setSurface(...) --[App UI进程]</span><br><span class="line">        android_view_Surface:getSurface(...) --[App UI进程] 这里返回上面创建的<span class="keyword">native</span> Surface</span><br><span class="line">    RenderProxy:setSurface(Surface) --[App UI进程] 接下来转进RenderThread线程处理</span><br><span class="line">        CanvasContext:setSurface(...) --[RenderThread线程]</span><br><span class="line">        SkiaVulkanPipeline:setSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager:createSurface(...) --[RenderThread线程]</span><br><span class="line">        VulkanSurface:Create(...) --[RenderThread线程]</span><br><span class="line">        VulkanManager.mGetPhysicalDeviceSurfaceCapabilitiesKHR(...)</span><br><span class="line">            获取Vulkan引擎中的Surface</span><br></pre></td></tr></table></figure><p>大致流程如下图：<br><img src="/images/SurfaceFlinger-4-Layer-Surface/4_3.png" alt="图片"></p><p>现在我们已经获取了渲染引擎中的Surface，向其中填充数据的过程就是performDraw的流程；<br>这个部分在RenderThread中有分析，不在赘述。</p><p>那当我们的Surface中已经被填充了数据后，是如何传递给SurfaceFlinger做合成的呢？<br>这个部分我们稍后详细分析，目前仅从trace上也可以看出来：</p><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_4_app.png" alt="图片"></p><p>上图中eglSwapBuffer最终就是通过binder通知到surfaceflinger中处理的：</p><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_4_sf.png" alt="图片"></p><h1 id="五-Layer实例"><a href="#五-Layer实例" class="headerlink" title="五. Layer实例"></a>五. Layer实例</h1><p>以如下图为例，看看对应Layer：</p><img src="/.io//screenshot_phone.png" width="100" hegiht="200" align="center"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Display 19260235133379457 HWC layers:</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> Layer name</span><br><span class="line">           Z |  Window Type |  Comp Type |  Transform |   Disp Frame (LTRB) |          Source Crop (LTRB)</span><br><span class="line">-------------------------------------------------------------------------------------------</span><br><span class="line"> com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">  rel      0 |            1 |     DEVICE |          0 |    0    0 1080 2340 |    0.0    0.0 1080.0 2340.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> PopupWindow:b04e24#0</span><br><span class="line">  rel      0 |         1002 |     DEVICE |          0 |  646   56 1080  656 |    0.0    0.0  434.0  600.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> StatusBar#0</span><br><span class="line">  rel      0 |         2000 |     DEVICE |          0 |    0    0 1080   80 |    0.0    0.0 1080.0   80.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> NavigationBar0#0</span><br><span class="line">  rel      0 |         2019 |     DEVICE |          0 |    0 2214 1080 2340 |    0.0    0.0 1080.0  126.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlay#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0    0 1080  240 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"> ScreenDecorOverlayBottom#0</span><br><span class="line">  rel      0 |         2024 |     DEVICE |          0 |    0 2100 1080 2340 |    0.0    0.0 1080.0  240.0</span><br><span class="line">- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - -- - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (5fd44db PopupWindow:b04e24#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        2, pos=(646,56), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (9628544 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ ContainerLayer (AppWindowToken&#123;8380fd9 token=Token&#123;2f31a20 ActivityRecord&#123;7c5523 u0 com.android.dialer/com.oneplus.contacts.activities.OPDialtactsActivity t5&#125;&#125;&#125;#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Task=5#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Task=5#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Stack=2#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;taskId:5&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Stack=2#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        5, pos=(0,0), size=(   0,   0), crop=[  0,   0, 1080, 2340], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (com.android.server.wm.DisplayContent$TaskStackContainers@c19f2e#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        1, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000000, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=Display Root#0</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br><span class="line"></span><br><span class="line">+ ContainerLayer (Display Root#0)</span><br><span class="line">  Region TransparentRegion (this=0 count=0)</span><br><span class="line">  Region VisibleRegion (this=0 count=0)</span><br><span class="line">  Region SurfaceDamageRegion (this=0 count=0)</span><br><span class="line">      layerStack=   0, z=        0, pos=(0,0), size=(   0,   0), crop=[  0,   0,  -1,  -1], cornerRadius=0.000000, isProtected=0, isOpaque=0, invalidate=1, dataspace=Default, defaultPixelFormat=Unknown/None, color=(0.000,0.000,0.000,1.000), flags=0x00000002, tr=[0.00, 0.00][0.00, 0.00]</span><br><span class="line">      parent=none</span><br><span class="line">      zOrderRelativeOf=none</span><br><span class="line">      activeBuffer=[   0x   0:   0,Unknown/None], tr=[0.00, 0.00][0.00, 0.00] queued-frames=0, mRefreshPending=0, metadata=&#123;&#125;</span><br></pre></td></tr></table></figure><p>示意图如下：</p><p><img src="/images/SurfaceFlinger-4-Layer-Surface/screenshot_phone_layer.png" alt="图片"></p><p>总的来说就是，树形结构+Z order排序。</p><h1 id="六-类图"><a href="#六-类图" class="headerlink" title="六. 类图"></a>六. 类图</h1><p><img src="/images/SurfaceFlinger-4-Layer-Surface/4_5_classmap.png" alt="图片"></p><p>现在我们Surface有了，也有渲染的内容了，那SurfaceFlinger是如何将这些Surface对应的Layer合成为一帧并显示出来的呢?</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>[Android Synchronization Fences – An Introduction]<a href="http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html">http://netaz.blogspot.com/2013/10/android-fences-introduction-in-any.html</a></li><li>[Android中的GraphicBuffer同步机制-Fence]<a href="https://blog.csdn.net/jinzhuojun/article/details/39698317">https://blog.csdn.net/jinzhuojun/article/details/39698317</a></li><li>[深入浅出Android BufferQueue]<a href="https://blog.51cto.com/13591395/2380727">https://blog.51cto.com/13591395/2380727</a></li><li>[从systrace看app冷启动过程（三）-首帧的合成与送显]<a href="https://www.jianshu.com/p/3829158b4699">https://www.jianshu.com/p/3829158b4699</a></li><li>[Android显示Surface]<a href="https://www.jianshu.com/p/fc3c3d6f9bf7">https://www.jianshu.com/p/fc3c3d6f9bf7</a></li><li>[surfaceflinger中各个layer的排序]<a href="https://www.cnblogs.com/riskyer/p/3297226.html">https://www.cnblogs.com/riskyer/p/3297226.html</a></li><li>[Android 4.0.3 显示系统深入理解]<a href="https://www.linuxidc.com/Linux/2012-03/55898p4.htm">https://www.linuxidc.com/Linux/2012-03/55898p4.htm</a></li><li>[Android窗口管理分析（3）：窗口分组及Z-order的确定]<a href="https://www.jianshu.com/p/90ede7b2a64a">https://www.jianshu.com/p/90ede7b2a64a</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Android Q&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面分析了Vsync信号的始末，其实还有很多可以细究的部分。比如硬件vsync是什么时候开始，什么时候结束？校准算法的原理等等。&lt;br&gt;接下来我们先看看SurfaceFlinger合成帧的部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(3)--AppEventThread接受vsync信号</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/</id>
    <published>2022-04-04T01:57:41.000Z</published>
    <updated>2022-04-04T02:28:58.320Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h1><p>前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。</p><span id="more"></span><p>一图以概之：</p><p><img src="/images/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/3_1.png" alt="图片"></p><p>我们知道android app绘制是离不开编舞者 Choreographer 的，关于 Choreographer 这里就不赘叙，详细可以参考这篇博文。<br>接下来重点分析一下应用app进程是如何与sw vsync信号同步的。</p><h1 id="二-App进程与AppEventThread建立通信过程"><a href="#二-App进程与AppEventThread建立通信过程" class="headerlink" title="二. App进程与AppEventThread建立通信过程"></a>二. App进程与AppEventThread建立通信过程</h1><p>回忆一下，我们知道当应用进程的第一个具有布局的Activity启动时，会初始化Choreographer.</p><h2 id="2-1-Choerographer初始化"><a href="#2-1-Choerographer初始化" class="headerlink" title="2.1 Choerographer初始化"></a>2.1 Choerographer初始化</h2><p>Choerographer是个单例，意味着一个应用进程中只会存在一个实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread local storage for the choreographer.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Choreographer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主线程中初始化，注意传入的第二个参数 VSYNC_SOURCE_APP</span></span><br><span class="line">        <span class="comment">// 这个值是DisplayEventReceiver.VSYNC_SOURCE_APP 也就是 0</span></span><br><span class="line">        <span class="comment">// 与ISurfaceComposer.h中的VsyncSource.eVsyncSourceApp值保持同步</span></span><br><span class="line">        <span class="comment">// 代表的就是 AppEventThread.</span></span><br><span class="line">        <span class="type">Choreographer</span> <span class="variable">choreographer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Choreographer</span>(looper, VSYNC_SOURCE_APP);</span><br><span class="line">        <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">            mMainInstance = choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> choreographer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Choreographer</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mHandler = <span class="keyword">new</span> <span class="title class_">FrameHandler</span>(looper);</span><br><span class="line">    <span class="comment">// 初始化 DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// USE_VSYNC 值默认为true，读取属性debug.choreographer.vsync</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> <span class="title class_">FrameDisplayEventReceiver</span>(looper, vsyncSource)</span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    mFrameIntervalNanos = (<span class="type">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line"></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> <span class="title class_">CallbackQueue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-FrameDisplayEventReceiver初始化"><a href="#2-2-FrameDisplayEventReceiver初始化" class="headerlink" title="2.2 FrameDisplayEventReceiver初始化"></a>2.2 FrameDisplayEventReceiver初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(looper, vsyncSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameDisplayEventReceiver类继承了DisplayEventReceiver类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="type">int</span> vsyncSource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;looper must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">// 转到jni层</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;DisplayEventReceiver&gt;(<span class="built_in">this</span>), mMessageQueue,</span><br><span class="line">            vsyncSource);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">&quot;dispose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意FrameDisplayEventReceiver类是DisplayEventReceiver的子类。</p><h2 id="2-3-android-view-DisplayEventReceiver-cpp-nativeInit"><a href="#2-3-android-view-DisplayEventReceiver-cpp-nativeInit" class="headerlink" title="2.3 android_view_DisplayEventReceiver.cpp:nativeInit"></a>2.3 android_view_DisplayEventReceiver.cpp:nativeInit</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject messageQueueObj, jint vsyncSource)</span> </span>&#123;</span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = <span class="built_in">android_os_MessageQueue_getMessageQueue</span>(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;MessageQueue is not initialized.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.4 根据传入的参数初始化NativeDisplayEventReceiver</span></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> <span class="built_in">NativeDisplayEventReceiver</span>(env,</span><br><span class="line">            receiverWeak, messageQueue, vsyncSource);</span><br><span class="line">    <span class="comment">// 2.8 连接BitTube通信信道</span></span><br><span class="line">    <span class="type">status_t</span> status = receiver-&gt;<span class="built_in">initialize</span>();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.<span class="built_in">appendFormat</span>(<span class="string">&quot;Failed to initialize display event receiver.  status=%d&quot;</span>, status);</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, message.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receiver-&gt;<span class="built_in">incStrong</span>(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(receiver.<span class="built_in">get</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-NativeDisplayEventReceiver-初始化"><a href="#2-4-NativeDisplayEventReceiver-初始化" class="headerlink" title="2.4 NativeDisplayEventReceiver 初始化"></a>2.4 NativeDisplayEventReceiver 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver::<span class="built_in">NativeDisplayEventReceiver</span>(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, <span class="type">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue, jint vsyncSource) :</span><br><span class="line">        <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="built_in">DisplayEventDispatcher</span>(messageQueue-&gt;<span class="built_in">getLooper</span>(),</span><br><span class="line">                <span class="comment">// 将传入的vsyncSource（0）强制转换为VsyncSource.eVsyncSourceApp</span></span><br><span class="line">                <span class="built_in">static_cast</span>&lt;ISurfaceComposer::VsyncSource&gt;(vsyncSource)),</span><br><span class="line">        <span class="built_in">mReceiverWeakGlobal</span>(env-&gt;<span class="built_in">NewGlobalRef</span>(receiverWeak)),</span><br><span class="line">        <span class="built_in">mMessageQueue</span>(messageQueue) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Initializing display event receiver.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeDisplayEventReceiver 继承了 DisplayEventDispatcher。</p><h2 id="2-5-DisplayEventDispatcher-初始化"><a href="#2-5-DisplayEventDispatcher-初始化" class="headerlink" title="2.5 DisplayEventDispatcher 初始化"></a>2.5 DisplayEventDispatcher 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventDispatcher::<span class="built_in">DisplayEventDispatcher</span>(<span class="type">const</span> sp&lt;Looper&gt;&amp; looper,</span><br><span class="line">        ISurfaceComposer::VsyncSource vsyncSource) :</span><br><span class="line">        <span class="comment">// 这里的looper是app主线程的looper，mReceiver是我们所寻找的纽带</span></span><br><span class="line">        <span class="built_in">mLooper</span>(looper), <span class="built_in">mReceiver</span>(vsyncSource), <span class="built_in">mWaitingForVsync</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Initializing display event dispatcher.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mReceiver是DisplayEventReceiver类型。</p><h2 id="2-6-DisplayEventReceiver初始化"><a href="#2-6-DisplayEventReceiver初始化" class="headerlink" title="2.6 DisplayEventReceiver初始化"></a>2.6 DisplayEventReceiver初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::<span class="built_in">DisplayEventReceiver</span>(ISurfaceComposer::VsyncSource vsyncSource) &#123;</span><br><span class="line">    <span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sf</span><span class="params">(ComposerService::getComposerService())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// vsyncSource就是VsyncSource.eVsyncSourceApp</span></span><br><span class="line">        <span class="comment">// 2.6.1 通过binder通信，在surfaceFlinger中创建DisplayEventConnection</span></span><br><span class="line">        mEventConnection = sf-&gt;<span class="built_in">createDisplayEventConnection</span>(vsyncSource);</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.7 取出EventThread类中新创建的BitTube的Fd（文件描述符表索引）</span></span><br><span class="line">            mDataChannel = std::<span class="built_in">make_unique</span>&lt;gui::BitTube&gt;();</span><br><span class="line">            mEventConnection-&gt;<span class="built_in">stealReceiveChannel</span>(mDataChannel.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的博文中也分析了，这里的ComposerService就是获取的SurfaceFlinger服务。</p><h3 id="2-6-1-SurfaceFlinger-createDisplayEventConnection"><a href="#2-6-1-SurfaceFlinger-createDisplayEventConnection" class="headerlink" title="2.6.1 SurfaceFlinger.createDisplayEventConnection"></a>2.6.1 SurfaceFlinger.createDisplayEventConnection</h3><p>进入SurfaceFlinger主线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">SurfaceFlinger::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        ISurfaceComposer::VsyncSource vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> resyncCallback = mScheduler-&gt;<span class="built_in">makeResyncCallback</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">        Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 这里的handle为mAppConnectionHandle</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; handle =</span><br><span class="line">            vsyncSource == eVsyncSourceSurfaceFlinger ? mSfConnectionHandle : mAppConnectionHandle;</span><br><span class="line">    <span class="comment">// 2.6.2 创建连接</span></span><br><span class="line">    <span class="keyword">return</span> mScheduler-&gt;<span class="built_in">createDisplayEventConnection</span>(handle, std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-2-Scheduler-cpp-createDisplayEventConnection"><a href="#2-6-2-Scheduler-cpp-createDisplayEventConnection" class="headerlink" title="2.6.2 Scheduler.cpp:createDisplayEventConnection"></a>2.6.2 Scheduler.cpp:createDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;IDisplayEventConnection&gt; <span class="title">Scheduler::createDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;Scheduler::ConnectionHandle&gt;&amp; handle, ResyncCallback resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_VALUE_IF_INVALID</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// mConnections是map类型，key值表示对应的EventThread类型</span></span><br><span class="line">    <span class="comment">// 这个初始化就是在SurfaceFlinger.init方法内，创建EventThread时同步生成的</span></span><br><span class="line">    <span class="comment">// 最终mConnections[handle-&gt;id]-&gt;thread.get()拿到的就是AppEventThread</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">createConnectionInternal</span>(mConnections[handle-&gt;id]-&gt;thread.<span class="built_in">get</span>(),</span><br><span class="line">                                    std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">Scheduler::createConnectionInternal</span><span class="params">(EventThread* eventThread,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                              ResyncCallback&amp;&amp; resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里传入的eventThread就是appEventThread</span></span><br><span class="line">    <span class="keyword">return</span> eventThread-&gt;<span class="built_in">createEventConnection</span>(std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里mConnections[handle-&gt;id]-&gt;thread.get()拿到的是handle对应的EventThread.</p><h3 id="2-6-3-EventThread-createEventConnection"><a href="#2-6-3-EventThread-createEventConnection" class="headerlink" title="2.6.3 EventThread.createEventConnection"></a>2.6.3 EventThread.createEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">EventThreadConnection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), std::<span class="built_in">move</span>(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThreadConnection::<span class="built_in">EventThreadConnection</span>(EventThread* eventThread,</span><br><span class="line">                                             ResyncCallback resyncCallback)</span><br><span class="line">      : <span class="built_in">resyncCallback</span>(std::<span class="built_in">move</span>(resyncCallback)),</span><br><span class="line">        <span class="built_in">mEventThread</span>(eventThread),</span><br><span class="line">        <span class="comment">// 注意这里创建的BitTube管道</span></span><br><span class="line">        <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure><p>创建EventThreadConnection时新建了个BitTube管道，看来就是通信枢纽就是这个了。</p><p>注意到这个类有onFirstRef方法，在生成对象后，就会调用。</p><h3 id="2-6-4-EventThreadConnection-onFirstRef"><a href="#2-6-4-EventThreadConnection-onFirstRef" class="headerlink" title="2.6.4 EventThreadConnection.onFirstRef"></a>2.6.4 EventThreadConnection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThreadConnection::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-5-EventThread-registerDisplayEventConnection"><a href="#2-6-5-EventThread-registerDisplayEventConnection" class="headerlink" title="2.6.5 EventThread.registerDisplayEventConnection"></a>2.6.5 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(<span class="type">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should never happen</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(mDisplayEventConnections.<span class="built_in">cbegin</span>(),</span><br><span class="line">            mDisplayEventConnections.<span class="built_in">cend</span>(), connection);</span><br><span class="line">    <span class="keyword">if</span> (it != mDisplayEventConnections.<span class="built_in">cend</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;DisplayEventConnection %p already exists&quot;</span>, connection.<span class="built_in">get</span>());</span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">        <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有新的连接了，就需要唤醒AppEventThread线程使能Vsync信号了。</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">push_back</span>(connection);</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在注意到我们仅仅是得到了一个BitTube，然而并没有用上这个管道。<br>接下来，回到[2.6 DisplayEventReceiver初始化] 创建DisplayEventReceiver的地方。</p><h2 id="2-7-EventThreadConnection-stealReceiveChannel"><a href="#2-7-EventThreadConnection-stealReceiveChannel" class="headerlink" title="2.7 EventThreadConnection.stealReceiveChannel"></a>2.7 EventThreadConnection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThreadConnection::stealReceiveChannel</span><span class="params">(gui::BitTube* outChannel)</span> </span>&#123;</span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将新建的BitTube的Fd复制给outChannel, 也就是DisplayEventReceiver中的 mDataChannel.<br>虽然还是没有用上这个BitTube，不着急，继续看。</p><h2 id="2-8-BitTube信道连接过程"><a href="#2-8-BitTube信道连接过程" class="headerlink" title="2.8 BitTube信道连接过程"></a>2.8 BitTube信道连接过程</h2><h3 id="2-8-1-DisplayEventDispatcher-initialize"><a href="#2-8-1-DisplayEventDispatcher-initialize" class="headerlink" title="2.8.1 DisplayEventDispatcher.initialize"></a>2.8.1 DisplayEventDispatcher.initialize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DisplayEventDispatcher::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的mReceiver 就是DisplayEventReceiver</span></span><br><span class="line">    <span class="comment">// 这一步就是确认BitTube创建无误</span></span><br><span class="line">    <span class="type">status_t</span> result = mReceiver.<span class="built_in">initCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to initialize display event receiver, status=%d&quot;</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个mLooper就是应用app进程的主线程Looper，所以这一步就是将</span></span><br><span class="line">    <span class="comment">// 创建的BitTube信道Fd添加到Looper中</span></span><br><span class="line">    <span class="type">int</span> rc = mLooper-&gt;<span class="built_in">addFd</span>(mReceiver.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个DisplayEventDispatcher是继承了LooperCallback, 所以这里的this方法就是handleEvent。</p><p>到这里这里整个Vsync流程已经跑通：</p><ol><li>SurfaceFlinger主线程收到硬件Vsync, 经过误差修正, 通知给DispSyncThread线程</li><li>DispSyncThread线程计算各个EventThread的SW Vsync信号时间并及时发出</li><li>AppEventThread收到sw Vsync信号，遍历各个Connection，调用sendEvent向对应BitTube管道发送事件</li><li>App进程的主线程收到事件，并处理</li></ol><p>接下来我们就看app收到sw vsync信号的处理过程。</p><h1 id="三-App进程收到SW-VSYNC信号"><a href="#三-App进程收到SW-VSYNC信号" class="headerlink" title="三. App进程收到SW VSYNC信号"></a>三. App进程收到SW VSYNC信号</h1><h2 id="3-1-DisplayEventDispatcher-handleEvent"><a href="#3-1-DisplayEventDispatcher-handleEvent" class="headerlink" title="3.1 DisplayEventDispatcher.handleEvent"></a>3.1 DisplayEventDispatcher.handleEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisplayEventDispatcher::handleEvent</span><span class="params">(<span class="type">int</span>, <span class="type">int</span> events, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    PhysicalDisplayId vsyncDisplayId;</span><br><span class="line">    <span class="type">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="comment">// 3.1.1 读取BitTube管道中的数据，返回值为true表示读取到了数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">processPendingEvents</span>(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3.2 分发收到的sw vsync信号</span></span><br><span class="line">        <span class="built_in">dispatchVsync</span>(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-DisplayEventDispatcher-processPendingEvents"><a href="#3-1-1-DisplayEventDispatcher-processPendingEvents" class="headerlink" title="3.1.1 DisplayEventDispatcher.processPendingEvents"></a>3.1.1 DisplayEventDispatcher.processPendingEvents</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DisplayEventDispatcher::processPendingEvents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">nsecs_t</span>* outTimestamp, PhysicalDisplayId* outDisplayId, <span class="type">uint32_t</span>* outCount)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="comment">// 读取管道中的所有数据</span></span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.<span class="built_in">getEvents</span>(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;dispatcher %p ~ Read %d events.&quot;</span>, <span class="keyword">this</span>, <span class="built_in">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// 拿到最新的sw vsync信号时间</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outDisplayId = ev.header.displayId;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                <span class="built_in">dispatchHotplug</span>(ev.header.timestamp, ev.header.displayId, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_CONFIG_CHANGED:</span><br><span class="line">                <span class="built_in">dispatchConfigChanged</span>(ev.header.timestamp, ev.header.displayId, ev.config.configId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;dispatcher %p ~ ignoring unknown event type %#x&quot;</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Failed to get events from display event dispatcher, status=%d&quot;</span>, <span class="built_in">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-NativeDisplayEventReceiver-dispatchVsync"><a href="#3-2-NativeDisplayEventReceiver-dispatchVsync" class="headerlink" title="3.2 NativeDisplayEventReceiver.dispatchVsync"></a>3.2 NativeDisplayEventReceiver.dispatchVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="type">nsecs_t</span> timestamp, PhysicalDisplayId displayId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::<span class="built_in">getJNIEnv</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, jniGetReferent(env, mReceiverWeakGlobal))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Invoking vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">        env-&gt;<span class="built_in">CallVoidMethod</span>(receiverObj.<span class="built_in">get</span>(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, displayId, count);</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;receiver %p ~ Returned from vsync handler.&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;<span class="built_in">raiseAndClearException</span>(env, <span class="string">&quot;dispatchVsync&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JNI回调到java层的DisplayEventReceiver.dispatchVsync方法</p><h2 id="3-3-DisplayEventReceiver-dispatchVsync"><a href="#3-3-DisplayEventReceiver-dispatchVsync" class="headerlink" title="3.3 DisplayEventReceiver.dispatchVsync"></a>3.3 DisplayEventReceiver.dispatchVsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dispatchVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    onVsync(timestampNanos, physicalDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考2.2中，这里的DisplayEventReceiver 对象就是其子类FrameDisplayEventReceiver的对象。</p><h2 id="3-4-FrameDisplayEventReceiver-onVsync"><a href="#3-4-FrameDisplayEventReceiver-onVsync" class="headerlink" title="3.4 FrameDisplayEventReceiver.onVsync"></a>3.4 FrameDisplayEventReceiver.onVsync</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onVsync</span><span class="params">(<span class="type">long</span> timestampNanos, <span class="type">long</span> physicalDisplayId, <span class="type">int</span> frame)</span> &#123;</span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Frame time is &quot;</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">                + <span class="string">&quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span></span><br><span class="line">                + <span class="string">&quot;timestamps using the correct timebase.&quot;</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;Already have a pending vsync event.  There should only be &quot;</span></span><br><span class="line">                + <span class="string">&quot;one at a time.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    <span class="comment">// mHandler就是mFrameHandler，传入runnable立刻执行，也就是执行run里面的</span></span><br><span class="line">    <span class="comment">// doFrame方法。</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain(mHandler, <span class="built_in">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    mHavePendingVsync = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 进入Choreographer的绘图，接下来就是measure,layout,draw的过程了、</span></span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的VSYNC流程图如下：</p><p><img src="/images/SurfaceFlinger-3-AppEventThread%E6%8E%A5%E5%8F%97vsync%E4%BF%A1%E5%8F%B7/Vsync.jpg" alt="图片"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li><li><a href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li><li><a href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h1&gt;&lt;p&gt;前面我们分析了SF EventThread接收到 sw vsync信号后的处理流程，以及SurfaceFlinger是如何通过DispSyncThread将HW Vsync转成sw vsync的流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(2)--DispSync</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-2-DispSync/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-2-DispSync/</id>
    <published>2022-04-04T01:52:26.000Z</published>
    <updated>2022-04-04T02:28:38.138Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><h1 id="一-DispSync"><a href="#一-DispSync" class="headerlink" title="一. DispSync"></a>一. DispSync</h1><p>DispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。</p><p>接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。<br>我们先看DispSync线程的创建过程。</p><span id="more"></span><h1 id="二-DispSync初始化"><a href="#二-DispSync初始化" class="headerlink" title="二. DispSync初始化"></a>二. DispSync初始化</h1><h2 id="2-1-SurfaceFlinger"><a href="#2-1-SurfaceFlinger" class="headerlink" title="2.1 SurfaceFlinger"></a>2.1 SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFligner</span>(SurfaceFlinger::SkipInitializationTag)</span><br><span class="line">        :   <span class="built_in">BnSurfaceComposer</span>(),</span><br><span class="line">            <span class="built_in">mTransactionFlags</span>(<span class="number">0</span>),</span><br><span class="line">            ......</span><br><span class="line">            <span class="built_in">mPrimaryDispSync</span>(<span class="string">&quot;PrimaryDispSync&quot;</span>),</span><br><span class="line">            <span class="built_in">mPrimaryHWVsyncEnabled</span>(<span class="literal">false</span>),</span><br><span class="line">            ......</span><br><span class="line">            &#123;&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger初始化的时候创建的。</p><h2 id="2-2-DispSync创建"><a href="#2-2-DispSync创建" class="headerlink" title="2.2 DispSync创建"></a>2.2 DispSync创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DispSync::<span class="built_in">DispSync</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">      : <span class="built_in">mName</span>(name), <span class="built_in">mRefreshSkipCount</span>(<span class="number">0</span>), <span class="built_in">mThread</span>(<span class="keyword">new</span> <span class="built_in">DispSyncThread</span>(name)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">DispSyncThread</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function">        : mName(name),</span></span><br><span class="line"><span class="function">        mStop(false),</span></span><br><span class="line"><span class="function">        mPeriod(<span class="number">0</span>), // 注意这里的mPeriod初始化为<span class="number">0</span></span></span><br><span class="line"><span class="function">        mPhase(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mReferenceTime(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mWakeupLatency(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        mFrameNumber(<span class="number">0</span>) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-SurfaceFlinger-SurfaceFlinger"><a href="#2-3-SurfaceFlinger-SurfaceFlinger" class="headerlink" title="2.3 SurfaceFlinger::SurfaceFlinger"></a>2.3 SurfaceFlinger::SurfaceFlinger</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::<span class="built_in">SurfaceFlinger</span>() : <span class="built_in">SurfaceFlinger</span>(SkipInitialization) &#123;</span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;SurfaceFlinger is starting&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    mPrimaryDispSync.<span class="built_in">init</span>(SurfaceFlinger::hasSyncFramework, </span><br><span class="line">            SurfaceFlinger::dispSyncPresentTimeOffset);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-DispSync-init"><a href="#2-4-DispSync-init" class="headerlink" title="2.4 DispSync.init"></a>2.4 DispSync.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::init</span><span class="params">(<span class="type">bool</span> hasSyncFramework, <span class="type">int64_t</span> dispSyncPresentTimeOffset)</span> </span>&#123;</span><br><span class="line">    mIgnorePresentFences = !hasSyncFramework;</span><br><span class="line">    mPresentTimeOffset = dispSyncPresentTimeOffset;</span><br><span class="line">    <span class="comment">// 线程改名为 DispSync，调整线程优先级</span></span><br><span class="line">    mThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;DispSync&quot;</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set DispSync to SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sched_setscheduler</span>(mThread-&gt;<span class="built_in">getTid</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for DispSyncThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">beginResync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">        <span class="comment">// If we&#x27;re not getting present fences then the ZeroPhaseTracer</span></span><br><span class="line">        <span class="comment">// would prevent HW vsync event from ever being turned off.</span></span><br><span class="line">        <span class="comment">// Even if we&#x27;re just ignoring the fences, the zero-phase tracing is</span></span><br><span class="line">        <span class="comment">// not needed because any time there is an event registered we will</span></span><br><span class="line">        <span class="comment">// turn on the HW vsync events.</span></span><br><span class="line">        <span class="keyword">if</span> (!mIgnorePresentFences &amp;&amp; kEnableZeroPhaseTracer) &#123;</span><br><span class="line">            mZeroPhaseTracer = std::<span class="built_in">make_unique</span>&lt;ZeroPhaseTracer&gt;();</span><br><span class="line">            <span class="built_in">addEventListener</span>(<span class="string">&quot;ZeroPhaseTracer&quot;</span>, <span class="number">0</span>, mZeroPhaseTracer.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-1-DispSyncThread-threadLoop"><a href="#2-4-1-DispSyncThread-threadLoop" class="headerlink" title="2.4.1 DispSyncThread.threadLoop"></a>2.4.1 DispSyncThread.threadLoop</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="comment">// 获取开机到现在的时长</span></span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于此时mPeriod为0，所以会进入该分支一直等待。</span></span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三-enableVysncLocked后续"><a href="#三-enableVysncLocked后续" class="headerlink" title="三. enableVysncLocked后续"></a>三. enableVysncLocked后续</h1><p>SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked</p><h2 id="3-1-DispSync-addEventListener"><a href="#3-1-DispSync-addEventListener" class="headerlink" title="3.1 DispSync.addEventListener"></a>3.1 DispSync.addEventListener</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t DispSync::addEventListener(const char* name, nsecs_t phase, Callback* callback) &#123;</span><br><span class="line">    Mutex::Autolock lock(mMutex);</span><br><span class="line">    return mThread-&gt;addEventListener(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-DispSync-DispSyncThread-addEventListener"><a href="#3-2-DispSync-DispSyncThread-addEventListener" class="headerlink" title="3.2 DispSync.DispSyncThread.addEventListener"></a>3.2 DispSync.DispSyncThread.addEventListener</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, DispSync::Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mEventListeners[i].mCallback == callback) &#123;</span><br><span class="line">            <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventListener listener;</span><br><span class="line">    listener.mName = name;</span><br><span class="line">    listener.mPhase = phase;</span><br><span class="line">    listener.mCallback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to allow the firstmost future event to fire without</span></span><br><span class="line">    <span class="comment">// allowing any past events to fire</span></span><br><span class="line">    listener.mLastEventTime = <span class="built_in">systemTime</span>() - mPeriod / <span class="number">2</span> + mPhase - mWakeupLatency;</span><br><span class="line"></span><br><span class="line">    mEventListeners.<span class="built_in">push</span>(listener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// threadLooper可以继续执行了</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里还是运行在SurfaceFlinger主线程，在mCond.signal之后，DispSync线程就可以继续执行了。<br>但是注意看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的continue意味着如果mPeriod为0，还是会一直等待。</p><h1 id="四-setPeriod"><a href="#四-setPeriod" class="headerlink" title="四. setPeriod"></a>四. setPeriod</h1><p>这样我们就需要看mPeriod是什么时候被更改的。<br>在SurfaceFlinger初始化Display后，会调用resyncToHardwareVsync跟硬件vsync进行同步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initializeDisplays();</span><br><span class="line">    flinger-&gt;onInitializeDisplays();</span><br><span class="line">        setPowerModeInternal()</span><br><span class="line">            resyncToHardwareVsync(true);</span><br><span class="line">                repaintEverything();</span><br></pre></td></tr></table></figure><h2 id="4-1-SurfaceFlinger-resyncToHardwareVsync"><a href="#4-1-SurfaceFlinger-resyncToHardwareVsync" class="headerlink" title="4.1 SurfaceFlinger.resyncToHardwareVsync"></a>4.1 SurfaceFlinger.resyncToHardwareVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable)</span> </span>&#123;</span><br><span class="line">    Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">        <span class="comment">// mHWVsyncAvailable 表示 HW vsync 被 enable</span></span><br><span class="line">        mHWVsyncAvailable = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">        <span class="comment">// Hardware vsync is not currently available, so abort the resync</span></span><br><span class="line">        <span class="comment">// attempt for now</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得显示设备的刷新率，比如60HZ, 那么period就是16.6667ms,即每隔16.6667就会产生一个硬件vsync信号</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; activeConfig = <span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">getActiveConfig</span>(HWC_DISPLAY_PRIMARY);</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = activeConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是设置DispSync线程中的period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="comment">// 4.2 设置period</span></span><br><span class="line">    mPrimaryDispSync.<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mPrimaryHWVsyncEnabled表示当前的硬件vsync是否enable,</span></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        mPrimaryDispSync.<span class="built_in">beginResync</span>();</span><br><span class="line">        <span class="comment">// 如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC</span></span><br><span class="line">        <span class="comment">// 这个和DispSync的setVsyncEnabled是不一样的</span></span><br><span class="line">        <span class="comment">// 5.1 硬件Vsync控制</span></span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-DispSync-setPeriod"><a href="#4-2-DispSync-setPeriod" class="headerlink" title="4.2 DispSync.setPeriod"></a>4.2 DispSync.setPeriod</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::setPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = <span class="number">0</span>;</span><br><span class="line">    mReferenceTime = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Ignore recompute as mReferenceTime is zero.</span></span><br><span class="line">    <span class="comment">// mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mPeriod表示具体的硬件产生vsync的时间间隔。这样，之后的DispSync线程中的threadLoop就可以继续执行了。</p><h1 id="五-硬件Vsync的开关控制"><a href="#五-硬件Vsync的开关控制" class="headerlink" title="五. 硬件Vsync的开关控制"></a>五. 硬件Vsync的开关控制</h1><p>接上面 4.1，当设置DispSync的mPeriod之后，如果硬件Vsync开关是开启状态，则会通过EventControlThread打开HW Vsync<br>我们先看看EventControlThread线程的启动，其启动在SurfaceFlinger的初始化，EventThread启动之后，显示屏初始化之前。</p><h2 id="5-1-EventControlThread的启动"><a href="#5-1-EventControlThread的启动" class="headerlink" title="5.1 EventControlThread的启动"></a>5.1 EventControlThread的启动</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = std::<span class="built_in">make_unique</span>&lt;impl::EventControlThread&gt;(</span><br><span class="line">            [<span class="keyword">this</span>](<span class="type">bool</span> enabled) &#123; <span class="built_in">setVsyncEnabled</span>(HWC_DISPLAY_PRIMARY, enabled); &#125;);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化时传入了函数 setVsyncEnabled。</p><p>注意EventControlThread中线程的初始化是在成员变量中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be last so that everything is initialized before the thread starts.</span></span><br><span class="line">std::thread mThread&#123;&amp;EventControlThread::threadMain, <span class="keyword">this</span>&#125;;</span><br></pre></td></tr></table></figure><p>所以先调用threadMain，后调用构造函数。</p><h3 id="5-1-1-EventControlThread-threadMain"><a href="#5-1-1-EventControlThread-threadMain" class="headerlink" title="5.1.1 EventControlThread.threadMain"></a>5.1.1 EventControlThread.threadMain</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unfortunately std::unique_lock gives warnings with -Wthread-safety</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> keepRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> currentVsyncEnabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (keepRunning) &#123;</span><br><span class="line">        <span class="comment">// 5.3 此时currentVsyncEnabled为false</span></span><br><span class="line">        <span class="built_in">mSetVSyncEnabled</span>(currentVsyncEnabled);</span><br><span class="line"></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">// 在这里等待</span></span><br><span class="line">        mCondition.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, currentVsyncEnabled, keepRunning]() NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">            <span class="keyword">return</span> currentVsyncEnabled != mVsyncEnabled || keepRunning != mKeepRunning;</span><br><span class="line">        &#125;);</span><br><span class="line">        currentVsyncEnabled = mVsyncEnabled;</span><br><span class="line">        keepRunning = mKeepRunning;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-EventControlThread初始化"><a href="#5-1-2-EventControlThread初始化" class="headerlink" title="5.1.2 EventControlThread初始化"></a>5.1.2 EventControlThread初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventControlThread::<span class="built_in">EventControlThread</span>(EventControlThread::SetVSyncEnabledFunction function)</span><br><span class="line">      : <span class="built_in">mSetVSyncEnabled</span>(function) &#123;</span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), <span class="string">&quot;EventControlThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line">    <span class="built_in">setpriority</span>(PRIO_PROCESS, tid, ANDROID_PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数里面设置了线程名和优先级</p><h2 id="5-2-EventControlThread-setVsyncEnabled"><a href="#5-2-EventControlThread-setVsyncEnabled" class="headerlink" title="5.2 EventControlThread.setVsyncEnabled"></a>5.2 EventControlThread.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventControlThread::setVsyncEnabled</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mVsyncEnabled = enabled;</span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mVsyncEnabled设置为true, 表明开启硬件Vsync.<br>mCondition.notify_all() 则通知EventControlThread线程继续执行，回到5.1.1的循环内。<br>mSetVSyncEnabled是传入的函数SurfaceFlinger.setVsyncEnabled.</p><h2 id="5-3-SurfaceFlinger-setVsyncEnabled"><a href="#5-3-SurfaceFlinger-setVsyncEnabled" class="headerlink" title="5.3 SurfaceFlinger.setVsyncEnabled"></a>5.3 SurfaceFlinger.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setVsyncEnabled</span><span class="params">(<span class="type">int</span> disp, <span class="type">int</span> enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="built_in">getHwComposer</span>().<span class="built_in">setVsyncEnabled</span>(disp,</span><br><span class="line">            enabled ? HWC2::Vsync::Enable : HWC2::Vsync::Disable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HWComposer&amp; <span class="title">getHwComposer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">getBE</span>().mHwc; &#125;</span><br><span class="line"><span class="function">SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br></pre></td></tr></table></figure><p>这里的disp &#x3D; HWC_DISPLAY_PRIMARY</p><h2 id="5-4-HWComposer-setVsyncEnabled"><a href="#5-4-HWComposer-setVsyncEnabled" class="headerlink" title="5.4 HWComposer.setVsyncEnabled"></a>5.4 HWComposer.setVsyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::setVsyncEnabled</span><span class="params">(DisplayId displayId, HWC2::Vsync enabled)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_INVALID_DISPLAY</span>(displayId);</span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayData.isVirtual) &#123;</span><br><span class="line">        <span class="built_in">LOG_DISPLAY_ERROR</span>(displayId, <span class="string">&quot;Invalid operation on virtual display&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we use our own internal lock here because we have to call</span></span><br><span class="line">    <span class="comment">// into the HWC with the lock held, and we want to make sure</span></span><br><span class="line">    <span class="comment">// that even if HWC blocks (which it shouldn&#x27;t), it won&#x27;t</span></span><br><span class="line">    <span class="comment">// affect other threads.</span></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(displayData.vsyncEnabledLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enabled == displayData.vsyncEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">auto</span> error = displayData.hwcDisplay-&gt;<span class="built_in">setVsyncEnabled</span>(enabled);</span><br><span class="line">    <span class="built_in">RETURN_IF_HWC_ERROR</span>(error, displayId);</span><br><span class="line"></span><br><span class="line">    displayData.vsyncEnabled = enabled;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> tag = <span class="string">&quot;HW_VSYNC_ON_&quot;</span> + <span class="built_in">to_string</span>(displayId);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(tag.<span class="built_in">c_str</span>(), enabled == HWC2::Vsync::Enable ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六-硬件Vsync信号更新"><a href="#六-硬件Vsync信号更新" class="headerlink" title="六. 硬件Vsync信号更新"></a>六. 硬件Vsync信号更新</h1><p>经过HWComposer使能硬件Vsync信号后，只要有硬件Vsync信号产生，就可回调 hook_vsync函数。<br>hook_vsync函数在HWComposer的初始化的时候被注册的。</p><h2 id="6-1-HWC初始化"><a href="#6-1-HWC初始化" class="headerlink" title="6.1 HWC初始化"></a>6.1 HWC初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ......</span><br><span class="line">    // 获取硬件HWC</span><br><span class="line">    getBE().mHwc.reset(</span><br><span class="line">            new HWComposer(std::make_unique&lt;Hwc2::impl::Composer&gt;(getBE().mHwcServiceName)));</span><br><span class="line">    // 注册回调</span><br><span class="line">    getBE().mHwc-&gt;registerCallback(this, getBE().mComposerSequenceId);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里这里先创建的是 Hwc2::impl::Composer,然后创建HWComposer</p><h3 id="6-1-1-ComposerHal-cpp-Composer"><a href="#6-1-1-ComposerHal-cpp-Composer" class="headerlink" title="6.1.1 ComposerHal.cpp:Composer"></a>6.1.1 ComposerHal.cpp:Composer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Composer::<span class="built_in">Composer</span>(<span class="type">const</span> std::string&amp; serviceName)</span><br><span class="line">    : <span class="built_in">mWriter</span>(kWriterInitialSize),</span><br><span class="line">      <span class="built_in">mIsUsingVrComposer</span>(serviceName == std::<span class="built_in">string</span>(<span class="string">&quot;vr&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    mComposer = V2_1::IComposer::<span class="built_in">getService</span>(serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mComposer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to get hwcomposer service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mComposer-&gt;<span class="built_in">createClient</span>(</span><br><span class="line">            [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="type">const</span> <span class="keyword">auto</span>&amp; tmpClient)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmpError == Error::NONE) &#123;</span><br><span class="line">                    mClient = tmpClient;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (mClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create composer client&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 support is optional</span></span><br><span class="line">    sp&lt;IComposer&gt; composer_2_2 = IComposer::<span class="built_in">castFrom</span>(mComposer);</span><br><span class="line">    <span class="keyword">if</span> (composer_2_2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        mClient_2_2 = IComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mClient_2_2 == <span class="literal">nullptr</span>, <span class="string">&quot;IComposer 2.2 did not return IComposerClient 2.2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsUsingVrComposer) &#123;</span><br><span class="line">        sp&lt;IVrComposerClient&gt; vrClient = IVrComposerClient::<span class="built_in">castFrom</span>(mClient);</span><br><span class="line">        <span class="keyword">if</span> (vrClient == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;failed to create vr composer client&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取composer服务。</p><h3 id="6-1-2-HWComposer创建"><a href="#6-1-2-HWComposer创建" class="headerlink" title="6.1.2 HWComposer创建"></a>6.1.2 HWComposer创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::<span class="built_in">HWComposer</span>(std::unique_ptr&lt;android::Hwc2::Composer&gt; composer)</span><br><span class="line">      : <span class="built_in">mHwcDevice</span>(std::<span class="built_in">make_unique</span>&lt;HWC2::Device&gt;(std::<span class="built_in">move</span>(composer))) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-注册回调HWComposer-registerCallback"><a href="#6-2-注册回调HWComposer-registerCallback" class="headerlink" title="6.2 注册回调HWComposer.registerCallback"></a>6.2 注册回调HWComposer.registerCallback</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HWComposer::registerCallback</span><span class="params">(HWC2::ComposerCallback* callback,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    mHwcDevice-&gt;<span class="built_in">registerCallback</span>(callback, sequenceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Device::registerCallback</span><span class="params">(ComposerCallback* callback, <span class="type">int32_t</span> sequenceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRegisteredCallback) &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Callback already registered. Ignored extra registration &quot;</span></span><br><span class="line">                <span class="string">&quot;attempt.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRegisteredCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">sp&lt;ComposerCallbackBridge&gt; <span class="title">callbackBridge</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> ComposerCallbackBridge(callback, sequenceId))</span></span>;</span><br><span class="line">    mComposer-&gt;<span class="built_in">registerCallback</span>(callbackBridge);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Composer::registerCallback</span><span class="params">(<span class="type">const</span> sp&lt;IComposerCallback&gt;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// mClient就是composer服务在SurfaceFlinger中的客户端</span></span><br><span class="line">    <span class="keyword">auto</span> ret = mClient-&gt;<span class="built_in">registerCallback</span>(callback);</span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">isOk</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;failed to register IComposerCallback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComposerCallbackBridge类就是实现onHotplug, onVsync等回调。<br>当HWC硬件产生vsync信号时，就会回调onVsync方法。</p><h2 id="6-3-Vsync信号更新"><a href="#6-3-Vsync信号更新" class="headerlink" title="6.3 Vsync信号更新"></a>6.3 Vsync信号更新</h2><h3 id="6-3-1-ComposerCallbackBridge-onVsync"><a href="#6-3-1-ComposerCallbackBridge-onVsync" class="headerlink" title="6.3.1 ComposerCallbackBridge.onVsync"></a>6.3.1 ComposerCallbackBridge.onVsync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Return&lt;<span class="type">void</span>&gt; <span class="title">onVsync</span><span class="params">(Hwc2::Display display, <span class="type">int64_t</span> timestamp)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mCallback-&gt;<span class="built_in">onVsyncReceived</span>(mSequenceId, display, timestamp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Void</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mCallback就是SurfaceFlinger[6.1].</p><h3 id="6-3-2-SurfaceFlinger-onVsyncReceived"><a href="#6-3-2-SurfaceFlinger-onVsyncReceived" class="headerlink" title="6.3.2 SurfaceFlinger.onVsyncReceived"></a>6.3.2 SurfaceFlinger.onVsyncReceived</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::onVsyncReceived</span><span class="params">(<span class="type">int32_t</span> sequenceId,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">hwc2_display_t</span> displayId, <span class="type">int64_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="comment">// Ignore any vsyncs from a previous hardware composer.</span></span><br><span class="line">    <span class="keyword">if</span> (sequenceId != <span class="built_in">getBE</span>().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> type;</span><br><span class="line">    <span class="comment">// 按条件决定是否过滤，记录此次HWC接收到的硬件Vsync</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getBE</span>().mHwc-&gt;<span class="built_in">onVsync</span>(displayId, timestamp, &amp;type)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="comment">// DISPLAY_PRIMARY为0，mPrimaryHWVsyncEnabled为true</span></span><br><span class="line">        <span class="keyword">if</span> (type == DisplayDevice::DISPLAY_PRIMARY &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.<span class="built_in">addResyncSample</span>(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        <span class="built_in">enableHardwareVsync</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">disableHardwareVsync</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-3-DispSync-addResyncSample"><a href="#6-3-3-DispSync-addResyncSample" class="headerlink" title="6.3.3 DispSync.addResyncSample"></a>6.3.3 DispSync.addResyncSample</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DispSync::addResyncSample</span><span class="params">(<span class="type">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample(%&quot;</span> PRId64 <span class="string">&quot;)&quot;</span>, mName, <span class="built_in">ns2us</span>(timestamp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MAX_RESYNC_SAMPLES = 32，即最大只保存32次硬件vsync时间戳，用来计算SW vsync模型.</span></span><br><span class="line">    <span class="comment">// mNumResyncSamples 表示已经有多少个硬件vsync 样本了 ，最多记录MAX_RESYNC_SAMPLES</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="type">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    mResyncSamples[idx] = timestamp;</span><br><span class="line">    <span class="comment">// 第一次收到Vsync信号，直接更新</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples == <span class="number">0</span>) &#123;</span><br><span class="line">        mPhase = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 参考时间设置为第一个硬件vsync的时间戳</span></span><br><span class="line">        mReferenceTime = timestamp;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] First resync sample: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = 0, &quot;</span></span><br><span class="line">              <span class="string">&quot;mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">              mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">        <span class="comment">// 6.3.5 通知更新DispSync线程收到Vsync信号</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新 mNumResyncSamples 或 mFirstResyncSample的值</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123;</span><br><span class="line">        mNumResyncSamples++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFirstResyncSample = (mFirstResyncSample + <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.3.4 开始计算更新SW vsync 模型</span></span><br><span class="line">    <span class="built_in">updateModelLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamplesSincePresent++ &gt; MAX_RESYNC_SAMPLES_WITHOUT_PRESENT) &#123;</span><br><span class="line">        <span class="built_in">resetErrorLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIgnorePresentFences) &#123;</span><br><span class="line">        <span class="comment">// If we don&#x27;t have the sync framework we will never have</span></span><br><span class="line">        <span class="comment">// addPresentFence called.  This means we have no way to know whether</span></span><br><span class="line">        <span class="comment">// or not we&#x27;re synchronized with the HW vsyncs, so we just request</span></span><br><span class="line">        <span class="comment">// that the HW vsync events be turned on whenever we need to generate</span></span><br><span class="line">        <span class="comment">// SW vsync events.</span></span><br><span class="line">        <span class="keyword">return</span> mThread-&gt;<span class="built_in">hasAnyEventListeners</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against kErrorThreshold / 2 to add some hysteresis before having to</span></span><br><span class="line">    <span class="comment">// resync again</span></span><br><span class="line">    <span class="type">bool</span> modelLocked = mModelUpdated &amp;&amp; mError &lt; (kErrorThreshold / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] addResyncSample returning %s&quot;</span>, mName, modelLocked ? <span class="string">&quot;locked&quot;</span> : <span class="string">&quot;unlocked&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !modelLocked;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是收到硬件Vsync信号, 在SurfaceFlinger主线程执行，在经过误差更正后，通知DispSync线程处理分发事件。</p><h3 id="6-3-4-DispSync-updateModelLocked"><a href="#6-3-4-DispSync-updateModelLocked" class="headerlink" title="6.3.4 DispSync.updateModelLocked"></a>6.3.4 DispSync.updateModelLocked</h3><p>这一步是计算模型参数如偏移、硬件Vsync更新间隔等。在分析前，我们先了解下几个重要参数的含义：</p><table><thead><tr><th>参数名</th><th>默认值</th><th>含义</th></tr></thead><tbody><tr><td>mNumResyncSamples</td><td>-</td><td>当前保存的硬件Vsyc信号数量，最大值为32</td></tr><tr><td>MIN_RESYNC_SAMPLES_FOR_UPDATE</td><td>6</td><td>更新模型参数的最小硬件Vsync数量</td></tr><tr><td>mPeriod</td><td>-</td><td>硬件刷新率，根据保存的Vsync去掉最大和最小求得的平均值</td></tr><tr><td>mPhase</td><td>-</td><td>偏移时间，仅作为针对mPeriod的一个偏移</td></tr><tr><td>mReferenceTime</td><td>第一个硬件Vsync事件</td><td>每次计算sw vsync模型时的基准时间，以减少误差</td></tr><tr><td>mRefreshSkipCount</td><td>0</td><td>多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSync::updateModelLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModelLocked %zu&quot;</span>, mName, mNumResyncSamples);</span><br><span class="line">    <span class="comment">// MIN_RESYNC_SAMPLES_FOR_UPDATE = 6, 也就是收到6次硬件Vsync之后，开始计算sw vsync模型</span></span><br><span class="line">    <span class="keyword">if</span> (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Computing...&quot;</span>, mName);</span><br><span class="line">        <span class="type">nsecs_t</span> durationSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> minDuration = INT64_MAX;</span><br><span class="line">        <span class="type">nsecs_t</span> maxDuration = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里计算总时长，以及拿到最长和最短的硬件vsync间隔</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">size_t</span> prev = (idx + MAX_RESYNC_SAMPLES - <span class="number">1</span>) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> duration = mResyncSamples[idx] - mResyncSamples[prev];</span><br><span class="line">            durationSum += duration;</span><br><span class="line">            minDuration = <span class="built_in">min</span>(minDuration, duration);</span><br><span class="line">            maxDuration = <span class="built_in">max</span>(maxDuration, duration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算平均间隔，去掉一个最大和一个最小的间隔</span></span><br><span class="line">        durationSum -= minDuration + maxDuration;</span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPeriod = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPeriod));</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> sampleAvgX = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> sampleAvgY = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> scale = <span class="number">2.0</span> * M_PI / <span class="built_in">double</span>(mPeriod);</span><br><span class="line">        <span class="comment">// 跳过第一个Vsync，因为第一个Vsync已经更新到DispSync中了。</span></span><br><span class="line">        <span class="comment">// mReferenceTime是第一个Vsync的时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; mNumResyncSamples; i++) &#123;</span><br><span class="line">            <span class="type">size_t</span> idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;</span><br><span class="line">            <span class="type">nsecs_t</span> sample = mResyncSamples[idx] - mReferenceTime;</span><br><span class="line">            <span class="type">double</span> samplePhase = <span class="built_in">double</span>(sample % mPeriod) * scale;</span><br><span class="line">            sampleAvgX += <span class="built_in">cos</span>(samplePhase);</span><br><span class="line">            sampleAvgY += <span class="built_in">sin</span>(samplePhase);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sampleAvgX /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line">        sampleAvgY /= <span class="built_in">double</span>(mNumResyncSamples - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        mPhase = <span class="built_in">nsecs_t</span>(<span class="built_in">atan2</span>(sampleAvgY, sampleAvgX) / scale);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] mPhase = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        <span class="comment">// 如果偏移值是负值，绝对值超过了mPeroid的一半</span></span><br><span class="line">        <span class="comment">// 则调整偏移值为对应正值</span></span><br><span class="line">        <span class="keyword">if</span> (mPhase &lt; -(mPeriod / <span class="number">2</span>)) &#123;</span><br><span class="line">            mPhase += mPeriod;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Adjusting mPhase -&gt; %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(mPhase));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Period&quot;</span>, mPeriod);</span><br><span class="line">            <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Phase&quot;</span>, mPhase + mPeriod / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mRefreshSkipCount表示多少个vsync才进行刷新，可以通过这个人为的降低显示设备刷新率(软件刷新率)</span></span><br><span class="line">        mPeriod += mPeriod * mRefreshSkipCount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.3.5 更新sw model. 这个方法会唤醒DispSync线程</span></span><br><span class="line">        mThread-&gt;<span class="built_in">updateModel</span>(mPeriod, mPhase, mReferenceTime);</span><br><span class="line">        mModelUpdated = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里算偏移还用上了反三角函数。mPeriod的含义就是圆周长，最终算出来的 mPhase 就是弧BC的长度。<br>也就是基于mPeriod的偏移值，如下图：</p><p><img src="/images/SurfaceFlinger-2-DispSync/2_1.png" alt="图片"></p><p>这个偏移值有什么用处呢？</p><h3 id="6-3-5-DispSync-DispSyncThread-updateModel"><a href="#6-3-5-DispSync-DispSyncThread-updateModel" class="headerlink" title="6.3.5 DispSync.DispSyncThread.updateModel"></a>6.3.5 DispSync.DispSyncThread.updateModel</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateModel</span><span class="params">(<span class="type">nsecs_t</span> period, <span class="type">nsecs_t</span> phase, <span class="type">nsecs_t</span> referenceTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mPeriod = period;</span><br><span class="line">    mPhase = phase;</span><br><span class="line">    mReferenceTime = referenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] updateModel: mPeriod = %&quot;</span> PRId64 <span class="string">&quot;, mPhase = %&quot;</span> PRId64</span><br><span class="line">          <span class="string">&quot; mReferenceTime = %&quot;</span> PRId64,</span><br><span class="line">          mName, <span class="built_in">ns2us</span>(mPeriod), <span class="built_in">ns2us</span>(mPhase), <span class="built_in">ns2us</span>(mReferenceTime));</span><br><span class="line">    <span class="comment">// 这里通知正在等待的DispSync线程开始执行</span></span><br><span class="line">    mCond.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新mPeriod和时间戳。<br>mCond.signal 后转DispSyncThread线程[2.4.1]DispSyncThread.threadLoop继续执行</p><h1 id="七-SW-Vsync更新"><a href="#七-SW-Vsync更新" class="headerlink" title="七. SW Vsync更新"></a>七. SW Vsync更新</h1><p>硬件Vsync信号经过DispSync的简单加工，会将相应的值更新，然后唤醒DispSyncThread线程</p><h2 id="7-1-DispSync-DispSyncThread-threadLoop"><a href="#7-1-DispSync-DispSyncThread-threadLoop" class="headerlink" title="7.1 DispSync.DispSyncThread.threadLoop"></a>7.1 DispSync.DispSyncThread.threadLoop</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    <span class="type">nsecs_t</span> now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line">        <span class="type">nsecs_t</span> targetTime = <span class="number">0</span>;</span><br><span class="line">        &#123; <span class="comment">// Scope for lock</span></span><br><span class="line">            <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:Frame&quot;</span>, mFrameNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Frame %&quot;</span> PRId64, mName, mFrameNumber);</span><br><span class="line">            ++mFrameNumber;</span><br><span class="line">            <span class="keyword">if</span> (mStop) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;</span><br><span class="line">                err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for new events: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2 计算下一个SW Vsync时间点</span></span><br><span class="line">            targetTime = <span class="built_in">computeNextEventTimeLocked</span>(now);</span><br><span class="line">            <span class="type">bool</span> isWakeup = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果计算出来的下一次vsync事件还没有到来，就等时间到了，才发送SW VSYNC信号</span></span><br><span class="line">            <span class="comment">// 可以看出 DispSyncThread的发送的vsync信号和真正硬件发生的vsync信号没有直接的关系，</span></span><br><span class="line">            <span class="comment">// 发送给app/sf的vsync信号都是由 DispSyncThread发送出去的.</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; targetTime) &#123;</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_NAME</span>(<span class="string">&quot;DispSync waiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (targetTime == INT64_MAX) &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting forever&quot;</span>, mName);</span><br><span class="line">                    err = mCond.<span class="built_in">wait</span>(mMutex);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Waiting until %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(targetTime));</span><br><span class="line">                    err = mCond.<span class="built_in">waitRelative</span>(mMutex, targetTime - now);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 等待超时，主动醒来，发送SW Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (err == TIMED_OUT) &#123;</span><br><span class="line">                    isWakeup = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;error waiting for next event: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            now = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算wake up消耗的时间, 但是不能超过1.5 ms</span></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">nsecs_t</span> kMaxWakeupLatency = <span class="built_in">us2ns</span>(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isWakeup) &#123;</span><br><span class="line">                <span class="comment">// 乍一看没明白为什么这么算。仔细想，每次wakeup时间是累加的，这个为了减小抖动？</span></span><br><span class="line">                mWakeupLatency = ((mWakeupLatency * <span class="number">63</span>) + (now - targetTime)) / <span class="number">64</span>;</span><br><span class="line">                mWakeupLatency = <span class="built_in">min</span>(mWakeupLatency, kMaxWakeupLatency);</span><br><span class="line">                <span class="keyword">if</span> (kTraceDetailedInfo) &#123;</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:WakeupLat&quot;</span>, now - targetTime);</span><br><span class="line">                    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;DispSync:AvgWakeupLat&quot;</span>, mWakeupLatency);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 7.3 搜集EventListener回调，一般就两个：SF和App EventThread</span></span><br><span class="line">            <span class="comment">// 并不是所有的wakeup都是等待了sw vsync的targetTime，如果SurfaceFlinger</span></span><br><span class="line">            <span class="comment">// 主线程收到硬件Vsync,也会唤醒此线程，此时isWakeup为false</span></span><br><span class="line">            <span class="comment">// 这里的callbackInvocations集合就为null，只有now&gt;=targetTime才不为null</span></span><br><span class="line">            callbackInvocations = <span class="built_in">gatherCallbackInvocationsLocked</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackInvocations.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fireCallbackInvocations</span>(callbackInvocations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-DispSync-DispSyncThread-computeNextEventTimeLocked"><a href="#7-2-DispSync-DispSyncThread-computeNextEventTimeLocked" class="headerlink" title="7.2 DispSync.DispSyncThread.computeNextEventTimeLocked"></a>7.2 DispSync.DispSyncThread.computeNextEventTimeLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeNextEventTimeLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (kTraceDetailedInfo) <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] computeNextEventTimeLocked&quot;</span>, mName);</span><br><span class="line">    <span class="type">nsecs_t</span> nextEventTime = INT64_MAX;</span><br><span class="line">    <span class="comment">// 对所有的EventListener进行分别计算，里面的mLastEventTime值不同</span></span><br><span class="line">    <span class="comment">// 找出一个最小的Vsync时间，即最近的时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], now);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; nextEventTime) &#123;</span><br><span class="line">            nextEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] nextEventTime = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(nextEventTime));</span><br><span class="line">    <span class="keyword">return</span> nextEventTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的EventListeners里面只有两个，一个是SF EventThread，另一个就是App EventThread.</p><h3 id="7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked"><a href="#7-2-1-DispSync-DispSyncThread-computeListenerNextEventTimeLocked" class="headerlink" title="7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked"></a>7.2.1 DispSync.DispSyncThread.computeListenerNextEventTimeLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nsecs_t</span> <span class="title">computeListenerNextEventTimeLocked</span><span class="params">(<span class="type">const</span> EventListener&amp; listener, <span class="type">nsecs_t</span> baseTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listener.mLasteEventTime就是上次SW VSync的时间点，mWakeupLatency就是上次线程醒来的耗时</span></span><br><span class="line">    <span class="type">nsecs_t</span> lastEventTime = listener.mLastEventTime + mWakeupLatency;</span><br><span class="line">    <span class="comment">// 一般baseTime也就是nowTime, 是大于lasterEventTime，除了第一次进入   </span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; lastEventTime) &#123;</span><br><span class="line">        baseTime = lastEventTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// baseTime减去第一次硬件Vsync的时间，算duration时长</span></span><br><span class="line">    baseTime -= mReferenceTime;</span><br><span class="line">    <span class="comment">// 偏移就是SW Vsync本身的偏移值加上各EventThread本身的偏移</span></span><br><span class="line">    <span class="comment">// sf 使用的是 SF_VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="comment">// APP使用的VSYNC_EVENT_PHASE_OFFSET_NS</span></span><br><span class="line">    <span class="type">nsecs_t</span> phase = mPhase + listener.mPhase;</span><br><span class="line">    <span class="comment">// baseTime也减去偏移</span></span><br><span class="line">    baseTime -= phase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// baseTime小于0，只有第一次进入的时候才会发生。</span></span><br><span class="line">    <span class="comment">// 此时硬件Vsync已经发生了，所以设置baseTime为-mPeriod这样后面算的numPeriod为-1</span></span><br><span class="line">    <span class="keyword">if</span> (baseTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        baseTime = -mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出下一个SW Vsync的时间点</span></span><br><span class="line">    <span class="comment">// 先得到baseTime对应第几个sw Vsync，也就是现在时间点发送了多少个sw Vsync</span></span><br><span class="line">    <span class="type">nsecs_t</span> numPeriods = baseTime / mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numberPeriods+1也就是下一个sw Vysnc，再加上偏移        </span></span><br><span class="line">    <span class="type">nsecs_t</span> t = (numPeriods + <span class="number">1</span>) * mPeriod + phase;</span><br><span class="line">    </span><br><span class="line">    t += mReferenceTime;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%s] Absolute t = %&quot;</span> PRId64, mName, <span class="built_in">ns2us</span>(t));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个vsync距离上一个vsync时间小于3/5个mPeriod的话，</span></span><br><span class="line">    <span class="comment">// 为了避免连续的两个sw vsync, 那么这次sw vsync就放弃了，直接放到下一个周期里</span></span><br><span class="line">    <span class="keyword">if</span> (t - listener.mLastEventTime &lt; (<span class="number">3</span> * mPeriod / <span class="number">5</span>)) &#123;</span><br><span class="line">        t += mPeriod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算出来的时间减掉wakeup累积时间，最大1.5ms</span></span><br><span class="line">    t -= mWakeupLatency;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="/images/SurfaceFlinger-2-DispSync/2_2.png" alt="图片"></p><p>看到这里就有一个疑问，sw vsync信号是在DispSyncThread收到第一个硬件Vsync更新sw model后就可以不依赖<br>硬件Vsync信号了，后续可以自己产生。那为什么google没有在这里disable硬件Vsync呢，因为sw vsync还是有误差<br>并不能与硬件Vsync完全保持一致，所以需要updateModelLocked持续消减误差。<br>重新梳理一下完整流程：</p><ol><li>SurfaceFlinger主线程收到硬件Vsync</li><li>DispSync.updateModelLocked及时更新sw model，并通知DispSyncThread线程</li><li>DispSyncThread线程更新mPeriod，mPhase等参数通过computeNextEventTimeLocked计算新的targetTime</li><li>继续等待直到新的targetTime，通知SF EventThread或者AppEventThread有sw vsync信号</li></ol><p>我们知道SF EventThread和App EventThread是有间隔的，并不同步，这里是如何实现的呢？<br>注意我们计算出来的targetTime是sf和app中最近的一次，那么继续看往下看。</p><h2 id="7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked"><a href="#7-3-DispSync-DispSyncThread-gatherCallbackInvocationsLocked" class="headerlink" title="7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked"></a>7.3 DispSync.DispSyncThread.gatherCallbackInvocationsLocked</h2><p>now是当前应该被触发的sw vsync时间点，可能是sf vsync也可能是app vsync。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;CallbackInvocation&gt; <span class="title">gatherCallbackInvocationsLocked</span><span class="params">(<span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里为什么是拿一个vsync周期前的时间点呢？</span></span><br><span class="line">    <span class="type">nsecs_t</span> onePeriodAgo = now - mPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算各个EventListener(也就是sf 和app EventThread)的对应的下一次vsync时间.</span></span><br><span class="line">    <span class="comment">// 因为对于时间点now来讲，sf 和 app的下一次vsync时间可能尚未到来。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">nsecs_t</span> t = <span class="built_in">computeListenerNextEventTimeLocked</span>(mEventListeners[i], onePeriodAgo);</span><br><span class="line">        <span class="comment">// 如果下一次vsync时间尚未到达，这一次就不通知给对应EventListener</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;</span><br><span class="line">            CallbackInvocation ci;</span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;</span><br><span class="line">            ci.mEventTime = t;</span><br><span class="line">            callbackInvocations.<span class="built_in">push</span>(ci);</span><br><span class="line">            <span class="comment">// 记录本次sw Vsync时间点</span></span><br><span class="line">            mEventListeners.<span class="built_in">editItemAt</span>(i).mLastEventTime = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完这个方法，其实不难理解，DispSyncThread中的targetTime是变化的值，有可能是app EventThread的下一次sw vsync时间，也可能是sf的。如下图：</p><p><img src="/images/SurfaceFlinger-2-DispSync/2_3.png" alt="图片"></p><p>到这里，sw vsync的流程基本梳理完毕了。</p><p>接下来继续看EventThread.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li><li><a href="http://echuang54.blogspot.com/2015/01/dispsync.html">DispSync</a></li><li><a href="http://tinylab.org/android-dispsync/#dispsync-%E6%98%AF%E4%BB%80%E4%B9%88">DispSync详解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-DispSync&quot;&gt;&lt;a href=&quot;#一-DispSync&quot; class=&quot;headerlink&quot; title=&quot;一. DispSync&quot;&gt;&lt;/a&gt;一. DispSync&lt;/h1&gt;&lt;p&gt;DispSyncThread, 软件产生vsync的线程, 也控制硬件VSync信号同步。&lt;/p&gt;
&lt;p&gt;接上一篇，SF EventThread在显示屏准备完毕后，会调用enableVSyncLocked，最终是在DispSync的mEventListeners中添加了一个EventListener。&lt;br&gt;我们先看DispSync线程的创建过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>SurfaceFlinger(1)--SFEventThread</title>
    <link href="https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-1-SFEventThread/"/>
    <id>https://swallowjoe.github.io/2022/04/04/SurfaceFlinger-1-SFEventThread/</id>
    <published>2022-04-04T01:52:04.000Z</published>
    <updated>2022-04-04T02:28:02.020Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><p><strong>Andorid Q</strong></p><h1 id="一-SFEventThread"><a href="#一-SFEventThread" class="headerlink" title="一. SFEventThread"></a>一. SFEventThread</h1><ol><li>EventControlThread: 控制硬件vsync的开关</li><li>DispSyncThread: 软件产生vsync的线程</li><li>SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染</li><li>App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图</li></ol><p>从这4个线程，可以将vsync分为4种不同的类型</p><ol><li>HW vsync, 真实由硬件产生的vsync信号</li><li>SW vsync, 由DispSync产生的vsync信号</li><li>SF vsync,  SF接收到的vsync信号</li><li>App vsync, App接收到的vsync信号</li></ol><p>这里我们着重看看SF EventThread.</p><span id="more"></span><h2 id="1-1-BitTube"><a href="#1-1-BitTube" class="headerlink" title="1.1 BitTube"></a>1.1 BitTube</h2><p>先大致了解下BitTube，其实现是socketpairt套接字，用于传递消息。<br>Buffer大小是4KB。</p><h1 id="二-EventThread启动"><a href="#二-EventThread启动" class="headerlink" title="二. EventThread启动"></a>二. EventThread启动</h1><h2 id="2-1-SurfaceFlinger-init"><a href="#2-1-SurfaceFlinger-init" class="headerlink" title="2.1 SurfaceFlinger.init"></a>2.1 SurfaceFlinger.init</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    mEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync, SurfaceFlinger::vsyncPhaseOffsetNs,</span><br><span class="line">                                             <span class="literal">true</span>, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">    mEventThread = std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                       [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                       impl::EventThread::<span class="built_in">InterceptVSyncsCallback</span>(),</span><br><span class="line">                                                       <span class="string">&quot;appEventThread&quot;</span>);</span><br><span class="line">    mSfEventThreadSource =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;DispSyncSource&gt;(&amp;mPrimaryDispSync,</span><br><span class="line">                                             SurfaceFlinger::sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">&quot;sf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mSFEventThread =</span><br><span class="line">            std::<span class="built_in">make_unique</span>&lt;impl::EventThread&gt;(mSfEventThreadSource.<span class="built_in">get</span>(),</span><br><span class="line">                                                [<span class="keyword">this</span>]() &#123; <span class="built_in">resyncWithRateLimit</span>(); &#125;,</span><br><span class="line">                                                [<span class="keyword">this</span>](<span class="type">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                                                    mInterceptor-&gt;<span class="built_in">saveVSyncEvent</span>(timestamp);</span><br><span class="line">                                                &#125;,</span><br><span class="line">                                                <span class="string">&quot;sfEventThread&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意传入的偏移是不同的。</p><ol><li>app EventThread : vsyncPhaseOffsetNs &#x3D; 2000000ns</li><li>sf EventThread : sfVsyncPhaseOffsetNs &#x3D; 6000000ns</li></ol><p>这个值是编译期间固定的，定义在BoardConfig.mk中</p><h2 id="2-2-EventThread初始化"><a href="#2-2-EventThread初始化" class="headerlink" title="2.2 EventThread初始化"></a>2.2 EventThread初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">EventThread::<span class="built_in">EventThread</span>(VSyncSource* src, ResyncWithRateLimitCallback resyncWithRateLimitCallback,</span><br><span class="line">                         InterceptVSyncsCallback interceptVSyncsCallback, <span class="type">const</span> <span class="type">char</span>* threadName)</span><br><span class="line">      : <span class="built_in">mVSyncSource</span>(src),</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>(resyncWithRateLimitCallback),</span><br><span class="line">        <span class="built_in">mInterceptVSyncsCallback</span>(interceptVSyncsCallback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; event : mVSyncEvent) &#123;</span><br><span class="line">        event.header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        event.header.id = <span class="number">0</span>;</span><br><span class="line">        event.header.timestamp = <span class="number">0</span>;</span><br><span class="line">        event.vsync.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定thread函数</span></span><br><span class="line">    mThread = std::<span class="built_in">thread</span>(&amp;EventThread::threadMain, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置thread名称</span></span><br><span class="line">    <span class="built_in">pthread_setname_np</span>(mThread.<span class="built_in">native_handle</span>(), threadName);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = <span class="built_in">pthread_gettid_np</span>(mThread.<span class="built_in">native_handle</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use SCHED_FIFO to minimize jitter</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> EVENT_THREAD_PRIORITY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_param</span> param = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = EVENT_THREAD_PRIORITY;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_setschedparam</span>(mThread.<span class="built_in">native_handle</span>(), SCHED_FIFO, &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Couldn&#x27;t set SCHED_FIFO for EventThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_sched_policy</span>(tid, SP_FOREGROUND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-EventThread-threadMain"><a href="#2-3-EventThread-threadMain" class="headerlink" title="2.3 EventThread.threadMain"></a>2.3 EventThread.threadMain</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::threadMain</span><span class="params">()</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (mKeepRunning) &#123;</span><br><span class="line">        DisplayEventReceiver::Event event;</span><br><span class="line">        Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">        <span class="comment">// 2.4 阻塞等待事件</span></span><br><span class="line">        signalConnections = <span class="built_in">waitForEventLocked</span>(&amp;lock, &amp;event);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分发事件给connection</span></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> count = signalConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="function"><span class="type">const</span> sp&lt;Connection&gt;&amp; <span class="title">conn</span><span class="params">(signalConnections[i])</span></span>;</span><br><span class="line">            <span class="comment">// 2.5 分发事件</span></span><br><span class="line">            <span class="type">status_t</span> err = conn-&gt;<span class="built_in">postEvent</span>(event);</span><br><span class="line">            <span class="keyword">if</span> (err == -EAGAIN || err == -EWOULDBLOCK) &#123;</span><br><span class="line">                <span class="comment">// The destination doesn&#x27;t accept events anymore, it&#x27;s probably</span></span><br><span class="line">                <span class="comment">// full. For now, we just drop the events on the floor.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> Note that some events cannot be dropped and would have</span></span><br><span class="line">                <span class="comment">// to be re-sent later.</span></span><br><span class="line">                <span class="comment">// Right-now we don&#x27;t have the ability to do this.</span></span><br><span class="line">                <span class="comment">//ALOGW(&quot;EventThread: dropping event (%08x) for connection %p&quot;, event.header.type,</span></span><br><span class="line">                <span class="comment">//      conn.get());</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// handle any other error on the pipe as fatal. the only</span></span><br><span class="line">                <span class="comment">// reasonable thing to do is to clean-up this connection.</span></span><br><span class="line">                <span class="comment">// The most common error we&#x27;ll get here is -EPIPE.</span></span><br><span class="line">                <span class="built_in">removeDisplayEventConnectionLocked</span>(signalConnections[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-EventThread-waitForEventLocked"><a href="#2-4-EventThread-waitForEventLocked" class="headerlink" title="2.4 EventThread.waitForEventLocked"></a>2.4 EventThread.waitForEventLocked</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This will return when (1) a vsync event has been received, and (2) there was</span></span><br><span class="line"><span class="comment">// at least one connection interested in receiving it when we started waiting.</span></span><br><span class="line">Vector&lt;sp&lt;EventThread::Connection&gt; &gt; EventThread::<span class="built_in">waitForEventLocked</span>(</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt;* lock, DisplayEventReceiver::Event* event) &#123;</span><br><span class="line">    Vector&lt;sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (signalConnections.<span class="built_in">isEmpty</span>() &amp;&amp; mKeepRunning) &#123;</span><br><span class="line">        <span class="type">bool</span> eventPending = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> waitForVSync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">size_t</span> vsyncCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">nsecs_t</span> timestamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES; i++) &#123;</span><br><span class="line">            timestamp = mVSyncEvent[i].header.timestamp;</span><br><span class="line">            <span class="keyword">if</span> (timestamp) &#123;</span><br><span class="line">                <span class="comment">// 当timestamp不为0时，说明有事件发生</span></span><br><span class="line">                <span class="keyword">if</span> (mInterceptVSyncsCallback) &#123;</span><br><span class="line">                    <span class="built_in">mInterceptVSyncsCallback</span>(timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">                *event = mVSyncEvent[i];</span><br><span class="line">                <span class="comment">// 置timestamp为0，标记为当前事件被消费</span></span><br><span class="line">                mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">                vsyncCount = mVSyncEvent[i].vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mDisplayEventConnections保存的是注册的Connection的,</span></span><br><span class="line">        <span class="comment">// SF EventThread线程里只有一个Connection, 而这个Connection主要是用来渲染</span></span><br><span class="line">        <span class="comment">// 而如果是APP EventThread, 这里会有多个connection</span></span><br><span class="line">        <span class="type">size_t</span> count = mDisplayEventConnections.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; count) &#123;</span><br><span class="line">            <span class="comment">// 没有vsync事件， 来看下是否有其它pending的event, 这里主要是hotplug的事件</span></span><br><span class="line">            eventPending = !mPendingEvents.<span class="built_in">isEmpty</span>();</span><br><span class="line">            <span class="keyword">if</span> (eventPending) &#123;</span><br><span class="line">                <span class="comment">// we have some other event to dispatch</span></span><br><span class="line">                *event = mPendingEvents[<span class="number">0</span>];</span><br><span class="line">                mPendingEvents.<span class="built_in">removeAt</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; count;) &#123;</span><br><span class="line">            <span class="function">sp&lt;Connection&gt; <span class="title">connection</span><span class="params">(mDisplayEventConnections[i].promote())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="type">bool</span> added = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// Connection-&gt;count的值大小含义如下：</span></span><br><span class="line">                <span class="comment">// 1. &gt;=1:  表示持续接收Vsync信号</span></span><br><span class="line">                <span class="comment">// 2. ==0:  只接收一次Vsync信号</span></span><br><span class="line">                <span class="comment">// 3. ==-1: 不接收Vsync信号</span></span><br><span class="line">                <span class="keyword">if</span> (connection-&gt;count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果有 connection-&gt;count &gt;= 0，说明需要Vsync信号</span></span><br><span class="line">                    waitForVSync = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timestamp) &#123; <span class="comment">// 大于0.说明有事件</span></span><br><span class="line">                        <span class="comment">// 处理本次事件</span></span><br><span class="line">                        <span class="keyword">if</span> (connection-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// fired this time around</span></span><br><span class="line">                            connection-&gt;count = <span class="number">-1</span>;</span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection-&gt;count == <span class="number">1</span> ||</span><br><span class="line">                                   (vsyncCount % connection-&gt;count) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// continuous event, and time to report it</span></span><br><span class="line">                            signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                            added = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (eventPending &amp;&amp; !timestamp &amp;&amp; !added) &#123;</span><br><span class="line">                    <span class="comment">// we don&#x27;t have a vsync event to process</span></span><br><span class="line">                    <span class="comment">// (timestamp==0), but we have some pending</span></span><br><span class="line">                    <span class="comment">// messages.</span></span><br><span class="line">                    signalConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// we couldn&#x27;t promote this reference, the connection has</span></span><br><span class="line">                <span class="comment">// died, so clean-up!</span></span><br><span class="line">                mDisplayEventConnections.<span class="built_in">removeAt</span>(i);</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here we figure out if we need to enable or disable vsyncs</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &amp;&amp; !waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 收到Vsync信号，但是没有Connection监听，所以关闭Vsync</span></span><br><span class="line">            <span class="built_in">disableVSyncLocked</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timestamp &amp;&amp; waitForVSync) &#123;</span><br><span class="line">            <span class="comment">// 有Connection监听，但是还没有Vsync信号，所以打开Vsync</span></span><br><span class="line">            <span class="built_in">enableVSyncLocked</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有事件发生</span></span><br><span class="line">        <span class="keyword">if</span> (!timestamp &amp;&amp; !eventPending) &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitForVSync) &#123; <span class="comment">// 如果有connection监听，则需要等待Vsync事件</span></span><br><span class="line">                <span class="comment">// 以防止硬件Driver出问题，设置一个超时时间16ms</span></span><br><span class="line">                <span class="type">bool</span> softwareSync = mUseSoftwareVSync;</span><br><span class="line">                <span class="keyword">auto</span> timeout = softwareSync ? <span class="number">16</span>ms : <span class="number">1000</span>ms;</span><br><span class="line">                <span class="keyword">if</span> (mCondition.<span class="built_in">wait_for</span>(*lock, timeout) == std::cv_status::timeout) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!softwareSync) &#123;</span><br><span class="line">                        <span class="built_in">ALOGW</span>(<span class="string">&quot;Timed out waiting for hw vsync; faking it&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> how do we decide which display id the fake</span></span><br><span class="line">                    <span class="comment">// vsync came from ?</span></span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.id = DisplayDevice::DISPLAY_PRIMARY;</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].header.timestamp = <span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">                    mVSyncEvent[<span class="number">0</span>].vsync.count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有connection监听，也没有收到事件，则一直等待</span></span><br><span class="line">                mCondition.<span class="built_in">wait</span>(*lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here we&#x27;re guaranteed to have a timestamp and some connections to signal</span></span><br><span class="line">    <span class="comment">// (The connections might have dropped out of mDisplayEventConnections</span></span><br><span class="line">    <span class="comment">// while we were asleep, but we&#x27;ll still have strong references to them.)</span></span><br><span class="line">    <span class="keyword">return</span> signalConnections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当EventThread初始化进入时，由于没有Connection，timestamp也为0，直接进入waitForEventLocked一直等待。</p><h2 id="2-5-EventThread-Connection-postEvent"><a href="#2-5-EventThread-Connection-postEvent" class="headerlink" title="2.5 EventThread.Connection.postEvent"></a>2.5 EventThread.Connection.postEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">postEvent</span>(<span class="type">const</span> DisplayEventReceiver::Event&amp; event) &#123;</span><br><span class="line">    <span class="type">ssize_t</span> size = DisplayEventReceiver::<span class="built_in">sendEvents</span>(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="built_in">status_t</span>(size) : <span class="built_in">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过BitTube发送事件。</p><h1 id="三-SF-EventThread-添加Connection"><a href="#三-SF-EventThread-添加Connection" class="headerlink" title="三. SF EventThread 添加Connection"></a>三. SF EventThread 添加Connection</h1><h2 id="3-1-SurfaceFlinger-init"><a href="#3-1-SurfaceFlinger-init" class="headerlink" title="3.1 SurfaceFlinger.init"></a>3.1 SurfaceFlinger.init</h2><p>sfEventThread添加Connection是在这个线程启动后就添加的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// mEventQueue就是MessageQueue类的对象</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">setEventThread</span>(mSFEventThread.<span class="built_in">get</span>());</span><br><span class="line">    mVsyncModulator.<span class="built_in">setEventThreads</span>(mSFEventThread.<span class="built_in">get</span>(), mEventThread.<span class="built_in">get</span>());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-MessageQueue-setEventThread"><a href="#3-2-MessageQueue-setEventThread" class="headerlink" title="3.2 MessageQueue.setEventThread"></a>3.2 MessageQueue.setEventThread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(android::EventThread* eventThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventThread == eventThread) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEventTube.<span class="built_in">getFd</span>() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;<span class="built_in">removeFd</span>(mEventTube.<span class="built_in">getFd</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    <span class="comment">// 3.3 创建Connection</span></span><br><span class="line">    mEvents = eventThread-&gt;<span class="built_in">createEventConnection</span>();</span><br><span class="line">    <span class="comment">// 3.4 建立BitTube连接</span></span><br><span class="line">    mEvents-&gt;<span class="built_in">stealReceiveChannel</span>(&amp;mEventTube);</span><br><span class="line">    <span class="comment">// 3.5 接受BitTube事件，调用cb_eventReceiver方法</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">addFd</span>(mEventTube.<span class="built_in">getFd</span>(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-EventThread-createEventConnection"><a href="#3-3-EventThread-createEventConnection" class="headerlink" title="3.3 EventThread.createEventConnection"></a>3.3 EventThread.createEventConnection</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;BnDisplayEventConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Connection</span>(<span class="built_in">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventThread::Connection::<span class="built_in">Connection</span>(EventThread* eventThread)</span><br><span class="line">      <span class="comment">// 注意这里的count是被赋值为-1，也就是不接收Vsync事件</span></span><br><span class="line">      : <span class="built_in">count</span>(<span class="number">-1</span>), <span class="built_in">mEventThread</span>(eventThread), <span class="built_in">mChannel</span>(gui::BitTube::DefaultSize) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-1-EventThread-Connection-onFirstRef"><a href="#3-3-1-EventThread-Connection-onFirstRef" class="headerlink" title="3.3.1 EventThread.Connection.onFirstRef"></a>3.3.1 EventThread.Connection.onFirstRef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> EventThread::Connection::<span class="built_in">onFirstRef</span>() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn&#x27;t hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;<span class="built_in">registerDisplayEventConnection</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Connection对象生成之后，就被注册到其对应的EventThread中</p><h3 id="3-3-2-EventThread-registerDisplayEventConnection"><a href="#3-3-2-EventThread-registerDisplayEventConnection" class="headerlink" title="3.3.2 EventThread.registerDisplayEventConnection"></a>3.3.2 EventThread.registerDisplayEventConnection</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="comment">// 添加到mDisplayEventConnections集合中</span></span><br><span class="line">    mDisplayEventConnections.<span class="built_in">add</span>(connection);</span><br><span class="line">    <span class="comment">// waitForEventLocked 可以继续执行了。</span></span><br><span class="line">    mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册connection后，waitForEventLocked便可以开始继续执行了。但是由于只有这一个connection，而且这个connection.count 还是 -1，所以最后还是会在waitForEventLocked中一直等待Vsync事件</p><h2 id="3-4-EventThread-Connection-stealReceiveChannel"><a href="#3-4-EventThread-Connection-stealReceiveChannel" class="headerlink" title="3.4  EventThread.Connection.stealReceiveChannel"></a>3.4  EventThread.Connection.stealReceiveChannel</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> EventThread::Connection::<span class="built_in">stealReceiveChannel</span>(gui::BitTube* outChannel) &#123;</span><br><span class="line">    <span class="comment">// 将Connection的mChannel复制</span></span><br><span class="line">    outChannel-&gt;<span class="built_in">setReceiveFd</span>(mChannel.<span class="built_in">moveReceiveFd</span>());</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-SF-EventThread-connection开始监听Vsync信号"><a href="#3-5-SF-EventThread-connection开始监听Vsync信号" class="headerlink" title="3.5 SF EventThread connection开始监听Vsync信号"></a>3.5 SF EventThread connection开始监听Vsync信号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SurfaceFlinger::initializeDisplays</span><br><span class="line">    SurfaceFlinger::onInitializeDisplays</span><br><span class="line">        SurfaceFlinger::setTransactionState</span><br><span class="line">            SurfaceFlinger::setTransactionFlags</span><br><span class="line">                SurfaceFlinger::signalTransaction</span><br><span class="line">                    MessageQueue::invalidate</span><br><span class="line">                        EventThread::Connection::requestNextVsync</span><br><span class="line">                            EventThread::requestNextVsync</span><br></pre></td></tr></table></figure><p>也就是说当显示屏准备完毕，sfEventThread就可以开始监听Vsync信号了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="type">const</span> sp&lt;EventThread::Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mResyncWithRateLimitCallback) &#123;</span><br><span class="line">        <span class="built_in">mResyncWithRateLimitCallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>; <span class="comment">// 只接受一次Vsync信号</span></span><br><span class="line">        mCondition.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-MessageQueue-cb-eventReceiver-处理Vsync信号"><a href="#3-6-MessageQueue-cb-eventReceiver-处理Vsync信号" class="headerlink" title="3.6 MessageQueue.cb_eventReceiver 处理Vsync信号"></a>3.6 MessageQueue.cb_eventReceiver 处理Vsync信号</h2><p>当SF EventThread收到Vsync信号时，最终会通过BitTube发送给对应connection的receiver[2.5]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, <span class="type">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* queue = <span class="built_in">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> queue-&gt;<span class="built_in">eventReceiver</span>(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="type">int</span> <span class="comment">/*fd*/</span>, <span class="type">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::<span class="built_in">getEvents</span>(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                mHandler-&gt;<span class="built_in">dispatchInvalidate</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-1-MessageQueue-Handler-dispatchInvalidate"><a href="#3-6-1-MessageQueue-Handler-dispatchInvalidate" class="headerlink" title="3.6.1 MessageQueue.Handler.dispatchInvalidate"></a>3.6.1 MessageQueue.Handler.dispatchInvalidate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">dispatchInvalidate</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">android_atomic_or</span>(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;<span class="built_in">sendMessage</span>(<span class="keyword">this</span>, <span class="built_in">Message</span>(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> MessageQueue::Handler::<span class="built_in">handleMessage</span>(<span class="type">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            <span class="built_in">android_atomic_and</span>(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;<span class="built_in">onMessageReceived</span>(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到SufaceFlinger主线程中处理了。</p><h1 id="四-开启硬件Vsync"><a href="#四-开启硬件Vsync" class="headerlink" title="四. 开启硬件Vsync"></a>四. 开启硬件Vsync</h1><h2 id="4-1-EventThread-enableVSyncLocked"><a href="#4-1-EventThread-enableVSyncLocked" class="headerlink" title="4.1 EventThread.enableVSyncLocked"></a>4.1 EventThread.enableVSyncLocked</h2><p>当显示屏准备完毕后，SF EventThread请求一次Vsync信号。那么走到waitForEventLocked中，会调用enableVSyncLocked方法开启硬件Vsync信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventThread::enableVSyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mUseSoftwareVSync) &#123; </span><br><span class="line">        <span class="comment">// mUseSoftwareVSync也就是显示屏power状态</span></span><br><span class="line">        <span class="comment">// 灭屏为true，亮屏置为false</span></span><br><span class="line">        <span class="keyword">if</span> (!mVsyncEnabled) &#123;</span><br><span class="line">            mVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setCallback</span>(<span class="keyword">this</span>);</span><br><span class="line">            mVSyncSource-&gt;<span class="built_in">setVSyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mDebugVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-DispSyncSource-setVSyncEnabled"><a href="#4-2-DispSyncSource-setVSyncEnabled" class="headerlink" title="4.2 DispSyncSource.setVSyncEnabled"></a>4.2 DispSyncSource.setVSyncEnabled</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSyncSource::setVSyncEnabled</span><span class="params">(<span class="type">bool</span> enable)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mVsyncMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">addEventListener</span>(mName, mPhaseOffset,</span><br><span class="line">                                                   <span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                   mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error registering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 1);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">status_t</span> err = mDispSync-&gt;<span class="built_in">removeEventListener</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>),</span><br><span class="line">                                                      &amp;mLastCallbackTime);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;error unregistering vsync callback: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ATRACE_INT(mVsyncOnLabel.c_str(), 0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启Vsync信号就是添加EventListener，关闭就是将这个listener移除</p><h2 id="4-3-DispSync-addEventListener"><a href="#4-3-DispSync-addEventListener" class="headerlink" title="4.3 DispSync.addEventListener"></a>4.3 DispSync.addEventListener</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">DispSync::addEventListener</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">nsecs_t</span> phase, Callback* callback)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> mThread-&gt;<span class="built_in">addEventListener</span>(name, phase, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是到了DispSync部分了。</p><p>大致流程如下：</p><p><img src="/images/SurfaceFlinger-1-SFEventThread/1_1.png" alt="图片"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/d3e4b1805c92">Android SurfaceFlinger SW Vsync模型</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Andorid Q&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;一-SFEventThread&quot;&gt;&lt;a href=&quot;#一-SFEventThread&quot; class=&quot;headerlink&quot; title=&quot;一. SFEventThread&quot;&gt;&lt;/a&gt;一. SFEventThread&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;EventControlThread: 控制硬件vsync的开关&lt;/li&gt;
&lt;li&gt;DispSyncThread: 软件产生vsync的线程&lt;/li&gt;
&lt;li&gt;SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染&lt;/li&gt;
&lt;li&gt;App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始画图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这4个线程，可以将vsync分为4种不同的类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HW vsync, 真实由硬件产生的vsync信号&lt;/li&gt;
&lt;li&gt;SW vsync, 由DispSync产生的vsync信号&lt;/li&gt;
&lt;li&gt;SF vsync,  SF接收到的vsync信号&lt;/li&gt;
&lt;li&gt;App vsync, App接收到的vsync信号&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们着重看看SF EventThread.&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/categories/Android/SurfaceFlinger/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
    <category term="SurfaceFlinger" scheme="https://swallowjoe.github.io/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>App申请帧率(4)--SF切换帧率</title>
    <link href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/"/>
    <id>https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-4-SF%E5%88%87%E6%8D%A2%E5%B8%A7%E7%8E%87/</id>
    <published>2022-02-26T19:54:03.000Z</published>
    <updated>2022-02-26T20:00:41.253Z</updated>
    
    <content type="html"><![CDATA[<p>以下分析基于Android R.</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。</p><p>接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。</p><span id="more"></span><h1 id="一-SurfaceFlinger接受帧率变化"><a href="#一-SurfaceFlinger接受帧率变化" class="headerlink" title="一. SurfaceFlinger接受帧率变化"></a>一. SurfaceFlinger接受帧率变化</h1><p>接上一章，从 SurfaceFlinger::setDesiredActiveConfig 开始. </p><p>这里的ActiveConfigInfo就是SurfaceFlinger根据Framework传入的帧率范围以及各个Layer投票计算的最终帧率信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ActiveConfigInfo</span> &#123;</span><br><span class="line">        HwcConfigIndexType configId;</span><br><span class="line">        Scheduler::ConfigEvent event = Scheduler::ConfigEvent::None;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ActiveConfigInfo&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> configId != other.configId || event != other.event;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="1-1-SurfaceFlinger-setDesiredActiveConfig"><a href="#1-1-SurfaceFlinger-setDesiredActiveConfig" class="headerlink" title="1.1 SurfaceFlinger.setDesiredActiveConfig"></a>1.1 SurfaceFlinger.setDesiredActiveConfig</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setDesiredActiveConfig</span><span class="params">(<span class="type">const</span> ActiveConfigInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate = mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(info.configId);</span><br><span class="line">    mVsyncPeriod = refreshRate.<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;setDesiredActiveConfig(%s)&quot;</span>, refreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mActiveConfigLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mDesiredActiveConfigChanged) &#123;</span><br><span class="line">        <span class="comment">// 如果帧率切换正在发生，缓存此次帧率切换</span></span><br><span class="line">        <span class="type">const</span> Scheduler::ConfigEvent prevConfig = mDesiredActiveConfig.event;</span><br><span class="line">        mDesiredActiveConfig = info;</span><br><span class="line">        mDesiredActiveConfig.event = mDesiredActiveConfig.event | prevConfig;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前帧率已经是请求的帧率了，直接返回</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">        <span class="keyword">if</span> (!display || display-&gt;<span class="built_in">getActiveConfig</span>() == refreshRate.<span class="built_in">getConfigId</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记正在做帧率切换</span></span><br><span class="line">        mDesiredActiveConfigChanged = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 存储即将切换的帧率配置信息</span></span><br><span class="line">        mDesiredActiveConfig = info;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 触发HWC刷新而不重置空闲计时器。</span></span><br><span class="line">        <span class="built_in">repaintEverythingForHWC</span>();</span><br><span class="line">        <span class="comment">// 1.3 现在开始接收vsync样本，这可以检测到硬件周期切换。</span></span><br><span class="line">        mScheduler-&gt;<span class="built_in">resyncToHardwareVsync</span>(<span class="literal">true</span>, refreshRate.<span class="built_in">getVsyncPeriod</span>());</span><br><span class="line">        <span class="comment">// 1.4 调用onRefreshRateChangeCompleted, 通知更新偏移量</span></span><br><span class="line">        mVSyncModulator-&gt;<span class="built_in">onRefreshRateChangeInitiated</span>();</span><br><span class="line">        <span class="comment">// 保存即将更新的Fps</span></span><br><span class="line">        mPhaseConfiguration-&gt;<span class="built_in">setRefreshRateFps</span>(refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line">        <span class="comment">// 1.5 再次更新偏移量, 不过这一次是根据即将更新的Fps拿到的固定偏移量</span></span><br><span class="line">        mVSyncModulator-&gt;<span class="built_in">setPhaseOffsets</span>(mPhaseConfiguration-&gt;<span class="built_in">getCurrentOffsets</span>());</span><br><span class="line">        mScheduler-&gt;<span class="built_in">setConfigChangePending</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRefreshRateOverlay) &#123;</span><br><span class="line">        mRefreshRateOverlay-&gt;<span class="built_in">changeRefreshRate</span>(refreshRate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-SurfaceFlinger-repaintEverythingForHWC"><a href="#1-2-SurfaceFlinger-repaintEverythingForHWC" class="headerlink" title="1.2 SurfaceFlinger.repaintEverythingForHWC"></a>1.2 SurfaceFlinger.repaintEverythingForHWC</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::repaintEverythingForHWC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记全部重绘制</span></span><br><span class="line">    mRepaintEverything = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 通知Power模组, Display将更新，OEM厂商自行实现这个标准接口</span></span><br><span class="line">    mPowerAdvisor.<span class="built_in">notifyDisplayUpdateImminent</span>();</span><br><span class="line">    <span class="comment">// EventThread请求下一帧Vsync</span></span><br><span class="line">    mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-Scheduler-resyncToHardwareVsync"><a href="#1-3-Scheduler-resyncToHardwareVsync" class="headerlink" title="1.3 Scheduler.resyncToHardwareVsync"></a>1.3 Scheduler.resyncToHardwareVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scheduler::resyncToHardwareVsync</span><span class="params">(<span class="type">bool</span> makeAvailable, <span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (makeAvailable) &#123;</span><br><span class="line">            mHWVsyncAvailable = makeAvailable;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mHWVsyncAvailable) &#123;</span><br><span class="line">            <span class="comment">// 硬件Vsync被禁止，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 参数不合法</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知到软件Vsync产生模块，更新Vsync周期</span></span><br><span class="line">    <span class="built_in">setVsyncPeriod</span>(period);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-1-Scheduler-setVsyncPeriod"><a href="#1-3-1-Scheduler-setVsyncPeriod" class="headerlink" title="1.3.1 Scheduler.setVsyncPeriod"></a>1.3.1 Scheduler.setVsyncPeriod</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scheduler::setVsyncPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mHWVsyncLock)</span></span>;</span><br><span class="line">    <span class="comment">// 1.3.2 更新软件Vsync周期</span></span><br><span class="line">    mPrimaryDispSync-&gt;<span class="built_in">setPeriod</span>(period);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">        <span class="comment">// 硬件Vsync关闭的情况下, 直接更改软件vsync周期，这里我们加上是开启的</span></span><br><span class="line">        mPrimaryDispSync-&gt;<span class="built_in">beginResync</span>();</span><br><span class="line">        mEventControlThread-&gt;<span class="built_in">setVsyncEnabled</span>(<span class="literal">true</span>);</span><br><span class="line">        mPrimaryHWVsyncEnabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在R上软件Vsync产生更改了架构，由Q上DispSync改成VSyncReactor, 不过原理不变就不分析了, 具体可以参考文章-SurfaceFlinger(2)–DispSync。</p><p>可以通过将属性debug.sf.vsync_reactor置为false后重启，切回Q上的DispSync机制</p><h3 id="1-3-2-VSyncReactor-setPeriod"><a href="#1-3-2-VSyncReactor-setPeriod" class="headerlink" title="1.3.2 VSyncReactor.setPeriod"></a>1.3.2 VSyncReactor.setPeriod</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::setPeriod</span><span class="params">(<span class="type">nsecs_t</span> period)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_INT64</span>(<span class="string">&quot;VSR-setPeriod&quot;</span>, period);</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mLastHwVsync.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mSupportKernelIdleTimer的是由属性控制的，Google源码中默认是true的</span></span><br><span class="line">    <span class="comment">// PRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.surface_flinger.support_kernel_idle_timer=true</span></span><br><span class="line">    <span class="keyword">if</span> (!mSupportKernelIdleTimer &amp;&amp; period == <span class="built_in">getPeriod</span>()) &#123;</span><br><span class="line">        <span class="built_in">endPeriodTransition</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 开始更新</span></span><br><span class="line">        <span class="built_in">startPeriodTransition</span>(period);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-VSyncReactor-startPeriodTransition"><a href="#1-3-3-VSyncReactor-startPeriodTransition" class="headerlink" title="1.3.3 VSyncReactor.startPeriodTransition"></a>1.3.3 VSyncReactor.startPeriodTransition</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::startPeriodTransition</span><span class="params">(<span class="type">nsecs_t</span> newPeriod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记各个变量，并记录待更新的Fps对应一帧的刷新时长</span></span><br><span class="line">    mPeriodConfirmationInProgress = <span class="literal">true</span>;</span><br><span class="line">    mPeriodTransitioningTo = newPeriod;</span><br><span class="line">    mMoreSamplesNeeded = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 忽略当前Fence，其实就是清空mUnfiredFences中的fence</span></span><br><span class="line">    <span class="built_in">setIgnorePresentFencesInternal</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::setIgnorePresentFencesInternal</span><span class="params">(<span class="type">bool</span> ignoration)</span> </span>&#123;</span><br><span class="line">    mInternalIgnoreFences = ignoration;</span><br><span class="line">    <span class="built_in">updateIgnorePresentFencesInternal</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncReactor::updateIgnorePresentFencesInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mExternalIgnoreFences || mInternalIgnoreFences) &#123;</span><br><span class="line">        mUnfiredFences.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-VSyncModulator-onRefreshRateChangeInitiated"><a href="#1-4-VSyncModulator-onRefreshRateChangeInitiated" class="headerlink" title="1.4 VSyncModulator.onRefreshRateChangeInitiated"></a>1.4 VSyncModulator.onRefreshRateChangeInitiated</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::onRefreshRateChangeInitiated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mRefreshRateChangePending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshRateChangePending = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">updateOffsets</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::updateOffsets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="built_in">updateOffsetsLocked</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::updateOffsetsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.4.1 选择偏移量</span></span><br><span class="line">    <span class="type">const</span> Offsets&amp; offsets = <span class="built_in">getNextOffsets</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.2 更新对应的偏移量，这个mPhaseOffsetControl其实就是Scheduler</span></span><br><span class="line">    mPhaseOffsetControl.<span class="built_in">setPhaseOffset</span>(mSfConnectionHandle, offsets.sf);</span><br><span class="line">    mPhaseOffsetControl.<span class="built_in">setPhaseOffset</span>(mAppConnectionHandle, offsets.app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新偏移量</span></span><br><span class="line">    mOffsets = offsets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个trace的debug开关是由属性: debug.sf.vsync_trace_detailed_info 0/1 决定的</span></span><br><span class="line">    <span class="keyword">if</span> (!mTraceDetailedInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isEarly = &amp;offsets == &amp;mOffsetsConfig.early;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isEarlyGl = &amp;offsets == &amp;mOffsetsConfig.earlyGl;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> isLate = &amp;offsets == &amp;mOffsetsConfig.late;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-EarlyOffsetsOn&quot;</span>, isEarly);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-EarlyGLOffsetsOn&quot;</span>, isEarlyGl);</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;Vsync-LateOffsetsOn&quot;</span>, isLate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-1-VSyncModulator-getNextOffsets"><a href="#1-4-1-VSyncModulator-getNextOffsets" class="headerlink" title="1.4.1 VSyncModulator.getNextOffsets"></a>1.4.1 VSyncModulator.getNextOffsets</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> VSyncModulator::Offsets&amp; <span class="title">VSyncModulator::getNextOffsets</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果正在进行刷新率更改，或者最近开始了一个事务，则使用early偏移量。</span></span><br><span class="line">    <span class="keyword">if</span> (mExplicitEarlyWakeup || mTransactionStart == Scheduler::TransactionStart::EarlyEnd ||</span><br><span class="line">        mRemainingEarlyFrameCount &gt; <span class="number">0</span> || mRefreshRateChangePending) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.early;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mRemainingRenderEngineUsageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.earlyGl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mOffsetsConfig.late;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-2-DispSyncSource-setPhaseOffset"><a href="#1-4-2-DispSyncSource-setPhaseOffset" class="headerlink" title="1.4.2 DispSyncSource.setPhaseOffset"></a>1.4.2 DispSyncSource.setPhaseOffset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DispSyncSource::setPhaseOffset</span><span class="params">(<span class="type">nsecs_t</span> phaseOffset)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mVsyncMutex)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> period = mDispSync-&gt;<span class="built_in">getPeriod</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常来讲偏移量在 [-period, period) 之间</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numPeriods = phaseOffset / period;</span><br><span class="line">    phaseOffset -= numPeriods * period;</span><br><span class="line">    <span class="keyword">if</span> (mPhaseOffset == phaseOffset) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPhaseOffset = phaseOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尚未使能，就不需要通知给各个listener</span></span><br><span class="line">    <span class="keyword">if</span> (!mEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.4.3 DispSyncSource是继承了DispSync::Callback的</span></span><br><span class="line">    <span class="type">status_t</span> err =</span><br><span class="line">            mDispSync-&gt;<span class="built_in">changePhaseOffset</span>(<span class="built_in">static_cast</span>&lt;DispSync::Callback*&gt;(<span class="keyword">this</span>), mPhaseOffset);</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;error changing vsync offset: %s (%d)&quot;</span>, <span class="built_in">strerror</span>(-err), err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-VSyncReactor-changePhaseOffset"><a href="#1-4-3-VSyncReactor-changePhaseOffset" class="headerlink" title="1.4.3 VSyncReactor.changePhaseOffset"></a>1.4.3 VSyncReactor.changePhaseOffset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">VSyncReactor::changePhaseOffset</span><span class="params">(DispSync::Callback* callback, <span class="type">nsecs_t</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> it = mCallbacks.<span class="built_in">find</span>(callback);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(it == mCallbacks.<span class="built_in">end</span>(), <span class="string">&quot;callback was %p not registered&quot;</span>, callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用start，更新VSyncDispatchTimerQueue中相关信息</span></span><br><span class="line">    it-&gt;second-&gt;<span class="built_in">start</span>(phase);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-VSyncReactor-CallbackRepeater-start"><a href="#1-4-4-VSyncReactor-CallbackRepeater-start" class="headerlink" title="1.4.4 VSyncReactor.CallbackRepeater.start"></a>1.4.4 VSyncReactor.CallbackRepeater.start</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(<span class="type">nsecs_t</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mStopped = <span class="literal">false</span>;</span><br><span class="line">    mOffset = offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> schedule_result = mRegistration.<span class="built_in">schedule</span>(<span class="built_in">calculateWorkload</span>(), mLastCallTime);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>((schedule_result != ScheduleResult::Scheduled),</span><br><span class="line">                        <span class="string">&quot;Error scheduling callback: rc %X&quot;</span>, schedule_result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-5-VSyncCallbackRegistration-schedule"><a href="#1-4-5-VSyncCallbackRegistration-schedule" class="headerlink" title="1.4.5 VSyncCallbackRegistration.schedule"></a>1.4.5 VSyncCallbackRegistration.schedule</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ScheduleResult <span class="title">VSyncCallbackRegistration::schedule</span><span class="params">(<span class="type">nsecs_t</span> workDuration, <span class="type">nsecs_t</span> earliestVsync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mValidToken) &#123;</span><br><span class="line">        <span class="keyword">return</span> ScheduleResult::Error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDispatch.<span class="built_in">get</span>().<span class="built_in">schedule</span>(mToken, workDuration, earliestVsync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ScheduleResult <span class="title">VSyncDispatchTimerQueue::schedule</span><span class="params">(CallbackToken token, <span class="type">nsecs_t</span> workDuration,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">nsecs_t</span> earliestVsync)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = ScheduleResult::Error;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;<span class="title">decltype</span><span class="params">(mMutex)</span>&gt; <span class="title">lk</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = mCallbacks.<span class="built_in">find</span>(token);</span><br><span class="line">        <span class="keyword">if</span> (it == mCallbacks.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>&amp; callback = it-&gt;second;</span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> now = mTimeKeeper-&gt;<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计时器线程即将运行，通过回调计时器重新计算应用此工作更新，以避免取消即将触发的回调。</span></span><br><span class="line">        <span class="keyword">auto</span> <span class="type">const</span> rearmImminent = now &gt; mIntendedWakeupTime;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CC_UNLIKELY</span>(rearmImminent)) &#123;</span><br><span class="line">            callback-&gt;<span class="built_in">addPendingWorkloadUpdate</span>(workDuration, earliestVsync);</span><br><span class="line">            <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = callback-&gt;<span class="built_in">schedule</span>(workDuration, earliestVsync, mTracker, now);</span><br><span class="line">        <span class="keyword">if</span> (result == ScheduleResult::CannotSchedule) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback-&gt;<span class="built_in">wakeupTime</span>() &lt; mIntendedWakeupTime - mTimerSlack) &#123;</span><br><span class="line">            <span class="built_in">rearmTimerSkippingUpdateFor</span>(now, it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ScheduleResult <span class="title">VSyncDispatchTimerQueueEntry::schedule</span><span class="params">(<span class="type">nsecs_t</span> workDuration, <span class="type">nsecs_t</span> earliestVsync,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      VSyncTracker&amp; tracker, <span class="type">nsecs_t</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> nextVsyncTime =</span><br><span class="line">            tracker.<span class="built_in">nextAnticipatedVSyncTimeFrom</span>(std::<span class="built_in">max</span>(earliestVsync, now + workDuration));</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="type">const</span> wouldSkipAVsyncTarget =</span><br><span class="line">            mArmedInfo &amp;&amp; (nextVsyncTime &gt; (mArmedInfo-&gt;mActualVsyncTime + mMinVsyncDistance));</span><br><span class="line">    <span class="keyword">if</span> (wouldSkipAVsyncTarget) &#123;</span><br><span class="line">        <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="type">const</span> alreadyDispatchedForVsync = mLastDispatchTime &amp;&amp;</span><br><span class="line">            ((*mLastDispatchTime + mMinVsyncDistance) &gt;= nextVsyncTime &amp;&amp;</span><br><span class="line">             (*mLastDispatchTime - mMinVsyncDistance) &lt;= nextVsyncTime);</span><br><span class="line">    <span class="keyword">if</span> (alreadyDispatchedForVsync) &#123;</span><br><span class="line">        nextVsyncTime =</span><br><span class="line">                tracker.<span class="built_in">nextAnticipatedVSyncTimeFrom</span>(*mLastDispatchTime + mMinVsyncDistance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> nextWakeupTime = nextVsyncTime - workDuration;</span><br><span class="line">    mWorkDuration = workDuration;</span><br><span class="line">    mEarliestVsync = earliestVsync;</span><br><span class="line">    mArmedInfo = &#123;nextWakeupTime, nextVsyncTime&#125;;</span><br><span class="line">    <span class="keyword">return</span> ScheduleResult::Scheduled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-VSyncModulator-setPhaseOffsets"><a href="#1-5-VSyncModulator-setPhaseOffsets" class="headerlink" title="1.5 VSyncModulator.setPhaseOffsets"></a>1.5 VSyncModulator.setPhaseOffsets</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VSyncModulator::setPhaseOffsets</span><span class="params">(<span class="type">const</span> OffsetsConfig&amp; config)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    mOffsetsConfig = config;</span><br><span class="line">    <span class="comment">// 见 1.4 流程</span></span><br><span class="line">    <span class="built_in">updateOffsetsLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的OffsetsConfig是通过PhaseOffsets拿到的</p><h3 id="1-5-1-PhaseOffsets-getCurrentOffsets"><a href="#1-5-1-PhaseOffsets-getCurrentOffsets" class="headerlink" title="1.5.1 PhaseOffsets.getCurrentOffsets"></a>1.5.1 PhaseOffsets.getCurrentOffsets</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Offsets <span class="title">getCurrentOffsets</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getOffsetsForRefreshRate</span>(mRefreshRateFps); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PhaseOffsets::Offsets <span class="title">PhaseOffsets::getOffsetsForRefreshRate</span><span class="params">(<span class="type">float</span> fps)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> iter = std::<span class="built_in">find_if</span>(mOffsets.<span class="built_in">begin</span>(), mOffsets.<span class="built_in">end</span>(),</span><br><span class="line">                                   [&amp;fps](<span class="type">const</span> std::pair&lt;<span class="type">float</span>, Offsets&gt;&amp; candidateFps) &#123;</span><br><span class="line">                                       <span class="keyword">return</span> <span class="built_in">fpsEqualsWithMargin</span>(fps, candidateFps.first);</span><br><span class="line">                                   &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter != mOffsets.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unknown refresh rate. This might happen if we get a hotplug event for an external display.</span></span><br><span class="line">    <span class="comment">// In this case just construct the offset.</span></span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;Can&#x27;t find offset for %.2f fps&quot;</span>, fps);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getPhaseOffsets</span>(fps, <span class="built_in">static_cast</span>&lt;<span class="type">nsecs_t</span>&gt;(<span class="number">1e9</span>f / fps));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PhaseOffsets::Offsets <span class="title">PhaseOffsets::getPhaseOffsets</span><span class="params">(<span class="type">float</span> fps, <span class="type">nsecs_t</span> vsyncPeriod)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里根据帧率大小，分两种情况获取偏移量，具体就不看了，和参数配置相关</span></span><br><span class="line">    <span class="keyword">if</span> (fps &gt; <span class="number">65.0f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHighFpsOffsets</span>(vsyncPeriod);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getDefaultOffsets</span>(vsyncPeriod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦吼，到这里setDesiredActiveConfig的流程也算是差不多分析完了，主要做的事情也就下面这些：</p><ol><li>触发HWC刷新而不重置空闲计时器。</li><li>软件Vsync产生模块记录更新的Vsync周期到mPeriodTransitioningTo中，且开始接收硬件vsync，这可以检测到硬件刷新率切换。</li><li>调用onRefreshRateChangeCompleted, 通知更新偏移量</li><li>保存即将更新的Fps到mPhaseConfiguration中</li><li>再次根据即将更新的Fps拿到的固定偏移量更新偏移量</li></ol><h1 id="二-硬件切换帧率"><a href="#二-硬件切换帧率" class="headerlink" title="二. 硬件切换帧率"></a>二. 硬件切换帧率</h1><p>上面的流程跑完后，实际上硬件帧率在哪儿切换还是没有看到，包括mPeriodTransitioningTo是怎么更新到实际软件Vsync中的呢？</p><p>注意到在步骤#1.2中也就是repaintEverythingForHWC会请求下一帧的Vsync，很自然的想法就是实际帧率切换应该是在下一帧到来的时候才开始的。</p><p>我们知道SurfaceFlinger接受到Vsync信号后，会调用onMessageInvalidate（Q上是onMessageReceived）方法开始更新、合成Layer。</p><p>回顾这个方法，很快就可以找到实际vsync切换在这一块代码中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先注意到这个参数默认是false的，也就是说</span></span><br><span class="line"><span class="comment">// 调用setDesiredActiveConfig方法后的第一帧是无法进入该分支的</span></span><br><span class="line"><span class="comment">// 我们先跳过这段代码</span></span><br><span class="line"><span class="keyword">if</span> (mSetActiveConfigPending) &#123;</span><br><span class="line">    <span class="keyword">if</span> (framePending) &#123;</span><br><span class="line">        mEventQueue-&gt;<span class="built_in">invalidate</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从HWC收到了当前的fence，假设它成功地更新了配置，因此更新SF各个状态</span></span><br><span class="line">    mSetActiveConfigPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 2.2 更新SurfaceFlinger的状态，此时HWC是已经更新了帧率</span></span><br><span class="line">    <span class="built_in">ON_MAIN_THREAD</span>(<span class="built_in">setActiveConfigInternal</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="comment">// 因为Layer更新刷新率, 重新来选择刷新率</span></span><br><span class="line">    <span class="comment">// 这里涉及到Layer的VoteType、权限等记录，有兴趣自行研究</span></span><br><span class="line">    mScheduler-&gt;<span class="built_in">chooseRefreshRateForContent</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 更新当前帧率设置</span></span><br><span class="line"><span class="built_in">ON_MAIN_THREAD</span>(<span class="built_in">performSetActiveConfig</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure><h2 id="2-1-SurfaceFlinger-performSetActiveConfig"><a href="#2-1-SurfaceFlinger-performSetActiveConfig" class="headerlink" title="2.1 SurfaceFlinger.performSetActiveConfig"></a>2.1 SurfaceFlinger.performSetActiveConfig</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::performSetActiveConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;performSetActiveConfig&quot;</span>);</span><br><span class="line">    <span class="comment">// 判断mDesiredActiveConfigChanged是否为true，获取变量mDesiredActiveConfig</span></span><br><span class="line">    <span class="comment">// 否则返回nullopt, 说明不需要帧率切换</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> desiredActiveConfig = <span class="built_in">getDesiredActiveConfig</span>();</span><br><span class="line">    <span class="keyword">if</span> (!desiredActiveConfig) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在需要切换的帧率配置(mDesiredActiveConfig)，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(desiredActiveConfig-&gt;configId);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;performSetActiveConfig changing active config to %d(%s)&quot;</span>,</span><br><span class="line">          refreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>(), refreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">    <span class="keyword">if</span> (!display || display-&gt;<span class="built_in">getActiveConfig</span>() == desiredActiveConfig-&gt;configId) &#123;</span><br><span class="line">        <span class="comment">// 显示设备无效，或者已经处于请求的帧率模式下，标记帧率请求已经完成</span></span><br><span class="line">        <span class="built_in">desiredActiveConfigChangeDone</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所需的活动配置已设置，它与当前使用的配置不同，但是在处理刷新时，允许的配置可能已更改。</span></span><br><span class="line">    <span class="comment">// 确保所需的配置仍然被允许</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isDisplayConfigAllowed</span>(desiredActiveConfig-&gt;configId)) &#123;</span><br><span class="line">        <span class="built_in">desiredActiveConfigChangeDone</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mUpcomingActiveConfig = *desiredActiveConfig;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> displayId = display-&gt;<span class="built_in">getId</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(!displayId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;ActiveConfigFPS_HWC&quot;</span>, refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/142753666) use constrains</span></span><br><span class="line">    hal::VsyncPeriodChangeConstraints constraints;</span><br><span class="line">    constraints.desiredTimeNanos = <span class="built_in">systemTime</span>();</span><br><span class="line">    constraints.seamlessRequired = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1.1 通知HWC更新帧率</span></span><br><span class="line">    hal::VsyncPeriodChangeTimeline outTimeline;</span><br><span class="line">    <span class="keyword">auto</span> status =</span><br><span class="line">            <span class="built_in">getHwComposer</span>().<span class="built_in">setActiveConfigWithConstraints</span>(*displayId,</span><br><span class="line">                                                           mUpcomingActiveConfig.configId.<span class="built_in">value</span>(),</span><br><span class="line">                                                           constraints, &amp;outTimeline);</span><br><span class="line">    <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">        <span class="comment">// setActiveConfigWithConstraints may fail if a hotplug event is just about</span></span><br><span class="line">        <span class="comment">// to be sent. We just log the error in this case.</span></span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;setActiveConfigWithConstraints failed: %d&quot;</span>, status);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScheduler-&gt;<span class="built_in">onNewVsyncPeriodChangeTimeline</span>(outTimeline);</span><br><span class="line">    <span class="comment">// 如果需要，Scheduler将向HWC提交一个空帧，回到onMessageInvalidate中处理</span></span><br><span class="line">    <span class="comment">// 也就是在下一帧会处理，距离调用setDesiredActiveConfig就是第二个帧了。</span></span><br><span class="line">    mSetActiveConfigPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做一些合法性判断，最重要的是告诉HWC去更新帧率了。</p><h2 id="2-1-1-HWComposer-setActiveConfigWithConstraints"><a href="#2-1-1-HWComposer-setActiveConfigWithConstraints" class="headerlink" title="2.1.1 HWComposer.setActiveConfigWithConstraints"></a>2.1.1 HWComposer.setActiveConfigWithConstraints</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">HWComposer::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        DisplayId displayId, <span class="type">size_t</span> configId, <span class="type">const</span> hal::VsyncPeriodChangeConstraints&amp; constraints,</span></span></span><br><span class="line"><span class="params"><span class="function">        hal::VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_INVALID_DISPLAY</span>(displayId, BAD_INDEX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; displayData = mDisplayData[displayId];</span><br><span class="line">    <span class="keyword">if</span> (displayData.configMap.<span class="built_in">count</span>(configId) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_DISPLAY_ERROR</span>(displayId, (<span class="string">&quot;Invalid config &quot;</span> + std::<span class="built_in">to_string</span>(configId)).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> BAD_INDEX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hwcDisplay是HWC2::impl::Display，用来描述硬件显示设备的</span></span><br><span class="line">    <span class="keyword">auto</span> error =</span><br><span class="line">            displayData.hwcDisplay-&gt;<span class="built_in">setActiveConfigWithConstraints</span>(displayData.configMap[configId],</span><br><span class="line">                                                                   constraints, outTimeline);</span><br><span class="line">    <span class="built_in">RETURN_IF_HWC_ERROR</span>(error, displayId, UNKNOWN_ERROR);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-HWC2-impl-Display-setActiveConfigWithConstraints"><a href="#2-1-2-HWC2-impl-Display-setActiveConfigWithConstraints" class="headerlink" title="2.1.2 HWC2::impl::Display.setActiveConfigWithConstraints"></a>2.1.2 HWC2::impl::Display.setActiveConfigWithConstraints</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Display::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> HWC2::Display::Config&gt;&amp; config,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> VsyncPeriodChangeConstraints&amp; constraints, VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;[%&quot;</span> PRIu64 <span class="string">&quot;] setActiveConfigWithConstraints&quot;</span>, mId);</span><br><span class="line">    <span class="keyword">if</span> (config-&gt;<span class="built_in">getDisplayId</span>() != mId) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;setActiveConfigWithConstraints received config %u for the wrong display %&quot;</span> PRIu64</span><br><span class="line">              <span class="string">&quot; (expected %&quot;</span> PRIu64 <span class="string">&quot;)&quot;</span>,</span><br><span class="line">              config-&gt;<span class="built_in">getId</span>(), config-&gt;<span class="built_in">getDisplayId</span>(), mId);</span><br><span class="line">        <span class="keyword">return</span> Error::BAD_CONFIG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持Vsync Period切换</span></span><br><span class="line">    <span class="comment">// 我们假设支持，其实不支持的话无非是换成调用setActiveConfig</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isVsyncPeriodSwitchSupported</span>()) &#123;</span><br><span class="line">        Hwc2::IComposerClient::VsyncPeriodChangeConstraints hwc2Constraints;</span><br><span class="line">        hwc2Constraints.desiredTimeNanos = constraints.desiredTimeNanos;</span><br><span class="line">        hwc2Constraints.seamlessRequired = constraints.seamlessRequired;</span><br><span class="line"></span><br><span class="line">        Hwc2::VsyncPeriodChangeTimeline vsyncPeriodChangeTimeline = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 2.2.2 通知HWComposer切换帧率</span></span><br><span class="line">        <span class="keyword">auto</span> intError =</span><br><span class="line">                mComposer.<span class="built_in">setActiveConfigWithConstraints</span>(mId, config-&gt;<span class="built_in">getId</span>(), hwc2Constraints,</span><br><span class="line">                                                         &amp;vsyncPeriodChangeTimeline);</span><br><span class="line">        outTimeline-&gt;newVsyncAppliedTimeNanos = vsyncPeriodChangeTimeline.newVsyncAppliedTimeNanos;</span><br><span class="line">        outTimeline-&gt;refreshRequired = vsyncPeriodChangeTimeline.refreshRequired;</span><br><span class="line">        outTimeline-&gt;refreshTimeNanos = vsyncPeriodChangeTimeline.refreshTimeNanos;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Error&gt;(intError);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-ComposerHal-setActiveConfigWithConstraints"><a href="#2-1-3-ComposerHal-setActiveConfigWithConstraints" class="headerlink" title="2.1.3 ComposerHal.setActiveConfigWithConstraints"></a>2.1.3 ComposerHal.setActiveConfigWithConstraints</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V2_4::Error <span class="title">Composer::setActiveConfigWithConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Display display, Config config,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> IComposerClient::VsyncPeriodChangeConstraints&amp; vsyncPeriodChangeConstraints,</span></span></span><br><span class="line"><span class="params"><span class="function">        VsyncPeriodChangeTimeline* outTimeline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Error = V2_4::Error;</span><br><span class="line">    <span class="keyword">if</span> (!mClient_2_4) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error::UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Error error = kDefaultError_2_4;</span><br><span class="line">    <span class="comment">// 转到composer service处理. 也就是给硬件厂商实现</span></span><br><span class="line">    mClient_2_4-&gt;<span class="built_in">setActiveConfigWithConstraints</span>(display, config, vsyncPeriodChangeConstraints,</span><br><span class="line">                                                [&amp;](<span class="type">const</span> <span class="keyword">auto</span>&amp; tmpError, <span class="type">const</span> <span class="keyword">auto</span>&amp; tmpTimeline) &#123;</span><br><span class="line">                                                    error = tmpError;</span><br><span class="line">                                                    <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">                                                        <span class="keyword">return</span>;</span><br><span class="line">                                                    &#125;</span><br><span class="line"></span><br><span class="line">                                                    *outTimeline = tmpTimeline;</span><br><span class="line">                                                &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里HWC切换帧率已经完成了。</p><h2 id="2-2-SurfaceFlinger-setActiveConfigInternal"><a href="#2-2-SurfaceFlinger-setActiveConfigInternal" class="headerlink" title="2.2 SurfaceFlinger.setActiveConfigInternal"></a>2.2 SurfaceFlinger.setActiveConfigInternal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SurfaceFlinger::setActiveConfigInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDefaultDisplayDeviceLocked</span>();</span><br><span class="line">    <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; oldRefreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(display-&gt;<span class="built_in">getActiveConfig</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mActiveConfigLock)</span></span>;</span><br><span class="line">    <span class="comment">// 更新配置为最新的帧率信息</span></span><br><span class="line">    mRefreshRateConfigs-&gt;<span class="built_in">setCurrentConfigId</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    mRefreshRateStats-&gt;<span class="built_in">setConfigMode</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    <span class="comment">// 将新的帧率保存在DisplayDevice中</span></span><br><span class="line">    display-&gt;<span class="built_in">setActiveConfig</span>(mUpcomingActiveConfig.configId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; refreshRate =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(mUpcomingActiveConfig.configId);</span><br><span class="line">    <span class="keyword">if</span> (refreshRate.<span class="built_in">getVsyncPeriod</span>() != oldRefreshRate.<span class="built_in">getVsyncPeriod</span>()) &#123;</span><br><span class="line">        <span class="comment">// 前后帧率不一致，记录此次帧率切换，就是次数（refreshRateSwitches）+1</span></span><br><span class="line">        mTimeStats-&gt;<span class="built_in">incrementRefreshRateSwitches</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偏移量管理类也要更新FPS信息</span></span><br><span class="line">    mPhaseConfiguration-&gt;<span class="built_in">setRefreshRateFps</span>(refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line">    <span class="comment">// HWC更新帧率了，偏移量再次更新</span></span><br><span class="line">    mVSyncModulator-&gt;<span class="built_in">setPhaseOffsets</span>(mPhaseConfiguration-&gt;<span class="built_in">getCurrentOffsets</span>());</span><br><span class="line">    <span class="built_in">ATRACE_INT</span>(<span class="string">&quot;ActiveConfigFPS&quot;</span>, refreshRate.<span class="built_in">getFps</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的event就是:Scheduler::ConfigEvent::Changed</span></span><br><span class="line">    <span class="keyword">if</span> (mUpcomingActiveConfig.event != Scheduler::ConfigEvent::None) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">nsecs_t</span> vsyncPeriod =</span><br><span class="line">                mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(mUpcomingActiveConfig.configId)</span><br><span class="line">                        .<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">        <span class="comment">// 更新AppEventThread中的Vsync间隔信息</span></span><br><span class="line">        mScheduler-&gt;<span class="built_in">onPrimaryDisplayConfigChanged</span>(mAppConnectionHandle, display-&gt;<span class="built_in">getId</span>()-&gt;value,</span><br><span class="line">                                                  mUpcomingActiveConfig.configId, vsyncPeriod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此帧率切换的过程，差不多就告一段落，当然这里面还有很对细节的部分。</p><p>比如硬件Vsync是怎么影响到VsyncRecator产生软件Vsync的，或者软件Vsync和硬件Vsync是怎么校准的。</p><p>不过我们先总结一下：</p><ol><li>SurfaceFlinger收到setDesiredDisplayConfigSpecs更新帧率配置后，根据传入的帧率配置以及当前Layer选择一个最佳帧率</li><li>将这个最佳帧率信息存储在mDesiredActiveConfig中，然后请求下一帧Vsync，顺便更新一下偏移量</li><li>下一帧Vsync到来后，首先根据Layer再次计算一下最佳帧率，然后通知HWC更新帧率，在等待下一帧</li><li>第二个Vsync到来后，实际此时硬件HWC的Vsync已经更新了，现在就是同步更新SurfaceFlinger中各个变量中的状态，然后通知给AppEventThread更新</li></ol><p>所以一个完整的帧率切换至少包含2个Vsync周期，不过这两个Vsync周期并不相同哦</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下分析基于Android R.&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;上一章我们分析了SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。&lt;/p&gt;
&lt;p&gt;接来下我们详细看看SurfaceFlinger是如何通知硬件切换帧率的。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/categories/Android/Vsync/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
  </entry>
  
  <entry>
    <title>App申请帧率(3)--SF计算最佳帧率</title>
    <link href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/"/>
    <id>https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-3-SF%E8%AE%A1%E7%AE%97%E6%9C%80%E4%BD%B3%E5%B8%A7%E7%8E%87/</id>
    <published>2022-02-26T19:53:53.000Z</published>
    <updated>2022-02-26T20:00:06.780Z</updated>
    
    <content type="html"><![CDATA[<p>以下分析基于Android R.</p><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>上一章我们分析了App是如何通过更改一个小小的WindowManager的LayoutParam的属性，来影响Framework决策帧率变化的。</p><p>接来下我们详细看看SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。</p><span id="more"></span><h1 id="一-SurfaceFlinger接受帧率变化"><a href="#一-SurfaceFlinger接受帧率变化" class="headerlink" title="一. SurfaceFlinger接受帧率变化"></a>一. SurfaceFlinger接受帧率变化</h1><p>接上一章，从 SurfaceFlinger::setAllowedDisplayConfigs 开始. 但是Android R上入口函数些许变化：</p><p>由SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes)</p><p>&#x3D;》SurfaceControl.setDesiredDisplayConfigSpecs(displayToken, configSpecs);</p><p>这里的configSpecs是DesiredDisplayConfigSpecs类型</p><h2 id="1-1-SurfaceControl-setDesiredDisplayConfigSpecs"><a href="#1-1-SurfaceControl-setDesiredDisplayConfigSpecs" class="headerlink" title="1.1 SurfaceControl.setDesiredDisplayConfigSpecs"></a>1.1 SurfaceControl.setDesiredDisplayConfigSpecs</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> boolean <span class="title">setDesiredDisplayConfigSpecs</span><span class="params">(IBinder displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">        SurfaceControl.DesiredDisplayConfigSpecs desiredDisplayConfigSpecs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (displayToken == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalArgumentException</span>(<span class="string">&quot;displayToken must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">nativeSetDesiredDisplayConfigSpecs</span>(displayToken, desiredDisplayConfigSpecs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-1-android-view-SurfaceControl-nativeSetDesiredDisplayConfigSpecs"><a href="#1-1-1-android-view-SurfaceControl-nativeSetDesiredDisplayConfigSpecs" class="headerlink" title="1.1.1 android_view_SurfaceControl.nativeSetDesiredDisplayConfigSpecs"></a>1.1.1 android_view_SurfaceControl.nativeSetDesiredDisplayConfigSpecs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">nativeSetDesiredDisplayConfigSpecs</span><span class="params">(JNIEnv* env, jclass clazz, jobject tokenObj,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   jobject desiredDisplayConfigSpecs)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">token</span><span class="params">(ibinderForJavaObject(env, tokenObj))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">nullptr</span>) <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    jint defaultConfig = env-&gt;<span class="built_in">GetIntField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                                          gDesiredDisplayConfigSpecsClassInfo.defaultConfig);</span><br><span class="line">    jfloat primaryRefreshRateMin =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.primaryRefreshRateMin);</span><br><span class="line">    jfloat primaryRefreshRateMax =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.primaryRefreshRateMax);</span><br><span class="line">    jfloat appRequestRefreshRateMin =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.appRequestRefreshRateMin);</span><br><span class="line">    jfloat appRequestRefreshRateMax =</span><br><span class="line">            env-&gt;<span class="built_in">GetFloatField</span>(desiredDisplayConfigSpecs,</span><br><span class="line">                               gDesiredDisplayConfigSpecsClassInfo.appRequestRefreshRateMax);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> result = SurfaceComposerClient::<span class="built_in">setDesiredDisplayConfigSpecs</span>(token, defaultConfig,</span><br><span class="line">                                                                        primaryRefreshRateMin,</span><br><span class="line">                                                                        primaryRefreshRateMax,</span><br><span class="line">                                                                        appRequestRefreshRateMin,</span><br><span class="line">                                                                        appRequestRefreshRateMax);</span><br><span class="line">    <span class="keyword">return</span> result == NO_ERROR ? JNI_TRUE : JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-2-SurfaceComposerClient-setDesiredDisplayConfigSpecs"><a href="#1-1-2-SurfaceComposerClient-setDesiredDisplayConfigSpecs" class="headerlink" title="1.1.2 SurfaceComposerClient.setDesiredDisplayConfigSpecs"></a>1.1.2 SurfaceComposerClient.setDesiredDisplayConfigSpecs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceComposerClient::setDesiredDisplayConfigSpecs</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">int32_t</span> defaultConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> primaryRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> primaryRefreshRateMax,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> appRequestRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                             <span class="type">float</span> appRequestRefreshRateMax)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转到SurfaceFlinger</span></span><br><span class="line">    <span class="keyword">return</span> ComposerService::<span class="built_in">getComposerService</span>()</span><br><span class="line">            -&gt;<span class="built_in">setDesiredDisplayConfigSpecs</span>(displayToken, defaultConfig, primaryRefreshRateMin,</span><br><span class="line">                                           primaryRefreshRateMax, appRequestRefreshRateMin,</span><br><span class="line">                                           appRequestRefreshRateMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-SurfaceFlinger-setDesiredDisplayConfigSpecs"><a href="#1-2-SurfaceFlinger-setDesiredDisplayConfigSpecs" class="headerlink" title="1.2 SurfaceFlinger.setDesiredDisplayConfigSpecs"></a>1.2 SurfaceFlinger.setDesiredDisplayConfigSpecs</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::setDesiredDisplayConfigSpecs</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">int32_t</span> defaultConfig,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> primaryRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> primaryRefreshRateMax,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> appRequestRefreshRateMin,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">float</span> appRequestRefreshRateMax)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!displayToken) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> future = <span class="built_in">schedule</span>([=]() -&gt; <span class="type">status_t</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken);</span><br><span class="line">        <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Attempt to set desired display configs for invalid display token %p&quot;</span>,</span><br><span class="line">                  displayToken.<span class="built_in">get</span>());</span><br><span class="line">            <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (display-&gt;<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Attempt to set desired display configs for virtual display&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">using</span> Policy = scheduler::RefreshRateConfigs::Policy;</span><br><span class="line">            <span class="comment">// 初始化policy</span></span><br><span class="line">            <span class="type">const</span> Policy policy&#123;<span class="built_in">HwcConfigIndexType</span>(defaultConfig),</span><br><span class="line">                                &#123;primaryRefreshRateMin, primaryRefreshRateMax&#125;,</span><br><span class="line">                                &#123;appRequestRefreshRateMin, appRequestRefreshRateMax&#125;&#125;;</span><br><span class="line">            <span class="keyword">constexpr</span> <span class="type">bool</span> kOverridePolicy = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">setDesiredDisplayConfigSpecsInternal</span>(display, policy, kOverridePolicy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> future.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-1-SurfaceFlinger-schedule"><a href="#1-2-1-SurfaceFlinger-schedule" class="headerlink" title="1.2.1 SurfaceFlinger.schedule"></a>1.2.1 SurfaceFlinger.schedule</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::future&lt;T&gt; <span class="title">SurfaceFlinger::schedule</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [task, future] = <span class="built_in">makeTask</span>(std::<span class="built_in">move</span>(f));</span><br><span class="line">    mEventQueue-&gt;<span class="built_in">postMessage</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  MessageQueue.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">makeTask</span><span class="params">(F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    sp&lt;Task&lt;F&gt;&gt; task = <span class="keyword">new</span> <span class="built_in">Task</span>&lt;F&gt;(std::<span class="built_in">move</span>(f));</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(task, task-&gt;mTask.<span class="built_in">get_future</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  MessageQueue.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> : <span class="keyword">public</span> MessageHandler &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> G&gt;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">auto</span> <span class="title">makeTask</span><span class="params">(G&amp;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Task</span><span class="params">(F&amp;&amp; f)</span> : mTask(std::move(f)) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleMessage</span><span class="params">(<span class="type">const</span> Message&amp;)</span> <span class="keyword">override</span> </span>&#123; <span class="built_in">mTask</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">invoke_result_t</span>&lt;F&gt;;</span><br><span class="line">    std::packaged_task&lt;<span class="built_in">T</span>()&gt; mTask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-3-SurfaceFlinger-setDesiredDisplayConfigSpecsInternal"><a href="#1-3-SurfaceFlinger-setDesiredDisplayConfigSpecsInternal" class="headerlink" title="1.3 SurfaceFlinger.setDesiredDisplayConfigSpecsInternal"></a>1.3 SurfaceFlinger.setDesiredDisplayConfigSpecsInternal</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::setDesiredDisplayConfigSpecsInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;DisplayDevice&gt;&amp; display,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::optional&lt;scheduler::RefreshRateConfigs::Policy&gt;&amp; policy, <span class="type">bool</span> overridePolicy)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// overridePolicy 一般都是false</span></span><br><span class="line">    <span class="type">status_t</span> setPolicyResult = overridePolicy</span><br><span class="line">            ? mRefreshRateConfigs-&gt;<span class="built_in">setOverridePolicy</span>(policy)</span><br><span class="line">            <span class="comment">// 1.3.1 更改当前帧率策略</span></span><br><span class="line">            : mRefreshRateConfigs-&gt;<span class="built_in">setDisplayManagerPolicy</span>(*policy);</span><br><span class="line">    <span class="keyword">if</span> (setPolicyResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setPolicyResult == scheduler::RefreshRateConfigs::CURRENT_POLICY_UNCHANGED) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduler::RefreshRateConfigs::Policy currentPolicy = mRefreshRateConfigs-&gt;<span class="built_in">getCurrentPolicy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;Setting desired display config specs: defaultConfig: %d primaryRange: [%.0f %.0f]&quot;</span></span><br><span class="line">          <span class="string">&quot; expandedRange: [%.0f %.0f]&quot;</span>,</span><br><span class="line">          currentPolicy.defaultConfig.<span class="built_in">value</span>(), currentPolicy.primaryRange.min,</span><br><span class="line">          currentPolicy.primaryRange.max, currentPolicy.appRequestRange.min,</span><br><span class="line">          currentPolicy.appRequestRange.max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(b/140204874): Leave the event in until we do proper testing with all apps that might</span></span><br><span class="line">    <span class="comment">// be depending in this callback.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">nsecs_t</span> vsyncPeriod =</span><br><span class="line">            mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(display-&gt;<span class="built_in">getActiveConfig</span>())</span><br><span class="line">                    .<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">    mScheduler-&gt;<span class="built_in">onPrimaryDisplayConfigChanged</span>(mAppConnectionHandle, display-&gt;<span class="built_in">getId</span>()-&gt;value,</span><br><span class="line">                                              display-&gt;<span class="built_in">getActiveConfig</span>(), vsyncPeriod);</span><br><span class="line">    <span class="built_in">toggleKernelIdleTimer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.3.3 获取configId</span></span><br><span class="line">    <span class="keyword">auto</span> configId = mScheduler-&gt;<span class="built_in">getPreferredConfigId</span>();</span><br><span class="line">    <span class="comment">// configId是std::optional&lt;HwcConfigIndexType&gt;类型的，这里判断是否存在值，一般存在</span></span><br><span class="line">    <span class="comment">// 根据HwcConfigIndexType获取实际的 RefreshRate 参数</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; preferredRefreshRate = configId</span><br><span class="line">            ? mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(*configId)</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> Choose the default config ID, if Scheduler doesn&#x27;t have one in mind.</span></span><br><span class="line">            : mRefreshRateConfigs-&gt;<span class="built_in">getRefreshRateFromConfigId</span>(currentPolicy.defaultConfig);</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;trying to switch to Scheduler preferred config %d (%s)&quot;</span>,</span><br><span class="line">          preferredRefreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>(), preferredRefreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断RefreshRate是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isDisplayConfigAllowed</span>(preferredRefreshRate.<span class="built_in">getConfigId</span>())) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;switching to Scheduler preferred config %d&quot;</span>,</span><br><span class="line">              preferredRefreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>());</span><br><span class="line">        <span class="comment">// 1.4 设置帧率</span></span><br><span class="line">        <span class="built_in">setDesiredActiveConfig</span>(</span><br><span class="line">                &#123;preferredRefreshRate.<span class="built_in">getConfigId</span>(), Scheduler::ConfigEvent::Changed&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;Desired config not allowed: %d&quot;</span>,</span><br><span class="line">                         preferredRefreshRate.<span class="built_in">getConfigId</span>().<span class="built_in">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-1-RefreshRateConfigs-setDisplayManagerPolicy"><a href="#1-3-1-RefreshRateConfigs-setDisplayManagerPolicy" class="headerlink" title="1.3.1 RefreshRateConfigs.setDisplayManagerPolicy"></a>1.3.1 RefreshRateConfigs.setDisplayManagerPolicy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">RefreshRateConfigs::setDisplayManagerPolicy</span><span class="params">(<span class="type">const</span> Policy&amp; policy)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isPolicyValid</span>(policy)) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前策略，如果mOverridePolicy是false，也就是没有覆写</span></span><br><span class="line">    <span class="comment">// 就是用的mDisplayManagerPolicy</span></span><br><span class="line">    Policy previousPolicy = *<span class="built_in">getCurrentPolicyLocked</span>();</span><br><span class="line">    mDisplayManagerPolicy = policy;</span><br><span class="line">    <span class="keyword">if</span> (*<span class="built_in">getCurrentPolicyLocked</span>() == previousPolicy) &#123;</span><br><span class="line">        <span class="keyword">return</span> CURRENT_POLICY_UNCHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.3.2 根据策略构建最终刷新率</span></span><br><span class="line">    <span class="built_in">constructAvailableRefreshRates</span>();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-RefreshRateConfigs-constructAvailableRefreshRates"><a href="#1-3-2-RefreshRateConfigs-constructAvailableRefreshRates" class="headerlink" title="1.3.2 RefreshRateConfigs.constructAvailableRefreshRates"></a>1.3.2 RefreshRateConfigs.constructAvailableRefreshRates</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RefreshRateConfigs::constructAvailableRefreshRates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Filter configs based on current policy and sort based on vsync period</span></span><br><span class="line">    <span class="type">const</span> Policy* policy = <span class="built_in">getCurrentPolicyLocked</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; defaultConfig = mRefreshRates.<span class="built_in">at</span>(policy-&gt;defaultConfig)-&gt;hwcConfig;</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;constructAvailableRefreshRates: default %d group %d primaryRange=[%.2f %.2f]&quot;</span></span><br><span class="line">          <span class="string">&quot; appRequestRange=[%.2f %.2f]&quot;</span>,</span><br><span class="line">          policy-&gt;defaultConfig.<span class="built_in">value</span>(), defaultConfig-&gt;<span class="built_in">getConfigGroup</span>(), policy-&gt;primaryRange.min,</span><br><span class="line">          policy-&gt;primaryRange.max, policy-&gt;appRequestRange.min, policy-&gt;appRequestRange.max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambuda A</span></span><br><span class="line">    <span class="keyword">auto</span> filterRefreshRates = [&amp;](<span class="type">float</span> min, <span class="type">float</span> max, <span class="type">const</span> <span class="type">char</span>* listName,</span><br><span class="line">                                  std::vector&lt;<span class="type">const</span> RefreshRate*&gt;* outRefreshRates) &#123;</span><br><span class="line">        <span class="comment">// lambuda B</span></span><br><span class="line">        <span class="built_in">getSortedRefreshRateList</span>(</span><br><span class="line">                [&amp;](<span class="type">const</span> RefreshRate&amp; refreshRate) <span class="built_in">REQUIRES</span>(mLock) &#123;</span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span>&amp; hwcConfig = refreshRate.hwcConfig;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> hwcConfig-&gt;<span class="built_in">getHeight</span>() == defaultConfig-&gt;<span class="built_in">getHeight</span>() &amp;&amp;</span><br><span class="line">                            hwcConfig-&gt;<span class="built_in">getWidth</span>() == defaultConfig-&gt;<span class="built_in">getWidth</span>() &amp;&amp;</span><br><span class="line">                            hwcConfig-&gt;<span class="built_in">getDpiX</span>() == defaultConfig-&gt;<span class="built_in">getDpiX</span>() &amp;&amp;</span><br><span class="line">                            hwcConfig-&gt;<span class="built_in">getDpiY</span>() == defaultConfig-&gt;<span class="built_in">getDpiY</span>() &amp;&amp;</span><br><span class="line">                            (policy-&gt;allowGroupSwitching ||</span><br><span class="line">                             hwcConfig-&gt;<span class="built_in">getConfigGroup</span>() == defaultConfig-&gt;<span class="built_in">getConfigGroup</span>()) &amp;&amp;</span><br><span class="line">                            refreshRate.<span class="built_in">inPolicy</span>(min, max);</span><br><span class="line">                &#125;,</span><br><span class="line">                outRefreshRates);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(outRefreshRates-&gt;<span class="built_in">empty</span>(),</span><br><span class="line">                            <span class="string">&quot;No matching configs for %s range: min=%.0f max=%.0f&quot;</span>, listName, min,</span><br><span class="line">                            max);</span><br><span class="line">        <span class="keyword">auto</span> stringifyRefreshRates = [&amp;]() -&gt; std::string &#123;</span><br><span class="line">            std::string str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> refreshRate : *outRefreshRates) &#123;</span><br><span class="line">                base::<span class="built_in">StringAppendF</span>(&amp;str, <span class="string">&quot;%s &quot;</span>, refreshRate-&gt;name.<span class="built_in">c_str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;%s refresh rates: %s&quot;</span>, listName, <span class="built_in">stringifyRefreshRates</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">filterRefreshRates</span>(policy-&gt;primaryRange.min, policy-&gt;primaryRange.max, <span class="string">&quot;primary&quot;</span>,</span><br><span class="line">                       &amp;mPrimaryRefreshRates);</span><br><span class="line">    <span class="built_in">filterRefreshRates</span>(policy-&gt;appRequestRange.min, policy-&gt;appRequestRange.max, <span class="string">&quot;app request&quot;</span>,</span><br><span class="line">                       &amp;mAppRequestRefreshRates);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RefreshRateConfigs::getSortedRefreshRateList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::function&lt;<span class="type">bool</span>(<span class="type">const</span> RefreshRate&amp;)&gt;&amp; shouldAddRefreshRate,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::vector&lt;<span class="type">const</span> RefreshRate*&gt;* outRefreshRates)</span> </span>&#123;</span><br><span class="line">    outRefreshRates-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    outRefreshRates-&gt;<span class="built_in">reserve</span>(mRefreshRates.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 遍历所有可能的RefreshRate</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [type, refreshRate] : mRefreshRates) &#123;</span><br><span class="line">        <span class="comment">// 调用上面的lambuda B方法, 其实就是条件判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shouldAddRefreshRate</span>(*refreshRate)) &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;getSortedRefreshRateList: config %d added to list policy&quot;</span>,</span><br><span class="line">                  refreshRate-&gt;configId.<span class="built_in">value</span>());</span><br><span class="line">            outRefreshRates-&gt;<span class="built_in">push_back</span>(refreshRate.<span class="built_in">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照帧率大小排序，VsyncPeriod越大，Fps越小。</span></span><br><span class="line">    <span class="comment">// 这里就是按照Fps升序排序了</span></span><br><span class="line">    std::<span class="built_in">sort</span>(outRefreshRates-&gt;<span class="built_in">begin</span>(), outRefreshRates-&gt;<span class="built_in">end</span>(),</span><br><span class="line">              [](<span class="type">const</span> <span class="keyword">auto</span> refreshRate1, <span class="type">const</span> <span class="keyword">auto</span> refreshRate2) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (refreshRate1-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>() !=</span><br><span class="line">                      refreshRate2-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>()) &#123;</span><br><span class="line">                      <span class="keyword">return</span> refreshRate1-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>() &gt;</span><br><span class="line">                              refreshRate2-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="keyword">return</span> refreshRate1-&gt;hwcConfig-&gt;<span class="built_in">getConfigGroup</span>() &gt;</span><br><span class="line">                              refreshRate2-&gt;hwcConfig-&gt;<span class="built_in">getConfigGroup</span>();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里吐槽一下，写的很丑。直接说明，在 mRefreshRates中寻找符合要求的configId(modeId)放入对应的集合中。</p><p>这里说的符合要求是指：</p><ol><li>宽高与所设置的Policy中的defaultConfig的宽高一致</li><li>其帧率在所设置的Policy的最小和最大帧率之中</li></ol><p>最终将结果保存在变量：mPrimaryRefreshRates以及mAppRequestRefreshRates中。</p><h3 id="1-3-3-Scheduler-getPreferredConfigId"><a href="#1-3-3-Scheduler-getPreferredConfigId" class="headerlink" title="1.3.3 Scheduler.getPreferredConfigId"></a>1.3.3 Scheduler.getPreferredConfigId</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;HwcConfigIndexType&gt; <span class="title">Scheduler::getPreferredConfigId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mFeatureStateLock)</span></span>;</span><br><span class="line">    <span class="comment">// Make sure that the default config ID is first updated, before returned.</span></span><br><span class="line">    <span class="comment">// mFeatures 是一个结构体</span></span><br><span class="line">    <span class="keyword">if</span> (mFeatures.configId.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="comment">// configId是一个 std:optional的变量</span></span><br><span class="line">        <span class="comment">// 计算当前刷新率的configId</span></span><br><span class="line">        mFeatures.configId = <span class="built_in">calculateRefreshRateConfigIndexType</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mFeatures.configId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方原以为mFeatures.configId一般是存在value的，其实并不是。</p><h3 id="1-3-4-Scheduler-calculateRefreshRateConfigIndexType"><a href="#1-3-4-Scheduler-calculateRefreshRateConfigIndexType" class="headerlink" title="1.3.4 Scheduler.calculateRefreshRateConfigIndexType"></a>1.3.4 Scheduler.calculateRefreshRateConfigIndexType</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consideredSignals 的默认参数是nullptr的</span></span><br><span class="line"><span class="function">HwcConfigIndexType <span class="title">Scheduler::calculateRefreshRateConfigIndexType</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        scheduler::RefreshRateConfigs::GlobalSignals* consideredSignals)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> touchActive = mTouchTimer &amp;&amp; mFeatures.touch == TouchState::Active;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> idle = mIdleTimer &amp;&amp; mFeatures.idleTimer == TimerState::Expired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 1.3.5 获取最佳ConfigId, 根据framework传来的帧率范围, 以及当下Layer投票产生</span></span><br><span class="line">    <span class="keyword">return</span> mRefreshRateConfigs</span><br><span class="line">            .<span class="built_in">getBestRefreshRate</span>(mFeatures.contentRequirements, &#123;.touch = touchActive, .idle = idle&#125;,</span><br><span class="line">                                consideredSignals)</span><br><span class="line">            .<span class="built_in">getConfigId</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-5-RefreshRateConfigs-getBestRefreshRate"><a href="#1-3-5-RefreshRateConfigs-getBestRefreshRate" class="headerlink" title="1.3.5 RefreshRateConfigs.getBestRefreshRate"></a>1.3.5 RefreshRateConfigs.getBestRefreshRate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> RefreshRate&amp; <span class="title">RefreshRateConfigs::getBestRefreshRate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;LayerRequirement&gt;&amp; layers, <span class="type">const</span> GlobalSignals&amp; globalSignals,</span></span></span><br><span class="line"><span class="params"><span class="function">        GlobalSignals* outSignalsConsidered)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line">    <span class="built_in">ALOGV</span>(<span class="string">&quot;getRefreshRateForContent %zu layers&quot;</span>, layers.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意传入的outSignalsConsidered是nullptr的</span></span><br><span class="line">    <span class="keyword">if</span> (outSignalsConsidered) *outSignalsConsidered = &#123;&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> setTouchConsidered = [&amp;] &#123;</span><br><span class="line">        <span class="keyword">if</span> (outSignalsConsidered) &#123;</span><br><span class="line">            outSignalsConsidered-&gt;touch = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> setIdleConsidered = [&amp;] &#123;</span><br><span class="line">        <span class="keyword">if</span> (outSignalsConsidered) &#123;</span><br><span class="line">            outSignalsConsidered-&gt;idle = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="comment">// 开始投票</span></span><br><span class="line">    <span class="comment">// 首先计算所有不同LayerVoteType的数量</span></span><br><span class="line">    <span class="comment">// 这里的Type稍后介绍</span></span><br><span class="line">    <span class="type">int</span> noVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> explicitDefaultVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> explicitExactOrMultipleVoteLayers = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录最大的权重</span></span><br><span class="line">    <span class="type">float</span> maxExplicitWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : layers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer.vote == LayerVoteType::NoVote) &#123;</span><br><span class="line">            noVoteLayers++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::Min) &#123;</span><br><span class="line">            minVoteLayers++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::Max) &#123;</span><br><span class="line">            maxVoteLayers++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitDefault) &#123;</span><br><span class="line">            explicitDefaultVoteLayers++;</span><br><span class="line">            maxExplicitWeight = std::<span class="built_in">max</span>(maxExplicitWeight, layer.weight);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitExactOrMultiple) &#123;</span><br><span class="line">            explicitExactOrMultipleVoteLayers++;</span><br><span class="line">            maxExplicitWeight = std::<span class="built_in">max</span>(maxExplicitWeight, layer.weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> hasExplicitVoteLayers =</span><br><span class="line">            explicitDefaultVoteLayers &gt; <span class="number">0</span> || explicitExactOrMultipleVoteLayers &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $1. 如果没有显式Layer, 考虑触摸事件, 如果存在触摸事件, 选择最大帧率</span></span><br><span class="line">    <span class="keyword">if</span> (globalSignals.touch &amp;&amp; !hasExplicitVoteLayers) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;TouchBoost - choose %s&quot;</span>, <span class="built_in">getMaxRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">setTouchConsidered</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果刷新率范围由单个刷新率组成，那么只有当层显式请求不同的刷新率时，才能选择超出范围</span></span><br><span class="line">    <span class="type">const</span> Policy* policy = <span class="built_in">getCurrentPolicyLocked</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> primaryRangeIsSingleRate = policy-&gt;primaryRange.min == policy-&gt;primaryRange.max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $2. 没有touch事件，屏幕处于idle状态, 刷新率存在一定范围或者不存在显示请求刷新率的Layer时</span></span><br><span class="line">    <span class="comment">// 选择最小帧率</span></span><br><span class="line">    <span class="keyword">if</span> (!globalSignals.touch &amp;&amp; globalSignals.idle &amp;&amp;</span><br><span class="line">        !(primaryRangeIsSingleRate &amp;&amp; hasExplicitVoteLayers)) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Idle - choose %s&quot;</span>, <span class="built_in">getMinRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="built_in">setIdleConsidered</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMinRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $3. 没有Layer或者所有Layer都没有投票(NoVote)时, 选择最大帧率？？？</span></span><br><span class="line">    <span class="keyword">if</span> (layers.<span class="built_in">empty</span>() || noVoteLayers == layers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $4. 存在Layer且所有Layer要么不投票，要么请求最小帧率时，选择最小帧率</span></span><br><span class="line">    <span class="keyword">if</span> (noVoteLayers + minVoteLayers == layers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;all layers Min - choose %s&quot;</span>, <span class="built_in">getMinRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getMinRefreshRateByPolicyLocked</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $5. 计算找到最佳刷新率</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">const</span> RefreshRate*, <span class="type">float</span>&gt;&gt; scores;</span><br><span class="line">    scores.<span class="built_in">reserve</span>(mAppRequestRefreshRates.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> refreshRate : mAppRequestRefreshRates) &#123;</span><br><span class="line">        scores.<span class="built_in">emplace_back</span>(refreshRate, <span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有Layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; layer : layers) &#123;</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Calculating score for %s (%s, weight %.2f)&quot;</span>, layer.name.<span class="built_in">c_str</span>(),</span><br><span class="line">              <span class="built_in">layerVoteTypeString</span>(layer.vote).<span class="built_in">c_str</span>(), layer.weight);</span><br><span class="line">        <span class="comment">// 忽略不投票或者投票选择最小帧率的Layer</span></span><br><span class="line">        <span class="keyword">if</span> (layer.vote == LayerVoteType::NoVote || layer.vote == LayerVoteType::Min) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> weight = layer.weight;</span><br><span class="line">        <span class="comment">// 注意这里还有一层循环，分别计算每个AppRequestRefreshRate的得分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0u</span>; i &lt; scores.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">bool</span> inPrimaryRange =</span><br><span class="line">                    scores[i].first-&gt;<span class="built_in">inPolicy</span>(policy-&gt;primaryRange.min, policy-&gt;primaryRange.max);</span><br><span class="line">            <span class="keyword">if</span> ((primaryRangeIsSingleRate || !inPrimaryRange) &amp;&amp;</span><br><span class="line">                !(layer.focused &amp;&amp;</span><br><span class="line">                  (layer.vote == LayerVoteType::ExplicitDefault ||</span><br><span class="line">                   layer.vote == LayerVoteType::ExplicitExactOrMultiple))) &#123;</span><br><span class="line">                <span class="comment">// $$5.1 只有具有显式帧速率设置的聚焦层才允许对主范围之外的刷新率进行评分</span></span><br><span class="line">                <span class="comment">// 换句话说，只有ExplicitDefault或者ExplicitExactOrMultiple类型的Layer，且该Layer是有焦点的</span></span><br><span class="line">                <span class="comment">// 才允许投票超出刷新率请求范围的帧率</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $$5.2 如果图层想要最大值，给更高的刷新率评分</span></span><br><span class="line">            <span class="keyword">if</span> (layer.vote == LayerVoteType::Max) &#123;</span><br><span class="line">                <span class="comment">// 用当前layer(app)请求的帧率除以最后一个layer(app)请求的帧率</span></span><br><span class="line">                <span class="comment">// 注意到mAppRequestRefreshRates中fps是按照升序排序的，最后一个是最大的</span></span><br><span class="line">                <span class="comment">// 所以这里就是用 当前请求的帧率除以最大的请求帧率得到一个 (0, 1] 的比值</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> ratio = scores[i].first-&gt;fps / scores.<span class="built_in">back</span>().first-&gt;fps;</span><br><span class="line">                <span class="comment">// 使用比值的平方得到一个较低的分数 ==&gt; 为啥？</span></span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> layerScore = ratio * ratio;</span><br><span class="line">                <span class="built_in">ALOGV</span>(<span class="string">&quot;%s (Max, weight %.2f) gives %s score of %.2f&quot;</span>, layer.name.<span class="built_in">c_str</span>(), weight,</span><br><span class="line">                      scores[i].first-&gt;name.<span class="built_in">c_str</span>(), layerScore);</span><br><span class="line">                <span class="comment">// 将比值的平方乘上权重系数，作为该layer的分数</span></span><br><span class="line">                scores[i].second += weight * layerScore;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏幕刷新率</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> displayPeriod = scores[i].first-&gt;hwcConfig-&gt;<span class="built_in">getVsyncPeriod</span>();</span><br><span class="line">            <span class="comment">// Layer所需的刷新率</span></span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> layerPeriod = <span class="built_in">round</span>&lt;<span class="type">nsecs_t</span>&gt;(<span class="number">1e9</span>f / layer.desiredRefreshRate);</span><br><span class="line">            <span class="comment">// $$5.3 如果是ExplicitDefault类型的Layer</span></span><br><span class="line">            <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitDefault) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> layerScore = [&amp;]() &#123;</span><br><span class="line">                    <span class="comment">// 找到Layer将渲染的实际速率，假设layerPeriod是渲染帧的最短时间</span></span><br><span class="line">                    <span class="keyword">auto</span> actualLayerPeriod = displayPeriod;</span><br><span class="line">                    <span class="type">int</span> multiplier = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 刷新时长依次翻倍，直到满足该Layer刷新的最低时长，也就是fps大小每次折半</span></span><br><span class="line">                    <span class="comment">// MARGIN_FOR_PERIOD_CALCULATION = 800us</span></span><br><span class="line">                    <span class="keyword">while</span> (layerPeriod &gt; actualLayerPeriod + MARGIN_FOR_PERIOD_CALCULATION) &#123;</span><br><span class="line">                        multiplier++;</span><br><span class="line">                        actualLayerPeriod = displayPeriod * multiplier;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 此时layer分数为 layer所需的时长除以满足刷新要求的最长时长</span></span><br><span class="line">                    <span class="keyword">return</span> std::<span class="built_in">min</span>(<span class="number">1.0f</span>,</span><br><span class="line">                                    <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(layerPeriod) /</span><br><span class="line">                                            <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(actualLayerPeriod));</span><br><span class="line">                &#125;();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">ALOGV</span>(<span class="string">&quot;%s (ExplicitDefault, weight %.2f) %.2fHz gives %s score of %.2f&quot;</span>,</span><br><span class="line">                      layer.name.<span class="built_in">c_str</span>(), weight, <span class="number">1e9</span>f / layerPeriod, scores[i].first-&gt;name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      layerScore);</span><br><span class="line">                <span class="comment">// layer分数乘上权重作为该layer的最终分数</span></span><br><span class="line">                scores[i].second += weight * layerScore;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $$5.4 如果是ExplicitExactOrMultiple或者Heuristic类型的Layer</span></span><br><span class="line">            <span class="keyword">if</span> (layer.vote == LayerVoteType::ExplicitExactOrMultiple ||</span><br><span class="line">                layer.vote == LayerVoteType::Heuristic) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="keyword">auto</span> layerScore = [&amp;] &#123;</span><br><span class="line">                    <span class="comment">// 计算我们需要多少个显示vSync来显示这个层的一个帧</span></span><br><span class="line">                    <span class="comment">// 其实就是计算 layerPeriod/displayPeriod 得到商和余数</span></span><br><span class="line">                    <span class="type">const</span> <span class="keyword">auto</span> [displayFramesQuot, displayFramesRem] =</span><br><span class="line">                            <span class="built_in">getDisplayFrames</span>(layerPeriod, displayPeriod);</span><br><span class="line">                    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> MAX_FRAMES_TO_FIT =</span><br><span class="line">                            <span class="number">10</span>; <span class="comment">// Stop calculating when score &lt; 0.1</span></span><br><span class="line">                    <span class="keyword">if</span> (displayFramesRem == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 整除的时候，直接返回1?</span></span><br><span class="line">                        <span class="comment">// 说明layer请求的fps是比display的fps小，得分直接拉满</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1.0f</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (displayFramesQuot == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 当layer请求的fps比display中的fps要大的时候</span></span><br><span class="line">                        <span class="comment">// 返回layer period除以display period的商的十一分之一</span></span><br><span class="line">                        <span class="comment">// 比如 layer = 120Hz， display = 90Hz</span></span><br><span class="line">                        <span class="comment">//                    8.33333         1.0</span></span><br><span class="line">                        <span class="comment">//  return =  -----------  *   ----</span></span><br><span class="line">                        <span class="comment">//                     11.1111         11</span></span><br><span class="line">                        <span class="comment">// 为啥怎么算呢，这里分数的极限值也就是1/11，最大限度排除这个layer请求的帧率？</span></span><br><span class="line">                        <span class="keyword">return</span> (<span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(layerPeriod) /</span><br><span class="line">                                <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(displayPeriod)) *</span><br><span class="line">                                (<span class="number">1.0f</span> / (MAX_FRAMES_TO_FIT + <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// layer所需的刷新率低于的显示刷新率，但又不是整数倍关系，检查它是否符合节奏</span></span><br><span class="line">                    <span class="comment">// 计算差值: 用 Pl 表述 layer period，Pd表示display period</span></span><br><span class="line">                    <span class="comment">// diff = | (Pl mod Pd) * 2 - Pd |</span></span><br><span class="line">                    <span class="comment">// 这里的意思是在计算多少帧内，display 刷新可以匹配 layer请求的刷新</span></span><br><span class="line">                    <span class="keyword">auto</span> diff = std::<span class="built_in">abs</span>(displayFramesRem - (displayPeriod - displayFramesRem));</span><br><span class="line">                    <span class="type">int</span> iter = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">while</span> (diff &gt; MARGIN_FOR_PERIOD_CALCULATION &amp;&amp; iter &lt; MAX_FRAMES_TO_FIT) &#123;</span><br><span class="line">                        <span class="comment">// 循环计算，总结公式：</span></span><br><span class="line">                        <span class="comment">// 1. diff0 = 2 * (Pl mod Pd) - Pd, Pl &gt; Pd 且 K ∈ &#123;1,2,3,...,9&#125;</span></span><br><span class="line">                        <span class="comment">// 2. 当diff0 &gt; 0 时, diff = (Pl mod Pd) * 2^k - Pd * (2^k-1)</span></span><br><span class="line">                        <span class="comment">// 3. 当diff0 &lt; 0 时, diff = Pd - 2^k * (Pl mode Pd)</span></span><br><span class="line">                        diff = diff - (displayPeriod - diff);</span><br><span class="line">                        iter++;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 得分取值范围是[0.1, 0.5]</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1.0f</span> / iter;</span><br><span class="line">                &#125;();</span><br><span class="line">                <span class="built_in">ALOGV</span>(<span class="string">&quot;%s (%s, weight %.2f) %.2fHz gives %s score of %.2f&quot;</span>, layer.name.<span class="built_in">c_str</span>(),</span><br><span class="line">                      <span class="built_in">layerVoteTypeString</span>(layer.vote).<span class="built_in">c_str</span>(), weight, <span class="number">1e9</span>f / layerPeriod,</span><br><span class="line">                      scores[i].first-&gt;name.<span class="built_in">c_str</span>(), layerScore);</span><br><span class="line">                <span class="comment">// 照例，乘上权重作为分数</span></span><br><span class="line">                scores[i].second += weight * layerScore;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $6 如果存在请求最大帧率的layer就反向遍历</span></span><br><span class="line">    <span class="comment">// 找到得分最大的帧率</span></span><br><span class="line">    <span class="type">const</span> RefreshRate* bestRefreshRate = maxVoteLayers &gt; <span class="number">0</span></span><br><span class="line">            ? <span class="built_in">getBestRefreshRate</span>(scores.<span class="built_in">rbegin</span>(), scores.<span class="built_in">rend</span>())</span><br><span class="line">            : <span class="built_in">getBestRefreshRate</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示主刷新率没有范围，只有定值时</span></span><br><span class="line">    <span class="keyword">if</span> (primaryRangeIsSingleRate) &#123;</span><br><span class="line">        <span class="comment">// 如果没有layer参与评分，从显示主刷新范围选取最大值</span></span><br><span class="line">        <span class="comment">// 否则返回计算得出的最佳刷新率</span></span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">all_of</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(),</span><br><span class="line">                        [](std::pair&lt;<span class="type">const</span> RefreshRate*, <span class="type">float</span>&gt; p) &#123; <span class="keyword">return</span> p.second == <span class="number">0</span>; &#125;)) &#123;</span><br><span class="line">            <span class="built_in">ALOGV</span>(<span class="string">&quot;layers not scored - choose %s&quot;</span>,</span><br><span class="line">                  <span class="built_in">getMaxRefreshRateByPolicyLocked</span>().<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *bestRefreshRate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有explicitDefaultLayers，请考虑touch事件。</span></span><br><span class="line">    <span class="comment">// ExplicitDefault主要是交互式的（与ExplicitExactOrMultiple相反），因此如果那些Layer发布了一个显式投票，</span></span><br><span class="line">    <span class="comment">// 那么存在touch事件，就不应该更改它。只有在触摸增强会增加刷新率超过正常选择时才应用。</span></span><br><span class="line">    <span class="type">const</span> RefreshRate&amp; touchRefreshRate = <span class="built_in">getMaxRefreshRateByPolicyLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在touch事件，不存在ExplicitDefault的Layer且显示主范围刷新率最大值大于计算的刷新率时</span></span><br><span class="line">    <span class="comment">// 采用最大刷新率</span></span><br><span class="line">    <span class="keyword">if</span> (globalSignals.touch &amp;&amp; explicitDefaultVoteLayers == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        bestRefreshRate-&gt;fps &lt; touchRefreshRate.fps) &#123;</span><br><span class="line">        <span class="built_in">setTouchConsidered</span>();</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;TouchBoost - choose %s&quot;</span>, touchRefreshRate.<span class="built_in">getName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> touchRefreshRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *bestRefreshRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Emmmm…. 这一言难尽的代码。</p><p>总结一下，在上层计算传入两个刷新率范围后，这里主要是根据Layer投票以及一系列判断得到最终所需的刷新率。</p><p>说明一下几个概念：</p><ol><li>显示主范围刷新率: DisplayModeDirector中投票算出的包含所有请求帧率的最小范围</li><li>layerPeriod: 根据当前layer.desiredRefreshRate计算出一帧的时长</li><li>displayPeriod: 当前AppReqeustRefereshRate中HwcConfig计算的一帧时长</li></ol><p><strong>整个投票过程简述:</strong></p><ol><li>首先计算所有不同LayerVoteType的数量</li><li>如果没有显式Layer,即ExplicitDefault和ExplicitExactOrMultiple类型,且存在触摸事件, 直接选择主范围刷新率最大帧率</li><li>没有touch事件且屏幕处于idle状态, 刷新率存在一定范围或者不存在显示请求刷新率的Layer时, 选择主范围刷新率最小帧率</li><li>没有Layer或者所有Layer都没有投票(NoVote)时, 选择最大帧率</li><li>存在Layer且所有Layer要么不投票，要么请求最小帧率时，选择最小帧率</li><li>当上述条件都不满足时，遍历所有Layer计算每个AppRequestRefreshRate的得分，找到最佳刷新率, 注意遍历时, 忽略不投票或者投票选择最小帧率的Layer<ol><li>遍历所有AppRequestRefreshRate<ol><li>只有ExplicitDefault或者ExplicitExactOrMultiple类型的Layer，且该Layer是有焦点的才允许投票超出刷新率请求范围的帧率，否则忽略该Layer</li><li>如果Layer是Max类型<ol><li>用当前layer(app)请求的帧率除以最后一个layer(app)请求的帧率,得到的比值的平方乘以权重，计入当前AppRequestRefreshRate的分数</li></ol></li><li>如果是ExplicitDefault类型的Layer<ol><li>找到Layer将渲染的实际速率，首先假设layer.desiredRefreshRate计算的Period是渲染帧的最短时间</li><li>将该AppReqeustRefereshRate中的Display Period刷新时长依次翻倍，直到满足该Layer刷新的最低时长，也就是fps大小每次折半</li><li>此时layer分数为 layer所需的时长除以满足刷新要求的最长时长在乘以权重计入当前AppRequestRefreshRate的分数</li></ol></li><li>如果是ExplicitExactOrMultiple或者Heuristic类型的Layer<ol><li>首先计算需要多少个显示vSync来显示这个层的一个帧，即计算 layerPeriod&#x2F;displayPeriod 得到商 quot 和余数 rem</li><li>如果是整数倍关系，当前AppRequestRefreshRate的分数直接加上该Layer的权重</li><li>当layer请求的fps比AppReqeustRefereshRate中的实际display的fps要大的时候，得分是layer period除以display period的商的十一分之一乘以layer的权重</li><li>layer所需的刷新率低于的显示刷新率，但又不是整数倍关系时，用 Pl 表述 layer period，Pd表示display period<ol><li>diff0 &#x3D; 2 * (Pl mod Pd) - Pd, Pl &gt; Pd 且 K ∈ {1,2,3,…,9}</li><li>当diff0 &gt; 0 时, diff &#x3D; (Pl mod Pd) * 2^k - Pd * (2^k-1)</li><li>当diff0 &lt; 0 时, diff &#x3D; Pd - 2^k * (Pl mode Pd)</li><li>当diff小于800时(差值小于800us), 或者k&gt;9结束, 得分是当前Layer的权重乘以1&#x2F;(2K)</li></ol></li></ol></li></ol></li></ol></li><li>如果存在请求最大帧率的layer就反向遍历,找到得分最大的帧率 bestRefreshRate</li><li>如果显示主刷新率没有范围，比如最小值和最大值都是120Hz时<ol><li>如果没有layer参与评分，从显示主刷新范围选取最大值</li><li>否则返回计算得出的最佳刷新率</li></ol></li><li>如果存在touch事件, 不存在ExplicitDefault的Layer且显示主范围刷新率最大值大于计算的刷新率时, 采用最大刷新率</li><li>以上条件均不满足时，返回计算的bestRefreshRate</li></ol><p>好了，本次分析到此为止，接下来就是继续看SurfaceFlinger如何通知HWC硬件切换帧率了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下分析基于Android R.&lt;/p&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;上一章我们分析了App是如何通过更改一个小小的WindowManager的LayoutParam的属性，来影响Framework决策帧率变化的。&lt;/p&gt;
&lt;p&gt;接来下我们详细看看SurfaceFlinger是如何根据Framework传入的帧率参数选择合适帧率的。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/categories/Android/Vsync/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
  </entry>
  
  <entry>
    <title>App申请帧率(2)--Framework选择最近帧率范围</title>
    <link href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/"/>
    <id>https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-2-Framework%E9%80%89%E6%8B%A9%E6%9C%80%E8%BF%91%E5%B8%A7%E7%8E%87%E8%8C%83%E5%9B%B4/</id>
    <published>2022-02-26T19:53:41.000Z</published>
    <updated>2022-02-26T19:58:50.653Z</updated>
    
    <content type="html"><![CDATA[<p>以下分析基于Android Q.</p><span id="more"></span><h1 id="一-preferredDisplayModeId改变"><a href="#一-preferredDisplayModeId改变" class="headerlink" title="一. preferredDisplayModeId改变"></a>一. preferredDisplayModeId改变</h1><p>上篇文章讲到，只要将window的Param设置就可以更改屏幕分辨率：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmParams!!.preferredDisplayModeId = highestMode.modeId</span><br></pre></td></tr></table></figure><p>代码是和实现的呢, 在App接受vsync信号后，会回调Choreographer.CALLBACK_TRAVERSAL，也就会调用到ViewRootImpl.doTraversal.</p><p>调用栈如下:</p><ol><li>Choreographer.onVsync()</li><li>Choreographer.doFrame() &#x2F;&#x2F; doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</li><li>ViewRootImpl.doTraversal()</li><li>ViewRootImpl.performTraversals()</li><li>ViewRootImpl.relayoutWindow() &#x2F;&#x2F; 这里将当前Window的Attr传入WindowManagerService</li><li>IWindowSession.relayout() &#x2F;&#x2F; 通过binder调用 Session.relayout</li><li>WindowManagerService.relayoutWindow() &#x2F;&#x2F; 进入SystenServer进程</li><li>WindowSurfacePlacer.performSurfacePlacement()</li><li>WindowSurfacePlacer.performSurfacePlacementLoop()</li><li>RootWindowContainer.performSurfacePlacement()</li><li>RootWindowContainer.performSurfacePlacementNoTrace()</li><li>RootWindowContainer.applySurfaceChangesTransaction()<ol><li>DisplayContent.applySurfaceChangesTransaction()<ol><li>DisplayContent.mApplySurfaceChangesTransaction &#x2F;&#x2F; 对所有window遍历执行，如果有属性变化响应变化</li><li>DisplayManagerService.setDisplayProperties &#x2F;&#x2F; 计算并保存合适的modeId</li></ol></li><li>DisplayManagerInternal.performTraversal(mDisplayTransaction) &#x2F;&#x2F; 应用modeId变化</li></ol></li></ol><h2 id="1-1-RootWindowContainer-applySurfaceChangesTransaction"><a href="#1-1-RootWindowContainer-applySurfaceChangesTransaction" class="headerlink" title="1.1 RootWindowContainer.applySurfaceChangesTransaction"></a>1.1 RootWindowContainer.applySurfaceChangesTransaction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">applySurfaceChangesTransaction</span><span class="params">(<span class="type">boolean</span> recoveringMemory)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mChildren.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; ++j) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> mChildren.get(j);</span><br><span class="line">        <span class="comment">// 1.2 对每个display都计算变化</span></span><br><span class="line">        dc.applySurfaceChangesTransaction(recoveringMemory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 通知SurfaceFlinger改变ModeId</span></span><br><span class="line">    mWmService.mDisplayManagerInternal.performTraversal(mDisplayTransaction);</span><br><span class="line">    SurfaceControl.mergeToGlobalTransaction(mDisplayTransaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-DisplayContent-applySurfaceChangesTransaction"><a href="#1-2-DisplayContent-applySurfaceChangesTransaction" class="headerlink" title="1.2 DisplayContent.applySurfaceChangesTransaction()"></a>1.2 DisplayContent.applySurfaceChangesTransaction()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">applySurfaceChangesTransaction</span><span class="params">(<span class="type">boolean</span> recoveringMemory)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;applyWindowSurfaceChanges&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.3 遍历所有window, 按照Z轴从上到下</span></span><br><span class="line">        forAllWindows(mApplySurfaceChangesTransaction, <span class="literal">true</span> <span class="comment">/* traverseTopToBottom */</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    prepareSurfaces();</span><br><span class="line"></span><br><span class="line">    mLastHasContent = mTmpApplySurfaceChangesTransactionState.displayHasContent;</span><br><span class="line">    <span class="comment">// 1.4 应用需要Display属性变化</span></span><br><span class="line">    mWmService.mDisplayManagerInternal.setDisplayProperties(mDisplayId,</span><br><span class="line">            mLastHasContent,</span><br><span class="line">            mTmpApplySurfaceChangesTransactionState.preferredRefreshRate,</span><br><span class="line">            mTmpApplySurfaceChangesTransactionState.preferredModeId,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/* inTraversal, must call performTraversalInTrans... below */</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-DisplayContent-mApplySurfaceChangesTransaction"><a href="#1-3-DisplayContent-mApplySurfaceChangesTransaction" class="headerlink" title="1.3 DisplayContent.mApplySurfaceChangesTransaction"></a>1.3 DisplayContent.mApplySurfaceChangesTransaction</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Consumer&lt;WindowState&gt; mApplySurfaceChangesTransaction = w -&gt; &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!mTmpApplySurfaceChangesTransactionState.obscured) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 获取wmParams.preferredDisplayModeId中的modeId</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">preferredModeId</span> <span class="operator">=</span> getDisplayPolicy().getRefreshRatePolicy()</span><br><span class="line">                .getPreferredModeId(w);</span><br><span class="line">        <span class="comment">// 注意这里是按照Z轴从上到下遍历Window，所以只会取第一个可见的有Surface的且被设置的window的modeId</span></span><br><span class="line">        <span class="keyword">if</span> (mTmpApplySurfaceChangesTransactionState.preferredModeId == <span class="number">0</span></span><br><span class="line">                &amp;&amp; preferredModeId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 标记preferredModeId</span></span><br><span class="line">            mTmpApplySurfaceChangesTransactionState.preferredModeId = preferredModeId;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-DisplayManagerService-setDisplayProperties"><a href="#1-4-DisplayManagerService-setDisplayProperties" class="headerlink" title="1.4 DisplayManagerService.setDisplayProperties"></a>1.4 DisplayManagerService.setDisplayProperties</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDisplayProperties</span><span class="params">(<span class="type">int</span> displayId, <span class="type">boolean</span> hasContent,</span></span><br><span class="line"><span class="params">        <span class="type">float</span> requestedRefreshRate, <span class="type">int</span> requestedMode, <span class="type">boolean</span> inTraversal)</span> &#123;</span><br><span class="line">    setDisplayPropertiesInternal(displayId, hasContent, requestedRefreshRate,</span><br><span class="line">            requestedMode, inTraversal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setDisplayPropertiesInternal</span><span class="params">(<span class="type">int</span> displayId, <span class="type">boolean</span> hasContent,</span></span><br><span class="line"><span class="params">        <span class="type">float</span> requestedRefreshRate, <span class="type">int</span> requestedModeId, <span class="type">boolean</span> inTraversal)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        <span class="type">LogicalDisplay</span> <span class="variable">display</span> <span class="operator">=</span> mLogicalDisplays.get(displayId);</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display.hasContentLocked() != hasContent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">&quot;Display &quot;</span> + displayId + <span class="string">&quot; hasContent flag changed: &quot;</span></span><br><span class="line">                        + <span class="string">&quot;hasContent=&quot;</span> + hasContent + <span class="string">&quot;, inTraversal=&quot;</span> + inTraversal);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            display.setHasContentLocked(hasContent);</span><br><span class="line">            scheduleTraversalLocked(inTraversal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当应用仅仅设置了刷新率，而没有设置modeId时，需要找到一个合适的modeId</span></span><br><span class="line">        <span class="comment">// 为什么这么做呢，因为modeId不仅仅包含刷新率，还有分辨率。</span></span><br><span class="line">        <span class="comment">// 当请求刷新率变化时，是不能或不必要改变分辨率的，所以就需要找到分辨率不变的modeId</span></span><br><span class="line">        <span class="keyword">if</span> (requestedModeId == <span class="number">0</span> &amp;&amp; requestedRefreshRate != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Scan supported modes returned by display.getInfo() to find a mode with the same</span></span><br><span class="line">            <span class="comment">// size as the default display mode but with the specified refresh rate instead.</span></span><br><span class="line">            requestedModeId = display.getDisplayInfoLocked().findDefaultModeByRefreshRate(</span><br><span class="line">                    requestedRefreshRate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.1 发现有应用请求Display改变modeId</span></span><br><span class="line">        mDisplayModeDirector.getAppRequestObserver().setAppRequestedMode(</span><br><span class="line">                displayId, requestedModeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-DisplayModeDirector"><a href="#二-DisplayModeDirector" class="headerlink" title="二. DisplayModeDirector"></a>二. DisplayModeDirector</h1><p>这个类是用于决策当前设备刷新率的</p><h2 id="2-1-DisplayModeDirector-AppRequestObserver-setAppRequestedMode"><a href="#2-1-DisplayModeDirector-AppRequestObserver-setAppRequestedMode" class="headerlink" title="2.1 DisplayModeDirector.AppRequestObserver.setAppRequestedMode"></a>2.1 DisplayModeDirector.AppRequestObserver.setAppRequestedMode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAppRequestedMode</span><span class="params">(<span class="type">int</span> displayId, <span class="type">int</span> modeId)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        setAppRequestedModeLocked(displayId, modeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setAppRequestedModeLocked</span><span class="params">(<span class="type">int</span> displayId, <span class="type">int</span> modeId)</span> &#123;</span><br><span class="line">    <span class="comment">// 做一个参数检查，确保displayId和modeId参数是可接受的</span></span><br><span class="line">    <span class="keyword">final</span> Display.<span class="type">Mode</span> <span class="variable">requestedMode</span> <span class="operator">=</span> findModeByIdLocked(displayId, modeId);</span><br><span class="line">    <span class="comment">// 如果当前displayId下的modeId已经是App所需的modeId，就不用继续了</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(requestedMode, mAppRequestedModeByDisplay.get(displayId))) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Vote refreshRateVote;</span><br><span class="line">    <span class="keyword">final</span> Vote sizeVote;</span><br><span class="line">    <span class="keyword">if</span> (requestedMode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 保存当前App设置的参数</span></span><br><span class="line">        mAppRequestedModeByDisplay.put(displayId, requestedMode);</span><br><span class="line">        <span class="type">float</span> <span class="variable">refreshRate</span> <span class="operator">=</span> requestedMode.getRefreshRate();</span><br><span class="line">        <span class="comment">// 创建刷新率Vote</span></span><br><span class="line">        refreshRateVote = Vote.forRefreshRates(refreshRate, refreshRate);</span><br><span class="line">        sizeVote = Vote.forSize(requestedMode.getPhysicalWidth(),</span><br><span class="line">                requestedMode.getPhysicalHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mAppRequestedModeByDisplay.remove(displayId);</span><br><span class="line">        refreshRateVote = <span class="literal">null</span>;</span><br><span class="line">        sizeVote = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateVoteLocked(displayId, Vote.PRIORITY_APP_REQUEST_REFRESH_RATE, refreshRateVote);</span><br><span class="line">    updateVoteLocked(displayId, Vote.PRIORITY_APP_REQUEST_SIZE, sizeVote);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-DisplayModeDirector-Vote-updateVoteLocked"><a href="#2-2-DisplayModeDirector-Vote-updateVoteLocked" class="headerlink" title="2.2 DisplayModeDirector.Vote.updateVoteLocked"></a>2.2 DisplayModeDirector.Vote.updateVoteLocked</h2><p>更新Vote策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateVoteLocked</span><span class="params">(<span class="type">int</span> displayId, <span class="type">int</span> priority, Vote vote)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;updateVoteLocked(displayId=&quot;</span> + displayId</span><br><span class="line">                + <span class="string">&quot;, priority=&quot;</span> + Vote.priorityToString(priority)</span><br><span class="line">                + <span class="string">&quot;, vote=&quot;</span> + vote + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (priority &lt; Vote.MIN_PRIORITY || priority &gt; Vote.MAX_PRIORITY) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Received a vote with an invalid priority, ignoring:&quot;</span></span><br><span class="line">                + <span class="string">&quot; priority=&quot;</span> + Vote.priorityToString(priority)</span><br><span class="line">                + <span class="string">&quot;, vote=&quot;</span> + vote, <span class="keyword">new</span> <span class="title class_">Throwable</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前display的所有Vote</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;Vote&gt; votes = getOrCreateVotesByDisplay(displayId);</span><br><span class="line">    <span class="comment">// 获取PRIORITY_APP_REQUEST_REFRESH_RATE优先级的Vote，不过根本没有用？</span></span><br><span class="line">    <span class="type">Vote</span> <span class="variable">currentVote</span> <span class="operator">=</span> votes.get(priority);</span><br><span class="line">    <span class="comment">// 传入的Vote不为空，说明有符合要求的ModeId,就保存，没有就移除当前优先级的Vote</span></span><br><span class="line">    <span class="keyword">if</span> (vote != <span class="literal">null</span>) &#123;</span><br><span class="line">        votes.put(priority, vote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        votes.remove(priority);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (votes.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">&quot;No votes left for display &quot;</span> + displayId + <span class="string">&quot;, removing.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mVotesByDisplay.remove(displayId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知ModeId改变</span></span><br><span class="line">    notifyAllowedModesChangedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-DisplayModeDirector-Vote-notifyAllowedModesChangedLocked"><a href="#2-3-DisplayModeDirector-Vote-notifyAllowedModesChangedLocked" class="headerlink" title="2.3 DisplayModeDirector.Vote.notifyAllowedModesChangedLocked"></a>2.3 DisplayModeDirector.Vote.notifyAllowedModesChangedLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyAllowedModesChangedLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="literal">null</span> &amp;&amp; !mHandler.hasMessages(MSG_ALLOWED_MODES_CHANGED)) &#123;</span><br><span class="line">        <span class="comment">// We need to post this to a handler to avoid calling out while holding the lock</span></span><br><span class="line">        <span class="comment">// since we know there are things that both listen for changes as well as provide</span></span><br><span class="line">        <span class="comment">// information. If we did call out while holding the lock, then there&#x27;s no guaranteed</span></span><br><span class="line">        <span class="comment">// lock order and we run the real of risk deadlock.</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mHandler.obtainMessage(MSG_ALLOWED_MODES_CHANGED, mListener);</span><br><span class="line">        msg.sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DisplayModeDirectorHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    DisplayModeDirectorHandler(Looper looper) &#123;</span><br><span class="line">        <span class="built_in">super</span>(looper, <span class="literal">null</span>, <span class="literal">true</span> <span class="comment">/*async*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_ALLOWED_MODES_CHANGED:</span><br><span class="line">                <span class="type">Listener</span> <span class="variable">listener</span> <span class="operator">=</span> (Listener) msg.obj;</span><br><span class="line">                listener.onAllowedDisplayModesChanged();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到DisplayThread线程处理，也就是回调onAllowedDisplayModesChanged.<br>这里的mListener是调用DisplayModeDirector.setListener设置的，这个是在DisplayManagerService中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called when the system is ready to go.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">systemReady</span><span class="params">(<span class="type">boolean</span> safeMode, <span class="type">boolean</span> onlyCore)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        mSafeMode = safeMode;</span><br><span class="line">        mOnlyCore = onlyCore;</span><br><span class="line">        mSystemReady = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Just in case the top inset changed before the system was ready. At this point, any</span></span><br><span class="line">        <span class="comment">// relevant configuration should be in place.</span></span><br><span class="line">        recordTopInsetLocked(mLogicalDisplays.get(Display.DEFAULT_DISPLAY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里：</span></span><br><span class="line">    mDisplayModeDirector.setListener(<span class="keyword">new</span> <span class="title class_">AllowedDisplayModeObserver</span>());</span><br><span class="line">    mDisplayModeDirector.start(mSensorManager);</span><br><span class="line"></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_REGISTER_ADDITIONAL_DISPLAY_ADAPTERS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-DisplayManagerService-onAllowedDisplayModesChangedInternal"><a href="#2-4-DisplayManagerService-onAllowedDisplayModesChangedInternal" class="headerlink" title="2.4 DisplayManagerService.onAllowedDisplayModesChangedInternal"></a>2.4 DisplayManagerService.onAllowedDisplayModesChangedInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">onAllowedDisplayModesChangedInternal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mLogicalDisplays.size();</span><br><span class="line">        <span class="comment">// 遍历所有的Display，依次设置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">LogicalDisplay</span> <span class="variable">display</span> <span class="operator">=</span> mLogicalDisplays.valueAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">displayId</span> <span class="operator">=</span> mLogicalDisplays.keyAt(i);</span><br><span class="line">            <span class="comment">// 2.5 获取displayId对应的ModeIds</span></span><br><span class="line">            <span class="type">int</span>[] allowedModes = mDisplayModeDirector.getAllowedModes(displayId);</span><br><span class="line">            <span class="comment">// Note that order is important here since not all display devices are capable of</span></span><br><span class="line">            <span class="comment">// automatically switching, so we do actually want to check for equality and not</span></span><br><span class="line">            <span class="comment">// just equivalent contents (regardless of order).</span></span><br><span class="line">            <span class="keyword">if</span> (!Arrays.equals(allowedModes, display.getAllowedDisplayModesLocked())) &#123;</span><br><span class="line">                <span class="comment">// 保存modeId集，以便判断是否有modeId变化，这个判断条件内getAllowedDisplayModesLocked</span></span><br><span class="line">                <span class="comment">// 拿到的modeId数组就是上一次在这里保存的</span></span><br><span class="line">                display.setAllowedDisplayModesLocked(allowedModes);</span><br><span class="line">                changed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有改变, 请求下一次Vsync, 以确保通知到SurfaceFlinger有modeId更改</span></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            scheduleTraversalLocked(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-DisplayModeDirector-getAllowedModes"><a href="#2-5-DisplayModeDirector-getAllowedModes" class="headerlink" title="2.5 DisplayModeDirector.getAllowedModes"></a>2.5 DisplayModeDirector.getAllowedModes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] getAllowedModes(<span class="type">int</span> displayId) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 取出displayId对应的所有Vote，注意这里包含GLOBAL_ID(-1), 即全局生效的Vote</span></span><br><span class="line">        SparseArray&lt;Vote&gt; votes = getVotesLocked(displayId);</span><br><span class="line">        Display.Mode[] modes = mSupportedModesByDisplay.get(displayId);</span><br><span class="line">        Display.<span class="type">Mode</span> <span class="variable">defaultMode</span> <span class="operator">=</span> mDefaultModeByDisplay.get(displayId);</span><br><span class="line">        <span class="keyword">if</span> (modes == <span class="literal">null</span> || defaultMode == <span class="literal">null</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">&quot;Asked about unknown display, returning empty allowed set! (id=&quot;</span></span><br><span class="line">                    + displayId + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.5.1 计算</span></span><br><span class="line">        <span class="keyword">return</span> getAllowedModesLocked(votes, modes, defaultMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算displayId对应允许的可自由切换的modeId列表</p><h3 id="2-5-1-DisplayModeDirector-getAllowedModesLocked"><a href="#2-5-1-DisplayModeDirector-getAllowedModesLocked" class="headerlink" title="2.5.1 DisplayModeDirector.getAllowedModesLocked"></a>2.5.1 DisplayModeDirector.getAllowedModesLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] getAllowedModesLocked(<span class="meta">@NonNull</span> SparseArray&lt;Vote&gt; votes,</span><br><span class="line">        <span class="meta">@NonNull</span> Display.Mode[] modes, <span class="meta">@NonNull</span> Display.Mode defaultMode) &#123;</span><br><span class="line">    <span class="comment">// 从最低优先级开始遍历，不过为什么会有两层循环？</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lowestConsideredPriority</span> <span class="operator">=</span> Vote.MIN_PRIORITY;</span><br><span class="line">    <span class="keyword">while</span> (lowestConsideredPriority &lt;= Vote.MAX_PRIORITY) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">minRefreshRate</span> <span class="operator">=</span> <span class="number">0f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">maxRefreshRate</span> <span class="operator">=</span> Float.POSITIVE_INFINITY;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> Vote.INVALID_SIZE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> Vote.INVALID_SIZE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从优先级最大的开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">priority</span> <span class="operator">=</span> Vote.MAX_PRIORITY;</span><br><span class="line">                priority &gt;= lowestConsideredPriority;</span><br><span class="line">                priority--) &#123;</span><br><span class="line">            <span class="type">Vote</span> <span class="variable">vote</span> <span class="operator">=</span> votes.get(priority);</span><br><span class="line">            <span class="keyword">if</span> (vote == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 刷新率最小值取两者中的较大值</span></span><br><span class="line">            minRefreshRate = Math.max(minRefreshRate, vote.minRefreshRate);</span><br><span class="line">            <span class="comment">// 刷新率最大值取两者中的较小值</span></span><br><span class="line">            maxRefreshRate = Math.min(maxRefreshRate, vote.maxRefreshRate);</span><br><span class="line">            <span class="comment">// 显示大小只需要取第一个值</span></span><br><span class="line">            <span class="keyword">if</span> (height == Vote.INVALID_SIZE &amp;&amp; width == Vote.INVALID_SIZE</span><br><span class="line">                    &amp;&amp; vote.height &gt; <span class="number">0</span> &amp;&amp; vote.width &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                width = vote.width;</span><br><span class="line">                height = vote.height;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we don&#x27;t have anything specifying the width / height of the display, just use the</span></span><br><span class="line">        <span class="comment">// default width and height. We don&#x27;t want these switching out from underneath us since</span></span><br><span class="line">        <span class="comment">// it&#x27;s a pretty disruptive behavior.</span></span><br><span class="line">        <span class="keyword">if</span> (height == Vote.INVALID_SIZE || width == Vote.INVALID_SIZE) &#123;</span><br><span class="line">            width = defaultMode.getPhysicalWidth();</span><br><span class="line">            height = defaultMode.getPhysicalHeight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.5.2 获取可取的mode</span></span><br><span class="line">        <span class="type">int</span>[] availableModes =</span><br><span class="line">                filterModes(modes, width, height, minRefreshRate, maxRefreshRate);</span><br><span class="line">        <span class="keyword">if</span> (availableModes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableModes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前优先级下没有找到合适的modeId时，提高优先级重新搜索</span></span><br><span class="line">        lowestConsideredPriority++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we still haven&#x27;t found anything that matches our current set of votes, just fall back</span></span><br><span class="line">    <span class="comment">// to the default mode.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; defaultMode.getModeId() &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里刷新率的算法是，遍历所有优先级的Vote，最终的minRefreshRate取所有Vote的最小刷新率中的最大值。<br>maxRefreshRate取所有Vote中最大刷新率的最小值。</p><p>这里有个地方一开始比较难理解，就是为什么是用双层循环，而且第一层循环是从优先级最低的开始，最内层是优先级最大的开始。不着急我们先看#2.5.2</p><h3 id="2-5-2-DisplayModeDirector-filterModes"><a href="#2-5-2-DisplayModeDirector-filterModes" class="headerlink" title="2.5.2 DisplayModeDirector.filterModes"></a>2.5.2 DisplayModeDirector.filterModes</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] filterModes(Display.Mode[] supportedModes,</span><br><span class="line">        <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">float</span> minRefreshRate, <span class="type">float</span> maxRefreshRate) &#123;</span><br><span class="line">    ArrayList&lt;Display.Mode&gt; availableModes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Display.Mode mode : supportedModes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode.getPhysicalWidth() != width || mode.getPhysicalHeight() != height) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> <span class="variable">refreshRate</span> <span class="operator">=</span> mode.getRefreshRate();</span><br><span class="line">        <span class="comment">// EPSILON = 0.001f</span></span><br><span class="line">        <span class="comment">// 为啥会有这呢，因为小数计算会有误差</span></span><br><span class="line">        <span class="comment">// 比如60Hz的刷新的vsync间隔是16.666666ms</span></span><br><span class="line">        <span class="comment">// 计算得来的refreshRate就是：1000/16.666666 = 60.0000024</span></span><br><span class="line">        <span class="comment">// 不是恰好为60，所以需要去掉这个误差</span></span><br><span class="line">        <span class="keyword">if</span> (refreshRate &lt; (minRefreshRate - EPSILON)</span><br><span class="line">                || refreshRate &gt; (maxRefreshRate + EPSILON)) &#123;</span><br><span class="line">            <span class="comment">// 当该mode的刷新率不符合边界条件时，抛弃该mode</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        availableModes.add(mode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> availableModes.size();</span><br><span class="line">    <span class="type">int</span>[] availableModeIds = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        availableModeIds[i] = availableModes.get(i).getModeId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回符合要求的modeId集合</span></span><br><span class="line">    <span class="keyword">return</span> availableModeIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实实际推演一下就不难理解了, 假设我们有如下Votes:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mSupportedModesByDisplay:</span><br><span class="line">    0 -&gt; [</span><br><span class="line">        &#123;id=1, width=1080, height=2376, fps=60.000004&#125;, </span><br><span class="line">        &#123;id=2, width=1440, height=3168, fps=120.00001&#125;, </span><br><span class="line">        &#123;id=3, width=1440, height=3168, fps=60.000004&#125;, </span><br><span class="line">        &#123;id=4, width=1080, height=2376, fps=120.00001&#125;]</span><br><span class="line"></span><br><span class="line">  mVotesByDisplay:</span><br><span class="line">    -1:</span><br><span class="line">      PRIORITY_LOW_POWER_MODE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=60.0&#125;</span><br><span class="line">      PRIORITY_USER_SETTING_PEAK_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=120.0&#125;</span><br><span class="line">      PRIORITY_USER_SETTING_MIN_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=0.0, maxRefreshRate=Infinity&#125;</span><br><span class="line">    0:</span><br><span class="line">      PRIORITY_APP_REQUEST_SIZE -&gt; Vote&#123;width=1080, height=2376, minRefreshRate=0.0, maxRefreshRate=Infinity&#125;</span><br><span class="line">      PRIORITY_APP_REQUEST_REFRESH_RATE -&gt; Vote&#123;width=-1, height=-1, minRefreshRate=120.00001, maxRefreshRate=120.00001&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意这里的优先级:</p><table><thead><tr><th>name</th><th>Value</th></tr></thead><tbody><tr><td>PRIORITY_LOW_BRIGHTNESS</td><td>0</td></tr><tr><td>PRIORITY_USER_SETTING_MIN_REFRESH_RATE</td><td>1</td></tr><tr><td>PRIORITY_APP_REQUEST_REFRESH_RATE</td><td>2</td></tr><tr><td>PRIORITY_APP_REQUEST_SIZE</td><td>3</td></tr><tr><td>PRIORITY_USER_SETTING_PEAK_REFRESH_RATE</td><td>4</td></tr><tr><td>PRIORITY_LOW_POWER_MODE</td><td>5</td></tr></tbody></table><p><strong>当外层循环第一次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_LOW_BRIGHTNESS &#x3D; 0</p><p>内层循环会遍历所有Vote(包含-1，和当前displayId,这里是0):</p><p>算出的minRefreshRate &#x3D; Infinity, maxRefreshRate &#x3D;0</p><p>当然，在filterModes中是找不到合适的mode的，所以优先级+1，继续搜索</p><p><strong>外层循环第二次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_USER_SETTING_MIN_REFRESH_RATE &#x3D; 1</p><p>此时排除优先级为0的所有Vote，其实结果还是一样，所以lowestConsideredPriority继续+1</p><p><strong>外层循环第三次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_APP_REQUEST_REFRESH_RATE &#x3D; 2</p><p>此时排除优先级小于PRIORITY_APP_REQUEST_REFRESH_RATE的所有Vote，结果还是一样，所以lowestConsideredPriority继续+1</p><p><strong>外层循环第四次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_APP_REQUEST_SIZE &#x3D; 3</p><p>此时排除优先级小于PRIORITY_APP_REQUEST_SIZE的所有Vote，结果还是一样，所以lowestConsideredPriority继续+1</p><p><strong>外层循环第五次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_USER_SETTING_PEAK_REFRESH_RATE &#x3D; 4</p><p>此时排除优先级小于PRIORITY_USER_SETTING_PEAK_REFRESH_RATE的所有Vote</p><p>内层循环其实只有两个选项：</p><p>PRIORITY_LOW_POWER_MODE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;60.0}</p><p>PRIORITY_USER_SETTING_PEAK_REFRESH_RATE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;120.0}</p><p>此时结果为minRefreshRate &#x3D; 60, maxRefreshRate &#x3D;0，当然还是没有有效的modeId</p><p><strong>外层循环第六次执行时</strong>：lowestConsideredPriority &#x3D; PRIORITY_LOW_POWER_MODE &#x3D; 5</p><p>只有选项：PRIORITY_LOW_POWER_MODE -&gt; Vote{width&#x3D;-1, height&#x3D;-1, minRefreshRate&#x3D;0.0, maxRefreshRate&#x3D;60.0}</p><p>所以最终的minRefreshRate &#x3D; 0.0, maxRefreshRate &#x3D; 60.0，width&#x3D;1080, height&#x3D;2376</p><p>最后满足条件的modeId就只有mSupportedModesByDisplay中的0了.</p><p>最终算出来了modeId, 这里面计算复杂，弯弯绕绕，为什么Google如此设计呢，个人猜测是为了尽可能满足低优先级下的刷新率要求，并不是优先级最高就能决定modeId的取值,<br>而是找到尽快满足更多优先级下合适刷新率的modeId集提供给SurfaceFlinger选择.</p><p>继续往下看，framework将这个modeId集传给SurfaceFlinger.</p><h1 id="三-通知SurfaceFlinger变化"><a href="#三-通知SurfaceFlinger变化" class="headerlink" title="三. 通知SurfaceFlinger变化"></a>三. 通知SurfaceFlinger变化</h1><h2 id="3-1-DisplayManagerInternal-performTraversal"><a href="#3-1-DisplayManagerInternal-performTraversal" class="headerlink" title="3.1 DisplayManagerInternal.performTraversal"></a>3.1 DisplayManagerInternal.performTraversal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTraversal</span><span class="params">(SurfaceControl.Transaction t)</span> &#123;</span><br><span class="line">    performTraversalInternal(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-DisplayManagerService-performTraversalInternal"><a href="#3-2-DisplayManagerService-performTraversalInternal" class="headerlink" title="3.2 DisplayManagerService.performTraversalInternal"></a>3.2 DisplayManagerService.performTraversalInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">performTraversalInternal</span><span class="params">(SurfaceControl.Transaction t)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mPendingTraversal) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingTraversal = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 3.2.1 通知SF有相关状态变化</span></span><br><span class="line">        performTraversalLocked(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// List is self-synchronized copy-on-write.</span></span><br><span class="line">    <span class="keyword">for</span> (DisplayTransactionListener listener : mDisplayTransactionListeners) &#123;</span><br><span class="line">        listener.onDisplayTransaction(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-1-DisplayManagerService-performTraversalLocked"><a href="#3-2-1-DisplayManagerService-performTraversalLocked" class="headerlink" title="3.2.1 DisplayManagerService.performTraversalLocked"></a>3.2.1 DisplayManagerService.performTraversalLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversalLocked</span><span class="params">(SurfaceControl.Transaction t)</span> &#123;</span><br><span class="line">    <span class="comment">// Clear all viewports before configuring displays so that we can keep</span></span><br><span class="line">    <span class="comment">// track of which ones we have configured.</span></span><br><span class="line">    clearViewportsLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2.2 对每个Display都做配置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mDisplayDevices.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">DisplayDevice</span> <span class="variable">device</span> <span class="operator">=</span> mDisplayDevices.get(i);</span><br><span class="line">        <span class="comment">// 与SurfaceFlinger通信，这里的device我们视为默认的LocalDisplayDevice</span></span><br><span class="line">        configureDisplayLocked(t, device);</span><br><span class="line">        device.performTraversalLocked(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-DisplayManagerService-configureDisplayLocked"><a href="#3-2-2-DisplayManagerService-configureDisplayLocked" class="headerlink" title="3.2.2 DisplayManagerService.configureDisplayLocked"></a>3.2.2 DisplayManagerService.configureDisplayLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t, DisplayDevice device)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 拿到对应LogicalDisplay</span></span><br><span class="line">    <span class="type">LogicalDisplay</span> <span class="variable">display</span> <span class="operator">=</span> findLogicalDisplayForDeviceLocked(device);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 3.2.3 应用状态变化</span></span><br><span class="line">    display.configureDisplayLocked(t, device, info.state == Display.STATE_OFF);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-LogicalDisplay-configureDisplayLocked"><a href="#3-2-3-LogicalDisplay-configureDisplayLocked" class="headerlink" title="3.2.3 LogicalDisplay.configureDisplayLocked"></a>3.2.3 LogicalDisplay.configureDisplayLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t,</span></span><br><span class="line"><span class="params">        DisplayDevice device,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> isBlanked)</span> &#123;</span><br><span class="line">    <span class="comment">// Set the layer stack.</span></span><br><span class="line">    device.setLayerStackLocked(t, isBlanked ? BLANK_LAYER_STACK : mLayerStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 应用配置变化，注意这里的device是LocalDisplayDevice</span></span><br><span class="line">    <span class="keyword">if</span> (device == mPrimaryDisplayDevice) &#123;</span><br><span class="line">        device.setAllowedDisplayModesLocked(mAllowedDisplayModes);</span><br><span class="line">        device.setRequestedColorModeLocked(mRequestedColorMode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Reset to default for non primary displays</span></span><br><span class="line">        device.setAllowedDisplayModesLocked(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>&#125;);</span><br><span class="line">        device.setRequestedColorModeLocked(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-LocalDisplayAdapter-LocalDisplayDevice-setAllowedDisplayModesLocked"><a href="#3-3-LocalDisplayAdapter-LocalDisplayDevice-setAllowedDisplayModesLocked" class="headerlink" title="3.3 LocalDisplayAdapter.LocalDisplayDevice.setAllowedDisplayModesLocked"></a>3.3 LocalDisplayAdapter.LocalDisplayDevice.setAllowedDisplayModesLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAllowedDisplayModesLocked</span><span class="params">(<span class="type">int</span>[] modes)</span> &#123;</span><br><span class="line">    updateAllowedModesLocked(modes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAllowedModesLocked</span><span class="params">(<span class="type">int</span>[] allowedModes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Arrays.equals(allowedModes, mAllowedModeIds) &amp;&amp; !mAllowedModeIdsInvalid) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (updateAllowedModesInternalLocked(allowedModes)) &#123;</span><br><span class="line">        updateDeviceInfoLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateAllowedModesInternalLocked</span><span class="params">(<span class="type">int</span>[] allowedModes)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;updateAllowedModesInternalLocked(allowedModes=&quot;</span></span><br><span class="line">                + Arrays.toString(allowedModes) + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] allowedPhysIndexes = <span class="keyword">new</span> <span class="title class_">int</span>[allowedModes.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将modeId转化为物理modeId，简单来说就是 physicalId = modeId - 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> modeId : allowedModes) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">physIndex</span> <span class="operator">=</span> findDisplayInfoIndexLocked(modeId);</span><br><span class="line">        <span class="keyword">if</span> (physIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Requested mode ID &quot;</span> + modeId + <span class="string">&quot; not available,&quot;</span></span><br><span class="line">                    + <span class="string">&quot; dropping from allowed set.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            allowedPhysIndexes[size++] = physIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 3.4 通过SurfaceControl通知SurfaceFlinger有modeId变化，binder通信</span></span><br><span class="line">    SurfaceControl.setAllowedDisplayConfigs(getDisplayTokenLocked(), allowedPhysIndexes);</span><br><span class="line">    <span class="type">int</span> <span class="variable">activePhysIndex</span> <span class="operator">=</span> SurfaceControl.getActiveConfig(getDisplayTokenLocked());</span><br><span class="line">    <span class="keyword">return</span> updateActiveModeLocked(activePhysIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-SurfaceControl-setAllowedDisplayConfigs"><a href="#3-4-SurfaceControl-setAllowedDisplayConfigs" class="headerlink" title="3.4 SurfaceControl.setAllowedDisplayConfigs"></a>3.4 SurfaceControl.setAllowedDisplayConfigs</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">nativeSetAllowedDisplayConfigs</span><span class="params">(IBinder displayToken,</span></span><br><span class="line"><span class="params">                                                                 <span class="type">int</span>[] allowedConfigs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setAllowedDisplayConfigs</span><span class="params">(IBinder displayToken, <span class="type">int</span>[] allowedConfigs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (displayToken == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;displayToken must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allowedConfigs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;allowedConfigs must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// JNI调用</span></span><br><span class="line">    <span class="keyword">return</span> nativeSetAllowedDisplayConfigs(displayToken, allowedConfigs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-android-view-SurfaceControl-nativeSetAllowedDisplayConfigs"><a href="#3-5-android-view-SurfaceControl-nativeSetAllowedDisplayConfigs" class="headerlink" title="3.5 android_view_SurfaceControl::nativeSetAllowedDisplayConfigs"></a>3.5 android_view_SurfaceControl::nativeSetAllowedDisplayConfigs</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jboolean <span class="title">nativeSetAllowedDisplayConfigs</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject tokenObj, jintArray configArray)</span> </span>&#123;</span><br><span class="line">    <span class="function">sp&lt;IBinder&gt; <span class="title">token</span><span class="params">(ibinderForJavaObject(env, tokenObj))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">nullptr</span>) <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int32_t</span>&gt; allowedConfigs;</span><br><span class="line">    jsize configArraySize = env-&gt;<span class="built_in">GetArrayLength</span>(configArray);</span><br><span class="line">    allowedConfigs.<span class="built_in">reserve</span>(configArraySize);</span><br><span class="line"></span><br><span class="line">    jint* configArrayElements = env-&gt;<span class="built_in">GetIntArrayElements</span>(configArray, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; configArraySize; i++) &#123;</span><br><span class="line">        allowedConfigs.<span class="built_in">push_back</span>(configArrayElements[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="built_in">ReleaseIntArrayElements</span>(configArray, configArrayElements, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3.5.1 通过SurfaceComposerClient</span></span><br><span class="line">    <span class="type">size_t</span> result = SurfaceComposerClient::<span class="built_in">setAllowedDisplayConfigs</span>(token, allowedConfigs);</span><br><span class="line">    <span class="keyword">return</span> result == NO_ERROR ? JNI_TRUE : JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-1-SurfaceComposerClient-setAllowedDisplayConfigs"><a href="#3-5-1-SurfaceComposerClient-setAllowedDisplayConfigs" class="headerlink" title="3.5.1 SurfaceComposerClient::setAllowedDisplayConfigs"></a>3.5.1 SurfaceComposerClient::setAllowedDisplayConfigs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceComposerClient::setAllowedDisplayConfigs</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken, <span class="type">const</span> std::vector&lt;<span class="type">int32_t</span>&gt;&amp; allowedConfigs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过binder调用到SurfaceFlinger</span></span><br><span class="line">    <span class="keyword">return</span> ComposerService::<span class="built_in">getComposerService</span>()-&gt;<span class="built_in">setAllowedDisplayConfigs</span>(displayToken,</span><br><span class="line">                                                                           allowedConfigs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-SurfaceFlinger-setAllowedDisplayConfigs"><a href="#3-6-SurfaceFlinger-setAllowedDisplayConfigs" class="headerlink" title="3.6 SurfaceFlinger::setAllowedDisplayConfigs"></a>3.6 SurfaceFlinger::setAllowedDisplayConfigs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">SurfaceFlinger::setAllowedDisplayConfigs</span><span class="params">(<span class="type">const</span> sp&lt;IBinder&gt;&amp; displayToken,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">const</span> std::vector&lt;<span class="type">int32_t</span>&gt;&amp; allowedConfigs)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ATRACE_CALL</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!displayToken || allowedConfigs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDebugDisplayConfigSetByBackdoor) &#123;</span><br><span class="line">        <span class="comment">// ignore this request as config is overridden by backdoor</span></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">postMessageSync</span>(<span class="keyword">new</span> <span class="built_in">LambdaMessage</span>([&amp;]() &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> display = <span class="built_in">getDisplayDeviceLocked</span>(displayToken);</span><br><span class="line">        <span class="keyword">if</span> (!display) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Attempt to set allowed display configs for invalid display token %p&quot;</span>,</span><br><span class="line">                  displayToken.<span class="built_in">get</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (display-&gt;<span class="built_in">isVirtual</span>()) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;Attempt to set allowed display configs for virtual display&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Mutex::Autolock <span class="built_in">lock</span>(mStateLock);</span><br><span class="line">            <span class="built_in">setAllowedDisplayConfigsInternal</span>(display, allowedConfigs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，app设置屏幕显示刷新的流程就走完了，接下来就是SurfaceFlinger去和硬件交互，通知切换刷新率了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下分析基于Android Q.&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/categories/Android/Vsync/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
  </entry>
  
  <entry>
    <title>App申请帧率(1)--简述</title>
    <link href="https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/"/>
    <id>https://swallowjoe.github.io/2022/02/27/App%E7%94%B3%E8%AF%B7%E5%B8%A7%E7%8E%87-1-%E7%AE%80%E8%BF%B0/</id>
    <published>2022-02-26T19:53:29.000Z</published>
    <updated>2022-02-26T19:58:12.384Z</updated>
    
    <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a><ul><li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%8F%AF%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%B7%E6%96%B0%E7%8E%87%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87">查看设备可支持的刷新率和分辨率</a></li><li><a href="#app%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E5%B8%A7%E7%8E%87">App设置设备帧率</a><ul><li><a href="#android-q%E5%8F%8A%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC">Android Q及以下版本</a></li><li><a href="#android-r">Android R</a></li></ul></li></ul></li></ul><!-- /TOC --><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着手机屏幕硬件能力的提升，越来越多的厂商提供支持多档次刷新率的Android设备。<br>而在Android Q上也是支持App指定当前屏幕帧率的，也有一套帧率分辨率切换的逻辑。</p><span id="more"></span><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/142212769?from_voters_page=true">https://zhuanlan.zhihu.com/p/142212769?from_voters_page=true</a></li></ol><h2 id="查看设备可支持的刷新率和分辨率"><a href="#查看设备可支持的刷新率和分辨率" class="headerlink" title="查看设备可支持的刷新率和分辨率"></a>查看设备可支持的刷新率和分辨率</h2><p>使用命令：<br>adb shell dumpsys display dump |grep -A 10 -iE “mSupportedModes”</p><p>这里设备使用的是OnePlus8Pro，结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSupportedModes=</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=1, width=1080, height=2376, fps=60.000004&#125;&#125;</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=2, width=1440, height=3168, fps=120.00001&#125;&#125;</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=3, width=1440, height=3168, fps=60.000004&#125;&#125;</span><br><span class="line">      DisplayModeRecord&#123;mMode=&#123;id=4, width=1080, height=2376, fps=120.00001&#125;&#125;</span><br></pre></td></tr></table></figure><p>可以看到是有四种模式：</p><ol><li>1080 + 60Hz</li><li>2K + 120Hz</li><li>2K + 60Hz</li><li>1080 + 120Hz</li></ol><h2 id="App设置设备帧率"><a href="#App设置设备帧率" class="headerlink" title="App设置设备帧率"></a>App设置设备帧率</h2><h3 id="Android-Q及以下版本"><a href="#Android-Q及以下版本" class="headerlink" title="Android Q及以下版本"></a>Android Q及以下版本</h3><p>在Android Q或更低版本上，可以通过指定当前Window的帧率来设置屏幕刷新率，如选择设备可支持的最高刷新率：</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> highestMode: Display.Mode = mWindowManager!!.defaultDisplay.supportedModes[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> (mode <span class="keyword">in</span> mWindowManager!!.defaultDisplay.supportedModes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode.refreshRate &gt; highestMode.refreshRate) &#123;</span><br><span class="line">        highestMode = mode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wmParams!!.preferredDisplayModeId = highestMode.modeId</span><br></pre></td></tr></table></figure><h3 id="Android-R"><a href="#Android-R" class="headerlink" title="Android R"></a>Android R</h3><p>如 <a href="https://zhuanlan.zhihu.com/p/142212769?from_voters_page=true">Google建议</a>利用可变刷新率</p><p>在较旧的 Android 版本 (Android 11 之前) 中并不存在 setFrameRate API，这时应用仍然可以通过直接将WindowManager.LayoutParams.preferredDisplayModeId设置为Display.getSupportedModes中的可用模式之一来影响刷新率。</p><p>从 Android 11 开始，我们不建议大家采用这种方法，因为平台会不知道应用的渲染意图。</p><p>例如，如果一个设备支持 48Hz、60Hz 和 120Hz，屏幕上有两个应用分别调用 setFrameRate(60, …) 和 setFrameRate(24, …)，那么平台可以选择 120Hz 来同时满足这两个应用。</p><p>而如果这些应用使用了preferredDisplayModeId，它们很可能会把模式设置为 60Hz 和 48Hz，那这时平台就无法使用 120Hz 了。<br>这时平台只能从 60Hz 或 48Hz 中选择一个，从而影响到另一个应用的显示效果。</p><ol><li><p>获取刷新率：</p><ol><li>SDK</li></ol></li></ol><p>通过 DisplayManager.DisplayListener 注册一个显示监听器，并通过 Display.getRefreshRate 查询刷新率。<br>   2. NDK<br>使用 AChoreographer_registerRefreshRateCallback 注册回调 (API 级别30)。</p><ol start="2"><li>设置刷新率应用可以调用以下方法之一:<ol><li>SDK<ol><li><a href="https://developer.android.google.cn/reference/android/view/Surface#setFrameRate(float,%20int)">Surface.setFrameRate</a></li><li><a href="https://developer.android.google.cn/reference/android/view/SurfaceControl.Transaction.html#setFrameRate(android.view.SurfaceControl,%20float,%20int)">SurfaceControl.Transaction.setFrameRate</a></li></ol></li><li>NDK<ol><li><a href="https://developer.android.google.cn/ndk/reference/group/a-native-window#anativewindow_setframerate">ANativeWindow_setRrameRate</a></li><li>ASurfaceTransaction_setFrameRate</li></ol></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;!-- TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E5%8F%AF%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%B7%E6%96%B0%E7%8E%87%E5%92%8C%E5%88%86%E8%BE%A8%E7%8E%87&quot;&gt;查看设备可支持的刷新率和分辨率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#app%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E5%B8%A7%E7%8E%87&quot;&gt;App设置设备帧率&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#android-q%E5%8F%8A%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC&quot;&gt;Android Q及以下版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#android-r&quot;&gt;Android R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- /TOC --&gt;

&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;随着手机屏幕硬件能力的提升，越来越多的厂商提供支持多档次刷新率的Android设备。&lt;br&gt;而在Android Q上也是支持App指定当前屏幕帧率的，也有一套帧率分辨率切换的逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/categories/Android/Vsync/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Vsync" scheme="https://swallowjoe.github.io/tags/Vsync/"/>
    
  </entry>
  
  <entry>
    <title>Looper-Android中的消息机制</title>
    <link href="https://swallowjoe.github.io/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>https://swallowjoe.github.io/2022/02/27/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</id>
    <published>2022-02-26T19:48:26.000Z</published>
    <updated>2022-02-26T19:57:34.959Z</updated>
    
    <content type="html"><![CDATA[<div style="page-break-after: always;"></div><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>本文详细分析android的消息机制Looper的底层原理。</p><span id="more"></span><p><strong>以下分析基于Android S.</strong></p><p>初学Android的时候, 比较容易遇到如下错误:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E AndroidRuntime: FATAL EXCEPTION: 非UI线程</span><br><span class="line">E AndroidRuntime: Process: com.android.demo, PID: 23939</span><br><span class="line">E AndroidRuntime: android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</span><br><span class="line">E AndroidRuntime: at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:9587)</span><br><span class="line">E AndroidRuntime: at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1894)</span><br><span class="line">......</span><br><span class="line">E AndroidRuntime: at java.lang.Thread.run(Thread.java:923)</span><br></pre></td></tr></table></figure><p>往往是我们在非UI线程更新UI组件导致的。解决的方案也很简单，将更新组件的操作移入UI线程执行即可。此时就需要用到Android中非常基础又非常重要的Handler、Looper、Message这三个类:</p><figure class="highlight kt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uiHandler = UiHandler(Looper.getMainLooper())</span><br><span class="line"><span class="keyword">val</span> message = uiHandler.obtainMessage(MSG_UPDATE_UI)</span><br><span class="line">message.obj = <span class="string">&quot;我在UI线程中更新UI组件哦!&quot;</span></span><br><span class="line">uiHandler.sendMessage(message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">val</span> MSG_UPDATE_UI = <span class="number">0x1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">UiHandler</span></span>(looper: Looper) : Handler(looper) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleMessage</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg)</span><br><span class="line">        <span class="keyword">when</span> (msg.what) &#123;</span><br><span class="line">            MSG_UPDATE_UI -&gt; &#123;</span><br><span class="line">                textview.text = msg.obj <span class="keyword">as</span> String</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，设置Handler的Looper为MainLooper，然后通过sendMessage将封装数据的Message发送到MainLooper代表的UI线程中处理，就这样切换了线程。接下来我们研究下其中的原理，为什么Looper有main looper, Handler的sendMessage是怎么找到对应线程，然后调用handleMessage的。</p><p>或者通过Looper prepare的方式， 其实也是获取主线程的Looper实现的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Keep</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MSG_A</span> <span class="operator">=</span> <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MSG_B</span> <span class="operator">=</span> <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        handler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> MSG_A: &#123; <span class="comment">/* .... */</span> &#125; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> MSG_B: &#123; <span class="comment">/* .... */</span> &#125; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在需要的时候执行: handler.sendMessage(handler.obtain(MSG_A)) 即可以实现线程交换了, 除了sendMessage，还有如下方式:</p><p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Handler.png" alt="Handler"></p><p>Android系统中大量使用Message来进行跨线程通信，实现交互，设计四个类：Message、Handler、Looper和MessageQueue, 类图如下:</p><p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Looper.png" alt="Looper类图"></p><ol><li>Message: 消息，封装待传递的数据</li><li>Handler: 消息辅助类，向消息池(MessageQueue)中存入消息和接收消息进行处理</li><li>Looper:  如其名，封装一个不断循环的函数体，不停的从消息池(MessageQueue)中取出合适的消息交给Handler处理</li><li>MessageQueue: 消息池，维护了一个由消息组成的链表，该链表按照消息执行的时间顺序排列</li></ol><p>我们首先看看UI线程的Looper获取：Looper.getMainLooper()</p><h1 id="一-Main-Looper的创建"><a href="#一-Main-Looper的创建" class="headerlink" title="一. Main Looper的创建"></a>一. Main Looper的创建</h1><h2 id="1-1-Looper-getMainLooper"><a href="#1-1-Looper-getMainLooper" class="headerlink" title="1.1 Looper.getMainLooper"></a>1.1 Looper.getMainLooper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title function_">getMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> sMainLooper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的就是Looper中静态变量sMainLooper。那么该sMainLooper是何时创建的呢：</p><h2 id="1-2-sMainLooper"><a href="#1-2-sMainLooper" class="headerlink" title="1.2 sMainLooper"></a>1.2 sMainLooper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepareMainLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.2.1 Looper准备工作</span></span><br><span class="line">    prepare(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.2.3 myLooper拿的就是当前线程的Looper.</span></span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sMainLooper是在Looper.prepareMainLooper被<strong>第一次调用</strong>时赋值的。而prepareMainLooper是在ActivityThread.main函数中调用的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ActivityThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 1.3 执行loop</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Zygote启动进程时，进程的入口函数是ActivityThread.main，也就是说三方进程启动后第一时间就会调用Looper.prepareMainLooper()设置sMainLooper。</p><h3 id="1-2-1-Looper-prepare"><a href="#1-2-1-Looper-prepare" class="headerlink" title="1.2.1 Looper.prepare"></a>1.2.1 Looper.prepare</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quitAllowed 这个参数表明该Looper是否允许退出</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.2.2 注意这里创建了一个Looper, 并保存在sThreadLocal中</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>quitAllowed 这个参数表明该Looper是否允许退出，自然UI线程(主线程)是不允许退出的，除非被kill或者进程自杀。</p><p>这里稍微提一下，sThreadLocal是ThreadLocal类型，实现了线程本地存储区(Thread Local Storage, 简称TLS)。每个线程都有自己私有的存储区域，不同线程之间彼此不能访问对方的TSL区域。简单来说，可以将这里的 <strong>sThreadLocal 视为一个Map集合，其中key为Thread, value是Looper</strong>, <strong>每次set和get都是获取当前线程对应的Looper</strong></p><h3 id="1-2-2-Looper-的创建"><a href="#1-2-2-Looper-的创建" class="headerlink" title="1.2.2 Looper 的创建"></a>1.2.2 Looper 的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    <span class="comment">// 3.1 MessageQueue创建</span></span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的创建了一个MessageQueue,并保存创建该Looper的线程。</p><h3 id="1-2-3-Looper-myLooper"><a href="#1-2-3-Looper-myLooper" class="headerlink" title="1.2.3 Looper.myLooper"></a>1.2.3 Looper.myLooper</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过sThreadLocal获取当前线程对应的Looper.</p><h2 id="1-3-Looper-loop"><a href="#1-3-Looper-loop" class="headerlink" title="1.3 Looper.loop"></a>1.3 Looper.loop</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的Looper</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="comment">// Looper一定存在某个线程中，线程不一定拥有Looper</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="comment">// 用于修改记录Looper中的Message是否执行慢或者超时的时长</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有message分发超时，这个变量就会被标记为true</span></span><br><span class="line">    me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是Loop名称的由来，一直循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop()函数很简单，就一直循环执行loopOnce就可</p><h2 id="1-4-Looper-loopOnce"><a href="#1-4-Looper-loopOnce" class="headerlink" title="1.4 Looper.loopOnce"></a>1.4 Looper.loopOnce</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="comment">// 5.1 通过MessageQueue获取下一个Message, 这里稍后分析</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next();</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取的下一个Message为null，说明该Looper将要退出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mLogging是Printer的对象，可以通过: looper.setMessageLogging(printer)设置</span></span><br><span class="line">    <span class="comment">// 用于打印Looper日志，如下：</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span></span><br><span class="line">                + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> sObserver;</span><br><span class="line">    <span class="comment">// traceTag用于抓取systrace，通过looper.setTraceTag设置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">    <span class="comment">// mSlowDispatchThresholdMs和mSlowDeliveryThresholdMs默认都是0</span></span><br><span class="line">    <span class="comment">// 可以通过setSlowLogThresholdMs设置</span></span><br><span class="line">    <span class="comment">// 比如SystemServer主线程的looper就被分别设置为100ms，200ms</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line">    <span class="type">long</span> <span class="variable">slowDeliveryThresholdMs</span> <span class="operator">=</span> me.mSlowDeliveryThresholdMs;</span><br><span class="line">    <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// thresholdOverride可以通过属性修改:setprop log.looper.1000.main.slow 1</span></span><br><span class="line">        slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">        slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDelivery</span> <span class="operator">=</span> (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">logSlowDispatch</span> <span class="operator">=</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needStartTime</span> <span class="operator">=</span> logSlowDelivery || logSlowDispatch;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">needEndTime</span> <span class="operator">=</span> logSlowDispatch;</span><br><span class="line">    <span class="comment">// 开始抓取trace</span></span><br><span class="line">    <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录Message分发开始的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">        token = observer.messageDispatchStarting();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.4.1 分发message， 这里的target就是Handler</span></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.messageDispatched(token, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录消息分发结束时间</span></span><br><span class="line">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">            Trace.traceEnd(traceTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">        <span class="comment">// mSlowDeliveryDetected 表明之前就有消息等待分发超时了</span></span><br><span class="line">        <span class="keyword">if</span> (me.mSlowDeliveryDetected) &#123;</span><br><span class="line">            <span class="comment">// message分发时间和该message需要执行的时间相差不超过10ms，说明Message分发及时</span></span><br><span class="line">            <span class="comment">// 去掉之前标记的消息分发超时</span></span><br><span class="line">            <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                me.mSlowDeliveryDetected = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里就是检测Message等待分发是否超过阈值</span></span><br><span class="line">            <span class="comment">// 打印的日志如： Looper: Slow delivery took 233ms android.ui h=com.XXX c=null m=31</span></span><br><span class="line">            <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                    msg)) &#123;</span><br><span class="line">                <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                me.mSlowDeliveryDetected = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消息分发是否超时</span></span><br><span class="line">    <span class="comment">// 打印的日志如： Looper: Slow dispatch took 233ms android.ui h=com.XXX c=null m=31</span></span><br><span class="line">    <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 回收该Message</span></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loopOnce函数看起来也很简单，一直从MessageQueue中获取Message并执行Handler.handleMessage函数。除非拿到的message是null时返回false，否则永远返回true。<br>注意弄清 delivery 和 dispatch 的区别：</p><ol><li>delivery: 消息被拿出准备分发的时间与消息期望被执行的时间差</li><li>dispatch: 消息处理的总时间，即handle.dispatchMessage的执行时长</li></ol><p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/Delivery_Dispatch.png" alt="Delivery_Dispatch"></p><h3 id="1-4-1-Handler-dispatchMessage"><a href="#1-4-1-Handler-dispatchMessage" class="headerlink" title="1.4.1 Handler.dispatchMessage"></a>1.4.1 Handler.dispatchMessage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行我们重载的函数了</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道在Handler.handleMessage这里已经转到Handler对应Looper所在的线程了。这样看起来，线程切换的奥秘都被隐藏在MessageQueue中了。</p><h1 id="二-Message"><a href="#二-Message" class="headerlink" title="二. Message"></a>二. Message</h1><p>在分析MessageQueue之前，简单看一下Message的设计。</p><table><thead><tr><th>变量</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>what</td><td>int</td><td>标明消息类别</td></tr><tr><td>arg1</td><td>int</td><td>参数1</td></tr><tr><td>arg2</td><td>int</td><td>参数2</td></tr><tr><td>obj</td><td>Object</td><td>消息内容</td></tr><tr><td>when</td><td>long</td><td>消息期望触发时间</td></tr><tr><td>data</td><td>Bundle</td><td>消息附带内容</td></tr><tr><td>target</td><td>Handler</td><td>消息触发执行的Handler</td></tr><tr><td>callback</td><td>Runnable</td><td>消息执行的Runnable</td></tr><tr><td>next</td><td>Message</td><td>下一个消息, 消息链表结构基础</td></tr></tbody></table><h2 id="2-1-消息链表结构"><a href="#2-1-消息链表结构" class="headerlink" title="2.1 消息链表结构"></a>2.1 消息链表结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">sPoolSync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">sPoolSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过维护一个大小为50的Message缓冲池，来缓解Message频繁创建销毁带来的资源损耗，所以在开发过程中尽可能选择使用obtain来创建Message。</p><h1 id="三-MessageQueue"><a href="#三-MessageQueue" class="headerlink" title="三. MessageQueue"></a>三. MessageQueue</h1><p>既然Message自己就维护了一个链表结构，还需要MessageQueue做什么呢？</p><h2 id="3-1-MessageQueue"><a href="#3-1-MessageQueue" class="headerlink" title="3.1 MessageQueue"></a>3.1 MessageQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="type">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">// 3.2 通过JNI进入native实例化</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置mQuitAllowed, 主线程的Looper不允许退出(调用quit，主动退出)。然后通过JNI进入native层初始化</p><h2 id="3-2-android-os-MessageQueue-nativeInit"><a href="#3-2-android-os-MessageQueue-nativeInit" class="headerlink" title="3.2 android_os_MessageQueue_nativeInit"></a>3.2 android_os_MessageQueue_nativeInit</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> <span class="built_in">NativeMessageQueue</span>();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">jniThrowRuntimeException</span>(env, <span class="string">&quot;Unable to allocate native queue&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">incStrong</span>(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是创建了一个NativeMessageQueue的对象。</p><h2 id="3-3-NativeMessageQueue"><a href="#3-3-NativeMessageQueue" class="headerlink" title="3.3 NativeMessageQueue"></a>3.3 NativeMessageQueue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::<span class="built_in">NativeMessageQueue</span>() :</span><br><span class="line">        <span class="built_in">mPollEnv</span>(<span class="literal">NULL</span>), <span class="built_in">mPollObj</span>(<span class="literal">NULL</span>), <span class="built_in">mExceptionObj</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意这里是native层的Loop了, 同样的也是通过TLS方式存储的</span></span><br><span class="line">    mLooper = Looper::<span class="built_in">getForThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.4 创建Looper</span></span><br><span class="line">        mLooper = <span class="keyword">new</span> <span class="built_in">Looper</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 保存在当前线程的TLS中</span></span><br><span class="line">        Looper::<span class="built_in">setForThread</span>(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-Looper-cpp"><a href="#3-4-Looper-cpp" class="headerlink" title="3.4 Looper.cpp"></a>3.4 Looper.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Looper::<span class="built_in">Looper</span>(<span class="type">bool</span> allowNonCallbacks)</span><br><span class="line">    : <span class="built_in">mAllowNonCallbacks</span>(allowNonCallbacks),</span><br><span class="line">      <span class="built_in">mSendingMessage</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mPolling</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mEpollRebuildRequired</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">mNextRequestSeq</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mResponseIndex</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">mNextMessageUptime</span>(LLONG_MAX) &#123;</span><br><span class="line">    <span class="comment">// eventfd函数会创建一个eventfd, 这里保存在mWakeEventFd中</span></span><br><span class="line">    <span class="comment">// EFD_NONBLOCK: 设置FD对象为非阻塞状态</span></span><br><span class="line">    <span class="comment">// EFD_CLOEXEC: 调用exec后会自动关闭文件描述符，防止泄漏</span></span><br><span class="line">    mWakeEventFd.<span class="built_in">reset</span>(<span class="built_in">eventfd</span>(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mWakeEventFd.<span class="built_in">get</span>() &lt; <span class="number">0</span>, <span class="string">&quot;Could not make wake event fd: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="comment">// 3.4.1 重建epoll</span></span><br><span class="line">    <span class="built_in">rebuildEpollLocked</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>eventfd 是 Linux 的一个系统调用，创建一个文件描述符用于事件通知，自 Linux 2.6.22 以后开始支持。该函数会创建一个 eventfd 对象，用户空间的应用程序可以用这个 eventfd 来实现事件的等待或通知机制，也可以用于内核通知新的事件到用户空间应用程序。</p></blockquote><p>看来初始化该Looper的线程是通过这个eventfd来实现被唤醒的。</p><h3 id="3-4-1-Looper-cpp-rebuildEpollLocked"><a href="#3-4-1-Looper-cpp-rebuildEpollLocked" class="headerlink" title="3.4.1 Looper.cpp:rebuildEpollLocked"></a>3.4.1 Looper.cpp:rebuildEpollLocked</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::rebuildEpollLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果原有fd存在，则关闭</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mEpollFd.<span class="built_in">reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的epoll实例, 并获取该实例的fd标记</span></span><br><span class="line">    mEpollFd.<span class="built_in">reset</span>(<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC));</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(mEpollFd &lt; <span class="number">0</span>, <span class="string">&quot;Could not create epoll instance: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="built_in">sizeof</span>(epoll_event));</span><br><span class="line">    <span class="comment">// EPOLLIN 表明fd文件可读</span></span><br><span class="line">    eventItem.events = EPOLLIN;</span><br><span class="line">    eventItem.data.fd = mWakeEventFd.<span class="built_in">get</span>();</span><br><span class="line">    <span class="comment">// 在epoll实例上注册mWakeEventFd文件描述符，并将EPOLL_CTL_ADD事件关联到mWakeEventFd</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, mWakeEventFd.<span class="built_in">get</span>(), &amp;eventItem);</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL_IF</span>(result != <span class="number">0</span>, <span class="string">&quot;Could not add wake event fd to epoll instance: %s&quot;</span>,</span><br><span class="line">                        <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对所有mRequests的fd进行重定向, 均关联到新创建的epoll实例上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">const</span> Request&amp; request = mRequests.<span class="built_in">valueAt</span>(i);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItem;</span><br><span class="line">        request.<span class="built_in">initEventItem</span>(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epollResult = <span class="built_in">epoll_ctl</span>(mEpollFd.<span class="built_in">get</span>(), EPOLL_CTL_ADD, request.fd, &amp;eventItem);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Error adding epoll events for fd %d while rebuilding epoll set: %s&quot;</span>,</span><br><span class="line">                  request.fd, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是创建了一个epoll实例，并将该Looper的mWakeEventFd（即eventfd）关联到该epoll实例上。如果该Looper的mRequests存在Request时，也对所有mRequests的fd进行重定向, 均关联到新创建的epoll实例上。</p><p>所以MessageQueue的初始化就是在Native层创建了一个NativeMessageQueue的对象，该对象持有一个Native层的Looper对象。而Native层的Looper里有两个文件描述符: </p><ol><li>通过eventfd创建的mWakeEventFd; </li><li>通过epoll_create1创建的代表epoll实例的mEpollFd。</li></ol><h1 id="四-sendMessageAtTime发送消息"><a href="#四-sendMessageAtTime发送消息" class="headerlink" title="四. sendMessageAtTime发送消息"></a>四. sendMessageAtTime发送消息</h1><p>现在回到Handler发送消息，假设Handler中的Looper是MainLooper, 现在是在非UI线程，比如bg线程读取网络数据后更新到UI组件上：uiHandler.sendMessageAtTime </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="comment">// 将Message的target设置为自己</span></span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mAsynchronous表明是否异步执行</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交给Handler的MessageQueue执行</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-MessageQueue-enqueueMessage"><a href="#4-1-MessageQueue-enqueueMessage" class="headerlink" title="4.1 MessageQueue.enqueueMessage"></a>4.1 MessageQueue.enqueueMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 标记该Message正在使用, 避免缓冲池重复使用该Message</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="comment">// 记录该Message期望执行的时间</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">// mMessages是一个Message对象，代表该MessageQueue队列的头节点</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 如果头节点是空的、传入的Message执行时间是0（立刻执行）</span></span><br><span class="line">            <span class="comment">// 或者执行时间在头节点消息执行之前，将该Message作为链表新的头节点</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            <span class="comment">// mBlocked为false代表Handler所在线程已经拿到合适的Message执行了</span></span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将Message插入到链表头节点之后</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="comment">// 找到该Message的位置，即其执行时间在链表中的顺序排列位置</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否需要唤醒, 唤醒什么，当然是Handler的Looper对应线程了！</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            <span class="comment">// 进入JNI, 通过epoll唤醒线程</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以Handler.sendMessage仅仅是将Message插入MessageQueue中Message链表的合适位置，即保持mMessages链表中的Message期望执行时间从小到大排列，等待执行。</p><h2 id="4-2-android-os-MessageQueue-nativeWake"><a href="#4-2-android-os-MessageQueue-nativeWake" class="headerlink" title="4.2 android_os_MessageQueue_nativeWake"></a>4.2 android_os_MessageQueue_nativeWake</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mLooper-&gt;<span class="built_in">wake</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到native层的loop执行。</p><h2 id="4-3-Looper-cpp-wake"><a href="#4-3-Looper-cpp-wake" class="headerlink" title="4.3 Looper.cpp:wake"></a>4.3 Looper.cpp:wake</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::wake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通过write向该Looper的mWakeEventFd中写入1</span></span><br><span class="line">    <span class="type">ssize_t</span> nWrite = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">write</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;inc, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;</span>,</span><br><span class="line">                             mWakeEventFd.<span class="built_in">get</span>(), nWrite, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，bg线程中uiHandler发送Message的流程就结束了。</p><h1 id="五-UI线程处理Message"><a href="#五-UI线程处理Message" class="headerlink" title="五. UI线程处理Message"></a>五. UI线程处理Message</h1><p>那么此时我们UI线程在做什么呢? 对了，就是一直在循环执行 Looper中的 loopOnce 函数！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> <span class="type">long</span> ident, <span class="keyword">final</span> <span class="type">int</span> thresholdOverride)</span> &#123;</span><br><span class="line">    <span class="comment">// 5.1 通过MessageQueue获取下一个Message</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> me.mQueue.next();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-MessageQueue-next"><a href="#5-1-MessageQueue-next" class="headerlink" title="5.1 MessageQueue.next"></a>5.1 MessageQueue.next</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 5.2 转到Native中执行，获取下一次poll的时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接转到native层执行pollOnce.</p><h2 id="5-2-android-os-MessageQueue-nativePollOnce"><a href="#5-2-android-os-MessageQueue-nativePollOnce" class="headerlink" title="5.2 android_os_MessageQueue_nativePollOnce"></a>5.2 android_os_MessageQueue_nativePollOnce</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="built_in">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;<span class="built_in">pollOnce</span>(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NativeMessageQueue::pollOnce</span><span class="params">(JNIEnv* env, jobject pollObj, <span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    <span class="comment">// 还是用到Native层的Looper</span></span><br><span class="line">    mLooper-&gt;<span class="built_in">pollOnce</span>(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;<span class="built_in">Throw</span>(mExceptionObj);</span><br><span class="line">        env-&gt;<span class="built_in">DeleteLocalRef</span>(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-Looper-cpp-pollOnce"><a href="#5-3-Looper-cpp-pollOnce" class="headerlink" title="5.3 Looper.cpp:pollOnce"></a>5.3 Looper.cpp:pollOnce</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pollOnce</span>(timeoutMillis, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollOnce</span><span class="params">(<span class="type">int</span> timeoutMillis, <span class="type">int</span>* outFd, <span class="type">int</span>* outEvents, <span class="type">void</span>** outData)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 当前mResponses还是空的，mResponseIndex为0</span></span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> Response&amp; response = mResponses.<span class="built_in">itemAt</span>(mResponseIndex++);</span><br><span class="line">            <span class="type">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="type">int</span> events = response.events;</span><br><span class="line">                <span class="type">void</span>* data = response.request.data;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = fd;</span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = events;</span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = data;</span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// result为0, 表明poll超时</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">nullptr</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">nullptr</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">nullptr</span>) *outData = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先执行这里</span></span><br><span class="line">        result = <span class="built_in">pollInner</span>(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-Looper-cpp-pollInner"><a href="#5-4-Looper-cpp-pollInner" class="headerlink" title="5.4 Looper.cpp:pollInner"></a>5.4 Looper.cpp:pollInner</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Looper::pollInner</span><span class="params">(<span class="type">int</span> timeoutMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Poll.</span></span><br><span class="line">    <span class="type">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.<span class="built_in">clear</span>();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标记正在poll</span></span><br><span class="line">    mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EPOLL_MAX_EVENTS默认是16</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line">    <span class="comment">// 通过epoll_wait监听mEpollFd文件描述符等待被唤醒, 注意这里timeoutMillis是0</span></span><br><span class="line">    <span class="comment">// 也就是说当mEpollFd没有事件时，立刻返回超时 0</span></span><br><span class="line">    <span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.<span class="built_in">get</span>(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// poll超时，在执行一次Looper.pollOnce的循环</span></span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll中存在事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="type">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="type">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="comment">// 当epoll中事件描述符是当前Looper的mWakeEventFd时, 说明有线程通过write向该fd写入值</span></span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">// 5.5 执行被唤醒后的处理</span></span><br><span class="line">                <span class="built_in">awoken</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">ALOGW</span>(<span class="string">&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;</span>, epollEvents);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p></blockquote><p>等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误。</p><ol><li>epfd是 epoll的描述符。</li><li>events则是分配好的 epoll_event结构体数组，epoll将会把发生的事件复制到 events数组中</li><li>maxevents表示本次可以返回的最大事件数目，通常 maxevents参数与预分配的events数组的大小是相等的。</li><li>timeout表示在没有检测到事件发生时最多等待的时间（单位为毫秒），如果 timeout为0，则表示 epoll_wait在 rdllist链表中为空，立刻返回，不会等待。</li></ol><h2 id="5-5-Looper-cpp-awoken"><a href="#5-5-Looper-cpp-awoken" class="headerlink" title="5.5 Looper.cpp:awoken"></a>5.5 Looper.cpp:awoken</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Looper::awoken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> counter;</span><br><span class="line">    <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">read</span>(mWakeEventFd.<span class="built_in">get</span>(), &amp;counter, <span class="built_in">sizeof</span>(<span class="type">uint64_t</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取mWakeEventFd中的值，也就是之前bg线程通过write写入的1. 然后回到Looper.cpp:pollOnce返回1.</p><p>这样UI线程就从epoll_wait阻塞状态(或者一直执行Looper.cpp:pollOnce函数的状态)退出，之后回到java层的MessageQueue.next中继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 5.2 转到Native中执行，获取下一次poll的时间</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录当前系统时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// 尝试找到抵达执行时间的Message</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// 如果头节点Message的执行时间尚未到来，那么下一次epoll_wait的等待时间就是</span></span><br><span class="line">                    <span class="comment">// 该message执行时间和当前时间的差值</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 找到可执行的Message了</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 头节点标记为下一个</span></span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="comment">// 打破循环，返回该Message，回到Looper.loopOnce中</span></span><br><span class="line">                    <span class="comment">// 即执行 [1.4.1] Handler.dispatchMessage</span></span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此，Android的线程切换就结束了。</p><h1 id="六-小结"><a href="#六-小结" class="headerlink" title="六. 小结"></a>六. 小结</h1><p>通过上述分析，画一张图来展示一次Message的执行:</p><p><img src="/images/Looper-Android%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/MessageHandle.png" alt="Message Handle"></p><div style="page-break-after: always;"></div><h2 id="6-1-Epoll机制"><a href="#6-1-Epoll机制" class="headerlink" title="6.1 Epoll机制"></a>6.1 Epoll机制</h2><p>关于Eopll推荐大家阅读这篇文: <a href="https://zhuanlan.zhihu.com/p/63179839">Epoll本质</a> <a href="https://zhuanlan.zhihu.com/p/63179839">https://zhuanlan.zhihu.com/p/63179839</a></p><ol><li>cpu running</li></ol><img src="/images/Looper-Android中的消息机制/epoll_1.jpg" width="500"><ol><li>Ui Thread: epoll_wait</li></ol><img src="/images/Looper-Android中的消息机制/epoll_2.jpg" width="500"><ol start="3"><li>Bg Thread: write fd</li></ol><img src="/images/Looper-Android中的消息机制/epoll_3.jpg" width="500"><ol start="4"><li>Ui Thread: read</li></ol><img src="/images/Looper-Android中的消息机制/epoll_4.jpg" width="500">]]></content>
    
    
    <summary type="html">&lt;div style=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;本文详细分析android的消息机制Looper的底层原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/categories/Android/"/>
    
    <category term="Looper" scheme="https://swallowjoe.github.io/categories/Android/Looper/"/>
    
    
    <category term="Android" scheme="https://swallowjoe.github.io/tags/Android/"/>
    
    <category term="Looper" scheme="https://swallowjoe.github.io/tags/Looper/"/>
    
  </entry>
  
  <entry>
    <title>Vulkan入门(15)-图像视图和采样器</title>
    <link href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/"/>
    <id>https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/</id>
    <published>2022-02-26T19:35:34.000Z</published>
    <updated>2022-02-26T19:44:47.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>回顾上一篇章中的读取图像的步骤:</p><ol><li>首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存</li><li>通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象</li><li>用VkBuffer图像文件中的像素填充创建的VkImage图像对象<ol><li>填充图像对象需要使用VkImageMemoryBarrier</li><li>使用vkCmdPipelineBarrier使得图像填充Barrier生效</li><li>通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充)</li><li>再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样</li></ol></li><li>创建图像视图和图像采样器</li><li>添加一个组合的图像采样器描述符来从纹理中采样颜色</li></ol><p>在图像采样器创建之前，我们首先看看纹理图像视图，这个是在我们创建交换链的时候见过:</p><span id="more"></span><h1 id="一-纹理图像视图-Texture-Image-View"><a href="#一-纹理图像视图-Texture-Image-View" class="headerlink" title="一. 纹理图像视图 Texture Image View"></a>一. 纹理图像视图 Texture Image View</h1><p>通过VkImageView类来存储纹理图像视图, 它描述了如何访问图像以及要访问的图像部分，创建VkImageView的方式也是通过一个结构体：VkImageViewCreateInfo, 来指明细节. 这部分我们在之前的交换链创建图像视图中有过接触，如果忘记了的话可以回顾一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">VkImageView textureImageView;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createTextureImage</span>();</span><br><span class="line">    <span class="built_in">createTextureImageView</span>();</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VkImageView <span class="title">createImageView</span><span class="params">(VkImage image, VkFormat format)</span> </span>&#123;</span><br><span class="line">    VkImageView imageView;</span><br><span class="line">    VkImageViewCreateInfo viewInfo = &#123;&#125;;</span><br><span class="line">    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;</span><br><span class="line">    viewInfo.image = image; <span class="comment">// 绑定 VkImage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// viewType和format字段指定应如何解释图像数据</span></span><br><span class="line">    <span class="comment">// viewType参数指定图像为一维纹理，二维纹理，三维纹理或立方体贴图</span></span><br><span class="line">    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;</span><br><span class="line">    <span class="comment">// 图像格式</span></span><br><span class="line">    viewInfo.format = format;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subresourceRange字段描述了图像的目的是什么以及应该访问图像的哪个部分。</span></span><br><span class="line">    <span class="comment">// 这里图像将用作颜色目标，没有任何mipmapping级别或多个层。</span></span><br><span class="line">    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    viewInfo.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    viewInfo.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    viewInfo.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    viewInfo.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意，通过vkCreateXXX创建的对象，不需要时要主动去释放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateImageView</span>(device, &amp;viewInfo, <span class="literal">nullptr</span>, &amp;imageView) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create image views!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createImageViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置集合大小</span></span><br><span class="line">    swapChainImageViews.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImageViews.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        swapChainImageViews[i] = <span class="built_in">createImageView</span>(swapChainImages[i],</span><br><span class="line">                                        swapChainImageFormat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImageView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    textureImageView = <span class="built_in">createImageView</span>(textureImage,</span><br><span class="line">                                VK_FORMAT_R8G8B8A8_UNORM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 vulkan 中推荐在创建的资源不需要后主动释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理交换链关联资源</span></span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="comment">// 清理纹理贴图</span></span><br><span class="line">    <span class="built_in">vkDestroyImageView</span>(device, textureImageView, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyImage</span>(device, textureImage, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, textureImageMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，纹理图像的视图创建成功了，很简单。接下来就是采样器的创建了。</p><h1 id="二-采样器"><a href="#二-采样器" class="headerlink" title="二. 采样器"></a>二. 采样器</h1><p>着色器可以直接从图像读取纹理像素，但是当将其用作纹理时，一般不会直接读取。 通常通过采样器访问纹理，采样器将应用过滤和转换以计算最终获取的颜色。</p><p>这些过滤器有助于处理过采样等问题。 考虑一个映射到几何图形的纹理，该纹理的碎片多于纹理像素。</p><p>如果只是在每个片段中使用最接近的纹理像素作为纹理坐标，那么将获得下图左边图像的结果：</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_1.png" alt="图像15-1"></p><p>而通过线性插值法将4个最接近的纹理像素组合在一起，那么将获得如上右图所示的更平滑的结果。 当然，您的应用程序可能具有更适合左侧风格的艺术风格要求（比如Minecraft，哈哈），但是在常规图形应用程序中，右侧风格是首选，图像越精细越好。 从纹理读取颜色时，采样器对象会自动为您应用此过滤。</p><p>抽样不足(欠采样)则是相反的问题，比如纹理像素多于片段。这将导致在以锐角采样高频图案(如棋盘纹理)时产生伪影:</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_2.png" alt="图像15-2"></p><p>如左图所示，纹理在远处变得模糊混乱。解决这个问题的方法是各向异性滤波，它也可以由采样器自动应用。</p><p>除了这些过滤器，采样器还可以处理转换。它决定当你试图通过它的寻址模式读取图像外的texel时会发生什么。下面的图片显示了一些可能性:</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_3.png" alt="图像15-3"></p><h2 id="2-1-createTextureSampler"><a href="#2-1-createTextureSampler" class="headerlink" title="2.1 createTextureSampler"></a>2.1 createTextureSampler</h2><p>现在创建一个函数createTextureSampler来设置这样的采样对象。稍后我们将在着色器中使用采样器从纹理中读取颜色:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">VkImageView textureImageView;</span><br><span class="line">VkSampler textureSampler;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createTextureImage</span>();</span><br><span class="line">    <span class="built_in">createTextureImageView</span>();</span><br><span class="line">    <span class="built_in">createTextureSampler</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureSampler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 采样器通过VkSamplerCreateInfo结构进行配置，该结构指定了应应用的所有过滤器和转换。 </span></span><br><span class="line">    VkSamplerCreateInfo samplerInfo = &#123;&#125;;</span><br><span class="line">    samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;</span><br><span class="line">    <span class="comment">// magFilter和minFilter字段指定如何对放大或缩小的纹理像素进行插值。</span></span><br><span class="line">    <span class="comment">// 放大倍数与上面描述的过采样问题有关，而缩小倍数与欠采样有关。</span></span><br><span class="line">    <span class="comment">// 指定要应用于查找的放大滤镜为线性过滤</span></span><br><span class="line">    samplerInfo.magFilter = VK_FILTER_LINEAR;</span><br><span class="line">    <span class="comment">// 指定要应用于查找的缩小过滤器为线性过滤</span></span><br><span class="line">    samplerInfo.minFilter = VK_FILTER_LINEAR;</span><br><span class="line">    <span class="comment">// 指定U、V、W坐标的[0..1]范围之外的寻址模式, 指定当超出图像尺寸时，重复纹理</span></span><br><span class="line">    <span class="comment">// 注意，轴称为U，V和W，而不是X，Y和Z。这是纹理空间坐标的约定</span></span><br><span class="line">    samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line">    samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line">    samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anisotropyEnable为true, 采样器使用使用各向异性过滤</span></span><br><span class="line">    samplerInfo.anisotropyEnable = VK_TRUE;</span><br><span class="line">    samplerInfo.maxAnisotropy = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// borderColor字段指定在使用边界寻址模式对图像进行采样以外时返回的颜色。 </span></span><br><span class="line">    <span class="comment">// 可以以float或int格式返回黑色，白色或透明。</span></span><br><span class="line">    samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;</span><br><span class="line">    <span class="comment">// 指定要用于处理图像中纹理像素的坐标系</span></span><br><span class="line">    <span class="comment">// 为VK_FALSE，则将使用所有轴上的[0，1）范围对纹理像素进行寻址</span></span><br><span class="line">    samplerInfo.unnormalizedCoordinates = VK_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果启用了比较功能，则将首先将纹理像素与一个值进行比较，并且该比较的结果将用于过滤操作中。 主要用于阴影贴图上的百分比封闭器过滤。</span></span><br><span class="line">    samplerInfo.compareEnable = VK_FALSE;</span><br><span class="line">    samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有这些字段都适用于mipmapping。以后讨论mipmapping</span></span><br><span class="line">    samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;</span><br><span class="line">    samplerInfo.mipLodBias = <span class="number">0.0f</span>;</span><br><span class="line">    samplerInfo.minLod = <span class="number">0.0f</span>;</span><br><span class="line">    samplerInfo.maxLod = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建采样器，注意清理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateSampler</span>(device, &amp;samplerInfo, <span class="literal">nullptr</span>, &amp;textureSampler) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create texture sampler!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="comment">// 清理采样器</span></span><br><span class="line">    <span class="built_in">vkDestroySampler</span>(device, textureSampler, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>samplerInfo中的anisotropyEnable和maxAnisotropy这两个字段指定是否应该使用各向异性过滤。最大各向异性字段限制了可以用来计算最终颜色的texel样本的数量。数值越低，性能越好，但质量越低。目前没有任何图形硬件可以使用超过16个样本，因为超过这个值的差异就可以忽略不计了。</p><p>unnormalizedCoordinates字段指定要用于处理图像中纹理像素的坐标系。 如果此字段为VK_TRUE，则可以简单地使用[0，texWidth）和[0，texHeight）范围内的坐标。 如果为VK_FALSE，则将使用所有轴上的[0，1）范围对纹理像素进行寻址。 实际应用中几乎总是使用归一化的坐标，因为这样一来，便可以使用分辨率完全相同的不同分辨率的纹理。</p><p>请注意，采样器未在任何地方引用VkImage。 采样器是一个独特的对象，它提供了一个接口来从纹理中提取颜色。 它可以应用于所需的任何图像，无论是1D，2D还是3D。 这与许多较早的API不同，后者将纹理图像和过滤合并为一个状态。</p><h2 id="2-2-VkSamplerCreateInfo"><a href="#2-2-VkSamplerCreateInfo" class="headerlink" title="2.2 VkSamplerCreateInfo"></a>2.2 VkSamplerCreateInfo</h2><p>VkSamplerCreateInfo结构体指定了采样器对象的状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkSamplerCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType         sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*             pNext;</span><br><span class="line">    VkSamplerCreateFlags    flags;</span><br><span class="line">    VkFilter                magFilter;</span><br><span class="line">    VkFilter                minFilter;</span><br><span class="line">    VkSamplerMipmapMode     mipmapMode;</span><br><span class="line">    VkSamplerAddressMode    addressModeU;</span><br><span class="line">    VkSamplerAddressMode    addressModeV;</span><br><span class="line">    VkSamplerAddressMode    addressModeW;</span><br><span class="line">    <span class="type">float</span>                   mipLodBias;</span><br><span class="line">    VkBool32                anisotropyEnable;</span><br><span class="line">    <span class="type">float</span>                   maxAnisotropy;</span><br><span class="line">    VkBool32                compareEnable;</span><br><span class="line">    VkCompareOp             compareOp;</span><br><span class="line">    <span class="type">float</span>                   minLod;</span><br><span class="line">    <span class="type">float</span>                   maxLod;</span><br><span class="line">    VkBorderColor           borderColor;</span><br><span class="line">    VkBool32                unnormalizedCoordinates;</span><br><span class="line">&#125; VkSamplerCreateInfo;</span><br></pre></td></tr></table></figure><ol><li>sType是此结构的类型， VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO</li><li>pNext是NULL或指向扩展特定结构的指针</li><li>flag是VkSamplerCreateFlagBits的位掩码，描述了采样器的其他参数</li><li>magFilter是VkFilter值，用于指定要应用于查找的放大滤镜<ol><li>VK_FILTER_NEAREST 指定最近的过滤</li><li>VK_FILTER_LINEAR 指定线性过滤</li><li>VK_FILTER_CUBIC_EXT 指定三次过滤</li><li>VK_FILTER_CUBIC_IMG 指定三次过滤，同VK_FILTER_CUBIC_EXT</li></ol></li><li>minFilter是一个VkFilter值，用于指定要应用于查找的缩小过滤器</li><li>mipmapMode是VkSamplerMipmapMode值，指定要应用于查找的mipmap过滤器</li><li>addressModeU是VkSamplerAddressMode值，用于为U坐标指定[0..1]范围之外的寻址模式<ol><li>VK_SAMPLER_ADDRESS_MODE_REPEAT 当超出图像尺寸时，重复纹理</li><li>VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT 类似于重复，但是当超出尺寸时会反转坐标以镜像图像</li><li>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE 在图像尺寸之外，获取最靠近坐标的边缘的颜色</li><li>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER 当采样超出图像尺寸时，返回纯色</li><li>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE 类似CLAMP_TO_EDGE，但使用与最近边缘相反的边缘,仅在启用samplerMirrorClampToEdge或启用[VK_KHR_sampler_mirror_clamp_to_edge]扩展名后才有效</li></ol></li><li>addressModeV是VkSamplerAddressMode值，用于指定V坐标的[0..1]范围之外的寻址模式</li><li>addressModeW是VkSamplerAddressMode值，它为W坐标指定[0..1]范围之外的寻址模式</li><li>mipLodBias是要添加到mipmap LOD（详细程度）计算中的偏差，以及由SPIR-V中的图像采样功能提供的偏差</li><li>anisotropyEnable为VK_TRUE以启用各向异性过滤，如“ Texel各向异性过滤”部分所述，否则为VK_FALSE</li><li>maxAnisotropy是anisotropyEnable为VK_TRUE时采样器使用的各向异性值钳位。如果anisotropyEnable为VK_FALSE，则maxAnisotropy被忽略</li><li>compareEnable为VK_TRUE，以允许在查找过程中与参考值进行比较，否则为VK_FALSE<ol><li>注意：如果此成员不匹配，则某些实现将默认为着色器状态</li></ol></li><li>compareOp是一个VkCompareOp值，它指定比较功能，以按“深度比较操作”部分所述在过滤之前将其应用于获取的数据</li><li>minLod和maxLod是用于钳位计算的LOD值的值</li><li>borderColor是VkBorderColor值，用于指定要使用的预定义边框颜色</li><li>unnormalizedCoordinates指定要用于处理图像中纹理像素的坐标系。设置为VK_TRUE时，用于查找纹理像素的图像坐标的范围在0到x，y和z的图像尺寸的范围内。设置为VK_FALSE时，图像坐标范围为零到一。<ol><li>当unnormalizedCoordinates为VK_TRUE时，在着色器中使用采样器的图像具有以下要求：<ol><li>viewType必须为VK_IMAGE_VIEW_TYPE_1D或VK_IMAGE_VIEW_TYPE_2D</li><li>图像视图必须具有单个图层和单个mip级别</li></ol></li><li>当unnormalizedCoordinates为VK_TRUE时，使用采样器的着色器中的图像内置函数具有以下要求：<ol><li>这些功能不得使用投影</li><li>这些函数不得使用偏移量</li></ol></li></ol></li></ol><h2 id="2-3-vkCreateSampler"><a href="#2-3-vkCreateSampler" class="headerlink" title="2.3 vkCreateSampler"></a>2.3 vkCreateSampler</h2><p>VkSampler对象表示图像采样器的状态，实现可使用该对象读取图像数据并为着色器应用过滤和其他转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateSampler</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkSamplerCreateInfo*                  pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkSampler*                                  pSampler)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device是创建采样器的逻辑设备</li><li>pCreateInfo是指向VkSamplerCreateInfo结构的指针，该结构指定采样器对象的状态</li><li>pAllocator控制主机内存分配</li><li>pSampler是指向VkSampler句柄的指针，在该句柄中返回生成的采样器对象</li></ol><h2 id="2-4-设备功能之各向异性过滤"><a href="#2-4-设备功能之各向异性过滤" class="headerlink" title="2.4 设备功能之各向异性过滤"></a>2.4 设备功能之各向异性过滤</h2><p>如果现在运行程序，则会看到如下所示的验证层消息：</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_4.png" alt="图片15-4"></p><p>这是因为各向异性过滤实际上是一个可选的设备特性。我们需要更新createLogicalDevice函数来请求它:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;;</span><br><span class="line">deviceFeatures.samplerAnisotropy = VK_TRUE;</span><br></pre></td></tr></table></figure><p>即使现在的显卡不支持它的可能性很小，我们也应该更新isDeviceSuitable来检查它是否可用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isDeviceSuitable</span><span class="params">(VkPhysicalDevice device)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    VkPhysicalDeviceFeatures supportedFeatures;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceFeatures</span>(device, &amp;supportedFeatures);</span><br><span class="line">    <span class="keyword">return</span> indices.<span class="built_in">isComplete</span>() &amp;&amp; extensionsSupported &amp;&amp;</span><br><span class="line">            swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vkGetPhysicalDeviceFeatures重新调整VkPhysicalDeviceFeatures结构的用途，通过设置布尔值来指示支持哪些功能，而不是请求哪些功能。</p><p>除了强制各向异性过滤的可用性，也可以通过条件设置不使用它:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samplerInfo.anisotropyEnable = VK_FALSE;</span><br><span class="line">samplerInfo.maxAnisotropy = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h2><p>现在图像有了，接下来，我们将向着色器公开图像和采样器对象，以便将纹理绘制到正方形上并呈现出来。</p><h1 id="三-组合图像采样器"><a href="#三-组合图像采样器" class="headerlink" title="三. 组合图像采样器"></a>三. 组合图像采样器</h1><p>我们在统一缓冲区部分中了解了描述符。 现在我们看一种新型的描述符：组合图像采样器。 该描述符使着色器可以通过采样器对象访问图像资源。</p><p>我们将从修改描述符布局，描述符池和描述符集开始，以包括此类组合的图像采样器描述符。 之后，我们将向顶点添加纹理坐标，并修改片段着色器以从纹理读取颜色，而不仅仅是插入顶点颜色。</p><h2 id="3-1-更新描述符"><a href="#3-1-更新描述符" class="headerlink" title="3.1 更新描述符"></a>3.1 更新描述符</h2><p>回到createDescriptorSetLayout函数，为组合的图像采样器描述符添加VkDescriptorSetLayoutBinding。 将其放在统一缓冲区之后的绑定中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建采样器描述符</span></span><br><span class="line">    VkDescriptorSetLayoutBinding samplerLayoutBinding = &#123;&#125;;</span><br><span class="line">    samplerLayoutBinding.binding = <span class="number">1</span>;</span><br><span class="line">    samplerLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">    samplerLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 指明片段着色器阶段可以使用组合的图像采样器描述符, 那就是片段颜色确定的地方。</span></span><br><span class="line">    <span class="comment">// 可以在顶点着色器中使用纹理采样，例如通过高度图使顶点网格动态变形。</span></span><br><span class="line">    samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;</span><br><span class="line"></span><br><span class="line">    std::array&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings = &#123;uboLayoutBinding, samplerLayoutBinding&#125;;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;;</span><br><span class="line">    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;</span><br><span class="line">    layoutInfo.bindingCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(bindings.<span class="built_in">size</span>());</span><br><span class="line">    layoutInfo.pBindings = bindings.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建描述符集布局</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorSetLayout</span>(device, &amp;layoutInfo, <span class="literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor set layout!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您现在运行带有验证层的应用程序，那么会发现描述符池无法使用此布局分配描述符集，因为它没有任何组合的图像采样器描述符。</p><p>转到createDescriptorPool函数并对其进行修改，以包括此描述符的VkDescriptorPoolSize：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorPoolSize poolSize = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 我们创建的是统一缓冲的描述符</span></span><br><span class="line">    poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    poolSize.descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 第一个是统一缓冲区描述符</span></span><br><span class="line">    poolSizes[<span class="number">0</span>].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    poolSizes[<span class="number">0</span>].descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 第二个是纹理图像采样器描述符</span></span><br><span class="line">    poolSizes[<span class="number">1</span>].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">    poolSizes[<span class="number">1</span>].descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;;</span><br><span class="line">    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;</span><br><span class="line">    poolInfo.poolSizeCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(poolSizes.<span class="built_in">size</span>());</span><br><span class="line">    poolInfo.pPoolSizes = poolSizes.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了可用的单个描述符的最大数量外，还需要指定可以分配的最大描述符集数量：与交换链图像数量一致</span></span><br><span class="line">    poolInfo.maxSets = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 创建描述符池</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorPool</span>(device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步是将实际图像和采样器资源绑定到描述符集中的描述符。 转到createDescriptorSets函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; descriptorSets.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定图像视图和采样器到描述符中</span></span><br><span class="line">        VkDescriptorImageInfo imageInfo = &#123;&#125;;</span><br><span class="line">        imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须在VkDescriptorImageInfo结构中指定用于组合图像采样器结构的资源</span></span><br><span class="line">        imageInfo.imageView = textureImageView;</span><br><span class="line">        imageInfo.sampler = textureSampler;</span><br><span class="line"></span><br><span class="line">        std::array&lt;VkWriteDescriptorSet, 2&gt; descriptorWrites = &#123;&#125;;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].dstSet = descriptorSets[i];</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].dstBinding = <span class="number">0</span>;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].dstArrayElement = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 绑定统一缓冲区至描述符</span></span><br><span class="line">        descriptorWrites[<span class="number">0</span>].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].descriptorCount = <span class="number">1</span>;</span><br><span class="line">        descriptorWrites[<span class="number">0</span>].pBufferInfo = &amp;bufferInfo;</span><br><span class="line"></span><br><span class="line">        descriptorWrites[<span class="number">1</span>].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].dstSet = descriptorSets[i];</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].dstBinding = <span class="number">1</span>;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].dstArrayElement = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 绑定图像视图和相应的采样器至描述符</span></span><br><span class="line">        descriptorWrites[<span class="number">1</span>].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].descriptorCount = <span class="number">1</span>;</span><br><span class="line">        descriptorWrites[<span class="number">1</span>].pImageInfo = &amp;imageInfo;</span><br><span class="line">        <span class="comment">// 应用描述符集更新</span></span><br><span class="line">        <span class="built_in">vkUpdateDescriptorSets</span>(device,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(descriptorWrites.<span class="built_in">size</span>()),</span><br><span class="line">            descriptorWrites.<span class="built_in">data</span>(), <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须在VkDescriptorImageInfo结构中指定用于组合图像采样器结构的资源，就像在VkDescriptorBufferInfo结构中指定用于统一缓冲区描述符的缓冲区资源一样。</p><h2 id="3-2-纹理坐标"><a href="#3-2-纹理坐标" class="headerlink" title="3.2 纹理坐标"></a>3.2 纹理坐标</h2><p>纹理映射还有一个重要要素就是每个顶点的实际坐标。 坐标决定了图像如何实际映射到几何体:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line">    glm::vec2 texCoord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">        bindingDescription.binding = <span class="number">0</span>;</span><br><span class="line">        bindingDescription.stride = <span class="built_in">sizeof</span>(Vertex);</span><br><span class="line">        bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;</span><br><span class="line">        <span class="keyword">return</span> bindingDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::array&lt;VkVertexInputAttributeDescription, 3&gt; <span class="title">getAttributeDescriptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions = &#123;&#125;;</span><br><span class="line">        <span class="comment">// position 顶点输入位置属性描述符</span></span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].location = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">0</span>].offset = <span class="built_in">offsetof</span>(Vertex, pos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// color 顶点输入颜色属性描述符</span></span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].location = <span class="number">1</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">1</span>].offset = <span class="built_in">offsetof</span>(Vertex, color);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// coordinates 顶点输入坐标属性描述符</span></span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].binding = <span class="number">0</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].location = <span class="number">2</span>;</span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].format = VK_FORMAT_R32G32_SFLOAT;</span><br><span class="line">        attributeDescriptions[<span class="number">2</span>].offset = <span class="built_in">offsetof</span>(Vertex, texCoord);</span><br><span class="line">        <span class="keyword">return</span> attributeDescriptions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改“顶点”结构，使其包含用于纹理坐标的vec2（texCoord）。 确保还添加了VkVertexInputAttributeDescription，以便我们可以将访问纹理坐标用作顶点着色器中的输入。 要将它们传递到片段着色器以便在正方形表面上进行插值，这是必要的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先使用从左上角的0、0到右下角的1、1的坐标简单地用纹理填充正方形。 随意尝试使用不同的坐标。 稍后我们看看低于0或高于1的坐标下的实际的寻址模式！</p><h2 id="3-3-着色器"><a href="#3-3-着色器" class="headerlink" title="3.3 着色器"></a>3.3 着色器</h2><p>最后一步是修改着色器，以从纹理中采样颜色。 我们首先需要修改顶点着色器，以将纹理坐标传递到片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> inTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec2</span> fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">    fragTexCoord = inTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像每个顶点的颜色一样，栅格化器会将fragTexCoord值平滑地插入到正方形区域中。 我们可以通过使片段着色器将纹理坐标输出为颜色来形象化：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> fragTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> outColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    outColor = <span class="type">vec4</span>(fragTexCoord, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们编译下着色器，然后运行下程序:</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_5.png" alt="图片15-5"></p><h3 id="3-3-1-片段着色器中的图像采样器描述符"><a href="#3-3-1-片段着色器中的图像采样器描述符" class="headerlink" title="3.3.1 片段着色器中的图像采样器描述符"></a>3.3.1 片段着色器中的图像采样器描述符</h3><p>组合的图像采样器描述符在GLSL中由采样器统一表示。 在片段着色器中添加对它的引用：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 对于其他类型的图像，存在等效的sampler1D和sampler3D类型。 确保在此处使用正确的绑定。 </span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> texSampler;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    outColor = <span class="built_in">texture</span>(texSampler, fragTexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译一下shader然后运行程序:</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-15-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/Vulkan_15_6.png" alt="图像15-6"></p><p>哒哒，一个旋转的贴图出现了！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;回顾上一篇章中的读取图像的步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存&lt;/li&gt;
&lt;li&gt;通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象&lt;/li&gt;
&lt;li&gt;用VkBuffer图像文件中的像素填充创建的VkImage图像对象&lt;ol&gt;
&lt;li&gt;填充图像对象需要使用VkImageMemoryBarrier&lt;/li&gt;
&lt;li&gt;使用vkCmdPipelineBarrier使得图像填充Barrier生效&lt;/li&gt;
&lt;li&gt;通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充)&lt;/li&gt;
&lt;li&gt;再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;创建图像视图和图像采样器&lt;/li&gt;
&lt;li&gt;添加一个组合的图像采样器描述符来从纹理中采样颜色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在图像采样器创建之前，我们首先看看纹理图像视图，这个是在我们创建交换链的时候见过:&lt;/p&gt;</summary>
    
    
    
    <category term="图像引擎" scheme="https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Vulkan" scheme="https://swallowjoe.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Vulkan入门(14)-VkImage图像的创建</title>
    <link href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2022-02-26T19:35:18.000Z</published>
    <updated>2022-02-26T19:44:04.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>在之前我们使用顶点着色器以及描述符来实现绘制有颜色的几何体，还实现了旋转动画。接下来我们学习一下纹理贴图，这个将是我们实现加载绘制基本3D模型的基础。</p><span id="more"></span><p>添加纹理的基本步骤有:</p><ol><li>创建由设备内存支持的图像对象</li><li>用图像文件中的像素填充创建的图像对象</li><li>创建图像采样器</li><li>添加一个组合的图像采样器描述符来从纹理中采样颜色</li></ol><p>我们以前已经使用过图像对象，但是这些对象是由swap chain扩展自动创建的。这次需要手动创建，创建图像并填充数据类似于创建顶点缓冲区。我们将通过创建一个暂存资源和填充它与像素数据，然后我们复制这到我们将用于渲染的最终图像对象。</p><p>可以创建一个暂存图像，不过Vulkan允许将像素从VkBuffer复制到image中，而且这个API在某些硬件上实际上更快。我们将首先创建这个缓冲区并填充像素值，然后我们将创建一个图像复制像素到。创建image与创建缓冲区并没有太大的不同。它包括查询内存需求、分配设备内存并绑定它，就像我们之前看到的那样。</p><p>图像可以有不同的布局，影响像素在内存中的存储方式。例如，由于图形硬件的工作方式，简单地逐行存储像素可能不会带来最好的性能。当对图像执行任何操作时，确保它们具有在该操作中使用的最佳布局。比如指定渲染通道时其中一些布局有:</p><ol><li>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: 适合呈现（present）</li><li>VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:片段着色器中写入颜色的最佳附件</li><li>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: 作为传输操作的最佳源，如vkCmdCopyImageToBuffer</li><li>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 作为传输操作的最佳目的地，如vkCmdCopyBufferToImage</li><li>VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: 适合着色器采样</li></ol><p>转换图像布局的最常见方法之一是管道屏障（pipeline barrier）。管道屏障主要用于同步对资源的访问，例如确保在读取图像之前将其写入。后面我们将了解如何将管道壁垒用于转换布局。</p><p>使用VK_SHARING_MODE_EXCLUSIVE时，可以另外使用屏障来转移队列系列的所有权。</p><h1 id="一-纹理贴图"><a href="#一-纹理贴图" class="headerlink" title="一. 纹理贴图"></a>一. 纹理贴图</h1><h2 id="1-1-图像库"><a href="#1-1-图像库" class="headerlink" title="1.1 图像库"></a>1.1 图像库</h2><p>有许多库可用于加载图像，您甚至可以编写自己的代码来加载BMP和PPM等简单格式。 这里我们将使用stb集合中的stb_image库。 这样做的好处是所有代码都在一个文件中，因此不需要任何棘手的构建配置。 下载stb_image.h并将其存储在方便的位置，例如保存GLFW和GLM的目录。 将位置添加到您的包含路径。</p><p>stb_image库地址: <a href="https://github.com/nothings/stb">https://github.com/nothings/stb</a></p><p>下载后解压，放在指定目录，然后修改我们的Makefile文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VULKAN_SDK_PATH = /home/jh/Program/vulkan/1.2.170.0/x86_64</span><br><span class="line">STB_IMAGE_PATH = /home/jh/Program/stb-image</span><br><span class="line"></span><br><span class="line">CFLAGS = -std=c++17 -I<span class="variable">$(VULKAN_SDK_PATH)</span>/<span class="keyword">include</span> -I<span class="variable">$(STB_IMAGE_PATH)</span></span><br></pre></td></tr></table></figure><h2 id="1-1-读取图片"><a href="#1-1-读取图片" class="headerlink" title="1.1 读取图片"></a>1.1 读取图片</h2><p>在shaders目录旁边创建一个新的目录textures来存储纹理图像：</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/texture.jpg" alt="texture"></p><p>首先添加头文件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stb_image.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>默认情况下，头文件只定义函数的原型。一个代码文件需要包含STB_IMAGE_IMPLEMENTATION定义的头文件来包含函数体，否则会有链接错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createCommandPool</span>();</span><br><span class="line">    <span class="comment">// 因为需要使用指令缓冲，所以在创建指令池之后调用</span></span><br><span class="line">    <span class="built_in">createTextureImage</span>();</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> texWidth, texHeight, texChannels;</span><br><span class="line">    <span class="comment">// 加载texture.jpg图像</span></span><br><span class="line">    stbi_uc* pixels = <span class="built_in">stbi_load</span>(<span class="string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);</span><br><span class="line">    <span class="comment">// 每个像素4个字节</span></span><br><span class="line">    VkDeviceSize imageSize = texWidth * texHeight * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pixels) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to load texture image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stbi_load函数将文件路径和要加载的通道数量作为参数。STBI_rgb_alpha值会强制为图像加载Alpha通道，即使它没有通道也是如此, 与其他纹理保持一致性。中间的三个参数是输出图像中通道的宽度、高度和实际数量。返回的指针是像素值数组中的第一个元素。在STBI_rgba_alpha中，像素逐行排列，每个像素4个字节，总共texWidth * texHeight * 4个值。</p><h2 id="1-2-缓存读取的图片"><a href="#1-2-缓存读取的图片" class="headerlink" title="1.2 缓存读取的图片"></a>1.2 缓存读取的图片</h2><p>现在，我们将在主机可见内存中创建一个缓冲区，以便我们可以使用vkMapMemory并将像素复制到其中。 将此临时缓冲区的变量添加到createTextureImage函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> texWidth, texHeight, texChannels;</span><br><span class="line">    <span class="comment">// 加载texture.jpg图像</span></span><br><span class="line">    stbi_uc* pixels = <span class="built_in">stbi_load</span>(<span class="string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);</span><br><span class="line">    <span class="comment">// 每个像素4个字节</span></span><br><span class="line">    VkDeviceSize imageSize = texWidth * texHeight * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pixels) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to load texture image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="comment">// 缓冲区应该在主机可见内存中，以便我们可以映射它，并且它应该可用作传输源，以便我们以后可以复制</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            stagingBufferMemory);</span><br><span class="line">    <span class="comment">// 内存映射</span></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, imageSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, pixels, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(imageSize));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line">    <span class="comment">// 最后释放原始像素数据</span></span><br><span class="line">    <span class="built_in">stbi_image_free</span>(pixels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-纹理图像-Texture-Image"><a href="#1-3-纹理图像-Texture-Image" class="headerlink" title="1.3 纹理图像(Texture Image)"></a>1.3 纹理图像(Texture Image)</h2><p>尽管我们可以设置着色器来访问缓冲区中的像素值，但为此目的最好使用Vulkan中的图像对象-VkImage。 通过使用2D坐标，图像对象将使检索颜色更加容易和快捷。 图像对象中的像素称为纹理像素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">VkImage textureImage;</span><br><span class="line">VkDeviceMemory textureImageMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    VkImageCreateInfo imageInfo = &#123;&#125;;</span><br><span class="line">    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;</span><br><span class="line">    imageInfo.imageType = VK_IMAGE_TYPE_2D; <span class="comment">//二维图像</span></span><br><span class="line">    imageInfo.extent.width = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texWidth);</span><br><span class="line">    imageInfo.extent.height = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texHeight);</span><br><span class="line">    imageInfo.extent.depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像的最小采样的细节级别</span></span><br><span class="line">    imageInfo.mipLevels = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像中的层数</span></span><br><span class="line">    imageInfo.arrayLayers = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定图像格式，对于像素像素，使用与缓冲区中像素相同的格式，否则复制操作将失败</span></span><br><span class="line">    imageInfo.format = VK_FORMAT_R8G8B8A8_UNORM;</span><br><span class="line">    <span class="comment">// 图像平铺模式,这里指定图像像素最佳内存拼接布局</span></span><br><span class="line">    <span class="comment">// 与图像的布局不同，平铺模式不能在以后更改。如果希望能够直接访问图像内存中的texel，则必须使用VK_IMAGE_TILING_OPTIMAL</span></span><br><span class="line">    imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图像的initialLayout只有两个可能的值：VK_IMAGE_LAYOUT_UNDEFINED || VK_IMAGE_LAYOUT_PREINITIALIZED</span></span><br><span class="line">    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line"></span><br><span class="line">    imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;</span><br><span class="line">    <span class="comment">// 图像将仅由一个队列族使用, 因此独占模式</span></span><br><span class="line">    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">    <span class="comment">// 图像采样</span></span><br><span class="line">    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">    imageInfo.flags = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    <span class="comment">// 创建图像</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="literal">nullptr</span>, &amp;textureImage) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的，需要给Image分配内存空间</span></span><br><span class="line">    VkMemoryRequirements memRequirements;</span><br><span class="line">    <span class="built_in">vkGetImageMemoryRequirements</span>(device, textureImage, &amp;memRequirements);</span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex =</span><br><span class="line">            <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;textureImageMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate image memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定图像和内存</span></span><br><span class="line">    <span class="built_in">vkBindImageMemory</span>(device, textureImage, textureImageMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于initialLayout，很少有情况需要在第一次过渡期间保留纹理像素，但是如果想将图像与VK_IMAGE_TILING_LINEAR布局结合使用作为缓存图像。 在这种情况下，将纹理像素数据上传到其中，然后将图像转换为传输源而又不丢失数据。但是，我们首先将图像转换为传输目标，然后从缓冲区对象将纹理像素数据复制到该图像，因此使用VK_IMAGE_LAYOUT_UNDEFINED。</p><p>对于usage, 与缓冲区创建期间的含义相同。 该图像将用作缓冲区副本的目的地，因此应将其设置为传输目的地。 我们还希望能够从着色器访问图像来为网格着色，因此用法应包括VK_IMAGE_USAGE_SAMPLED_BIT。</p><p>采样标志与多重采样有关。 这仅与将用作附件的图像有关，这里使用一个样本。 对于与稀疏图像有关的图像，有一些可选的标志。 稀疏图像是其中实际上仅某些区域由内存支持的图像。 例如，如果将3D纹理用于体素地形，则可以使用它来避免分配内存来存储大量的“空”值，这里我们设置为0。</p><h3 id="1-3-1-VkImageCreateInfo"><a href="#1-3-1-VkImageCreateInfo" class="headerlink" title="1.3.1 VkImageCreateInfo"></a>1.3.1 VkImageCreateInfo</h3><p>创建图像的一系列参数是在VkImageCreateInfo中指明的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType          sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*              pNext;</span><br><span class="line">    VkImageCreateFlags       flags;</span><br><span class="line">    VkImageType              imageType;</span><br><span class="line">    VkFormat                 format;</span><br><span class="line">    VkExtent3D               extent;</span><br><span class="line">    <span class="type">uint32_t</span>                 mipLevels;</span><br><span class="line">    <span class="type">uint32_t</span>                 arrayLayers;</span><br><span class="line">    VkSampleCountFlagBits    samples;</span><br><span class="line">    VkImageTiling            tiling;</span><br><span class="line">    VkImageUsageFlags        usage;</span><br><span class="line">    VkSharingMode            sharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>                 queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*          pQueueFamilyIndices;</span><br><span class="line">    VkImageLayout            initialLayout;</span><br><span class="line">&#125; VkImageCreateInfo;</span><br></pre></td></tr></table></figure><ol><li>sType是此结构的类型,VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</li><li>pNext是NULL或指向扩展特定结构的指针</li><li>flag是VkImageCreateFlagBits的位掩码，用于描述图像的其他参数</li><li>imageType是VkImageType值，用于指定图像的基本尺寸。就图像类型而言，阵列纹理中的图层不算作尺寸<ol><li>VK_IMAGE_TYPE_1D指定一维图像</li><li>VK_IMAGE_TYPE_2D指定二维图像</li><li>VK_IMAGE_TYPE_3D指定三维图像</li></ol></li><li>format是一种VkFormat，它描述了将包含在图像中的texel块的格式和类型</li><li>extent是一个VkExtent3D，它描述基本级别的每个维度中的数据元素数量</li><li>mipLevels描述可用于图像的最小采样的细节级别的数量</li><li>arrayLayers是图像中的层数</li><li>samples是VkSampleCountFlagBits，用于指定每个纹理像素的样本数</li><li>tiling是一个VkImageTiling值，它指定内存中纹理元素块的平铺模式<ol><li>VK_IMAGE_TILING_LINEAR: 以主要行顺序排列像素</li><li>VK_IMAGE_TILING_OPTIMAL: 指定最佳平铺（纹理像素以实现相关的安排进行布局，以实现更好的内存访问）</li><li>VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: 表示图片的拼贴是由Linux DRM格式修饰符定义的</li></ol></li><li>usage是VkImageUsageFlagBits的位掩码，用于描述图像的预期用法</li><li>SharingMode是VkSharingMode值，用于指定多个队列系列将访问图像时的图像共享模式</li><li>queueFamilyIndexCount是pQueueFamilyIndi​​ces数组中的条目数</li><li>pQueueFamilyIndi​​ces是将访问此图像的队列系列的列表（如果sharedMode不是VK_SHARING_MODE_CONCURRENT，则将被忽略）</li><li>initialLayout是一个VkImageLayout值，它指定图像的所有图像子资源的初始VkImageLayout。请参阅图像布局<ol><li>VK_IMAGE_LAYOUT_UNDEFINED: GPU不可用，第一次转换将丢弃纹理像素</li><li>VK_IMAGE_LAYOUT_PREINITIALIZED:GPU无法使用，但第一个过渡将保留纹理像素</li></ol></li></ol><h3 id="1-3-2-vkCreateImage"><a href="#1-3-2-vkCreateImage" class="headerlink" title="1.3.2 vkCreateImage"></a>1.3.2 vkCreateImage</h3><p>图像表示多维（最多3个）数据数组，可用于各种目的（例如附件、纹理），通过描述符集将其绑定到图形或计算管道，或直接将其指定为特定命令的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkImageCreateInfo*                    pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage*                                    pImage)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device是创建Image的逻辑设备</li><li>pCreateInfo是指向VkImageCreateInfo结构的指针，该结构包含用于创建图像的参数</li><li>pAllocator如“内存分配”一章中所述控制主机内存分配</li><li>pImage是指向VkImage句柄的指针，在该句柄中返回生成的图像对象</li></ol><h3 id="1-3-3-createImage"><a href="#1-3-3-createImage" class="headerlink" title="1.3.3 createImage"></a>1.3.3 createImage</h3><p>现在我们重构下createTextureImage, 将创建VkImage的部分单独做个函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createImage</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height, VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkImageTiling tiling, VkImageUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkMemoryPropertyFlags properties, VkImage&amp; image,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDeviceMemory&amp; imageMemory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VkImageCreateInfo imageInfo = &#123;&#125;;</span><br><span class="line">    imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;</span><br><span class="line">    imageInfo.imageType = VK_IMAGE_TYPE_2D; <span class="comment">//二维图像</span></span><br><span class="line">    imageInfo.extent.width = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(width);</span><br><span class="line">    imageInfo.extent.height = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(height);</span><br><span class="line">    imageInfo.extent.depth = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像的最小采样的细节级别</span></span><br><span class="line">    imageInfo.mipLevels = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 图像中的层数</span></span><br><span class="line">    imageInfo.arrayLayers = <span class="number">1</span>;</span><br><span class="line">    imageInfo.format = format;</span><br><span class="line">    <span class="comment">// 图像平铺模式,这里指定图像像素最佳内存拼接布局</span></span><br><span class="line">    <span class="comment">// 与图像的布局不同，平铺模式不能在以后更改。如果希望能够直接访问图像内存中的texel，则必须使用VK_IMAGE_TILING_OPTIMAL</span></span><br><span class="line">    imageInfo.tiling = tiling;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图像的initialLayout只有两个可能的值：VK_IMAGE_LAYOUT_UNDEFINED || VK_IMAGE_LAYOUT_PREINITIALIZED</span></span><br><span class="line">    imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;</span><br><span class="line"></span><br><span class="line">    imageInfo.usage = usage;</span><br><span class="line">    <span class="comment">// 图像将仅由一个队列族使用, 因此独占模式</span></span><br><span class="line">    imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">    <span class="comment">// 图像采样</span></span><br><span class="line">    imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">    imageInfo.flags = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    <span class="comment">// 创建图像</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateImage</span>(device, &amp;imageInfo, <span class="literal">nullptr</span>, &amp;image) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的，需要给Image分配内存空间</span></span><br><span class="line">    VkMemoryRequirements memRequirements;</span><br><span class="line">    <span class="built_in">vkGetImageMemoryRequirements</span>(device, image, &amp;memRequirements);</span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex =</span><br><span class="line">            <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;imageMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate image memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定图像和内存</span></span><br><span class="line">    <span class="built_in">vkBindImageMemory</span>(device, image, imageMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> texWidth, texHeight, texChannels;</span><br><span class="line">    <span class="comment">// 加载texture.jpg图像</span></span><br><span class="line">    stbi_uc* pixels = <span class="built_in">stbi_load</span>(<span class="string">&quot;textures/texture.jpg&quot;</span>, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);</span><br><span class="line">    <span class="comment">// 每个像素4个字节</span></span><br><span class="line">    VkDeviceSize imageSize = texWidth * texHeight * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (!pixels) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to load texture image!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="comment">// 缓冲区应该在主机可见内存中，以便我们可以映射它，并且它应该可用作传输源，以便我们以后可以复制</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="comment">// 内存映射</span></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, imageSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, pixels, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(imageSize));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line">    <span class="comment">// 最后释放原始像素数据</span></span><br><span class="line">    <span class="built_in">stbi_image_free</span>(pixels);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createImage</span>(texWidth, texHeight, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL,</span><br><span class="line">            VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-布局转换"><a href="#1-4-布局转换" class="headerlink" title="1.4 布局转换"></a>1.4 布局转换</h2><p>我们需要再次记录和执行一个命令缓冲区以完成布局转换功能，所以最好是将执行指令缓冲区的部分逻辑抽离:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkCommandBuffer <span class="title">beginSingleTimeCommands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandPool = commandPool;</span><br><span class="line">    allocInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer;</span><br><span class="line">    <span class="built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);</span><br><span class="line"></span><br><span class="line">    VkCommandBufferBeginInfo beginInfo = &#123;&#125;;</span><br><span class="line">    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</span><br><span class="line">    <span class="built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);</span><br><span class="line">    <span class="keyword">return</span> commandBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">endSingleTimeCommands</span><span class="params">(VkCommandBuffer commandBuffer)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vkEndCommandBuffer</span>(commandBuffer);</span><br><span class="line"></span><br><span class="line">    VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);</span><br><span class="line">    <span class="built_in">vkQueueWaitIdle</span>(graphicsQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="number">1</span>, &amp;commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有了beginSingleTimeCommands和endSingleTimeCommands函数，可以对执行单条指令缓冲区的函数进行优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyBuffer</span><span class="params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;</span><br><span class="line">    VkCommandBuffer commandBuffer= <span class="built_in">beginSingleTimeCommands</span>();</span><br><span class="line">    <span class="comment">// 缓冲拷贝指令</span></span><br><span class="line">    VkBufferCopy copyRegion = &#123;&#125;;</span><br><span class="line">    copyRegion.srcOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.dstOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.size = size;</span><br><span class="line">    <span class="comment">// std::cout&lt;&lt;&quot;copyBuffer vkCmdCopyBuffer&quot;&lt;&lt;std::endl;</span></span><br><span class="line">    <span class="comment">// 缓冲区的内容使用vkCmdCopyBuffer命令传输。</span></span><br><span class="line">    <span class="comment">// 源和目标缓冲区以及要复制的区域数组作为参数。copyRegion由源缓冲区偏移量、目标缓冲区偏移量和大小组成</span></span><br><span class="line">    <span class="built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="number">1</span>, &amp;copyRegion);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">endSingleTimeCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们仍然使用缓冲区，那么我们现在可以编写一个函数来记录并执行vkCmdCopyBufferToImage，但是这个命令要求首先将Image置于正确的布局中。</p><p>创建一个新函数来处理布局转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">transitionImageLayout</span><span class="params">(VkImage image, VkFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkImageLayout oldLayout, VkImageLayout newLayout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer = <span class="built_in">beginSingleTimeCommands</span>();</span><br><span class="line">    <span class="comment">// 使用图像内存屏障,用于同步资源访问</span></span><br><span class="line">    VkImageMemoryBarrier barrier = &#123;&#125;;</span><br><span class="line">    barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;</span><br><span class="line">    <span class="comment">// 指定布局转换。如果不关心图像的现有内容，可以将VK_IMAGE_LAYOUT_UNDEFINED用作oldLayout</span></span><br><span class="line">    barrier.oldLayout = oldLayout;</span><br><span class="line">    barrier.newLayout = newLayout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果使用屏障来传递队列族的所有权，那么这两个字段应该是队列族的索引</span></span><br><span class="line">    <span class="comment">// 如果不这样做，则必须将它们设置为VK_QUEUE_FAMILY_IGNORED</span></span><br><span class="line">    barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;</span><br><span class="line">    <span class="comment">// image和subresourceRange指定受影响的图像以及图像的特定部分</span></span><br><span class="line">    barrier.image = image;</span><br><span class="line">    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    <span class="comment">// 我们的图像不是数组，也没有mipmapping级别，因此只指定了一个级别和层</span></span><br><span class="line">    barrier.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    barrier.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    barrier.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 屏障主要用于同步目的，因此必须指定哪些涉及资源的操作类型必须在屏障之前发生，哪些涉及资源的操作必须在屏障上等待</span></span><br><span class="line">    barrier.srcAccessMask = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line">    barrier.dstAccessMask = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在管道上执行barrier指令, 所有类型的管道屏障都使用相同的函数提交</span></span><br><span class="line">    <span class="built_in">vkCmdPipelineBarrier</span>(commandBuffer,</span><br><span class="line">        <span class="number">0</span> <span class="comment">/* TODO */</span>, <span class="number">0</span> <span class="comment">/* TODO */</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">1</span>, &amp;barrier</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">endSingleTimeCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行布局转换的最常见方法之一是使用图像内存屏障。像这样的管道屏障通常用于同步对资源的访问，例如确保在从缓冲区读取之前完成对缓冲区的写入，但是当使用VK_SHARING_MODE_EXCLUSIVE时，它也可以用于转换映像布局和传输队列族所有权。对于缓冲区，有一个等效的缓冲存储器屏障来实现这一点。</p><h3 id="1-4-1-VkImageMemoryBarrier"><a href="#1-4-1-VkImageMemoryBarrier" class="headerlink" title="1.4.1 VkImageMemoryBarrier"></a>1.4.1 VkImageMemoryBarrier</h3><p>图像存储器屏障仅适用于涉及特定图像子资源范围的存储器访问。也就是说，从图像存储器屏障形成的存储器依赖被限定为通过指定的图像子资源范围进行访问。图像内存屏障还可用于定义指定图像子资源范围的图像布局转换或队列族所有权转移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkImageMemoryBarrier</span> &#123;</span><br><span class="line">    VkStructureType            sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                pNext;</span><br><span class="line">    VkAccessFlags              srcAccessMask;</span><br><span class="line">    VkAccessFlags              dstAccessMask;</span><br><span class="line">    VkImageLayout              oldLayout;</span><br><span class="line">    VkImageLayout              newLayout;</span><br><span class="line">    <span class="type">uint32_t</span>                   srcQueueFamilyIndex;</span><br><span class="line">    <span class="type">uint32_t</span>                   dstQueueFamilyIndex;</span><br><span class="line">    VkImage                    image;</span><br><span class="line">    VkImageSubresourceRange    subresourceRange;</span><br><span class="line">&#125; VkImageMemoryBarrier;</span><br></pre></td></tr></table></figure><ol><li>sType就是这种结构的类型, VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER</li><li>pNext为NULL或指向特定于扩展的结构的指针</li><li>srccessmask是指定源访问掩码的VkAccessFlagBits的位掩码, 指定在哪个管道阶段发生操作，这些操作应该在屏障之前发生</li><li>dstAccessMask是指定目标访问掩码的VkAccessFlagBits位掩码, 指定操作将在其中等待屏障的管道阶段</li><li>oldLayout是图像布局转换中的旧布局</li><li>newLayout是图像布局转换中的新布局</li><li>srcQueueFamilyIndex是队列系列所有权转移的源队列系列</li><li>dstQueueFamilyIndex是队列系列所有权转移的目标队列系列</li><li>image是受此屏障影响的图像</li><li>subresourceRange描述图像中受此屏障影响的图像子资源范围</li></ol><h3 id="1-4-2-vkCmdPipelineBarrier"><a href="#1-4-2-vkCmdPipelineBarrier" class="headerlink" title="1.4.2 vkCmdPipelineBarrier"></a>1.4.2 vkCmdPipelineBarrier</h3><p>vkCmdPipelineBarrier是一个同步命令，它在提交到同一队列的命令之间或同一子类中的命令之间插入依赖关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdPipelineBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineStageFlags                        srcStageMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineStageFlags                        dstStageMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDependencyFlags                           dependencyFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    memoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkMemoryBarrier*                      pMemoryBarriers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    bufferMemoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferMemoryBarrier*                pBufferMemoryBarriers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    imageMemoryBarrierCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkImageMemoryBarrier*                 pImageMemoryBarriers)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是将命令记录到的命令缓冲区</li><li>srcStageMask是一个指定源级掩码的VkPipelineStageFlagBits的位掩码</li><li>dstStageMask是指定目标阶段掩码的VkPipelineStageFlagBits的位掩码</li><li>dependencyFlags是VkdePendencyFlags的位掩码，指定如何形成执行和内存依赖关系</li><li>memoryBarrierCount是pMemoryBarriers数组的长度</li><li>pMemoryBarriers是指向VKMemorySbarrier结构数组的指针</li><li>bufferMemoryBarrierCount是pBufferMemoryBarriers数组的长度</li><li>pBufferMemoryBarriers是指向VkBufferMemoryBarrier结构数组的指针</li><li>imageMemoryBarrierCount是pImageMemoryBarriers数组的长度</li><li>pImageMemoryBarriers是指向VkimAgemoryBarrier结构数组的指针</li></ol><p>当vkCmdPipelineBarrier提交到队列时，它定义了在它之前提交的命令和在它之后提交的命令之间的内存依赖关系。</p><p>如果vkCmdPipelineBarrier是在渲染过程实例外部录制的，则第一个同步作用域将包括按提交顺序较早出现的所有命令。如果vkCmdPipelineBarrier记录在渲染过程实例中，则第一个同步作用域仅包括在同一子过程中以提交顺序较早出现的命令。在这两种情况下，第一个同步作用域仅限于由srcStageMask指定的源阶段掩码确定的管道阶段上的操作。</p><p>如果vkCmdPipelineBarrier是在渲染过程实例外部录制的，则第二个同步作用域将包括以后按提交顺序执行的所有命令。如果vkCmdPipelineBarrier记录在渲染过程实例中，则第二个同步作用域仅包括稍后在同一子过程中按提交顺序出现的命令。在任何一种情况下，第二同步作用域都限于由dstStageMask指定的目的级掩码确定的管道级上的操作。</p><p>第一个访问范围被限制为在由srcStageMask指定的源阶段掩码确定的管道阶段中进行访问。其中，第一访问作用域仅包括由pMemoryBarriers、pBufferMemoryBarriers和pImageMemoryBarriers数组的元素定义的第一访问作用域，每个元素定义一组内存屏障。如果未指定内存屏障，则第一个访问作用域不包括任何访问。</p><p>第二访问范围被限制为在由dstStageMask指定的目标阶段掩码确定的管道阶段中的访问。其中，第二访问作用域仅包括由pMemoryBarriers、pBufferMemoryBarriers和pImageMemoryBarriers数组的元素定义的第二访问作用域，它们各自定义了一组内存屏障。如果未指定内存屏障，则第二访问作用域不包括任何访问。</p><h2 id="1-5-拷贝缓存数据至Image"><a href="#1-5-拷贝缓存数据至Image" class="headerlink" title="1.5 拷贝缓存数据至Image"></a>1.5 拷贝缓存数据至Image</h2><p>就像缓冲区复制一样，需要指定缓冲区的哪个部分将被复制到图像的哪个部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyBufferToImage</span><span class="params">(VkBuffer buffer, VkImage image, <span class="type">uint32_t</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer = <span class="built_in">beginSingleTimeCommands</span>();</span><br><span class="line">    <span class="comment">// 使用VkBufferImageCopy指定缓冲区复制行为</span></span><br><span class="line">    VkBufferImageCopy region = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定缓冲区中像素值开始的字节偏移量</span></span><br><span class="line">    region.bufferOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 指定像素在内存中的布局方式, 指定0表示像素紧密打包</span></span><br><span class="line">    region.bufferRowLength = <span class="number">0</span>;</span><br><span class="line">    region.bufferImageHeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指示要将像素复制到图像的哪个部分</span></span><br><span class="line">    region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    region.imageSubresource.mipLevel = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    region.imageSubresource.layerCount = <span class="number">1</span>;</span><br><span class="line">    region.imageOffset = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    region.imageExtent = &#123;width, height, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用vkCmdCopyBufferToImage函数将缓冲区到图像的复制操作排队</span></span><br><span class="line">    <span class="comment">// 第四个参数指示图像当前使用的布局</span></span><br><span class="line">    <span class="built_in">vkCmdCopyBufferToImage</span>(commandBuffer, buffer, image,</span><br><span class="line">            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">            <span class="number">1</span>, &amp;region);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">endSingleTimeCommands</span>(commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-1-VkBufferImageCopy"><a href="#1-5-1-VkBufferImageCopy" class="headerlink" title="1.5.1 VkBufferImageCopy"></a>1.5.1 VkBufferImageCopy</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkBufferImageCopy</span> &#123;</span><br><span class="line">    VkDeviceSize                bufferOffset;</span><br><span class="line">    <span class="type">uint32_t</span>                    bufferRowLength;</span><br><span class="line">    <span class="type">uint32_t</span>                    bufferImageHeight;</span><br><span class="line">    VkImageSubresourceLayers    imageSubresource;</span><br><span class="line">    VkOffset3D                  imageOffset;</span><br><span class="line">    VkExtent3D                  imageExtent;</span><br><span class="line">&#125; VkBufferImageCopy;</span><br></pre></td></tr></table></figure><ol><li>bufferOffset是从复制图像数据的缓冲区对象的起始处开始的以字节为单位的偏移量</li><li>bufferRowLength和bufferImageHeight以texel为单位指定缓冲存储器中较大的二维或三维图像的子区域，并控制寻址计算。如果这些值中的任何一个为零，则根据imageExtent，缓冲存储器的这一方面被认为是紧密压缩的</li><li>imageSubresource是一个VkImageSubresourceLayers，用于指定用于源或目标图像数据的图像的特定图像子资源</li><li>imageOffset选择源或目标图像数据子区域的初始x、y、z偏移（以texel为单位）</li><li>imageExtent是要在宽度、高度和深度上复制的图像的大小（以texel为单位）</li></ol><p>当复制到或从深度或模具方面时，缓冲区内存中的数据使用的布局是深度或模具数据的(大部分)紧密封装的表示形式。具体地说:</p><ol><li>复制到或从任何深度&#x2F;模板格式的模板方面的数据都用每个texel的VK_FORMAT_S8_UINT值紧密打包</li><li>复制到或从VK_FORMAT_D16_UNORM或VK_FORMAT_D16_UNORM_S8_UINT格式的深度方面的数据使用每个texel的VK_FORMAT_D16_UNORM值紧密打包</li><li>复制到或从VK_FORMAT_D32_SFLOAT或VK_FORMAT_D32_SFLOAT_S8_UINT格式的深度方面的数据使用每个texel的一个VK_FORMAT_D32_SFLOAT值紧密打包</li><li>复制到或从VK_FORMAT_X8_D24_UNORM_PACK32或VK_FORMAT_D24_UNORM_S8_UINT格式的深度方面的数据被打包为每个texel一个32位单词，每个单词的lsb中有D24值，8个msb中有未定义的值</li></ol><p>由于图像副本的深度或模板方面缓冲区在某些实现上可能需要格式转换，因此不支持图形的队列不支持格式转换。<br>当复制到深度方面时，并且没有启用VK_EXT_depth_range_unrestricted扩展名，缓冲区内存中的数据必须在[0,1]范围内，否则结果值是未定义的。<br>复制从imageSubresource的图像图层baseArrayLayer成员开始一层一层地进行。layerCount层从源图像或目标图像复制。</p><h3 id="1-5-2-vkCmdCopyBufferToImage"><a href="#1-5-2-vkCmdCopyBufferToImage" class="headerlink" title="1.5.2 vkCmdCopyBufferToImage"></a>1.5.2 vkCmdCopyBufferToImage</h3><p>在缓冲区和图像之间复制数据, 从buffer对象复制数据到image对象, 调用vkCmdCopyBufferToImage:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdCopyBufferToImage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    srcBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImage                                     dstImage,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkImageLayout                               dstImageLayout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    regionCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferImageCopy*                    pRegions)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是命令将被记录到的命令缓冲区</li><li>srcBuffer是源缓冲区</li><li>dstImage是目标图像</li><li>dstImageLayout是复制的目标图像子资源的布局</li><li>regionCount是要复制的区域数</li><li>pRegions是一个指向VkBufferImageCopy结构数组的指针，该结构数组指定要复制的区域</li></ol><p>区域中的每个区域从源缓冲区的指定区域复制到目标图像的指定区域。</p><p>如果dstImage的格式是一个多平面的图像格式)，必须使用VkBufferImageCopy结构的pRegions成员单独指定作为拷贝目标的每个平面的区域。在本例中，imageSubresource的aspectMask必须为VK_IMAGE_ASPECT_PLANE_0_BIT、VK_IMAGE_ASPECT_PLANE_1_BIT或VK_IMAGE_ASPECT_PLANE_2_BIT。对于vkCmdCopyBufferToImage来说，多平面图像的每个平面都被视为具有由相应子资源的aspectMask标识的平面的多平面格式的兼容平面格式中列出的格式。这既适用于VkFormat，也适用于复制中使用的坐标，它对应于平面中的texel，而不是这些texel如何映射到整个图像中的坐标。</p><h2 id="1-6-准备纹理图像"><a href="#1-6-准备纹理图像" class="headerlink" title="1.6 准备纹理图像"></a>1.6 准备纹理图像</h2><p>回到createTextureImage函数。我们在那里做的最后一件事是创建纹理图像。下一步是将暂存缓冲区复制到纹理图像。这包括两个步骤:</p><ol><li>转换纹理图像到VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</li><li>执行缓冲区到图像复制操作</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该图像是使用VK_IMAGE_LAYOUT_UNDEFINED布局创建的，因此在转换textureImage时应将oldLayout指定为VK_IMAGE_LAYOUT_UNDEFINED</span></span><br><span class="line"><span class="comment">// 在执行复制操作之前，不关心图像内容，所以可以这样做</span></span><br><span class="line"><span class="built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">        VK_IMAGE_LAYOUT_UNDEFINED,</span><br><span class="line">        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝stagingBuffer中缓存的图像数据至Image（GPU可见内存）</span></span><br><span class="line"><span class="built_in">copyBufferToImage</span>(stagingBuffer, textureImage,</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texWidth), <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(texHeight));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了能够从着色器中的纹理图像开始采样，我们需要最后一个过渡来准备着色器访问(用于同步对资源的访问)：</span></span><br><span class="line"><span class="built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-7-转换屏障的含义-VkAccessFlags"><a href="#1-7-转换屏障的含义-VkAccessFlags" class="headerlink" title="1.7 转换屏障的含义 VkAccessFlags"></a>1.7 转换屏障的含义 VkAccessFlags</h2><p>现在在启用验证层的情况下运行应用程序，那么将看到transitionImageLayout中的访问掩码和管道阶段无效。</p><p>我们需要根据过渡中的布局来设置它们，拷贝前后的两种转换都需要设置：</p><ol><li>VK_IMAGE_LAYOUT_UNDEFINED-&gt;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: 不需要等待任何内容的传输写入</li><li>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL-&gt; VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: shader reads应该等待Transfer writes，特别是shader在片段着色器中读取，因为这就是我们要使用纹理的地方</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineStageFlags sourceStage;</span><br><span class="line">VkPipelineStageFlags destinationStage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED</span><br><span class="line">        &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123;</span><br><span class="line">    barrier.srcAccessMask = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Image或缓冲区在清除或复制操作中的写访问</span></span><br><span class="line">    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line">    <span class="comment">// 指定队列最初接收到任何命令的管道阶段</span></span><br><span class="line">    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;</span><br><span class="line">    <span class="comment">// 指定所有复制命令和清除命令管道阶段</span></span><br><span class="line">    destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</span><br><span class="line">        &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123;</span><br><span class="line">    <span class="comment">// Image或缓冲区在清除或复制操作中的写访问</span></span><br><span class="line">    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;</span><br><span class="line">    <span class="comment">// 指定对存储缓冲区、物理存储缓冲区、统一texel缓冲区、存储texel缓冲区、采样图像或存储图像的读访问</span></span><br><span class="line">    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</span><br><span class="line">    <span class="comment">// 指定所有复制命令和清除命令管道阶段</span></span><br><span class="line">    sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;</span><br><span class="line">    <span class="comment">// 指定片段着色器阶段</span></span><br><span class="line">    destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;unsupported layout transition!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkCmdPipelineBarrier</span>(commandBuffer, sourceStage, destinationStage,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="number">1</span>, &amp;barrier);</span><br></pre></td></tr></table></figure><p>传输写入必须在管道传输阶段进行。因为写操作不需要等待任何东西，所以您可以为预barrier操作指定一个空的访问掩码和尽可能早的管道阶段VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT。需要注意的是，VK_PIPELINE_STAGE_TRANSFER_BIT并不是图形和计算管道中的一个真正的阶段。它更多的是一个发生转移的伪阶段。</p><p>图像将在相同的管道阶段被写入，然后被片段着色器读取，这就是为什么我们在片段着色器管道阶段指定着色器读取访问。需要注意的一点是，命令缓冲区提交在开始时会导致隐式的VK_ACCESS_HOST_WRITE_BIT同步。由于transitionImageLayout函数只使用一个命令来执行一个命令缓冲区，所以如果在布局转换中需要VK_ACCESS_HOST_WRITE_BIT依赖项，您可以使用这个隐式同步并将srcAccessMask设置为0。</p><p>实际上，有一种特殊的图像布局类型可以支持所有操作–VK_IMAGE_LAYOUT_GENERAL。当然，它的问题在于，它不一定能为任何操作提供最佳性能。在某些特殊情况下，例如使用图像作为输入和输出，或者在离开预初始化的布局后读取图像。到目前为止，所有提交命令的帮助程序功能都已设置为通过等待队列变为空闲状态而同步执行。对于实际应用，建议将这些操作组合在单个命令缓冲区中，并异步执行它们以提高吞吐量，尤其是createTextureImage函数中的过渡和复制。通过创建一个helper函数将命令记录到其中的setupCommandBuffer并尝试添加一个flushSetupCommands来执行到目前为止已记录的命令，来尝试进行此操作。最好在纹理贴图工作后执行此操作，以检查纹理资源是否仍正确设置。</p><h3 id="1-7-1-VkAccessFlagBits"><a href="#1-7-1-VkAccessFlagBits" class="headerlink" title="1.7.1 VkAccessFlagBits"></a>1.7.1 VkAccessFlagBits</h3><p>Vulkan中的内存可以通过shader调用和管道中的一些固定函数来访问。访问类型是所使用的描述符类型的函数，或者固定函数阶段如何访问内存。每个访问类型对应于VkAccessFlagBits中的一个位标志。</p><p>一些同步命令以访问类型集作为参数来定义内存依赖项的访问范围。如果同步命令包含源访问掩码，则其第一个访问作用域仅包括通过该掩码中指定的访问类型进行的访问。类似地，如果同步命令包含目标访问掩码，则其第二个访问作用域仅包括通过该掩码中指定的访问类型进行的访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkAccessFlagBits</span> &#123;</span><br><span class="line">    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_ACCESS_INDEX_READ_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_ACCESS_UNIFORM_READ_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_ACCESS_SHADER_READ_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_ACCESS_SHADER_WRITE_BIT = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_ACCESS_TRANSFER_READ_BIT = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_ACCESS_TRANSFER_WRITE_BIT = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_ACCESS_HOST_READ_BIT = <span class="number">0x00002000</span>,</span><br><span class="line">    VK_ACCESS_HOST_WRITE_BIT = <span class="number">0x00004000</span>,</span><br><span class="line">    VK_ACCESS_MEMORY_READ_BIT = <span class="number">0x00008000</span>,</span><br><span class="line">    VK_ACCESS_MEMORY_WRITE_BIT = <span class="number">0x00010000</span>,</span><br><span class="line">    VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = <span class="number">0x02000000</span>,</span><br><span class="line">    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = <span class="number">0x04000000</span>,</span><br><span class="line">    VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = <span class="number">0x08000000</span>,</span><br><span class="line">    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = <span class="number">0x00100000</span>,</span><br><span class="line">    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = <span class="number">0x00020000</span>,</span><br><span class="line">    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = <span class="number">0x00040000</span>,</span><br><span class="line">    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = <span class="number">0x00080000</span>,</span><br><span class="line">    VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = <span class="number">0x00800000</span>,</span><br><span class="line">    VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = <span class="number">0x00200000</span>,</span><br><span class="line">    VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = <span class="number">0x00400000</span>,</span><br><span class="line">    VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = <span class="number">0x01000000</span>,</span><br><span class="line">    VK_ACCESS_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkAccessFlagBits;</span><br></pre></td></tr></table></figure><ol><li>VK_ACCESS_INDIRECT_COMMAND_READ_BIT指定对作为间接绘图或调度命令一部分的间接命令数据的读访问</li><li>VK_ACCESS_INDEX_READ_BIT指定对索引缓冲区的读访问，作为索引绘图命令的一部分，由vkCmdBindIndexBuffer绑定</li><li>VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT指定对顶点缓冲区的读访问，作为绘图命令的一部分，由vkCmdBindVertexBuffers绑定</li><li>VK_ACCESS_UNIFORM_READ_BIT统一缓冲区读访问权限</li><li>VK_ACCESS_INPUT_ATTACHMENT_READ_BIT指定在片段着色期间渲染通道内对输入附件的读访问</li><li>VK_ACCESS_SHADER_READ_BIT指定对存储缓冲区、物理存储缓冲区、统一texel缓冲区、存储texel缓冲区、采样图像或存储图像的读访问</li><li>VK_ACCESS_SHADER_WRITE_BIT存储缓冲区、物理存储缓冲区、存储texel缓冲区或存储映像的写访问</li><li>VK_ACCESS_COLOR_ATTACHMENT_READ_BIT指定对颜色附件的读访问，例如通过混合、逻辑操作或通过某些subpass加载操作。它不包括高级混合操作</li><li>VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT指定在渲染通道期间或通过某些子通道加载和存储操作对颜色、解析或深度&#x2F;模板解析附件的写访问</li><li>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT指定对深度&#x2F;模板附件的读访问，通过深度或模板操作，或通过某些子传递加载操作</li><li>VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT指定对深度&#x2F;模板附件的写访问，通过深度或模板操作，或者通过某些子传递加载和存储操作</li><li>VK_ACCESS_TRANSFER_READ_BIT拷贝操作中对镜像或缓冲区的读访问</li><li>VK_ACCESS_TRANSFER_WRITE_BIT映像或缓冲区在清除或复制操作中的写访问</li><li>VK_ACCESS_HOST_READ_BIT主机操作读访问。这种类型的访问不是通过资源执行的，而是直接在内存上执行的</li><li>VK_ACCESS_HOST_WRITE_BIT主机操作写访问。这种类型的访问不是通过资源执行的，而是直接在内存上执行的</li><li>VK_ACCESS_MEMORY_READ_BIT所有读访问。它在任何访问掩码中都是有效的，并被视为等同于设置所有在使用它时有效的读访问标志</li><li>VK_ACCESS_MEMORY_WRITE_BIT所有写访问。它在任何访问掩码中都是有效的，并被视为等同于设置所有在使用它时有效的写访问标志</li><li>VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT指定对谓词的读访问，作为条件呈现的一部分</li><li>VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT指定在转换反馈激活时对转换反馈缓冲区的写访问</li><li>VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT指定对转换反馈计数器缓冲区的读访问，当vkCmdBeginTransformFeedbackEXT执行时读取该缓冲区</li><li>VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT指定对转换反馈计数器缓冲区的写访问，该缓冲区在vkCmdEndTransformFeedbackEXT执行时写入</li><li>VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX指定从VkBuffer输入读取vkCmdProcessCommandsNVX</li><li>VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX指定写到vkCmdProcessCommandsNVX的目标命令缓冲区</li><li>VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT类似于VK_ACCESS_COLOR_ATTACHMENT_READ_BIT，但是也包括高级的混合操作</li><li>VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV指定对着色率图像的读取访问，作为绘图命令的一部分，由vkcmdbindshadingraemimagenv绑定</li><li>VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV指定对加速结构的读访问，作为跟踪或构建命令的一部分</li><li>VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV指定对加速结构的写访问，作为构建命令的一部分</li><li>VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT动态碎片密度图操作时对碎片密度图附件的读访问</li></ol><h3 id="1-7-2-VkPipelineStageFlags-管道阶段"><a href="#1-7-2-VkPipelineStageFlags-管道阶段" class="headerlink" title="1.7.2 VkPipelineStageFlags 管道阶段"></a>1.7.2 VkPipelineStageFlags 管道阶段</h3><p>操作或同步命令执行的工作由多个操作组成，这些操作作为逻辑上独立的步骤序列执行，称为管道阶段。执行的确切管道阶段取决于所使用的特定命令，以及记录命令时的当前命令缓冲区状态。绘制命令、分派命令、复制命令、清除命令和同步命令都在管道阶段的不同集合中执行。同步命令不会在已定义的管道中执行，但会执行VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT和VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT。</p><p>注意同步命令执行的操作(例如可用性和可见性操作)不是由定义的管道阶段执行的。但是，其他命令仍然可以通过VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT和VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT管道阶段与它们同步。</p><p>跨管道阶段执行操作必须遵循隐式排序保证，特别是包括管道阶段顺序。否则，与其他阶段相比，跨管道阶段的执行可能会重叠或无序执行，除非执行依赖项强制执行。</p><p>一些同步命令包括管道阶段参数，将该命令的同步范围限制在这些阶段。这允许对精确的执行依赖关系和操作命令执行的访问进行细粒度的控制。实现应该使用这些管道阶段来避免不必要的停顿或缓存刷新。</p><p>可以设置指定管道阶段通过VkPipelineStageFlags:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkPipelineStageFlagBits</span> &#123;</span><br><span class="line">    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TRANSFER_BIT = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = <span class="number">0x00002000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_HOST_BIT = <span class="number">0x00004000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = <span class="number">0x00008000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = <span class="number">0x00010000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT = <span class="number">0x01000000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = <span class="number">0x00040000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = <span class="number">0x00020000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV = <span class="number">0x00400000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV = <span class="number">0x00200000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV = <span class="number">0x02000000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV = <span class="number">0x00080000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV = <span class="number">0x00100000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT = <span class="number">0x00800000</span>,</span><br><span class="line">    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkPipelineStageFlagBits;</span><br></pre></td></tr></table></figure><ol><li>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT指定队列最初接收到任何命令的管道阶段</li><li>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT指定使用Draw&#x2F;DispatchIndirect数据结构的管道阶段。这个阶段还包括读取vkCmdProcessCommandsNVX写的命令</li><li>VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV指定任务着色器阶段</li><li>VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV指定网格着色器阶段</li><li>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT指定消耗顶点和索引缓冲区的流水线阶段</li><li>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT指定顶点着色器阶段</li><li>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT指定镶嵌控制着色器阶段</li><li>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT指定镶嵌评估着色器阶段</li><li>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT指定几何着色器阶段</li><li>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT指定片段着色器阶段</li><li>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT指定执行早期片段测试（片段着色之前的深度和模板测试）的管道阶段。此阶段还包括针对具有深度&#x2F;模板格式的帧缓冲区附件的子传递加载操作</li><li>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT指定执行后期片段测试（片段着色后的深度和模板测试）的管道阶段。此阶段还包括用于具有深度&#x2F;模板格式的帧缓冲区附件的子传递存储操作</li><li>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT指定混合后管道的阶段，从管道输出最终颜色值。此阶段还包括子通道加载和存储操作以及具有颜色或深度&#x2F;模板格式的帧缓冲区附件的多样本解析操作</li><li>VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT指定执行计算着色器</li><li>VK_PIPELINE_STAGE_TRANSFER_BIT指定以下命令：<ol><li>所有复制命令，包括vkCmdCopyQueryPoolResults，vkCmdBlitImage，vkCmdResolveImage</li><li>所有清除命令，但vkCmdClearAttachments除外</li></ol></li><li>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT指定管道中由所有命令生成的操作完成执行的最后阶段</li><li>VK_PIPELINE_STAGE_HOST_BIT指定一个伪阶段，指示在主机上执行设备存储器的读&#x2F;写操作。记录在命令缓冲区中的任何命令都不会调用此阶段</li><li>VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV指定光线跟踪着色器阶段的执行</li><li>VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV指定vkCmdBuildAccelerationStructureNV，vkCmdCopyAccelerationStructureNV和vkCmdWriteAccelerationStructuresPropertiesNV的执行</li><li>VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT指定所有图形管线阶段的执行，并且等效于：<ol><li>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</li><li>VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT</li><li>VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV</li><li>VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV</li><li>VK_PIPELINE_STAGE_VERTEX_INPUT_BIT</li><li>VK_PIPELINE_STAGE_VERTEX_SHADER_BIT</li><li>VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT</li><li>VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT</li><li>VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT</li><li>VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT</li><li>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</li><li>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</li><li>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</li><li>VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT</li><li>VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT</li><li>VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT</li><li>VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV</li><li>VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT</li></ol></li><li>VK_PIPELINE_STAGE_ALL_COMMANDS_BIT等效于与其一起使用的队列上支持的所有其他管道阶段标志的逻辑或</li><li>VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT指定使用条件渲染谓词的管道阶段</li><li>VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT指定将顶点属性输出值写入转换反馈缓冲区的管线阶段</li><li>VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX指定了处理通过vkCmdProcessCommandsNVX在设备端生成命令的管道阶段</li><li>VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV指定管道的阶段，在该阶段中读取阴影率图像，以确定栅格化图元各部分的阴影率</li><li>VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT指定读取片段密度图以生成片段区域的管线阶段</li></ol><h2 id="1-8-清理"><a href="#1-8-清理" class="headerlink" title="1.8 清理"></a>1.8 清理</h2><p>创建纹理贴图后，不能忘记在必要的时候将内存释放出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createTextureImage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通过清除过渡缓冲区及其末尾的内存来完成createTextureImage函数：</span></span><br><span class="line">    <span class="built_in">transitionImageLayout</span>(textureImage, VK_FORMAT_R8G8B8A8_UNORM,</span><br><span class="line">            VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,</span><br><span class="line">            VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyImage</span>(device, textureImage, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, textureImageMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-9-总结"><a href="#1-9-总结" class="headerlink" title="1.9 总结"></a>1.9 总结</h2><p>到目前为止，我们从设备物理存储上读取了图片内容，将其转成临时缓存后又将其存储在对应GPU可见的内存中以及生成对应VkImage纹理贴图对象，接下来需要将其显示在屏幕上还需要把这个对象放入图形管道中。</p><p>在回顾下本章中的读取图像的步骤:</p><ol><li>首先利用stb-image库读取图片，将其内容存储在临时缓存区VkBuffer中，注意需要开辟GPU可见内存</li><li>通过VkImageCreateInfo结构指明图像格式并通过vkCreateImage创建VkImage对象</li><li>用VkBuffer图像文件中的像素填充创建的VkImage图像对象<ol><li>填充图像对象需要使用VkImageMemoryBarrier</li><li>使用vkCmdPipelineBarrier使得图像填充Barrier生效</li><li>通过vkCmdCopyBufferToImage完成图像像素从VkBuffer到VkImage的拷贝(填充)</li><li>再通过VkImageMemoryBarrier指定图像是能够从着色器中的纹理图像开始采样</li></ol></li><li>创建图像视图和图像采样器(后续下一章开始处理)</li><li>添加一个组合的图像采样器描述符来从纹理中采样颜色</li></ol><p>上面步骤中，4和5是下一章的内容。</p><h2 id="1-10-Windows上的CMakefileLists-txt写法"><a href="#1-10-Windows上的CMakefileLists-txt写法" class="headerlink" title="1.10 Windows上的CMakefileLists.txt写法"></a>1.10 Windows上的CMakefileLists.txt写法</h2><p>windows平台上编译当前项目，可以使用cmake, CMakefileLists.txt文件如下(注意先安装Vulkan sdk)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cmake_minimum_required (VERSION 3.7) #最低要求的CMake版本</span><br><span class="line">project(MyVulkan) # 项目名称</span><br><span class="line">set(VERSION 0.0.1)</span><br><span class="line">set(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17 -g -Wall -Wno-unused-variable -pthread&quot;)</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;This is &quot; $&#123;PROJECT_NAME&#125; &quot; version &quot; $&#123;VERSION&#125;)</span><br><span class="line">message(STATUS &quot;This is for windows platform&quot;)</span><br><span class="line">message(&quot;Build Type:&quot; $&#123;CMAKE_BUILD_TYPE&#125; $&#123;CMAKE_CXX_FLAGS&#125;)</span><br><span class="line"></span><br><span class="line"># Use FindVulkan module added with CMAKE 3.7</span><br><span class="line">if (NOT CMAKE_VERSION VERSION_LESS 3.7.0)</span><br><span class="line">    message(STATUS &quot;Using module to find Vulkan&quot;)</span><br><span class="line">    find_package(Vulkan)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">find_library(Vulkan_LIBRARY NAMES vulkan-1 vulkan PATHS $&#123;CMAKE_SOURCE_DIR&#125;/libs/vulkan)</span><br><span class="line">IF (Vulkan_LIBRARY)</span><br><span class="line">    set(Vulkan_FOUND ON)</span><br><span class="line">    MESSAGE(&quot;Using bundled Vulkan library version&quot;)</span><br><span class="line">ENDIF()</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;Using Vulkan lib: &quot; $&#123;Vulkan_LIBRARY&#125;)</span><br><span class="line"></span><br><span class="line"># CMAKE_SOURCE_DIR 代表工程根目录CMakeLists.txt文件所在目录</span><br><span class="line">set(ROOT_DIR $&#123;CMAKE_SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">### GLFW3</span><br><span class="line">set(GLFW_LIB_DIR $&#123;ROOT_DIR&#125;/lib/glfw3)</span><br><span class="line">set(GLFW_LIBS $&#123;GLFW_LIB_DIR&#125;/glfw3dll.lib)</span><br><span class="line">### GLM</span><br><span class="line">set(GLM_INCLUDE_DIRS  $&#123;ROOT_DIR&#125;/include/glm)</span><br><span class="line">### stb-image</span><br><span class="line">set(STB_IMAGE_DIRS  $&#123;ROOT_DIR&#125;/include/stb-image)</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;Lib path: &quot;)</span><br><span class="line">message(STATUS &quot;  GLFW3: &quot; $&#123;GLFW_LIBS&#125;)</span><br><span class="line">message(STATUS &quot;  GLM  : &quot; $&#123;GLM_INCLUDE_DIRS&#125;)</span><br><span class="line">message(STATUS &quot;  STB_IMAGE: &quot; $&#123;STB_IMAGE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 定义头文件搜索路径</span><br><span class="line">include_directories($&#123;ROOT_DIR&#125;/inlcude</span><br><span class="line">                    $&#123;GLM_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">#aux_source_directory(./ SOURCE_DIR)</span><br><span class="line">aux_source_directory($&#123;ROOT_DIR&#125;/inlcude SOURCE_DIR)</span><br><span class="line">aux_source_directory($&#123;ROOT_DIR&#125;/src SOURCE_DIR)</span><br><span class="line"></span><br><span class="line"># Target</span><br><span class="line">add_executable(MyVulkan $&#123;SOURCE_DIR&#125;)</span><br><span class="line"></span><br><span class="line">####Vulkan</span><br><span class="line">find_package(Vulkan REQUIRED)</span><br><span class="line"># GLFW3 is dynamic link</span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; Vulkan::Vulkan $&#123;GLFW_LIBS&#125;)</span><br></pre></td></tr></table></figure><p>项目文件目录:</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-14-VkImage%E5%9B%BE%E5%83%8F%E7%9A%84%E5%88%9B%E5%BB%BA/Vulkan_14_1.png" alt="图像14-1"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;在之前我们使用顶点着色器以及描述符来实现绘制有颜色的几何体，还实现了旋转动画。接下来我们学习一下纹理贴图，这个将是我们实现加载绘制基本3D模型的基础。&lt;/p&gt;</summary>
    
    
    
    <category term="图像引擎" scheme="https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Vulkan" scheme="https://swallowjoe.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Vulkan入门(13)-描述符布局及缓存</title>
    <link href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/"/>
    <id>https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-13-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BC%93%E5%AD%98/</id>
    <published>2022-02-26T19:34:54.000Z</published>
    <updated>2022-02-26T19:43:22.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。</p><span id="more"></span><p>在Vulkan中解决这个问题的正确方法是使用资源描述符（resource descriptor）。描述符是着色器自由访问缓冲区和图像等资源的一种方式。我们将设置一个包含变换矩阵的缓冲区，并让顶点着色器通过描述符访问它们。描述符的使用包括三个部分：</p><ol><li>在管道创建期间指定描述符布局</li><li>从描述符池分配描述符集</li><li>渲染期间绑定描述符集</li></ol><p>描述符是表示着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。描述符被组织成描述符集，这些描述符集在命令记录期间被绑定，以便在后续的绘制命令中使用。每个描述符集中内容的安排由描述符集布局决定，该布局决定了可以在其中存储哪些描述符。管道可使用的描述符集布局序列在管道布局中指定。每个管道对象最多可以使用maxBoundDescriptorSets(参见限制)描述符集。</p><p>描述符布局指定管道要访问的资源类型，就像渲染过程指定要访问的附件类型一样。描述符集指定将绑定到描述符的实际缓冲区或图像资源，就像帧缓冲区指定要绑定到渲染过程附件的实际图像视图一样。然后为绘图命令绑定描述符集，就像顶点缓冲区和帧缓冲区一样。</p><p>着色器通过装饰有描述符集和绑定数的变量访问资源，这些变量将它们连接到描述符集中的描述符。着色器接口到绑定描述符集的映射在着色器资源接口部分描述。着色器也可以通过64位地址使用物理存储缓冲区访问，而不需要通过描述符来访问缓冲区。</p><p>描述符有很多种类型，这里使用统一缓冲区对象(UBO)。如下所示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UniformBufferObject</span> &#123;</span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    glm::mat4 view;</span><br><span class="line">    glm::mat4 proj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用GLM中的数据类型精确匹配着色器中的定义。矩阵中的数据与着色器期望的方式是二进制兼容的，因此我们可以稍后将UniformBufferObject的memcpy转换为VkBuffer。</p><p>需要更改顶点着色器:</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> UniformBufferObject &#123;</span><br><span class="line">    <span class="type">mat4</span> model;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">    <span class="type">mat4</span> proj;</span><br><span class="line">&#125; ubo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = ubo.proj * ubo.view * ubo.model * <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定指令类似于属性的位置指令。 我们将在描述符布局中引用此绑定。 更改了带有gl_Position的行，以使用转换来计算剪辑坐标中的最终位置。 与2D三角形不同，剪辑坐标的最后一个分量可能不是1，这在转换为屏幕上的最终归一化设备坐标时将导致除法。 这在透视投影中用作透视划分，对于使较近的对象看起来比较远的对象看起来更大，这是必不可少的。</p><h1 id="一-描述符集布局"><a href="#一-描述符集布局" class="headerlink" title="一. 描述符集布局"></a>一. 描述符集布局</h1><p>我们需要提供着色器中用于管道创建的每个描述符绑定的详细信息，就像我们必须为每个顶点属性及其位置索引所做的那样。我们将设置一个新函数来定义所有这些信息，称为createDescriptorSetLayout。在创建管道之前应该调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorSetLayout</span>();</span><br><span class="line">    <span class="built_in">createGraphicsPipeline</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个绑定都需要通过VkDescriptorSetLayoutBinding结构来描述。前两个字段指定在着色器中使用的绑定和描述符的类型，该描述符是一个统一的缓冲区对象。着色器变量可能表示一个统一缓冲区对象的数组，而描述符计数指定该数组中值的数量。 例如，这可用于为骨骼动画指定骨骼中每个骨骼的变换。 我们的MVP转换位于单个统一缓冲区对象中，因此我们使用的描述符数为1。</p><h2 id="1-1-VkDescriptorSetLayoutBinding"><a href="#1-1-VkDescriptorSetLayoutBinding" class="headerlink" title="1.1 VkDescriptorSetLayoutBinding"></a>1.1 VkDescriptorSetLayoutBinding</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutBinding</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>              binding;</span><br><span class="line">    VkDescriptorType      descriptorType;</span><br><span class="line">    <span class="type">uint32_t</span>              descriptorCount;</span><br><span class="line">    VkShaderStageFlags    stageFlags;</span><br><span class="line">    <span class="type">const</span> VkSampler*      pImmutableSamplers;</span><br><span class="line">&#125; VkDescriptorSetLayoutBinding;</span><br></pre></td></tr></table></figure><ol><li>binding是此条目的绑定号，并且与着色器阶段中具有相同绑定号的资源相对应。</li><li>descriptorType是VkDescriptorType，它指定用于此绑定的资源描述符的类型。</li><li>descriptorCount是绑定中包含的描述符数量，在着色器中以数组形式访问，除非描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，在这种情况下，描述符计数是嵌入式统一块的字节大小。如果描述符计数为零，则此绑定条目被保留，并且不得使用设置的布局在任何管道内通过任何绑定从任何阶段访问资源。</li><li>stageFlags成员是VkShaderStageFlagBits的位掩码，用于指定哪些管道着色器阶段可以访问此绑定的资源。 VK_SHADER_STAGE_ALL是一种简写形式，用于指定所有定义的着色器阶段，包括扩展定义的任何其他阶段，都可以访问该资源。如果stageFlags中未包含着色器阶段，则不得使用设置的布局在任何管道中通过此绑定从该阶段访问资源。除了限于片段着色器的输入附件之外，对于阶段的哪些组合可以使用描述符绑定没有任何限制，特别是图形阶段和计算阶段都可以使用绑定。</li><li>pImmutableSamplers影响采样器的初始化。如果描述符类型指定VK_DESCRIPTOR_TYPE_SAMPLER或VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER类型描述符，则可以使用pImmutableSamplers初始化一组不可变的采样器。不可变的采样器永久绑定到设置的布局中，不得更改。不允许使用不可变采样器更新VK_DESCRIPTOR_TYPE_SAMPLER描述符，并且使用不可变采样器更新VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER描述符不会修改采样器（将更新图像视图，但会忽略采样器更新）。如果pImmutableSamplers不为NULL，则它指向一个采样器句柄数组，该数组将被复制到set布局中并用于相应的绑定。仅采样器句柄被复制；在最终使用集合布局以及使用它创建的任何描述符池和集合之前，不得破坏采样器对象。如果pImmutableSamplers为NULL，则采样器插槽是动态的，必须使用此布局将采样器句柄绑定到描述符集中。如果描述符类型不是这些描述符类型之一，则将忽略pImmutableSamplers。</li></ol><h3 id="1-1-1-VkDescriptorType"><a href="#1-1-1-VkDescriptorType" class="headerlink" title="1.1.1 VkDescriptorType"></a>1.1.1 VkDescriptorType</h3><p>其中描述符的类型VkDescriptorType有如下取值:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkDescriptorType</span> &#123;</span><br><span class="line">    VK_DESCRIPTOR_TYPE_SAMPLER = <span class="number">0</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = <span class="number">1</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = <span class="number">2</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = <span class="number">3</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = <span class="number">4</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = <span class="number">5</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = <span class="number">6</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = <span class="number">7</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = <span class="number">8</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = <span class="number">9</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = <span class="number">10</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT = <span class="number">1000138000</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV = <span class="number">1000165000</span>,</span><br><span class="line">    VK_DESCRIPTOR_TYPE_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkDescriptorType;</span><br></pre></td></tr></table></figure><ol><li>VK_DESCRIPTOR_TYPE_SAMPLER: 指定采样器描述符</li><li>VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: 指定组合图像采样器描述符</li><li>VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: 指定采样图像描述符</li><li>VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: 指定存储映像描述符</li><li>VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: 指定统一纹理像素缓冲区描述符</li><li>VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: 指定存储纹理元素缓冲区描述符</li><li>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: 统一缓冲区描述符</li><li>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: 指定存储缓冲区描述符</li><li>VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: 指定动态统一缓冲区描述符</li><li>VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: 指定动态存储缓冲区描述符</li><li>VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: 指定输入附件描述符</li><li>VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: 指定内联统一块</li></ol><h3 id="1-1-2-VkShaderStageFlags"><a href="#1-1-2-VkShaderStageFlags" class="headerlink" title="1.1.2 VkShaderStageFlags"></a>1.1.2 VkShaderStageFlags</h3><p>需要指定一个或多个着色器阶段的命令和结构使用位对应于阶段的位掩码来指定。可以设置为指定着色器阶段的位有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkShaderStageFlagBits</span> &#123;</span><br><span class="line">    VK_SHADER_STAGE_VERTEX_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_SHADER_STAGE_GEOMETRY_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_SHADER_STAGE_FRAGMENT_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_SHADER_STAGE_COMPUTE_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL_GRAPHICS = <span class="number">0x0000001F</span>,</span><br><span class="line">    VK_SHADER_STAGE_ALL = <span class="number">0x7FFFFFFF</span>,</span><br><span class="line">    VK_SHADER_STAGE_RAYGEN_BIT_NV = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_SHADER_STAGE_ANY_HIT_BIT_NV = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_SHADER_STAGE_MISS_BIT_NV = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_SHADER_STAGE_INTERSECTION_BIT_NV = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_SHADER_STAGE_CALLABLE_BIT_NV = <span class="number">0x00002000</span>,</span><br><span class="line">    VK_SHADER_STAGE_TASK_BIT_NV = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_SHADER_STAGE_MESH_BIT_NV = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkShaderStageFlagBits;</span><br></pre></td></tr></table></figure><ol><li>VK_SHADER_STAGE_VERTEX_BIT: 顶点阶段</li><li>VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: 细分控制阶段</li><li>VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: 细分评估阶段</li><li>VK_SHADER_STAGE_GEOMETRY_BIT: 几何图形阶段</li><li>VK_SHADER_STAGE_FRAGMENT_BIT: 片段阶段</li><li>VK_SHADER_STAGE_COMPUTE_BIT: 计算阶段</li><li>VK_SHADER_STAGE_ALL_GRAPHICS: 用作速记的位的组合，用于指定上面定义的所有图形阶段（计算阶段除外）</li><li>VK_SHADER_STAGE_ALL: 用作简写的位的组合，用于指定设备支持的所有着色器阶段，包括扩展引入的所有其他阶段</li><li>VK_SHADER_STAGE_TASK_BIT_NV: 任务阶段</li><li>VK_SHADER_STAGE_MESH_BIT_NV: 网格阶段</li><li>VK_SHADER_STAGE_RAYGEN_BIT_NV: 射线生成阶段</li><li>VK_SHADER_STAGE_ANY_HIT_BIT_NV: 任何命中阶段</li><li>VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: 最接近的命中阶段</li><li>VK_SHADER_STAGE_MISS_BIT_NV: 未命中阶段</li><li>VK_SHADER_STAGE_INTERSECTION_BIT_NV: 相交阶段</li><li>VK_SHADER_STAGE_CALLABLE_BIT_NV: 可调用阶段</li></ol><h2 id="1-2-创建VkDescriptorSetLayout"><a href="#1-2-创建VkDescriptorSetLayout" class="headerlink" title="1.2 创建VkDescriptorSetLayout"></a>1.2 创建VkDescriptorSetLayout</h2><p>所有描述符绑定都合并到一个vkDescriptorSetLayout对象中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">VkDescriptorSetLayout descriptorSetLayout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSetLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 指定在着色器中使用的绑定</span></span><br><span class="line">    uboLayoutBinding.binding = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 描述符的类型</span></span><br><span class="line">    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    uboLayoutBinding.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 指定描述符将在顶点着色器阶段被引用</span></span><br><span class="line">    uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">    <span class="comment">// pImmutableSamplers仅与图像采样描述符有关</span></span><br><span class="line">    uboLayoutBinding.pImmutableSamplers = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;;</span><br><span class="line">    layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;</span><br><span class="line">    layoutInfo.bindingCount = <span class="number">1</span>;</span><br><span class="line">    layoutInfo.pBindings = &amp;uboLayoutBinding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建描述符集布局</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorSetLayout</span>(device, &amp;layoutInfo, <span class="literal">nullptr</span>, &amp;descriptorSetLayout) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor set layout!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-1-VkDescriptorSetLayoutCreateInfo"><a href="#1-2-1-VkDescriptorSetLayoutCreateInfo" class="headerlink" title="1.2.1 VkDescriptorSetLayoutCreateInfo"></a>1.2.1 VkDescriptorSetLayoutCreateInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetLayoutCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                            pNext;</span><br><span class="line">    VkDescriptorSetLayoutCreateFlags       flags;</span><br><span class="line">    <span class="type">uint32_t</span>                               bindingCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayoutBinding*    pBindings;</span><br><span class="line">&#125; VkDescriptorSetLayoutCreateInfo;</span><br></pre></td></tr></table></figure><ol><li>sType就是这种结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</li><li>pNext为NULL或指向特定于扩展的结构的指针</li><li>flags是VkDescriptorSetLayoutCreateFlagBits的位掩码，用于指定描述符集布局创建的选项</li><li>bindingCount是pBindings中的元素数</li><li>pBindings是指向VkDescriptorSetLayoutBinding结构数组的指针</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkDescriptorSetLayoutCreateFlagBits</span> &#123;</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,</span><br><span class="line">    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkDescriptorSetLayoutCreateFlagBits;</span><br></pre></td></tr></table></figure><ol><li>VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT: 指定不得使用此布局分配描述符集，而是由vkCmdPushDescriptorSetKHR推送描述符</li><li>VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR: 指定描述符集使用此布局必须从创建一个描述符池分配VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT位集。描述符集布局创建这部分设置有备用限制描述符的最大数量每级和per-pipeline布局。non-UpdateAfterBind限制仅计数在没有此标志的情况下创建的集合中的描述符。UpdateAfterBind限制计算所有描述符，但是限制可能高于非UpdateAfterBind限制。</li></ol><h3 id="1-2-2-vkCreateDescriptorSetLayout"><a href="#1-2-2-vkCreateDescriptorSetLayout" class="headerlink" title="1.2.2 vkCreateDescriptorSetLayout"></a>1.2.2 vkCreateDescriptorSetLayout</h3><p>描述符集布局对象由零个或多个描述符绑定的数组定义。每个单独的描述符绑定由描述符类型、绑定中描述符数量的计数（数组大小）、可以访问绑定的一组着色器阶段以及（如果使用不可变采样器）采样器描述符数组指定。</p><p>创建描述符集布局可以使用函数: vkCreateDescriptorSetLayout</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorSetLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetLayoutCreateInfo*      pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSetLayout*                      pSetLayout)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 创建描述符集布局的逻辑设备</li><li>pCreateInfo: 指向VkDescriptorSetLayoutCreateInfo结构的指针，它指定了描述符集布局对象的状态</li><li>pAllocator: 控制主机内存分配</li><li>pSetLayout: 指向VkDescriptorSetLayout句柄的指针，在这个句柄中返回结果描述符集布局对象</li></ol><p>当然通过vkCreate*创建的对象或资源，一般需要显示销毁:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="built_in">vkDestroyDescriptorSetLayout</span>(device, descriptorSetLayout, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-管道指定描述符集布局"><a href="#1-3-管道指定描述符集布局" class="headerlink" title="1.3 管道指定描述符集布局"></a>1.3 管道指定描述符集布局</h2><p>我们需要在管道创建期间指定描述符集布局，以告诉Vulkan着色器将使用哪些描述符。描述符集布局在管道布局对象中指定。修改VkPipelineLayoutCreateInfo以引用布局对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;;</span><br><span class="line">pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;</span><br><span class="line">pipelineLayoutInfo.setLayoutCount = <span class="number">1</span>;</span><br><span class="line">pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout;</span><br></pre></td></tr></table></figure><p>这里留个悬念，为什么可以指定多个描述符集布局。</p><h2 id="1-4-统一缓存"><a href="#1-4-统一缓存" class="headerlink" title="1.4 统一缓存"></a>1.4 统一缓存</h2><p>我们将指定包含着色器的UBO数据的缓冲区，但是我们需要首先创建这个缓冲区。我们将在每一帧将新数据复制到统一缓冲区，因此使用暂存缓冲区实际上没有任何意义。在这种情况下，它只会增加额外的开销，而且可能会降低性能。</p><p>我们应该有多个缓冲区，因为多个帧可能在同一时间绘制，我们不想更新缓冲区，准备下一帧，而前一帧仍在读取它！我们可以为每个帧或每个交换链图像提供统一的缓冲区。然而，由于我们需要从每个交换链映像所拥有的命令缓冲区引用统一缓冲区，因此最好也为每个交换链映像创建一个统一缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">VkBuffer indexBuffer;</span><br><span class="line">VkDeviceMemory indexBufferMemory;</span><br><span class="line"></span><br><span class="line">std::vector&lt;VkBuffer&gt; uniformBuffers;</span><br><span class="line">std::vector&lt;VkDeviceMemory&gt; uniformBuffersMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    <span class="built_in">createIndexBuffer</span>();</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createUniformBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br><span class="line">    uniformBuffers.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    uniformBuffersMemory.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImages.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">createBuffer</span>(bufferSize,</span><br><span class="line">                VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,</span><br><span class="line">                uniformBuffers[i], uniformBuffersMemory[i],</span><br><span class="line">                VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将编写一个单独的函数，在每一帧用一个新的转换来更新统一缓冲区，所以这里没有vkMapMemory。</p><p>统一数据将被用于所有的draw调用，所以包含它的缓冲区只有在我们停止渲染时才会被销毁。因为它也取决于交换链图像的数量，这可能会在重新创建后改变，所以在cleanupSwapChain中清理它:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; uniformBuffers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">vkDestroyBuffer</span>(device, uniformBuffers[i], <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">vkFreeMemory</span>(device, uniformBuffersMemory[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createFramebuffers</span>();</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-更新统一缓存数据"><a href="#1-5-更新统一缓存数据" class="headerlink" title="1.5 更新统一缓存数据"></a>1.5 更新统一缓存数据</h2><p>在绘制更新交换链帧的时候更新统一缓存数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">updateUniformBuffer</span>(imageIndex);</span><br><span class="line"></span><br><span class="line">    VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUniformBuffer</span><span class="params">(<span class="type">uint32_t</span> currentImage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateUniformBuffer函数将在每帧生成一个新的变换，以使几何体旋转。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保glm::rotate之类的函数使用弧度作为参数是必要的，以避免任何可能的混淆</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLM_FORCE_RADIANS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="comment">// chrono标准库标头公开了执行精确计时的功能</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateUniformBuffer</span><span class="params">(<span class="type">uint32_t</span> currentImage)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> startTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> currentTime = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 计算时长</span></span><br><span class="line">    <span class="type">float</span> time = std::chrono::<span class="built_in">duration</span>&lt;<span class="type">float</span>, std::chrono::seconds::period&gt;(currentTime - startTime).<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">    UniformBufferObject ubo = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 在统一缓冲区对象中定义模型，视图和投影转换。 使用时间变量，模型旋转将是围绕Z轴的简单旋转</span></span><br><span class="line">    <span class="comment">// 意思是每秒旋转90度</span></span><br><span class="line">    ubo.model = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), time * glm::<span class="built_in">radians</span>(<span class="number">90.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line">    <span class="comment">// 设置视图角度，从上方以45度角查看几何图形。 glm :: lookAt函数将眼睛位置，中心位置和上轴作为参数。</span></span><br><span class="line">    ubo.view = glm::<span class="built_in">lookAt</span>(glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>, <span class="number">2.0f</span>, <span class="number">2.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用具有45度垂直视场的透视投影。</span></span><br><span class="line">    <span class="comment">// 其他参数是长宽比，近视平面和远视平面。 重要的是使用当前交换链范围来计算纵横比，以考虑调整大小后窗口的新宽度和高度。</span></span><br><span class="line">    ubo.proj = glm::<span class="built_in">perspective</span>(glm::<span class="built_in">radians</span>(<span class="number">45.0f</span>), swapChainExtent.width / (<span class="type">float</span>) swapChainExtent.height, <span class="number">0.1f</span>, <span class="number">10.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLM最初是为OpenGL(左手坐标系)设计的，将其中坐标的Y坐标反转。 最简单的补偿方法是在投影矩阵中翻转Y轴缩放比例上的符号。 </span></span><br><span class="line">    <span class="comment">// 如果不这样做，那么图像将被倒置呈现。</span></span><br><span class="line">    ubo.proj[<span class="number">1</span>][<span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将统一缓冲区对象中的数据复制到当前的统一缓冲区中。 与使用顶点缓冲区的方式完全相同，只是不需要暂存缓冲区（因为每帧都要更新）：</span></span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, uniformBuffersMemory[currentImage], <span class="number">0</span>, <span class="built_in">sizeof</span>(ubo), <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, &amp;ubo, <span class="built_in">sizeof</span>(ubo));</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, uniformBuffersMemory[currentImage]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然此时编译运行程序是不成功的，因为我们仅仅是更新数据，但是没有将描述符集绑定到图形管道中。</p><h1 id="二-描述符"><a href="#二-描述符" class="headerlink" title="二. 描述符"></a>二. 描述符</h1><p>前面我们创建了描述符集布局，描述了可以绑定的描述符的类型，现在我们给统一缓冲区的每个缓冲创建一个描述符集，然后将其绑定到统一缓冲区描述符中。</p><h2 id="2-1-描述符池"><a href="#2-1-描述符池" class="headerlink" title="2.1 描述符池"></a>2.1 描述符池</h2><p>描述符集无法直接创建，它们必须从命令缓冲区之类的池中分配。描述符集又称为描述符池。 我们将编写一个新函数createDescriptorPool进行设置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDescriptorPoolSize poolSize = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 我们创建的是统一缓冲的描述符</span></span><br><span class="line">    poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">    poolSize.descriptorCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;;</span><br><span class="line">    poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;</span><br><span class="line">    poolInfo.poolSizeCount = <span class="number">1</span>;</span><br><span class="line">    poolInfo.pPoolSizes = &amp;poolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了可用的单个描述符的最大数量外，还需要指定可以分配的最大描述符集数量：与交换链图像数量一致</span></span><br><span class="line">    poolInfo.maxSets = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 创建描述符池</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateDescriptorPool</span>(device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;descriptorPool) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create descriptor pool!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要使用VkDescriptorPoolSize结构来描述我们的描述符集将包含哪些描述符类型以及其中有多少个描述符类型。</p><h3 id="2-1-1-VkDescriptorPoolSize"><a href="#2-1-1-VkDescriptorPoolSize" class="headerlink" title="2.1.1 VkDescriptorPoolSize"></a>2.1.1 VkDescriptorPoolSize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolSize</span> &#123;</span><br><span class="line">    VkDescriptorType    type;</span><br><span class="line">    <span class="type">uint32_t</span>            descriptorCount;</span><br><span class="line">&#125; VkDescriptorPoolSize;</span><br></pre></td></tr></table></figure><ol><li>type是描述符的类型</li><li>descriptorCount是要分配的该类型的描述符数。如果类型是VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则descriptorCount是要为此类型的描述符分配的字节数</li></ol><h3 id="2-1-2-VkDescriptorPoolCreateInfo"><a href="#2-1-2-VkDescriptorPoolCreateInfo" class="headerlink" title="2.1.2 VkDescriptorPoolCreateInfo"></a>2.1.2 VkDescriptorPoolCreateInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorPoolCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType                sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                    pNext;</span><br><span class="line">    VkDescriptorPoolCreateFlags    flags;</span><br><span class="line">    <span class="type">uint32_t</span>                       maxSets;</span><br><span class="line">    <span class="type">uint32_t</span>                       poolSizeCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorPoolSize*    pPoolSizes;</span><br><span class="line">&#125; VkDescriptorPoolCreateInfo;</span><br></pre></td></tr></table></figure><ol><li>sType是此结构的类型, VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO</li><li>pNext是NULL或指向扩展特定结构的指针</li><li>flags是VkDescriptorPoolCreateFlagBits的位掩码，用于指定池中某些受支持的操作</li><li>maxSets是可以从池中分配的描述符集的最大数量</li><li>poolSizeCount是pPoolSizes中的元素数</li><li>pPoolSizes是一个指向VkDescriptorPoolSize结构数组的指针，每个结构都包含一个描述符类型和要在池中分配的该类型的描述符数量</li></ol><h3 id="2-1-3-vkCreateDescriptorPool"><a href="#2-1-3-vkCreateDescriptorPool" class="headerlink" title="2.1.3 vkCreateDescriptorPool"></a>2.1.3 vkCreateDescriptorPool</h3><p>描述符池维护着一个描述符池，从中分配描述符集。 描述符池是外部同步的，这意味着应用程序不得同时从多个线程中的同一池中分配和&#x2F;或释放描述符集。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateDescriptorPool</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorPoolCreateInfo*           pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorPool*                           pDescriptorPool)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 创建描述符池的逻辑设备</li><li>pCreateInfo: 指向VkDescriptorPoolCreateInfo结构的指针，该结构指定描述符池对象的状态</li><li>pAllocator: 内存分配</li><li>pDescriptorPool: 指向VkDescriptorPool句柄的指针，在该句柄中返回生成的描述符池对象</li></ol><p>别忘了手动清理描述符池：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanupSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">vkDestroyDescriptorPool</span>(device, descriptorPool, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createUniformBuffers</span>();</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-描述符集"><a href="#2-2-描述符集" class="headerlink" title="2.2 描述符集"></a>2.2 描述符集</h2><p>有了描述符池就可以分配描述符集了。为此添加createDescriptorSets函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">VkDescriptorPool descriptorPool;</span><br><span class="line">std::vector&lt;VkDescriptorSet&gt; descriptorSets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createDescriptorSets</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recreateSwapChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createDescriptorPool</span>();</span><br><span class="line">    <span class="built_in">createDescriptorSets</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createDescriptorSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;VkDescriptorSetLayout&gt; <span class="title">layouts</span><span class="params">(swapChainImages.size(), descriptorSetLayout)</span></span>;</span><br><span class="line"></span><br><span class="line">    VkDescriptorSetAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.descriptorPool = descriptorPool;</span><br><span class="line">    allocInfo.descriptorSetCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    allocInfo.pSetLayouts = layouts.<span class="built_in">data</span>();</span><br><span class="line">    <span class="comment">// 重置大小</span></span><br><span class="line">    descriptorSets.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 内存分配描述符集</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateDescriptorSets</span>(device, &amp;allocInfo, descriptorSets.<span class="built_in">data</span>()) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate descriptor sets!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置描述符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; descriptorSets.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 引用缓冲区的描述符（例如我们的统一缓冲区描述符）使用VkDescriptorBufferInfo结构进行配置</span></span><br><span class="line">        <span class="comment">// 指定缓冲区以及其中包含描述符数据的区域。</span></span><br><span class="line">        VkDescriptorBufferInfo bufferInfo = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 绑定缓冲区</span></span><br><span class="line">        bufferInfo.buffer = uniformBuffers[i];</span><br><span class="line">        bufferInfo.offset = <span class="number">0</span>;</span><br><span class="line">        bufferInfo.range = <span class="built_in">sizeof</span>(UniformBufferObject);</span><br><span class="line"></span><br><span class="line">        VkWriteDescriptorSet descriptorWrite = &#123;&#125;;</span><br><span class="line">        descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;</span><br><span class="line">        descriptorWrite.dstSet = descriptorSets[i];</span><br><span class="line">        descriptorWrite.dstBinding = <span class="number">0</span>;</span><br><span class="line">        descriptorWrite.dstArrayElement = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;</span><br><span class="line">        descriptorWrite.descriptorCount = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        descriptorWrite.pBufferInfo = &amp;bufferInfo;</span><br><span class="line">        descriptorWrite.pImageInfo = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">        descriptorWrite.pTexelBufferView = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用描述符集更新</span></span><br><span class="line">        <span class="built_in">vkUpdateDescriptorSets</span>(device, <span class="number">1</span>, &amp;descriptorWrite, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述符集分配用VkDescriptorSetAllocateInfo结构描述。需要指定要从中分配的描述符池、要分配的描述符集的数量以及基于它们的描述符布局。</p><h3 id="2-2-1-VkDescriptorSetAllocateInfo"><a href="#2-2-1-VkDescriptorSetAllocateInfo" class="headerlink" title="2.2.1 VkDescriptorSetAllocateInfo"></a>2.2.1 VkDescriptorSetAllocateInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorSetAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType                 sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                     pNext;</span><br><span class="line">    VkDescriptorPool                descriptorPool;</span><br><span class="line">    <span class="type">uint32_t</span>                        descriptorSetCount;</span><br><span class="line">    <span class="type">const</span> VkDescriptorSetLayout*    pSetLayouts;</span><br><span class="line">&#125; VkDescriptorSetAllocateInfo;</span><br></pre></td></tr></table></figure><ol><li>sType是此结构的类型</li><li>pNext是NULL或指向扩展特定结构的指针</li><li>descriptorPool是从中分配集合的池</li><li>descriptorSetCount确定要从池中分配的描述符集的数量</li><li>pSetLayouts是一个指向描述符集布局数组的指针，每个成员指定如何分配相应的描述符集</li></ol><h3 id="2-2-2-vkAllocateDescriptorSets"><a href="#2-2-2-vkAllocateDescriptorSets" class="headerlink" title="2.2.2 vkAllocateDescriptorSets"></a>2.2.2 vkAllocateDescriptorSets</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSetAllocateInfo*          pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDescriptorSet*                            pDescriptorSets)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 拥有描述符池的逻辑设备</li><li>pAllocateInfo: 指向VkDescriptorSetAllocateInfo结构的指针，该结构描述分配参数</li><li>pDescriptorSets: 指向VkDescriptorSet句柄数组的指针，在该数组中返回生成的描述符集对象</li></ol><p>无需手动清理描述符集，因为在销毁描述符池时，会自动释放描述符集。 对vkAllocateDescriptorSets的调用将分配描述符集，每个描述符集具有一个统一的缓冲区描述符。</p><h3 id="2-2-3-VkDescriptorBufferInfo"><a href="#2-2-3-VkDescriptorBufferInfo" class="headerlink" title="2.2.3 VkDescriptorBufferInfo"></a>2.2.3 VkDescriptorBufferInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkDescriptorBufferInfo</span> &#123;</span><br><span class="line">    VkBuffer        buffer;</span><br><span class="line">    VkDeviceSize    offset;</span><br><span class="line">    VkDeviceSize    range;</span><br><span class="line">&#125; VkDescriptorBufferInfo;</span><br></pre></td></tr></table></figure><ol><li>buffer是缓冲区资源</li><li>offset是从缓冲区开始的偏移量（以字节为单位）。 通过此描述符访问缓冲存储器将使用相对于此起始偏移量的寻址</li><li>range是用于此描述符更新的大小（以字节为单位），或者是VK_WHOLE_SIZE以使用从偏移量到缓冲区末尾的范围</li></ol><h3 id="2-2-4-VkWriteDescriptorSet"><a href="#2-2-4-VkWriteDescriptorSet" class="headerlink" title="2.2.4 VkWriteDescriptorSet"></a>2.2.4 VkWriteDescriptorSet</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkWriteDescriptorSet</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkDescriptorSet                  dstSet;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstBinding;</span><br><span class="line">    <span class="type">uint32_t</span>                         dstArrayElement;</span><br><span class="line">    <span class="type">uint32_t</span>                         descriptorCount;</span><br><span class="line">    VkDescriptorType                 descriptorType;</span><br><span class="line">    <span class="type">const</span> VkDescriptorImageInfo*     pImageInfo;</span><br><span class="line">    <span class="type">const</span> VkDescriptorBufferInfo*    pBufferInfo;</span><br><span class="line">    <span class="type">const</span> VkBufferView*              pTexelBufferView;</span><br><span class="line">&#125; VkWriteDescriptorSet;</span><br></pre></td></tr></table></figure><ol><li>sType是此结构的类型, VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET</li><li>pNext是NULL或指向扩展特定结构的指针</li><li>dstSet是要更新的目标描述符集</li><li>dstBinding是该集合内的描述符绑定</li><li>dstArrayElement是该数组中的起始元素。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则dstArrayElement指定绑定内的起始字节偏移量</li><li>descriptorCount是要更新的描述符的数量（pImageInfo，pBufferInfo或pTexelBufferView中的元素数量，或者与pNext链中的VkWriteDescriptorSetInlineUniformBlockEXT结构的dataSize成员匹配的值，或者与pNext中的VkWriteDescriptorSetAccelerationStructureNV结构的AccelerationStructureCount匹配的值。链 ）。如果由dstSet和dstBinding标识的描述符绑定的描述符类型为VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT，则描述符计数指定要更新的字节数</li><li>descriptorType是VkDescriptorType，用于指定pImageInfo，pBufferInfo或pTexelBufferView中每个描述符的类型，如下所述。它必须与在dstBinding中为dstSet的VkDescriptorSetLayoutBinding中指定的类型相同。描述符的类型还控制描述符从哪个数组获取</li><li>pImageInfo是指向VkDescriptorImageInfo结构数组的指针</li><li>pBufferInfo是指向VkDescriptorBufferInfo结构数组的指针</li><li>pTexelBufferView是指向VkBufferView句柄数组的指针</li></ol><h3 id="2-2-5-vkUpdateDescriptorSets"><a href="#2-2-5-vkUpdateDescriptorSets" class="headerlink" title="2.2.5 vkUpdateDescriptorSets"></a>2.2.5 vkUpdateDescriptorSets</h3><p>内存分配后，描述符集可以使用写和复制操作的组合进行更新。 要更新描述符集，调用：vkUpdateDescriptorSets</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkUpdateDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorWriteCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkWriteDescriptorSet*                 pDescriptorWrites,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorCopyCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkCopyDescriptorSet*                  pDescriptorCopies)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device是更新描述符集的逻辑设备</li><li>descriptorWriteCount是pDescriptorWrites数组中元素的数量</li><li>pDescriptorWrites是指向VkWriteDescriptorSet结构数组的指针，该结构描述了要写入的描述符集</li><li>descriptorCopyCount是pDescriptorCopies数组中元素的数量</li><li>pDescriptorCopies是指向VkCopyDescriptorSet结构数组的指针，该结构描述了要在其间复制的描述符集</li></ol><h2 id="2-3-使用描述符集"><a href="#2-3-使用描述符集" class="headerlink" title="2.3 使用描述符集"></a>2.3 使用描述符集</h2><p>现在，我们需要更新createCommandBuffers函数，以将每个交换链图像的正确描述符集实际绑定到具有cmdBindDescriptorSets的着色器中的描述符。 </p><p>需要在vkCmdDrawIndexed调用之前完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindDescriptorSets</span>(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;descriptorSets[i], <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkCmdDrawIndexed</span>(commandBuffers[i], <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(indices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>与顶点和索引缓冲区不同，描述符集不是图形管线所独有的。因此，我们需要指定是否要将描述符集绑定到图形或计算管道–vkCmdBindDescriptorSets。</p><p>现在运行程序，是看不到任何内容的。问题在于，由于我们在投影矩阵中进行了Y翻转，因此现在以顺时针顺序而不是逆时针顺序绘制了顶点。这将导致背面剔除，并阻止绘制任何几何图形。</p><p>在createGraphicsPipeline函数中VkPipelineRasterizationStateCreateInfo中修改frontFace来更正此问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;</span><br><span class="line">rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;</span><br></pre></td></tr></table></figure><p>frontFace是VkFrontFace结构体内的类型:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkFrontFace</span> &#123;</span><br><span class="line">    VK_FRONT_FACE_COUNTER_CLOCKWISE = <span class="number">0</span>,</span><br><span class="line">    VK_FRONT_FACE_CLOCKWISE = <span class="number">1</span>,</span><br><span class="line">    VK_FRONT_FACE_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkFrontFace;</span><br></pre></td></tr></table></figure><ol><li>VK_FRONT_FACE_COUNTER_CLOCKWISE 指定具有正面积的三角形被认为是朝前的</li><li>VK_FRONT_FACE_CLOCKWISE 指定具有负面积的三角形被认为是朝前的</li></ol><p>如何计算面积的正负，后续研究。现在运行程序可以看到我们的图像在沿着逆时针旋转~</p><h3 id="2-3-1-vkCmdBindDescriptorSets"><a href="#2-3-1-vkCmdBindDescriptorSets" class="headerlink" title="2.3.1 vkCmdBindDescriptorSets"></a>2.3.1 vkCmdBindDescriptorSets</h3><p>绑定描述符集调用 vkCmdBindDescriptorSets:<br>一个参数是描述符所基于的布局。接下来的三个参数指定第一个描述符集的索引，要绑定的集的数量以及要绑定的集的数组。我们待会儿再讲这个。最后两个参数指定用于动态描述符的偏移量数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindDescriptorSets</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineBindPoint                         pipelineBindPoint,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkPipelineLayout                            layout,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstSet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    descriptorSetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDescriptorSet*                      pDescriptorSets,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    dynamicOffsetCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint32_t</span>*                             pDynamicOffsets)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是描述符集将绑定到的命令缓冲区</li><li>pipelineBindPoint是一个VkPipelineBindPoint，它指示描述符是由图形管线还是由计算管线使用。 每个图形和计算都有一组单独的绑定点，因此绑定一个不会干扰另一个</li><li>layout是一个VkPipelineLayout对象，用于对绑定进行编程</li><li>firstSet是要绑定的第一个描述符集的集号</li><li>descriptorSetCount是pDescriptorSets数组中元素的数量</li><li>pDescriptorSets是指向VkDescriptorSet对象的句柄数组的指针，该对象描述了要写入的描述符集</li><li>dynamicOffsetCount是pDynamicOffsets数组中的动态偏移量</li><li>pDynamicOffsets是指向指定动态偏移量的uint32_t值数组的指针</li></ol><p>vkCmdBindDescriptorSets导致编号为[firstSet..firstSet + descriptorSetCount-1]的集合使用存储在pDescriptorSets [0..descriptorSetCount-1]中的绑定用于后续渲染命令（根据pipelineBindPoint计算或图形）。以前通过这些集合应用的任何绑定都不再有效。</p><p>绑定后，描述符集会影响命令缓冲区中后续图形或计算命令的渲染，直到将不同的集绑定到相同的集编号，或者直到该集受到干扰（如管线布局兼容性中所述）为止。</p><p>在记录绘制或分派命令以使用该管道执行时，必须为管道中任何着色器访问的所有设定编号绑定一个兼容的描述符集。但是，如果管道中的所有着色器都不静态使用具有特定集合号的任何绑定，则即使该管道编号包括该集合号的非平凡描述符集合布局，也不需要为该集合号绑定任何描述符集。</p><p>如果要绑定的任何集合包括动态统一缓冲区或存储缓冲区，则pDynamicOffsets会为每个集合中每个动态描述符类型绑定中的每个数组元素包含一个元素。从pDynamicOffsets中获取值的顺序是：集合N的所有条目都在集合N + 1之前；在一个集合中，条目按描述符集合布局中的绑定号排序；在绑定数组中，元素是有序的。 dynamicOffsetCount必须等于要绑定的集合中动态描述符的总数。</p><p>用于动态统一和存储缓冲区绑定的有效偏移量是从pDynamicOffsets获取的相对偏移量与缓冲区的基地址加描述符集中的基本偏移量之和。动态统一和存储缓冲区绑定的范围是描述符集中指定的缓冲区范围。</p><p>每个pDescriptorSet都必须与layout指定的管道布局兼容。用于编程绑定的布局还必须与后续图形或计算命令中使用的管线兼容，如“管线布局兼容性”部分中所定义。</p><p>调用vkCmdBindDescriptorSets绑定的描述符集内容可能在以下时间使用：</p><ol><li>对于使用VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT位置1创建的描述符绑定，在将命令缓冲区提交到队列时，在着色器执行结果绘制和调度时或在两者之间的任何时间，内容都可能被消耗。</li><li>在命令的主机执行期间，或在着色器执行结果绘制和派发期间，或之间的任何时间。</li></ol><p>因此，在描述符集合绑定的内容可能被消耗的第一个时间点和该命令在队列上完成执行之间，不得更改（由更新命令覆盖或释放）描述符集绑定的内容。</p><p>在执行vkCmdBindDescriptorSets时，pDynamicOffsets的内容将立即消耗。一旦所有待定用途都已完成，就可以更新和重用描述符集。</p><h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><p>描述符的使用包括三个部分：</p><ol><li>在管道创建期间指定描述符布局</li><li>从描述符池分配描述符集</li><li>渲染期间绑定描述符集</li></ol><p>所谓描述符，就是用来描述着色器资源的不透明数据结构，比如缓冲区、缓冲区视图、图像视图、采样器或组合图像采样器。</p><p>接下来，我们尝试一些更让人激动的东西–贴图。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;我们现在可以为每个顶点传递任意属性到顶点着色器，但是全局变量呢？我们将从本章开始讨论三维图形，这需要一个模型视图投影矩阵。我们可以将其作为顶点数据包含，但这是对内存的浪费，而且每当变换发生变化时，都需要我们更新顶点缓冲区。然而这种转换可能在每一帧都有。&lt;/p&gt;</summary>
    
    
    
    <category term="图像引擎" scheme="https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Vulkan" scheme="https://swallowjoe.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Vulkan入门(12)-暂存缓冲和索引缓冲</title>
    <link href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/"/>
    <id>https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/</id>
    <published>2022-02-26T19:34:41.000Z</published>
    <updated>2022-02-26T19:42:33.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>虽然现在我们创建的顶点缓冲区工作正常，但是从CPU访问它的内存类型可能不是图形显卡本身读取的最佳内存类型，最理想的内存具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT位标志，并且通常不可由专用图形显卡上的CPU访问。而且我们上一篇最后实现的随鼠标移动的功能也没有考虑同步，简单一点，考虑读写分离。</p><p>现在创建两个顶点缓冲区：CPU可访问内存中的一个暂存缓冲区用于从顶点数组上传数据，最终顶点缓冲区位于设备本地内存中。然后我们将使用一个缓冲区复制命令将数据从暂存缓冲区移动到实际的顶点缓冲区。简单来说就是暂存缓冲区用于cpu写入，顶点缓冲区用于GPU读取数据。</p><span id="more"></span><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>Vulkan coordinate system <a href="http://vulkano.rs/guide/vertex-input">http://vulkano.rs/guide/vertex-input</a></li></ol><h1 id="一-传输队列"><a href="#一-传输队列" class="headerlink" title="一. 传输队列"></a>一. 传输队列</h1><p>buffer copy命令需要支持传输操作的队列族，使用VK_QUEUE_TRANSFER_BIT表示。不过任何具有VK_QUEUE_GRAPHICS_BIT或VK_QUEUE_COMPUTE_BIT功能的队列家族都已经隐式支持VK_QUEUE_TRANSFER_BIT操作。在这些情况下，不需要实现在queueFlags中显式地列出它。</p><p>但可以尝试使用专门用于传输操作的不同队列族， 可以如下操作:</p><ol><li>修改QueueFamilyIndices和findQueueFamilies来显式地查找具有VK_QUEUE_TRANSFER位的队列族，而不是VK_QUEUE_GRAPHICS_BIT位</li><li>修改createLogicalDevice以请求传输队列的句柄</li><li>为传输队列系列上提交的命令缓冲区创建第二个命令池</li><li>修改资源的共享模式为VK_SHARING_MODE_CONCURRENT，并指定图形和传输队列族</li><li>提交传输命令，如vkCmdCopyBuffer到传输队列，而不是图形队列</li></ol><h1 id="二-暂存缓冲区"><a href="#二-暂存缓冲区" class="headerlink" title="二. 暂存缓冲区"></a>二. 暂存缓冲区</h1><p>因为我们要创建多个VkBuffer，所以最好把共有的部分抽出，以避免代码累赘:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入必要参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createBuffer</span><span class="params">(VkDeviceSize size, VkBufferUsageFlags usage,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkMemoryPropertyFlags properties, VkBuffer&amp; buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">        VkDeviceMemory&amp; bufferMemory, VkSharingMode mode)</span> </span>&#123;</span><br><span class="line">    VkBufferCreateInfo bufferInfo = &#123;&#125;;</span><br><span class="line">    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;</span><br><span class="line">    bufferInfo.size = size;</span><br><span class="line">    bufferInfo.usage = usage;</span><br><span class="line">    bufferInfo.sharingMode = mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="literal">nullptr</span>, &amp;buffer) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create vertex buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VkMemoryRequirements memRequirements;</span><br><span class="line">    <span class="built_in">vkGetBufferMemoryRequirements</span>(device, buffer, &amp;memRequirements);</span><br><span class="line"></span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex = <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits, properties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;bufferMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate vertex buffer memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vkBindBufferMemory</span>(device, buffer, bufferMemory, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(vertices[<span class="number">0</span>]) * vertices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的MEMORY_PROPERTY是VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT！</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |</span><br><span class="line">            VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            vertexBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们需要使用传输队列，所以注意stagingBuffer的usage是用的VK_BUFFER_USAGE_TRANSFER_SRC_BIT，而vertexBuffer现在用的是VK_BUFFER_USAGE_TRANSFER_DST_BIT！</p><p>vertexBuffer现在从设备本地的内存类型分配，这意味着我们不能使用vkMapMemory。但是，我们可以将数据从stagingBuffer复制到vertexBuffer。我们必须通过指定stagingBuffer的传输源标志和vertexBuffer的传输目标标志以及顶点缓冲区使用标志来表明我们打算这样做。</p><h2 id="2-1-VkBufferUsageFlagBits"><a href="#2-1-VkBufferUsageFlagBits" class="headerlink" title="2.1 VkBufferUsageFlagBits"></a>2.1 VkBufferUsageFlagBits</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkBufferUsageFlagBits</span> &#123;</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFER_DST_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = <span class="number">0x00000100</span>,</span><br><span class="line">    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = <span class="number">0x00020000</span>,</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = <span class="number">0x00000800</span>,</span><br><span class="line">    VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = <span class="number">0x00001000</span>,</span><br><span class="line">    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = <span class="number">0x00000200</span>,</span><br><span class="line">    VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = <span class="number">0x00000400</span>,</span><br><span class="line">    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,</span><br><span class="line">    VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,</span><br><span class="line">    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkBufferUsageFlagBits;</span><br></pre></td></tr></table></figure><p>VkBufferUsageFlagBits设置的位可以指定缓冲区的使用行为：</p><ol><li>VK_BUFFER_USAGE_TRANSFER_SRC_BIT指定缓冲区可以用作传输命令的源(请参阅VK_PIPELINE_STAGE_TRANSFER_BIT的定义)。</li><li>VK_BUFFER_USAGE_TRANSFER_DST_BIT指定缓冲区可以用作传输命令的目的地。</li><li>VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT缓冲区可用于创建一个VkBufferView，该视图适合占用VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER类型的VkDescriptorSet槽位。</li><li>VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT指定该缓冲区可以用来创建一个VkBufferView，该视图适合于占用VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER类型的VkDescriptorSet槽位。</li><li>VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT缓冲区可以用于VkDescriptorBufferInfo中，该缓冲区适合于占用VkDescriptorSet类型的VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC槽位。</li><li>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT指定该缓冲区可用于VkDescriptorBufferInfo中，该缓冲区适合于占用VkDescriptorSet类型的VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC槽位。</li><li>VK_BUFFER_USAGE_INDEX_BUFFER_BIT指定该缓冲区适合作为buffer参数传递给vkCmdBindIndexBuffer。</li><li>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT指定缓冲区适合作为pBuffers数组的元素传递给vkCmdBindVertexBuffers。</li><li>VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT缓冲区适合作为buffer参数传递给vkCmdDrawIndirect、vkCmdDrawIndexedIndirect、vkCmdDrawMeshTasksIndirectNV、vkCmdDrawMeshTasksIndirectCountNV或vkCmdDispatchIndirect。它也适合作为VkIndirectCommandsTokenNVX的缓冲区成员，或VkCmdProcessCommandsInfoNVX的sequencesCountBuffer或sequencesIndexBuffer成员传递</li><li>VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT指定缓冲区适合作为buffer参数传递给vkCmdBeginConditionalRenderingEXT。</li><li>VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT指定该缓冲区适合使用for binding作为vkCmdBindTransformFeedbackBuffersEXT的转换反馈缓冲区。</li><li>VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT指定该缓冲区适合与vkCmdBeginTransformFeedbackEXT和vkCmdEndTransformFeedbackEXT一起用作计数器缓冲区。</li><li>VK_BUFFER_USAGE_RAY_TRACING_BIT_NV指定缓冲区适用于vkCmdTraceRaysNV和vkCmdBuildAccelerationStructureNV。</li><li>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT指定缓冲区可以通过vkGetBufferDeviceAddress来检索缓冲区设备地址，并使用该地址从着色器访问缓冲区的内存。</li></ol><h2 id="2-2-VkMemoryPropertyFlags"><a href="#2-2-VkMemoryPropertyFlags" class="headerlink" title="2.2 VkMemoryPropertyFlags"></a>2.2 VkMemoryPropertyFlags</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">VkMemoryPropertyFlagBits</span> &#123;</span><br><span class="line">    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = <span class="number">0x00000001</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = <span class="number">0x00000002</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = <span class="number">0x00000004</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = <span class="number">0x00000008</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = <span class="number">0x00000010</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_PROTECTED_BIT = <span class="number">0x00000020</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD = <span class="number">0x00000040</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD = <span class="number">0x00000080</span>,</span><br><span class="line">    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = <span class="number">0x7FFFFFFF</span></span><br><span class="line">&#125; VkMemoryPropertyFlagBits;</span><br></pre></td></tr></table></figure><ol><li>VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: 指定使用这种类型分配的内存对于设备访问是最有效的。当且仅当内存类型属于设置了VK_MEMORY_HEAP_DEVICE_LOCAL_BIT的堆时，才会设置此属性。</li><li>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: 指定使用这种类型分配的内存可以通过vkMapMemory映射给主机访问。</li><li>VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: 指定主机缓存管理命令vkFlushMappedMemoryRanges和vkInvalidateMappedMemoryRanges分别用于刷新主机对设备的写操作，或者使设备的写操作对主机可见。</li><li>VK_MEMORY_PROPERTY_HOST_CACHED_BIT: 指定用这种类型分配的内存缓存在主机上。主机内存对非缓存内存的访问比对缓存内存的访问慢，但是非缓存内存总是与主机一致的。</li><li>VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: 指定内存类型仅允许设备访问内存。内存类型不能同时设置VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT和VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT。另外，对象的后备内存可以由在惰性分配内存中指定的lazy实现提供。</li><li>VK_MEMORY_PROPERTY_PROTECTED_BIT: 指定内存类型仅允许设备访问内存，并允许受保护的队列操作访问内存。内存类型不能设置VK_MEMORY_PROPERTY_PROTECTED_BIT和任何VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT、VK_MEMORY_PROPERTY_HOST_COHERENT_BIT或VK_MEMORY_PROPERTY_HOST_CACHED_BIT。</li><li>VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: 指定对这种内存类型分配的设备访问将自动变为可用和可见的。</li><li>VK_MEMORY_PROPERTY_DEVICE_UNCACHHED_BIT_AMD: 指定用这种类型分配的内存不会缓存到设备上。非缓存设备内存总是设备一致的。</li></ol><h2 id="2-3-缓冲区拷贝函数"><a href="#2-3-缓冲区拷贝函数" class="headerlink" title="2.3 缓冲区拷贝函数"></a>2.3 缓冲区拷贝函数</h2><p>内存传输操作使用命令缓冲区执行，就像绘制命令一样。因此，首先分配一个临时的命令缓冲区。您可能希望为这些短期缓冲区创建一个单独的命令池，因为实现可能能够应用内存分配优化。在这种情况下，您应该在生成命令池期间使用VK_COMMAND_POOL_CREATE_TRANSIENT_BIT标志。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyBuffer</span><span class="params">(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size)</span> </span>&#123;</span><br><span class="line">    VkCommandBufferAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">    allocInfo.commandPool = commandPool;</span><br><span class="line">    allocInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    VkCommandBuffer commandBuffer;</span><br><span class="line">    <span class="built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer);</span><br><span class="line">    <span class="comment">// 开始记录指令</span></span><br><span class="line">    VkCommandBufferBeginInfo beginInfo = &#123;&#125;;</span><br><span class="line">    beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">    <span class="comment">// 只使用一次命令缓冲区，并等待函数返回，直到复制操作完成执行</span></span><br><span class="line">    <span class="comment">// 所以使用VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT标志</span></span><br><span class="line">    beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;</span><br><span class="line">    <span class="built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲拷贝指令</span></span><br><span class="line">    VkBufferCopy copyRegion = &#123;&#125;;</span><br><span class="line">    copyRegion.srcOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.dstOffset = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">    copyRegion.size = size;</span><br><span class="line">    <span class="comment">// 缓冲区的内容使用vkCmdCopyBuffer命令传输。</span></span><br><span class="line">    <span class="comment">// 源和目标缓冲区以及要复制的区域数组作为参数。copyRegion由源缓冲区偏移量、目标缓冲区偏移量和大小组成</span></span><br><span class="line">    <span class="built_in">vkCmdCopyBuffer</span>(commandBuffer, srcBuffer, dstBuffer, <span class="number">1</span>, &amp;copyRegion);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkEndCommandBuffer</span>(commandBuffer);</span><br><span class="line">    VkSubmitInfo submitInfo = &#123;&#125;;</span><br><span class="line">    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">    submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">    submitInfo.pCommandBuffers = &amp;commandBuffer;</span><br><span class="line">    <span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE);</span><br><span class="line">    <span class="built_in">vkQueueWaitIdle</span>(graphicsQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkFreeCommandBuffers</span>(device, commandPool, <span class="number">1</span>, &amp;commandBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝缓冲指令的一般流程是:</p><ol><li>vkAllocateCommandBuffers 创建指令缓冲，分配内存</li><li>vkBeginCommandBuffer     开始指令记录</li><li>vkCmdCopyBuffer          执行具体指令</li><li>vkEndCommandBuffer       结束指令记录</li><li>vkQueueSubmit            将指令提交到管道</li><li>vkQueueWaitIdle          等待管道执行指令,也可以通过fence机制</li><li>vkFreeCommandBuffers     释放指令缓冲区</li></ol><h3 id="2-2-1-vkCmdCopyBuffer-拷贝缓冲区"><a href="#2-2-1-vkCmdCopyBuffer-拷贝缓冲区" class="headerlink" title="2.2.1 vkCmdCopyBuffer 拷贝缓冲区"></a>2.2.1 vkCmdCopyBuffer 拷贝缓冲区</h3><p>在缓冲区对象之间复制数据，调用:vkCmdCopyBuffer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdCopyBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    srcBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    dstBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    regionCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferCopy*                         pRegions)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是命令将被记录到的命令缓冲区。</li><li>srcBuffer是源缓冲区。</li><li>dstBuffer是目标缓冲区。</li><li>regionCount是要复制的区域数。</li><li>pRegions是一个指向VkBufferCopy结构体数组的指针，该数组指定了要复制的区域。</li></ol><h2 id="2-3-缓冲区拷贝"><a href="#2-3-缓冲区拷贝" class="headerlink" title="2.3 缓冲区拷贝"></a>2.3 缓冲区拷贝</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(vertices[<span class="number">0</span>]) * vertices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里的MEMORY_PROPERTY是VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT！</span></span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT |</span><br><span class="line">            VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            vertexBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将暂存缓冲区的数据内容拷贝到顶点缓冲区</span></span><br><span class="line">    <span class="built_in">copyBuffer</span>(stagingBuffer, vertexBuffer, bufferSize);</span><br><span class="line">    <span class="comment">// 销毁暂存缓冲区，释放内存</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里思考一下，为什么要使用一个暂存缓冲区替换原来的直接使用memcpy呢，而且使用暂存缓冲还额外多了一个创建缓冲区的操作？</p><p>因为图形管道使用顶点数据缓冲区时，如果需要更改顶点数据内容，还需要等待memcpy,如果使用暂存缓冲区，可以将更改顶点数据内容的操作放在另一个线程执行，等到写完之后，再使用vkCmdCopyBuffer指令拷贝内存数据，这样图形管道最多等待这个指令拷贝的时间。当然这一点现在看不出来优势，等我们的顶点数据多而且绘制内容复杂的时候就可以体现出来了。</p><p>让我们更近一步，考虑到每次拷贝都需要执行vkAllocateCommandBuffers分配内存，不如一开始就请求一块合适的内存区域，毕竟这个函数开销还是很大的。通过使用我们在许多函数中看到的偏移参数，在许多不同的对象之间分割单个分配或回收。可以自己实现也可以使用GPUOpen倡议提供的VulkanMemoryAllocator库。</p><h1 id="三-索引缓冲区"><a href="#三-索引缓冲区" class="headerlink" title="三. 索引缓冲区"></a>三. 索引缓冲区</h1><p>在真实世界的应用程序中渲染的3D网格经常会在多个三角形之间共享顶点。比如画一个矩形:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_1.png" alt="12_1"></p><p>绘制一个矩形需要两个三角形(基本绘制单元只有点、线和三角形，所以矩形是两个三角形之和)，这意味着需要有6个顶点的顶点缓冲区。问题是两个顶点的部分数据重复，会产生50%的冗余。在更复杂的网格中，只会变得更糟，因为顶点会在平均3个三角形中重复使用。解决这个问题的方法是使用索引缓冲区。</p><p>索引缓冲区本质上是一个指向顶点缓冲区的指针数组。它允许重新排序顶点数据，并为多个顶点重用现有数据。上面的插图演示了一个顶点缓冲区包含四个不同的顶点，其索引缓冲区会是什么样子的。前三个索引定义了右上角的三角形，后三个索引定义了左下角三角形的顶点(顺时钟)。</p><h2 id="3-1-创建索引缓冲区"><a href="#3-1-创建索引缓冲区" class="headerlink" title="3.1 创建索引缓冲区"></a>3.1 创建索引缓冲区</h2><p>接下来将修改顶点数据并添加索引数据来绘制一个矩形，像上图中一样。修改顶点数据以表示四个角:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>左上角是红色的，右上方是绿色的，右下角是蓝色的，左下角是白色的。现在添加一个新的数组索引来表示索引缓冲区的内容，匹配图中的索引来绘制右上三角形和左下三角形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以使用uint16_t或uint32_t作为索引缓冲区，这取决于顶点中条目的数量。我们可以坚持uint16_t现在，因为我们使用少于65535唯一顶点。</p><p>就像顶点数据一样，索引需要上传到VkBuffer中，GPU才能访问它们。定义两个新的类成员来保存索引缓冲区的资源:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">VkBuffer indexBuffer;</span><br><span class="line">VkDeviceMemory indexBufferMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    <span class="built_in">createIndexBuffer</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createIndexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkDeviceSize bufferSize = <span class="built_in">sizeof</span>(indices[<span class="number">0</span>]) * indices.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    VkBuffer stagingBuffer;</span><br><span class="line">    VkDeviceMemory stagingBufferMemory;</span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT |</span><br><span class="line">            VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            stagingBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, stagingBufferMemory, <span class="number">0</span>, bufferSize, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, indices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferSize);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, stagingBufferMemory);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">createBuffer</span>(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT</span><br><span class="line">            | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,</span><br><span class="line">            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer,</span><br><span class="line">            <span class="comment">// 资源只能由单个队列族独占</span></span><br><span class="line">            indexBufferMemory, VK_SHARING_MODE_EXCLUSIVE);</span><br><span class="line">    <span class="comment">// 将暂存缓冲区的数据内容拷贝到顶点缓冲区</span></span><br><span class="line">    <span class="built_in">copyBuffer</span>(stagingBuffer, indexBuffer, bufferSize);</span><br><span class="line">    <span class="comment">// 销毁暂存缓冲区，释放内存</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, stagingBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, stagingBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 createIndexBuffer 几乎和 createVertexBuffer 一样，只有bufferSize和VkBufferUsageFlags不同而已，毕竟都是只是缓冲区。</p><p>索引缓冲同样也需要显示销毁： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, indexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, indexBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, vertexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, vertexBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-使用顶点缓冲"><a href="#3-2-使用顶点缓冲" class="headerlink" title="3.2 使用顶点缓冲"></a>3.2 使用顶点缓冲</h2><p>使用索引缓冲区绘制涉及createCommandBuffers的两个更改。我们首先需要绑定索引缓冲区，就像我们对顶点缓冲区所做的那样。但是索引缓冲区只能有一个。而且，不可能对每个顶点属性使用不同的索引，所以即使只有一个属性发生变化，仍然需要完全复制顶点数据。</p><p>索引缓冲区与vkCmdBindIndexBuffer绑定，vkCmdBindIndexBuffer包含索引缓冲区、其中的字节偏移量和索引数据类型作为参数。如前所述，可能的类型是VK_INDEX_TYPE_UINT16和VK_INDEX_TYPE_UINT32。</p><p>仅仅绑定索引缓冲区还不能改变任何东西，我们还需要更改绘图命令来告诉Vulkan使用索引缓冲区。移除vkCmdDraw，并用vkCmdDrawIndexed替换:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;</span><br><span class="line">VkDeviceSize offsets[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vkCmdBindVertexBuffers</span>(commandBuffers[i], <span class="number">0</span>, <span class="number">1</span>, vertexBuffers, offsets);</span><br><span class="line"><span class="comment">// VK_INDEX_TYPE_UINT16 是因为我们索引用的就是uint16_t</span></span><br><span class="line"><span class="built_in">vkCmdBindIndexBuffer</span>(commandBuffers[i], indexBuffer, <span class="number">0</span>, VK_INDEX_TYPE_UINT16);</span><br><span class="line"><span class="comment">// 使用vkCmdDrawIndexed替换vkCmdDraw</span></span><br><span class="line"><span class="comment">// vkCmdDraw(commandBuffers[i], static_cast&lt;uint32_t&gt;(vertices.size()), 1, 0, 0);</span></span><br><span class="line"><span class="built_in">vkCmdDrawIndexed</span>(commandBuffers[i], <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(indices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">vkCmdEndRenderPass</span>(commandBuffers[i]);</span><br></pre></td></tr></table></figure><p>对vkCmdDrawIndexed函数的调用非常类似于vkCmdDraw。前两个参数指定索引的数量和实例的数量。我们没有使用实例，所以只指定一个实例。索引的数量表示将被传递到顶点缓冲区的顶点的数量。下一个参数指定到索引缓冲区的偏移量，使用值1将导致显卡从第二个索引开始读取。倒数第二个参数指定要添加到索引缓冲区中的索引的偏移量。最后一个参数指定了实例化的偏移量。</p><h1 id="四-绘制命令概述"><a href="#四-绘制命令概述" class="headerlink" title="四. 绘制命令概述"></a>四. 绘制命令概述</h1><p>绘制命令大致分为两类:非索引绘图命令和索引绘图命令。</p><h2 id="4-1-非索引绘图命令"><a href="#4-1-非索引绘图命令" class="headerlink" title="4.1 非索引绘图命令"></a>4.1 非索引绘图命令</h2><p>非索引绘图命令为顶点着色器提供一个连续的vertexIndex。顺序索引是由设备自动生成的，这些命令有:</p><ol><li>vkCmdDraw</li><li>vkCmdDrawIndirect</li><li>vkCmdDrawIndirectCount</li><li>vkCmdDrawIndirectCountKHR</li><li>vkCmdDrawIndirectCountAMD</li></ol><h3 id="4-1-1-vkCmdDraw"><a href="#4-1-1-vkCmdDraw" class="headerlink" title="4.1.1 vkCmdDraw"></a>4.1.1 vkCmdDraw</h3><p>vkCmdDraw可以记录一个非索引的绘制，其原型如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDraw</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    vertexCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    instanceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstVertex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstInstance)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是命令记录到的命令缓冲区</li><li>vertexCount是要绘制的顶点数</li><li>instanceCount是要绘制的实例数量</li><li>firstVertex是绘制的第一个顶点的索引</li><li>firstInstance是绘制的第一个实例的实例ID</li></ol><p>执行该命令时，将使用当前基本体拓扑和顶点计数连续顶点索引（第一个顶点索引值等于第一个顶点）组装基本体。原语绘制实例数量为instanceCount，instanceIndex从firstInstance开始，每个实例依次递增。<strong>组装原语的执行要绑定到图形管道</strong>。</p><h3 id="4-1-2-vkCmdDrawIndirect"><a href="#4-1-2-vkCmdDrawIndirect" class="headerlink" title="4.1.2 vkCmdDrawIndirect"></a>4.1.2 vkCmdDrawIndirect</h3><p>vkCmdDrawIndirect用于记录非索引的间接绘制，其原型如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    drawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是记录命令的命令缓冲区</li><li>buffer是包含绘图参数的缓冲区</li><li>offset是参数开始的缓冲区中的字节偏移量</li><li>drawCount是要执行的绘制数，可以为零</li><li>stride是连续绘图参数集之间的字节步幅</li></ol><p>vkCmdDrawIndirect的行为与vkCmdDraw类似，不同的是参数是在执行过程中由设备从缓冲区读取的。drawCount绘制由命令执行，参数从缓冲区的偏移量开始，每次绘制时按步长字节递增。每次绘制的参数都编码在一个VkDrawIndirectCommand结构数组中。如果drawCount小于或等于1，则忽略stride。</p><h3 id="4-1-3-vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD"><a href="#4-1-3-vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD" class="headerlink" title="4.1.3 vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD"></a>4.1.3 vkCmdDrawIndirectCount、vkCmdDrawIndirectCountKHR、vkCmdDrawIndirectCountAMD</h3><p>记录来自缓冲区的draw调用计数的非索引绘制调用,可以使用vkCmdDrawIndirectCount，vkCmdDrawIndirectCountKHR或者vkCmdDrawIndirectCountAMD, 这三个指令几乎等效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirectCount</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirectCountKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndirectCountAMD</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是记录命令的命令缓冲区</li><li>buffer是包含绘图参数的缓冲区</li><li>offset是参数开始的缓冲区中的字节偏移量</li><li>countBuffer是包含绘图计数的缓冲区</li><li>countBufferOffset是开始绘制计数的字节偏移到countBuffer中</li><li>maxDrawCount指定将执行的最大绘制数。实际执行的绘制调用数是countBuffer和maxDrawCount中指定的最小计数</li><li>stride是连续绘图参数集之间的字节步幅</li></ol><p>vkCmdDrawIndirectCount的行为与vkCmdDrawIndirectCount类似，只是在执行期间设备从缓冲区读取绘制计数。该命令将从位于countBufferOffset的countBuffer中读取一个无符号32位整数，并将其用作绘图计数。</p><h2 id="4-2-索引绘图命令"><a href="#4-2-索引绘图命令" class="headerlink" title="4.2 索引绘图命令"></a>4.2 索引绘图命令</h2><p>索引图形命令从索引缓冲区读取索引值，并使用此命令计算顶点着色器的vertexIndex值。这些命令有：</p><ol><li>vkCmdDrawIndexed</li><li>vkCmdDrawIndexedIndirect</li><li>vkCmdDrawIndexedIndirectCount</li><li>vkCmdDrawIndexedIndirectCountKHR</li><li>vkCmdDrawIndexedIndirectCountAMD</li></ol><h3 id="4-2-1-vkCmdDrawIndexed"><a href="#4-2-1-vkCmdDrawIndexed" class="headerlink" title="4.2.1 vkCmdDrawIndexed"></a>4.2.1 vkCmdDrawIndexed</h3><p>vkCmdDrawIndexed可以记录一个索引的绘制，其原型如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    indexCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    instanceCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span>                                     vertexOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstInstance)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是命令记录到的命令缓冲区</li><li>indexCount是要绘制的顶点数</li><li>instanceCount是要绘制的实例数</li><li>firstIndex是索引缓冲区中的基索引</li><li>vertexOffset是在索引到顶点缓冲区之前添加到顶点索引的值</li><li>firstInstance是要绘制的第一个实例的实例ID</li></ol><p>在执行该命令时，使用当前基元拓扑和indexCount顶点组装基元，这些顶点的索引是从索引缓冲区检索的。索引缓冲区被视为一个紧凑封装的大小无符号整数数组，该整数由vkCmdBindIndexBuffer::indexType形参定义，该形参与该缓冲区绑定。</p><p>第一个顶点索引位于绑定索引缓冲区中的firstIndex * indexSize + offset的偏移量，其中offset是由vkCmdBindIndexBuffer指定的偏移量，indexSize是由indexType指定的类型的字节大小。从索引缓冲区中连续的位置检索后续的索引值。索引首先与原始的重启值比较，然后0扩展到32位(如果indexType是VK_INDEX_TYPE_UINT8_EXT或VK_INDEX_TYPE_UINT16)，并添加vertexOffset，然后再作为vertexIndex值提供。</p><p>这些原语是用从firstInstance开始的instanceIndex绘制instanceCount次数，并按顺序增加每个实例。<strong>组装的原语执行应绑定图形管道</strong>。</p><h3 id="4-2-2-vkCmdDrawIndexedIndirect"><a href="#4-2-2-vkCmdDrawIndexedIndirect" class="headerlink" title="4.2.2 vkCmdDrawIndexedIndirect"></a>4.2.2 vkCmdDrawIndexedIndirect</h3><p>vkCmdDrawIndexedIndirect用于记录索引的间接绘制，其原型如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    drawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是记录命令的命令缓冲区</li><li>buffer是包含绘图参数的缓冲区</li><li>offset是参数开始的缓冲区中的字节偏移量</li><li>drawCount是要执行的绘制数，可以为零</li><li>stride是连续绘图参数集之间的字节步幅</li></ol><p>vkCmdDrawIndexedIndirect的行为与vkcmddrawindex类似，不同的是参数是在执行过程中由设备从缓冲区中读取的。drawCount绘制由命令执行，参数从缓冲区的偏移量开始，每次绘制时按步长字节递增。每次绘制的参数都编码在vkdrawindexdindirectcommand结构的数组中。如果drawCount小于或等于1，则忽略stride。</p><h3 id="4-2-3-vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD"><a href="#4-2-3-vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD" class="headerlink" title="4.2.3 vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD"></a>4.2.3 vkCmdDrawIndexedIndirectCount、vkCmdDrawIndexedIndirectKHR、vkCmdDrawIndexedIndirectAMD</h3><p>同样的，记录来自缓冲区的draw调用计数的索引绘制调用,可以使用, 这三个指令几乎等效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirectCount</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirectCountKHR</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdDrawIndexedIndirectCountAMD</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    countBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                countBufferOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    maxDrawCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    stride)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer是记录命令的命令缓冲区</li><li>buffer是包含绘图参数的缓冲区</li><li>offset是参数开始的缓冲区中的字节偏移量</li><li>countBuffer是包含绘制计数的缓冲区</li><li>countBufferOffset是进入countBuffer的字节偏移量，在这里开始绘制计数</li><li>maxDrawCount指定将执行的最大绘制数。实际执行的draw调用数是countBuffer和maxDrawCount中指定的最小计数</li><li>stride是连续绘图参数集之间的字节步幅</li></ol><p>vkCmdDrawIndexedIndirectCount的行为与vkCmdDrawIndexedIndirect类似，只是在执行期间设备从缓冲区读取绘制计数。该命令将从位于countBufferOffset的countBuffer中读取一个无符号32位整数，并将其用作绘图计数。</p><h1 id="五-小结"><a href="#五-小结" class="headerlink" title="五. 小结"></a>五. 小结</h1><p>在上一篇文章中，我们使用顶点描述符VkVertexInputBindingDescription和VkVertexInputAttributeDescription替换了硬编码顶点，并且使用VkBuffer存储了顶点数据，好处是可随时更改顶点信息。在本文中，我们又使用了暂存缓冲优化了顶点缓冲每次都需要memcpy的弊端，还介绍了顶点索引，使得我们的程序可以画出更多的图形。</p><p>使用暂存缓冲是因为图形管道使用顶点数据缓冲区时，如果需要更改顶点数据内容，还需要等待memcpy,如果使用暂存缓冲区，可以将更改顶点数据内容的操作放在另一个线程执行，等到写完之后，再使用vkCmdCopyBuffer指令拷贝内存数据，这样图形管道最多等待这个指令拷贝的时间。当顶点数据多而且绘制内容复杂的时候就可以体现出来了。</p><p>而使用顶点索引缓冲是和顶点缓冲几乎一样的流程，只是VkBuffer创建时的VkBufferUsageFlags和size(对应的数据不同嘛)不同。</p><p>不过这里还是很好奇，顶点索引和顶点的关系，比如如果我们顶点坐标不变，顶点索引改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的图形就变成了:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_2.png" alt="图形"></p><p>但是当顶点索引改成:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的图形就变成了:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_3.png" alt="图形"></p><p>这个顶点索引和最终图像的生成到底是什么个关系呢，参考:<a href="https://zhuanlan.zhihu.com/p/97496535">https://zhuanlan.zhihu.com/p/97496535</a></p><p>Vulkan中的坐标系使用的右手坐标系，相比OpenGL是用的左手坐标系：</p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_4.png" alt="坐标系"></p><p>其中原点(0,0,0)在屏幕中央, 所以当我们想画一个三棱锥可以使用如下顶点及索引:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line">std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">-0.25f</span>, <span class="number">-0.01f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.01f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.25f</span>, <span class="number">0.01f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.01f</span>, <span class="number">0.15f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顶点索引</span></span><br><span class="line">std::vector&lt;<span class="type">uint16_t</span>&gt; indices = &#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-12-%E6%9A%82%E5%AD%98%E7%BC%93%E5%86%B2%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2/Vulkan_12_5.png" alt="三棱锥"></p><p>接下来，让我们再接再厉，学习使用资源描述符来加载3D图形。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;虽然现在我们创建的顶点缓冲区工作正常，但是从CPU访问它的内存类型可能不是图形显卡本身读取的最佳内存类型，最理想的内存具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT位标志，并且通常不可由专用图形显卡上的CPU访问。而且我们上一篇最后实现的随鼠标移动的功能也没有考虑同步，简单一点，考虑读写分离。&lt;/p&gt;
&lt;p&gt;现在创建两个顶点缓冲区：CPU可访问内存中的一个暂存缓冲区用于从顶点数组上传数据，最终顶点缓冲区位于设备本地内存中。然后我们将使用一个缓冲区复制命令将数据从暂存缓冲区移动到实际的顶点缓冲区。简单来说就是暂存缓冲区用于cpu写入，顶点缓冲区用于GPU读取数据。&lt;/p&gt;</summary>
    
    
    
    <category term="图像引擎" scheme="https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Vulkan" scheme="https://swallowjoe.github.io/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>Vulkan入门(11)-顶点输入描述及顶点缓冲的创建</title>
    <link href="https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>https://swallowjoe.github.io/2022/02/27/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2022-02-26T19:34:26.000Z</published>
    <updated>2022-02-26T19:41:34.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>接下来，我们将用内存中的顶点缓冲区替换顶点着色器中的硬编码顶点数据。我们将从创建CPU可见缓冲区的最简单方法开始，并使用memcpy将顶点数据直接复制到其中，然后我们将看到如何使用分段缓冲区将顶点数据复制到高性能内存。</p><span id="more"></span><p>首先修改顶点着色器不再包含顶点数据在着色器代码本身， 顶点着色器使用in关键字从顶点缓冲区获取输入。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="meta">#extension GL_ARB_separate_shader_objects : enable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec2</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为fragColor</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec3</span> fragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(inPosition, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    fragColor = inColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inPosition和inColor变量是顶点属性。 它们是在顶点缓冲区中为每个顶点指定的属性，就像我们使用两个数组为每个顶点手动指定位置和颜色一样。 更改后记得重新编译顶点着色器！</p><p>像fragColor一样，layout（location &#x3D; x）批注为输入分配索引，我们之后可以使用索引来引用它们。 重要的是要知道某些类型（例如dvec3 64位向量）使用多个插槽。 这意味着之后的索引必须至少高2倍（这里没搞懂, 需要学习一下GLSL的语法:<a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)%EF%BC%89%EF%BC%9A">https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)）：</a></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">dvec3</span> inPosition;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec3</span> inColor;</span><br></pre></td></tr></table></figure><h1 id="一-顶点数据"><a href="#一-顶点数据" class="headerlink" title="一. 顶点数据"></a>一. 顶点数据</h1><p>将顶点数据从着色器代码移动到程序代码中的数组中。需要引入GLM库，它为我们提供了与线性代数相关的类型，如向量和矩阵, 有与着色器语言中使用的向量类型完全匹配的c++类型。我们将使用这些类型来指定位置和颜色向量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">0.0f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建一个名为Vertex的新结构，内有两个属性，我们将在其内部的顶点着色器中使用. 使用顶点结构来指定顶点数据的数组。我们使用和之前完全相同的位置和颜色值，但现在它们被组合到一个顶点数组中, 这就是所谓的交错顶点(interleaving vertex)属性。</p><p>接下来是告诉Vulkan，一旦数据格式被上传到GPU内存，如何将其传递到顶点着色器。而传达这个信息需要有两种类型的结构: VkVertexInputBindingDescription和VkVertexInputAttributeDescription.</p><h2 id="1-1-绑定描述"><a href="#1-1-绑定描述" class="headerlink" title="1.1 绑定描述"></a>1.1 绑定描述</h2><p>第一个结构是VkVertexInputBindingDescription，我们将向顶点结构添加一个成员函数，用正确的数据填充它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> bindingDescription;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-1-1-VkVertexInputBindingDescription"><a href="#1-1-1-VkVertexInputBindingDescription" class="headerlink" title="1.1.1 VkVertexInputBindingDescription"></a>1.1.1 VkVertexInputBindingDescription</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputBindingDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>             binding;</span><br><span class="line">    <span class="type">uint32_t</span>             stride;</span><br><span class="line">    VkVertexInputRate    inputRate;</span><br><span class="line">&#125; VkVertexInputBindingDescription;</span><br></pre></td></tr></table></figure><ol><li>binding: 该结构描述的绑定号</li><li>stride : 是缓冲区中两个连续元素之间的距离(以字节为单位)</li><li>inputRate: 是一个VkVertexInputRate值，指定顶点属性寻址是顶点索引还是实例索引的函数<ol><li>VK_VERTEX_INPUT_RATE_VERTEX: 指定顶点属性寻址是顶点索引的函数，即移动到每个顶点后的下一个数据项</li><li>VK_VERTEX_INPUT_RATE_INSTANCE: 指定顶点属性寻址是实例索引的函数，即移到每个实例之后的下一个数据项</li></ol></li></ol><p>顶点绑定描述在所有顶点中从内存加载数据的速率。它指定数据条目之间的字节数，以及是在每个顶点之后还是在每个实例之后移动到下一个数据条目。</p><h3 id="1-1-2-绑定"><a href="#1-1-2-绑定" class="headerlink" title="1.1.2 绑定"></a>1.1.2 绑定</h3><p>所有的顶点数据都打包在一个数组中，所以我们只需要一个绑定:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">    bindingDescription.binding = <span class="number">0</span>;</span><br><span class="line">    bindingDescription.stride = <span class="built_in">sizeof</span>(Vertex);</span><br><span class="line">    bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bindingDescription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-属性描述"><a href="#1-2-属性描述" class="headerlink" title="1.2 属性描述"></a>1.2 属性描述</h2><p>第二个描述如何处理顶点输入的结构是VkVertexInputAttributeDescription。我们将添加另一个辅助函数到顶点来填充这些结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    glm::vec2 pos;</span><br><span class="line">    glm::vec3 color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> VkVertexInputBindingDescription <span class="title">getBindingDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        VkVertexInputBindingDescription bindingDescription = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> bindingDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="title">getAttributeDescriptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions = &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> attributeDescriptions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正如函数原型所表明的，有两个VkVertexInputAttributeDescription,分别代表位置和颜色。</p><p>属性描述结构描述如何从源自绑定描述的顶点数据块中提取顶点属性。</p><h3 id="1-2-1-VkVertexInputAttributeDescription"><a href="#1-2-1-VkVertexInputAttributeDescription" class="headerlink" title="1.2.1 VkVertexInputAttributeDescription"></a>1.2.1 VkVertexInputAttributeDescription</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkVertexInputAttributeDescription</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>    location;</span><br><span class="line">    <span class="type">uint32_t</span>    binding;</span><br><span class="line">    VkFormat    format;</span><br><span class="line">    <span class="type">uint32_t</span>    offset;</span><br><span class="line">&#125; VkVertexInputAttributeDescription;</span><br></pre></td></tr></table></figure><ol><li>location: 属性的着色器绑定位置号</li><li>binding: 该属性获取其数据的绑定号</li><li>format: 指顶点属性数据的大小和类型, 应使用颜色通道数量与着色器数据类型中的组件数量相匹配的格式<ol><li>float: VK_FORMAT_R32_SFLOAT</li><li>vec2: VK_FORMAT_R32G32_SFLOAT</li><li>vec3: VK_FORMAT_R32G32B32_SFLOAT</li><li>vec4: VK_FORMAT_R32G32B32A32_SFLOAT</li></ol></li><li>offset: 该属性相对于顶点输入绑定中元素开始的字节偏移量</li></ol><h3 id="1-2-2-绑定"><a href="#1-2-2-绑定" class="headerlink" title="1.2.2 绑定"></a>1.2.2 绑定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> std::array&lt;VkVertexInputAttributeDescription, 2&gt; <span class="title">getAttributeDescriptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// position</span></span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].binding = <span class="number">0</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].location = <span class="number">0</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].format = VK_FORMAT_R32G32_SFLOAT;</span><br><span class="line">    attributeDescriptions[<span class="number">0</span>].offset = <span class="built_in">offsetof</span>(Vertex, pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// color</span></span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].binding = <span class="number">0</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].location = <span class="number">1</span>;</span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].format = VK_FORMAT_R32G32B32_SFLOAT;</span><br><span class="line">    attributeDescriptions[<span class="number">1</span>].offset = <span class="built_in">offsetof</span>(Vertex, color);</span><br><span class="line">    <span class="keyword">return</span> attributeDescriptions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里offsetof函数是用来获取偏移量的。</p><h2 id="1-3-管道输入顶点"><a href="#1-3-管道输入顶点" class="headerlink" title="1.3 管道输入顶点"></a>1.3 管道输入顶点</h2><p>现在需要通过引用createGraphicsPipeline中的结构来设置图形管道以接受这种格式的顶点数据。找到vertexInputInfo结构体并修改它以引用以下两种描述:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bindingDescription = Vertex::<span class="built_in">getBindingDescription</span>();</span><br><span class="line"><span class="keyword">auto</span> attributeDescriptions = Vertex::<span class="built_in">getAttributeDescriptions</span>();</span><br><span class="line">vertexInputInfo.vertexBindingDescriptionCount = <span class="number">1</span>;</span><br><span class="line">vertexInputInfo.vertexAttributeDescriptionCount =</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(attributeDescriptions.<span class="built_in">size</span>());</span><br><span class="line">vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;</span><br><span class="line">vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure><p>管道现在已经准备好接受顶点容器格式的顶点数据，并将其传递给顶点着色器。</p><p>如果在启用验证层的情况下运行程序，将报出没有顶点缓冲区绑定到绑定。下一步是创建一个顶点缓冲区，并将顶点数据移动到其中，以便GPU能够访问它。</p><h1 id="二-顶点缓冲区"><a href="#二-顶点缓冲区" class="headerlink" title="二. 顶点缓冲区"></a>二. 顶点缓冲区</h1><p>Vulkan中的缓冲区是用于存储任意数据的内存区域，这些数据可以被显卡读取，通过描述符集或特定命令将它们绑定到图形或计算管道，或者直接将它们指定为特定命令的参数。它们可以用来存储顶点数据，但也可以用于许多其他目的，以后中探讨。</p><p>与我们目前处理的Vulkan对象不同，缓冲区不会自动为自己分配内存， Vulkan API让程序员控制了几乎所有的事情，内存管理就是其中之一。</p><h2 id="2-1-创建缓冲区"><a href="#2-1-创建缓冲区" class="headerlink" title="2.1 创建缓冲区"></a>2.1 创建缓冲区</h2><p>创建一个新的函数createVertexBuffer，并在createCommandBuffers之前从initVulkan调用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initVulkan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">createCommandPool</span>();</span><br><span class="line">    <span class="comment">// 有可能使用指令，所以需要在指令池创建之后创建</span></span><br><span class="line">    <span class="built_in">createVertexBuffer</span>();</span><br><span class="line">    <span class="built_in">createCommandBuffers</span>();</span><br><span class="line">    <span class="built_in">createSyncObjects</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建顶点缓冲区需要填充VkBufferCreateInfo结构。</p><h3 id="2-1-1-VkBufferCreateInfo"><a href="#2-1-1-VkBufferCreateInfo" class="headerlink" title="2.1.1 VkBufferCreateInfo"></a>2.1.1 VkBufferCreateInfo</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkBufferCreateInfo</span> &#123;</span><br><span class="line">    VkStructureType        sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*            pNext;</span><br><span class="line">    VkBufferCreateFlags    flags;</span><br><span class="line">    VkDeviceSize           size;</span><br><span class="line">    VkBufferUsageFlags     usage;</span><br><span class="line">    VkSharingMode          sharingMode;</span><br><span class="line">    <span class="type">uint32_t</span>               queueFamilyIndexCount;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span>*        pQueueFamilyIndices;</span><br><span class="line">&#125; VkBufferCreateInfo;</span><br></pre></td></tr></table></figure><ol><li>sType: 结构体类型, VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</li><li>pNext: 为空或指向特定于扩展的结构的指针</li><li>flags: VkBufferCreateFlagBits的位掩码，指定缓冲区的附加参数, 用于配置稀疏缓冲区内存</li><li>size:  是要创建的缓冲区的大小(以字节为单位)</li><li>usage: VkBufferUsageFlagBits的位掩码，指定缓冲区允许的用法</li><li>sharingMode: VkSharingMode值，指定当多个队列族访问缓冲区时，缓冲区的共享模式<ol><li>VK_SHARING_MODE_EXCLUSIVE:  指定对对象的任何范围或图像子资源的访问一次只能由单个队列族独占</li><li>VK_SHARING_MODE_CONCURRENT: 指定支持对来自多个队列族的对象的任何范围或映像子资源的并发访问</li></ol></li><li>queueFamilyIndexCount: 是pQueueFamilyIndices数组中的数量</li><li>pQueueFamilyIndices: 将访问这个缓冲区的队列族列表(如果shareingmode不是VK_SHARING_MODE_CONCURRENT则忽略)</li></ol><h3 id="2-1-2-vkCreateBuffer"><a href="#2-1-2-vkCreateBuffer" class="headerlink" title="2.1.2 vkCreateBuffer"></a>2.1.2 vkCreateBuffer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkCreateBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBufferCreateInfo*                   pCreateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer*                                   pBuffer)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 创建缓冲区对象的逻辑设备</li><li>pCreateInfo: 指向VkBufferCreateInfo结构的指针，该结构包含影响缓冲区创建的参数</li><li>pAllocator: 控制主机内存分配</li><li>pBuffer: 指向VkBuffer句柄的指针，在该句柄中返回结果缓冲区对象</li></ol><p>VkBuffer缓冲区表示用于各种目的的数据的线性数组，通过描述符集或特定命令将它们绑定到图形或计算管道，或者直接将它们指定为特定命令的参数。</p><p>缓冲区由VkBuffer句柄表示：</p><h3 id="2-1-3-createVertexBuffer"><a href="#2-1-3-createVertexBuffer" class="headerlink" title="2.1.3 createVertexBuffer"></a>2.1.3 createVertexBuffer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">VkBuffer vertexBuffer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    VkBufferCreateInfo bufferInfo = &#123;&#125;;</span><br><span class="line">    bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;</span><br><span class="line">    bufferInfo.size = <span class="built_in">sizeof</span>(vertices[<span class="number">0</span>]) * vertices.<span class="built_in">size</span>();</span><br><span class="line">    bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;</span><br><span class="line">    bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkCreateBuffer</span>(device, &amp;bufferInfo, <span class="literal">nullptr</span>, &amp;vertexBuffer) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create vertex buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建后不需要时应该手动销毁:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, vertexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-给顶点缓冲区分配内存"><a href="#2-2-给顶点缓冲区分配内存" class="headerlink" title="2.2 给顶点缓冲区分配内存"></a>2.2 给顶点缓冲区分配内存</h2><p>缓冲区已创建，但实际上尚未分配任何内存。为缓冲区分配内存的第一步是使用vkGetBufferMemoryRequirements函数查询其内存需求.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VkMemoryRequirements memRequirements;</span><br><span class="line"><span class="built_in">vkGetBufferMemoryRequirements</span>(device, vertexBuffer, &amp;memRequirements);</span><br></pre></td></tr></table></figure><h3 id="2-2-1-vkGetBufferMemoryRequirements"><a href="#2-2-1-vkGetBufferMemoryRequirements" class="headerlink" title="2.2.1 vkGetBufferMemoryRequirements"></a>2.2.1 vkGetBufferMemoryRequirements</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkGetBufferMemoryRequirements</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkMemoryRequirements*                       pMemoryRequirements)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 创建缓冲区对象的逻辑设备</li><li>buffer: 待请求所需内存大小的缓冲区</li><li>pMemoryRequirements: 指向VkMemoryRequirements结构的指针，在该结构中返回缓冲区对象的内存需求</li></ol><h3 id="2-2-2-VkMemoryRequirements"><a href="#2-2-2-VkMemoryRequirements" class="headerlink" title="2.2.2 VkMemoryRequirements"></a>2.2.2 VkMemoryRequirements</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryRequirements</span> &#123;</span><br><span class="line">    VkDeviceSize    size;</span><br><span class="line">    VkDeviceSize    alignment;</span><br><span class="line">    <span class="type">uint32_t</span>        memoryTypeBits;</span><br><span class="line">&#125; VkMemoryRequirements;</span><br></pre></td></tr></table></figure><ol><li>size: 资源所需的内存分配的大小（以字节为单位）</li><li>alignment: 资源所需的分配内偏移量的对齐（以字节为单位）,即缓冲区在分配的内存区域中开始的偏移量</li><li>memoryTypeBits: 适合缓冲区的内存类型的位字段</li></ol><h3 id="2-2-3-findMemoryType"><a href="#2-2-3-findMemoryType" class="headerlink" title="2.2.3 findMemoryType"></a>2.2.3 findMemoryType</h3><p>图形显卡可以提供不同类型的内存进行分配。每种类型的内存在允许的操作和性能特性方面都有所不同。</p><p>我们需要结合缓冲区的需求和我们自己的应用程序需求来找到合适的内存类型。为此，我们创建一个新函数findMemoryType:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">findMemoryType</span><span class="params">(<span class="type">uint32_t</span> typeFilter, VkMemoryPropertyFlags properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先获取物理显卡支持的内存类型</span></span><br><span class="line">    VkPhysicalDeviceMemoryProperties memProperties;</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceMemoryProperties</span>(physicalDevice, &amp;memProperties);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; memProperties.memoryTypeCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (typeFilter &amp; (<span class="number">1</span> &lt;&lt; i) &amp;&amp;</span><br><span class="line">                <span class="comment">// 可能有多个属性</span></span><br><span class="line">                (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to find suitable memory type!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>typeFilter参数用于指定适合的内存类型的位字段。</p><h4 id="2-2-3-1-VkPhysicalDeviceMemoryProperties"><a href="#2-2-3-1-VkPhysicalDeviceMemoryProperties" class="headerlink" title="2.2.3.1 VkPhysicalDeviceMemoryProperties"></a>2.2.3.1 VkPhysicalDeviceMemoryProperties</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkPhysicalDeviceMemoryProperties</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>        memoryTypeCount;</span><br><span class="line">    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];</span><br><span class="line">    <span class="type">uint32_t</span>        memoryHeapCount;</span><br><span class="line">    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];</span><br><span class="line">&#125; VkPhysicalDeviceMemoryProperties;</span><br></pre></td></tr></table></figure><ol><li>memoryTypeCount: memoryTypes数组中的有效元素数。</li><li>memoryTypes: VK_MAX_MEMORY_TYPES_Vk MemoryType结构数组，描述可用于访问从memoryHeaps指定的堆中分配的内存的内存类型。</li><li>memoryHeapCount: memoryHeaps数组中的有效元素数。</li><li>memoryHeaps: VK_MAX_MEMORY_HEAPS VkMemoryHeap结构的数组，描述可以从中分配内存的内存堆。</li></ol><p>VkPhysicalDeviceMemoryProperties结构描述了许多内存堆以及一些内存类型，这些内存类型可用于访问这些堆中分配的内存。每个堆描述特定大小的内存资源，每个内存类型描述一组内存属性（例如，主机缓存与未缓存），这些属性可以与给定内存堆一起使用。使用特定内存类型的分配将消耗该内存类型的堆索引指示的堆中的资源。多个内存类型可以共享每个堆，堆和内存类型提供了一种机制，以宣告物理内存资源的精确大小，同时允许将内存与各种不同的属性一起使用。</p><h3 id="2-2-4-分配内存"><a href="#2-2-4-分配内存" class="headerlink" title="2.2.4 分配内存"></a>2.2.4 分配内存</h3><p>通过findMemoryType, 现在可以获取正确的内存类型，接下来就是给VkBuffer分配内存了。</p><p>不同类型的内存具有不同的属性。一些类型的内存可以被CPU访问，一些不可以。一些类型可以在GPU和CPU间保持数据一致性、一些类型可以被CPU缓存使用等等。可以通过查询物理设备获取这些信息。我们可以根据需要使用不同的内存类型，比如对于暂存资源，我们需要使用可以被CPU访问的内存类型。对于用于渲染的图像、顶点数据，我们通常为其分配GPU内存。</p><p>内存分配现在只需指定大小和类型就可以了，这两种类型都来自于顶点缓冲区的内存需求和所需的属性。创建一个类成员来将句柄存储到内存中，并用vkallocatemory分配它。</p><h4 id="2-2-4-1-VkMemoryAllocateInfo"><a href="#2-2-4-1-VkMemoryAllocateInfo" class="headerlink" title="2.2.4.1 VkMemoryAllocateInfo"></a>2.2.4.1 VkMemoryAllocateInfo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkMemoryAllocateInfo</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*        pNext;</span><br><span class="line">    VkDeviceSize       allocationSize;</span><br><span class="line">    <span class="type">uint32_t</span>           memoryTypeIndex;</span><br><span class="line">&#125; VkMemoryAllocateInfo;</span><br></pre></td></tr></table></figure><ol><li>sType: 结构体类型, VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</li><li>pNext: 为空或指向特定于扩展的结构的指针</li><li>allocationSize: 内存分配大小，以字节为单位</li><li>memoryTypeIndex: 内存类型的索引，VkPhysicalDeviceMemoryProperties结构的memoryTypes数组中的数据</li></ol><h4 id="2-2-4-2-内存分配"><a href="#2-2-4-2-内存分配" class="headerlink" title="2.2.4.2 内存分配"></a>2.2.4.2 内存分配</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createVertexBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    VkMemoryAllocateInfo allocInfo = &#123;&#125;;</span><br><span class="line">    allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;</span><br><span class="line">    allocInfo.allocationSize = memRequirements.size;</span><br><span class="line">    allocInfo.memoryTypeIndex = <span class="built_in">findMemoryType</span>(memRequirements.memoryTypeBits,</span><br><span class="line">                VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vkAllocateMemory</span>(device, &amp;allocInfo, <span class="literal">nullptr</span>, &amp;vertexBufferMemory) != VK_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to allocate vertex buffer memory!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存对象对设备内存中的数据进行操作可以使用vkAllocateMemory函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkAllocateMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkMemoryAllocateInfo*                 pAllocateInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkAllocationCallbacks*                pAllocator,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory*                             pMemory)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 是拥有内存的逻辑设备</li><li>pAllocateInfo: 指向描述分配参数的VkMemoryAllocateInfo结构的指针。成功返回的分配必须使用请求的参数 - 实现不允许替换。</li><li>pAllocator: 控制内存分配</li><li>pMemory: 指向VkDeviceMemory句柄的指针，在该句柄中返回有关已分配内存的信息</li></ol><p>vkallocatemory返回的分配保证满足实现的任何对齐要求。例如，如果一个实现需要128字节的图像对齐和64字节的缓冲区对齐，那么通过这个机制返回的设备内存将是128字节对齐的。这确保了应用程序可以在同一内存对象中正确地子分配不同类型的对象（具有可能不同的对齐要求）。</p><h4 id="2-2-4-3-内存与缓冲区关联"><a href="#2-2-4-3-内存与缓冲区关联" class="headerlink" title="2.2.4.3 内存与缓冲区关联"></a>2.2.4.3 内存与缓冲区关联</h4><p>如果内存分配成功，那么可以使用vkBindBufferMemory将此内存与缓冲区关联：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkBindBufferMemory</span>(device, vertexBuffer, vertexBufferMemory, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>要将内存附加到缓冲区对象可以调用vkBindBufferMemory函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkBindBufferMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkBuffer                                    buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                memoryOffset)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 是拥有内存的逻辑设备</li><li>buffer: 要附加到内存的缓冲区</li><li>memory: 描述要附加的设备内存的VkDeviceMemory对象</li><li>memoryOffset: 要绑定到缓冲区的内存区域的起始偏移量。因为这个内存被专门分配给这个顶点缓冲区，所以偏移量是0。如果偏移量不为零，则要求它可以被整除内存memRequirements.alignment.</li></ol><p>一旦缓冲区不再使用，绑定到缓冲区对象的内存可能会被释放，因此让我们在缓冲区被销毁后释放它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 vulkan 中推荐在创建的资源不需要后主动释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清理交换链关联资源</span></span><br><span class="line">    <span class="built_in">cleanupSwapChain</span>();</span><br><span class="line">    <span class="comment">// 清理顶点缓冲区</span></span><br><span class="line">    <span class="built_in">vkDestroyBuffer</span>(device, vertexBuffer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">vkFreeMemory</span>(device, vertexBufferMemory, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-填充顶点缓冲区"><a href="#2-3-填充顶点缓冲区" class="headerlink" title="2.3 填充顶点缓冲区"></a>2.3 填充顶点缓冲区</h2><p>现在是时候将顶点数据复制到缓冲区了。可以通过使用vkMapMemory将缓冲内存映射到CPU可访问内存来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkResult <span class="title">vkMapMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDevice                                    device,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceMemory                              memory,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkDeviceSize                                size,</span></span></span><br><span class="line"><span class="params"><span class="function">    VkMemoryMapFlags                            flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>**                                      ppData)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>device: 拥有内存的逻辑设备</li><li>memory: 要映射的VkDeviceMemory对象</li><li>offset: 从内存对象开始的以零为基础的字节偏移量</li><li>size:  映射的内存范围的大小，或者是要从偏移量映射到分配末尾的VK_WHOLE_SIZE大小</li><li>flags: 保留供将来使用</li><li>ppData: 指向void*变量的指针，指向映射内存的指针的输出。在该变量中返回指向映射范围开头的主机可访问指针。此指针减去偏移量必须至少与VkPhysicalDeviceLimits:：minMemoryMapAlignment对齐</li></ol><p>此函数允许我们访问由偏移量和大小定义的指定内存资源区域:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* data;</span><br><span class="line"><span class="comment">// 将缓冲内存映射到CPU可访问内存</span></span><br><span class="line"><span class="built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="number">0</span>, bufferInfo.size, <span class="number">0</span>, &amp;data);</span><br><span class="line"><span class="comment">// 将顶点数据拷贝到映射内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) bufferInfo.size);</span><br><span class="line"><span class="comment">// 使用vkUnmapMemory再次取消映射</span></span><br><span class="line"><span class="built_in">vkUnmapMemory</span>(device, vertexBufferMemory);</span><br></pre></td></tr></table></figure><p>填充顶点数据到缓冲区内存的方式就是先映射然后拷贝，最后解映射。</p><p>但是驱动程序可能不会立即将数据复制到缓冲区内存中，例如因为缓存(Cache)机制。有两种方法可以解决这个问题：</p><ol><li>缓存的内存类型使用主机相关的内存堆，用VK_MEMORY_PROPERTY_HOST_COHERENT_BIT表示</li><li>在写入映射内存后调用vkFlushMappedMemoryRanges以及在从映射内存读取之前调用vkInvalidateMappedMemoryRanges</li></ol><p>对于CPU可以访问的内存类型，可以使用vkMapMemory&#x2F;vkUnmapMemory函数对其进行映射。这一映射是持久化的，只要进行了正确的同步，可以在GPU使用这一内存区域时访问它。</p><p>vkMapMemory函数返回的指针可以被保存使用，只要进行了正确的同步，甚至可以在GPU使用这一内存区域时对其进行写入操作，同步规则可以保证CPU不会写入数据到GPU正在使用的那部分内存。</p><p>这里我们采用第一个方式实现，确保映射内存始终与分配内存的内容匹配。</p><p>刷新内存范围或使用一致的内存堆意味着驱动程序将知道我们对缓冲区的写入，但这并不意味着它们在GPU上实际上是可见的。将数据传输到GPU是一个在后台发生的操作，规范简单地告诉我们，它保证在下一次调用vkQueueSubmit时完成。</p><h2 id="2-4-绑定顶点缓冲区"><a href="#2-4-绑定顶点缓冲区" class="headerlink" title="2.4 绑定顶点缓冲区"></a>2.4 绑定顶点缓冲区</h2><p>现在我们有了顶点缓冲区，也分配了内存并填充了顶点数据，就剩下在渲染操作期间绑定顶点缓冲区。</p><p>通过扩展createCommandBuffers函数来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindPipeline</span>(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);</span><br><span class="line"></span><br><span class="line">VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;</span><br><span class="line">VkDeviceSize offsets[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vkCmdBindVertexBuffers</span>(commandBuffers[i], <span class="number">0</span>, <span class="number">1</span>, vertexBuffers, offsets);</span><br><span class="line"><span class="built_in">vkCmdDraw</span>(commandBuffers[i], <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(vertices.<span class="built_in">size</span>()), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkCmdEndRenderPass</span>(commandBuffers[i]);</span><br></pre></td></tr></table></figure><p>将顶点缓冲区绑定到命令缓冲区，以便在后续绘制命令中使用，需要使用vkCmdBindVertexBuffers:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vkCmdBindVertexBuffers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VkCommandBuffer                             commandBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    firstBinding,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span>                                    bindingCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkBuffer*                             pBuffers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VkDeviceSize*                         pOffsets)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>commandBuffer: 记录命令的命令缓冲区。</li><li>firstBinding: 第一个顶点输入绑定的索引，其状态由命令更新。</li><li>bindingCount: 状态由命令更新的顶点输入绑定数</li><li>pBuffers: 指向缓冲区句柄数组的指针。</li><li>pOffsets: 指向缓冲区偏移量数组的指针。</li></ol><p>从pBuffers和poffset的元素i获取的值替换了顶点输入绑定firstBinding+i的当前状态，即[0，bindingCount]中的i。顶点输入绑定将更新为从缓冲区pBuffers[i]开始的由pOffsets[i]指示的偏移处开始。所有使用这些绑定的顶点输入属性都将在后续绘制命令的地址计算中使用这些更新的地址。</p><h1 id="三-根据鼠标移动变化颜色"><a href="#三-根据鼠标移动变化颜色" class="headerlink" title="三. 根据鼠标移动变化颜色"></a>三. 根据鼠标移动变化颜色</h1><p>现在我们完成了从硬编码的顶点输入转为程序内的顶点数据输入， 更改vertices就可以看到颜色有变化，比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点数据</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;Vertex&gt; vertices = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">0.0f</span>, <span class="number">-0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的图形就是: </p><p><img src="/images/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/Vulkan_11_1.png" alt="图形"></p><p>现在我们动手做根据鼠标移动动态变化颜色:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 处理事件</span></span><br><span class="line">    <span class="built_in">initGlfwInput</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initGlfwInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册鼠标位置监听</span></span><br><span class="line">    <span class="built_in">glfwSetCursorPosCallback</span>(window, cursor_position_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">cursor_position_callback</span><span class="params">(GLFWwindow* window, <span class="type">double</span> xpos, <span class="type">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> app = <span class="built_in">reinterpret_cast</span>&lt;HelloTriangleApplication*&gt;(<span class="built_in">glfwGetWindowUserPointer</span>(window));</span><br><span class="line">    <span class="keyword">if</span> (app-&gt;widthOfWindow != <span class="number">0</span> &amp;&amp; app-&gt;heightOfWindow != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> xP = xpos/app-&gt;widthOfWindow;</span><br><span class="line">        <span class="type">float</span> yP = ypos/app-&gt;heightOfWindow;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> x = xP * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="type">float</span> y = yP * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        app-&gt;vertices = &#123;</span><br><span class="line">            &#123;&#123;x, y&#125;, &#123;xP, xP, xP&#125;&#125;,</span><br><span class="line">            &#123;&#123;<span class="number">0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;yP, yP, yP&#125;&#125;,</span><br><span class="line">            &#123;&#123;<span class="number">-0.5f</span>, <span class="number">0.5f</span>&#125;, &#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 顶点数据变化后，重新拷贝至内存中</span></span><br><span class="line">        app-&gt;<span class="built_in">reMemcpyVertexBuffer</span>(<span class="built_in">sizeof</span>(app-&gt;vertices[<span class="number">0</span>]) * app-&gt;vertices.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reMemcpyVertexBuffer</span><span class="params">(VkDeviceSize size)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* data;</span><br><span class="line">    <span class="built_in">vkMapMemory</span>(device, vertexBufferMemory, <span class="number">0</span>, size, <span class="number">0</span>, &amp;data);</span><br><span class="line">    <span class="built_in">memcpy</span>(data, vertices.<span class="built_in">data</span>(), (<span class="type">size_t</span>) size);</span><br><span class="line">    <span class="built_in">vkUnmapMemory</span>(device, vertexBufferMemory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果:<br><img src="/images/Vulkan%E5%85%A5%E9%97%A8-11-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0%E5%8F%8A%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E7%9A%84%E5%88%9B%E5%BB%BA/Vulkan_11_2.png" alt="图片"></p><p>哈哈，有那么回事了，第一个顶点会跟随鼠标移动而移动，并且三角形也会变幻颜色, 不过这里只是简单的处理，甚至没有考虑同步问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;接下来，我们将用内存中的顶点缓冲区替换顶点着色器中的硬编码顶点数据。我们将从创建CPU可见缓冲区的最简单方法开始，并使用memcpy将顶点数据直接复制到其中，然后我们将看到如何使用分段缓冲区将顶点数据复制到高性能内存。&lt;/p&gt;</summary>
    
    
    
    <category term="图像引擎" scheme="https://swallowjoe.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Vulkan" scheme="https://swallowjoe.github.io/tags/Vulkan/"/>
    
  </entry>
  
</feed>
